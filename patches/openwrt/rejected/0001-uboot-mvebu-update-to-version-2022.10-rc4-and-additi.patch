From 8438854dff4c0d379eb02c314eabf9a0779e2157 Mon Sep 17 00:00:00 2001
From: Josef Schlehofer <pepe.schlehofer@gmail.com>
Date: Thu, 15 Sep 2022 11:12:09 +0200
Subject: [PATCH] uboot-mvebu: update to version 2022.10-rc4 and additional
 patches

---
 package/boot/uboot-mvebu/Makefile             |   4 +-
 ...nux.h-Fix-compilation-on-non-glibc-s.patch |  50 ++++
 ...arm-mvebu-Fix-function-enable_caches.patch |  59 +++++
 ...ools-mkimage-fix-build-with-LibreSSL.patch |  33 +++
 ...ard-non-AXP-code-by-checking-for-AXP.patch |  36 +++
 ...image-fix-build-with-recent-LibreSSL.patch |  32 +++
 ...owlevel.S-Use-CR_M-from-asm-system.h.patch |  42 ++++
 ...-mvebu-Fix-moving-internal-registers.patch | 157 ++++++++++++
 ..._omnia-Allow-to-use-second-serial-po.patch |  59 +++++
 ..._mox-Add-support-for-distroboot-fdt_.patch | 115 +++++++++
 ...8-board-turris-Initialize-serial-env.patch | 143 +++++++++++
 ...heck-for-A38x-A37xx-OTP-secure-bits-.patch | 226 ++++++++++++++++++
 ...t-Check-for-A38x-image-data-checksum.patch |  91 +++++++
 ..._-omnia-mox-Reset-bootdelay-env-for-.patch |  73 ++++++
 ...u-Enable-L2-cache-also-on-Armada-38x.patch |  91 +++++++
 ...ark-constant-data-with-const-keyword.patch | 114 +++++++++
 ..._omnia-Fix-setting-switch-CONFIG-pin.patch |  36 +++
 .../uboot-mvebu/patches/100-fix-build.patch   |  20 --
 18 files changed, 1359 insertions(+), 22 deletions(-)
 create mode 100644 package/boot/uboot-mvebu/patches/0001-tools-termios_linux.h-Fix-compilation-on-non-glibc-s.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0002-arm-mvebu-Fix-function-enable_caches.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0002-tools-mkimage-fix-build-with-LibreSSL.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0003-arm-mvebu-Guard-non-AXP-code-by-checking-for-AXP.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0003-tools-mkimage-fix-build-with-recent-LibreSSL.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0004-arm-mvebu-lowlevel.S-Use-CR_M-from-asm-system.h.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0005-arm-mvebu-Fix-moving-internal-registers.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0006-arm-mvebu-turris_omnia-Allow-to-use-second-serial-po.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0007-arm-mvebu-turris_mox-Add-support-for-distroboot-fdt_.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0008-board-turris-Initialize-serial-env.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0009-cmd-mvebu-bubt-Check-for-A38x-A37xx-OTP-secure-bits-.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0010-cmd-mvebu-bubt-Check-for-A38x-image-data-checksum.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0011-arm-mvebu-turris_-omnia-mox-Reset-bootdelay-env-for-.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0012-arm-mvebu-Enable-L2-cache-also-on-Armada-38x.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0013-arm-mvebu-Mark-constant-data-with-const-keyword.patch
 create mode 100644 package/boot/uboot-mvebu/patches/0014-arm-mvebu-turris_omnia-Fix-setting-switch-CONFIG-pin.patch
 delete mode 100644 package/boot/uboot-mvebu/patches/100-fix-build.patch

diff --git a/package/boot/uboot-mvebu/Makefile b/package/boot/uboot-mvebu/Makefile
index 5bf5d59b02..36cee26bdd 100644
--- a/package/boot/uboot-mvebu/Makefile
+++ b/package/boot/uboot-mvebu/Makefile
@@ -8,10 +8,10 @@
 include $(TOPDIR)/rules.mk
 include $(INCLUDE_DIR)/kernel.mk
 
-PKG_VERSION:=2022.07
+PKG_VERSION:=2022.10-rc4
 PKG_RELEASE:=$(AUTORELEASE)
 
-PKG_HASH:=92b08eb49c24da14c1adbf70a71ae8f37cc53eeb4230e859ad8b6733d13dcf5e
+PKG_HASH:=81598cac40028a552e535dd417b3495e43e89630567c22ce85d950d78a90d5a1
 
 include $(INCLUDE_DIR)/u-boot.mk
 include $(INCLUDE_DIR)/package.mk
diff --git a/package/boot/uboot-mvebu/patches/0001-tools-termios_linux.h-Fix-compilation-on-non-glibc-s.patch b/package/boot/uboot-mvebu/patches/0001-tools-termios_linux.h-Fix-compilation-on-non-glibc-s.patch
new file mode 100644
index 0000000000..8eaed00274
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0001-tools-termios_linux.h-Fix-compilation-on-non-glibc-s.patch
@@ -0,0 +1,50 @@
+From 3096389ff8b8d66a6b31ec34b7d22fd8a36563c0 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 8 Sep 2022 16:59:36 +0200
+Subject: [PATCH 01/13] tools: termios_linux.h: Fix compilation on non-glibc
+ systems
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+TCGETS2 is defined in header file asm/ioctls.h provided by linux kernel.
+On glib systems it is automatically included by some other glibc include
+header file and therefore TCGETS2 is present in termios_linux.h when
+linux kernel provides it.
+
+On non-glibc systems (e.g. musl) asm/ioctls.h is not automatically included
+which results in the strange error that BOTHER is supported, TCGETS2 not
+defined and struct termios does not provide c_ispeed member.
+
+    tools/kwboot.c: In function 'kwboot_tty_change_baudrate':
+    tools/kwboot.c:662:6: error: 'struct termios' has no member named 'c_ospeed'
+      662 |   tio.c_ospeed = tio.c_ispeed = baudrate;
+          |      ^
+
+Fix this issue by explicitly including asm/ioctls.h file which provides
+TCGETS2 macro (if supported on selected architecture) to not depending on
+glibc auto-include behavior and because termios_linux.h requires it.
+
+With this change it is possible compile kwboot with musl libc.
+
+Reported-by: Michal Vasilek <michal.vasilek@nic.cz>
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ tools/termios_linux.h | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/tools/termios_linux.h b/tools/termios_linux.h
+index 45f5c1233c..0806a91180 100644
+--- a/tools/termios_linux.h
++++ b/tools/termios_linux.h
+@@ -29,6 +29,7 @@
+ #include <errno.h>
+ #include <sys/ioctl.h>
+ #include <sys/types.h>
++#include <asm/ioctls.h>
+ #include <asm/termbits.h>
+ 
+ #if defined(BOTHER) && defined(TCGETS2)
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0002-arm-mvebu-Fix-function-enable_caches.patch b/package/boot/uboot-mvebu/patches/0002-arm-mvebu-Fix-function-enable_caches.patch
new file mode 100644
index 0000000000..d5d4d61ba0
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0002-arm-mvebu-Fix-function-enable_caches.patch
@@ -0,0 +1,59 @@
+From bc77b40f8bbdc0e0c8728eb2561dd5266820f0f9 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 8 Sep 2022 16:06:50 +0200
+Subject: [PATCH 02/13] arm: mvebu: Fix function enable_caches
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Commit 3308933d2fe9 ("arm: mvebu: Avoid reading MVEBU_REG_PCIE_DEVID
+register too many times") broke support for caches on all Armada SoCs.
+
+Before that commit there was code:
+
+    if (mvebu_soc_family() != MVEBU_SOC_A375) {
+        dcache_enable();
+    }
+
+And after that commit there is code:
+
+    if (IS_ENABLED(CONFIG_ARMADA_375)) {
+        dcache_enable();
+    }
+
+Comment above this code says that d-cache should be disabled on Armada 375.
+But new code inverted logic and broke Armada 375 and slowed down all other
+Armada SoCs (including A38x).
+
+Fix this issue by changing logic to:
+
+    if (!IS_ENABLED(CONFIG_ARMADA_375)) {
+        dcache_enable();
+    }
+
+Which matches behavior prior that commit.
+
+Fixes: 3308933d2fe9 ("arm: mvebu: Avoid reading MVEBU_REG_PCIE_DEVID register too many times")
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+Reviewed-by: Stefan Roese <sr@denx.de>
+---
+ arch/arm/mach-mvebu/cpu.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/arch/arm/mach-mvebu/cpu.c b/arch/arm/mach-mvebu/cpu.c
+index 1457af1d6a..b512ccc501 100644
+--- a/arch/arm/mach-mvebu/cpu.c
++++ b/arch/arm/mach-mvebu/cpu.c
+@@ -663,7 +663,7 @@ void enable_caches(void)
+ 	 * ethernet driver (mvpp2). So lets keep the d-cache disabled
+ 	 * until this is solved.
+ 	 */
+-	if (IS_ENABLED(CONFIG_ARMADA_375)) {
++	if (!IS_ENABLED(CONFIG_ARMADA_375)) {
+ 		/* Enable D-cache. I-cache is already enabled in start.S */
+ 		dcache_enable();
+ 	}
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0002-tools-mkimage-fix-build-with-LibreSSL.patch b/package/boot/uboot-mvebu/patches/0002-tools-mkimage-fix-build-with-LibreSSL.patch
new file mode 100644
index 0000000000..8b12edc44e
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0002-tools-mkimage-fix-build-with-LibreSSL.patch
@@ -0,0 +1,33 @@
+From aed6107ae96870cd190b23d6da34a7e616799ed3 Mon Sep 17 00:00:00 2001
+From: Michal Vasilek <michal.vasilek@nic.cz>
+Date: Fri, 22 Jul 2022 19:55:53 +0200
+Subject: [PATCH 1/2] tools: mkimage: fix build with LibreSSL
+
+RSA_get0_* functions are not available in LibreSSL
+
+Signed-off-by: Michal Vasilek <michal.vasilek@nic.cz>
+Reviewed-by: Simon Glass <sjg@chromium.org>
+---
+ tools/sunxi_toc0.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/tools/sunxi_toc0.c b/tools/sunxi_toc0.c
+index bab5d17b7d..56200bd927 100644
+--- a/tools/sunxi_toc0.c
++++ b/tools/sunxi_toc0.c
+@@ -34,6 +34,12 @@
+ #define pr_warn(fmt, args...)	fprintf(stderr, pr_fmt(fmt), "warning", ##args)
+ #define pr_info(fmt, args...)	fprintf(stderr, pr_fmt(fmt), "info", ##args)
+ 
++#if defined(LIBRESSL_VERSION_NUMBER)
++#define RSA_get0_n(key) (key)->n
++#define RSA_get0_e(key) (key)->e
++#define RSA_get0_d(key) (key)->d
++#endif
++
+ struct __packed toc0_key_item {
+ 	__le32  vendor_id;
+ 	__le32  key0_n_len;
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0003-arm-mvebu-Guard-non-AXP-code-by-checking-for-AXP.patch b/package/boot/uboot-mvebu/patches/0003-arm-mvebu-Guard-non-AXP-code-by-checking-for-AXP.patch
new file mode 100644
index 0000000000..0eb9ab1249
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0003-arm-mvebu-Guard-non-AXP-code-by-checking-for-AXP.patch
@@ -0,0 +1,36 @@
+From f1074149c85a271261fa264f82261cbaa7bde491 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 8 Sep 2022 16:06:51 +0200
+Subject: [PATCH 03/13] arm: mvebu: Guard non-AXP code by checking for AXP
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Commit c86d53fd88df ("arm: mvebu: Don't disable cache at startup on Armada
+XP at all") introduced branch for non-AXP code which was guarded by A38X
+condition. Fix this issue by checking for AXP platform, not by A38X.
+
+Fixes: c86d53fd88df ("arm: mvebu: Don't disable cache at startup on Armada XP at all")
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+Reviewed-by: Stefan Roese <sr@denx.de>
+---
+ arch/arm/mach-mvebu/cpu.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/arch/arm/mach-mvebu/cpu.c b/arch/arm/mach-mvebu/cpu.c
+index b512ccc501..8e5d1ba21e 100644
+--- a/arch/arm/mach-mvebu/cpu.c
++++ b/arch/arm/mach-mvebu/cpu.c
+@@ -448,7 +448,7 @@ int arch_cpu_init(void)
+ 	struct pl310_regs *const pl310 =
+ 		(struct pl310_regs *)CONFIG_SYS_PL310_BASE;
+ 
+-	if (IS_ENABLED(CONFIG_ARMADA_38X)) {
++	if (!IS_ENABLED(CONFIG_ARMADA_XP)) {
+ 		/*
+ 		 * To fully release / unlock this area from cache, we need
+ 		 * to flush all caches and disable the L2 cache.
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0003-tools-mkimage-fix-build-with-recent-LibreSSL.patch b/package/boot/uboot-mvebu/patches/0003-tools-mkimage-fix-build-with-recent-LibreSSL.patch
new file mode 100644
index 0000000000..c6ca3f21e9
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0003-tools-mkimage-fix-build-with-recent-LibreSSL.patch
@@ -0,0 +1,32 @@
+From 16b94d211b18ae0204c4f850fdf23573b19170ec Mon Sep 17 00:00:00 2001
+From: Mark Kettenis <kettenis@openbsd.org>
+Date: Mon, 29 Aug 2022 13:34:01 +0200
+Subject: [PATCH 2/2] tools: mkimage: fix build with recent LibreSSL
+
+LibreSSL 3.5.0 and later (also shipped as part of OpenBSD 7.1 and
+and later) have an opaque RSA object and do provide the
+RSA_get0_* functions that OpenSSL provides.
+
+Fixes: 2ecc354b8e46 ("tools: mkimage: fix build with LibreSSL")
+Signed-off-by: Mark Kettenis <kettenis@openbsd.org>
+Reviewed-by: Jonathan Gray <jsg@jsg.id.au>
+---
+ tools/sunxi_toc0.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/tools/sunxi_toc0.c b/tools/sunxi_toc0.c
+index 56200bd927..7a8d74bb8e 100644
+--- a/tools/sunxi_toc0.c
++++ b/tools/sunxi_toc0.c
+@@ -34,7 +34,7 @@
+ #define pr_warn(fmt, args...)	fprintf(stderr, pr_fmt(fmt), "warning", ##args)
+ #define pr_info(fmt, args...)	fprintf(stderr, pr_fmt(fmt), "info", ##args)
+ 
+-#if defined(LIBRESSL_VERSION_NUMBER)
++#if defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x3050000fL
+ #define RSA_get0_n(key) (key)->n
+ #define RSA_get0_e(key) (key)->e
+ #define RSA_get0_d(key) (key)->d
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0004-arm-mvebu-lowlevel.S-Use-CR_M-from-asm-system.h.patch b/package/boot/uboot-mvebu/patches/0004-arm-mvebu-lowlevel.S-Use-CR_M-from-asm-system.h.patch
new file mode 100644
index 0000000000..f601ea04a1
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0004-arm-mvebu-lowlevel.S-Use-CR_M-from-asm-system.h.patch
@@ -0,0 +1,42 @@
+From 47a3061b51f2a89f32f4a4ea430c4994e06ba84d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 8 Sep 2022 16:06:52 +0200
+Subject: [PATCH 04/13] arm: mvebu: lowlevel.S: Use CR_M from asm/system.h
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Replace magic constant 1 when disabling MMU by macro CR_M from include
+header file asm/system.h.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+Reviewed-by: Stefan Roese <sr@denx.de>
+---
+ arch/arm/mach-mvebu/lowlevel.S | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/arch/arm/mach-mvebu/lowlevel.S b/arch/arm/mach-mvebu/lowlevel.S
+index 2491310eb0..b460382c6b 100644
+--- a/arch/arm/mach-mvebu/lowlevel.S
++++ b/arch/arm/mach-mvebu/lowlevel.S
+@@ -2,6 +2,7 @@
+ 
+ #include <config.h>
+ #include <linux/linkage.h>
++#include <asm/system.h>
+ 
+ ENTRY(arch_very_early_init)
+ #ifdef CONFIG_ARMADA_38X
+@@ -12,7 +13,7 @@ ENTRY(arch_very_early_init)
+ 	 * still locked to cache.
+ 	 */
+ 	mrc	p15, 0, r0, c1, c0, 0
+-	bic	r0, #1
++	bic	r0, #CR_M
+ 	mcr	p15, 0, r0, c1, c0, 0
+ #endif
+ 
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0005-arm-mvebu-Fix-moving-internal-registers.patch b/package/boot/uboot-mvebu/patches/0005-arm-mvebu-Fix-moving-internal-registers.patch
new file mode 100644
index 0000000000..553a0f8934
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0005-arm-mvebu-Fix-moving-internal-registers.patch
@@ -0,0 +1,157 @@
+From 3092d12d7930f4ea1eca39511446bb240c772431 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 8 Sep 2022 16:06:54 +0200
+Subject: [PATCH 05/13] arm: mvebu: Fix moving internal registers
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Commit 5bb2c550b11e ("arm: mvebu: Move internal registers in
+arch_very_early_init() function") moved code from file cpu.c to lowlevel.c,
+which moves Marvell internal registers from address INTREG_BASE_ADDR_REG to
+SOC_REGS_PHY_BASE.
+
+But the steps describing how to do it correctly were documented only in
+older U-Boot versions and commit cefd764222ee ("arm: mvebu: Fix internal
+register config on A38x") probably unintentionally removed important
+details about MMU from code comments around.
+
+Commit 5bb2c550b11e ("arm: mvebu: Move internal registers in
+arch_very_early_init() function") implemented code movement according to
+(now incomplete) comments which resulted in semi-broken code.
+
+The result is that I-cache is currently disabled for all Armada 38x boards
+and maybe there are some other (unreported / undetected) issues.
+
+Reimplement it correctly. First flush all caches, then disable MMU and L2
+cache and then move Marvell internal registers. There is no need to
+explicitly disable I-cache.
+
+After this change lzmadec command with lzma image of 0x7000000 bytes is
+doing decompression just 5 seconds. Before this change it was 30 seconds.
+
+To make lowlevel.S code more readable, extend asm/pl310.h header file to be
+compatible with assembler and use macros from this file.
+
+Fixes: 5bb2c550b11e ("arm: mvebu: Move internal registers in arch_very_early_init() function")
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+Reviewed-by: Stefan Roese <sr@denx.de>
+---
+ arch/arm/include/asm/pl310.h   |  9 +++++++--
+ arch/arm/mach-mvebu/cpu.c      | 13 -------------
+ arch/arm/mach-mvebu/lowlevel.S | 27 +++++++++++++++++++++++++++
+ 3 files changed, 34 insertions(+), 15 deletions(-)
+
+diff --git a/arch/arm/include/asm/pl310.h b/arch/arm/include/asm/pl310.h
+index f69e9e45f8..9d4cd68ee4 100644
+--- a/arch/arm/include/asm/pl310.h
++++ b/arch/arm/include/asm/pl310.h
+@@ -7,13 +7,12 @@
+ #ifndef _PL310_H_
+ #define _PL310_H_
+ 
+-#include <linux/types.h>
+-
+ /* Register bit fields */
+ #define PL310_AUX_CTRL_ASSOCIATIVITY_MASK	(1 << 16)
+ #define L2X0_DYNAMIC_CLK_GATING_EN		(1 << 1)
+ #define L2X0_STNDBY_MODE_EN			(1 << 0)
+ #define L2X0_CTRL_EN				1
++#define L2X0_CTRL_OFF				0x100
+ 
+ #define L310_SHARED_ATT_OVERRIDE_ENABLE		(1 << 22)
+ #define L310_AUX_CTRL_DATA_PREFETCH_MASK	(1 << 28)
+@@ -27,6 +26,10 @@
+ #define L2X0_CACHE_ID_RTL_MASK          0x3f
+ #define L2X0_CACHE_ID_RTL_R3P2          0x8
+ 
++#ifndef __ASSEMBLY__
++
++#include <linux/types.h>
++
+ struct pl310_regs {
+ 	u32 pl310_cache_id;
+ 	u32 pl310_cache_type;
+@@ -87,3 +90,5 @@ void pl310_inval_range(u32 start, u32 end);
+ void pl310_clean_inval_range(u32 start, u32 end);
+ 
+ #endif
++
++#endif
+diff --git a/arch/arm/mach-mvebu/cpu.c b/arch/arm/mach-mvebu/cpu.c
+index 8e5d1ba21e..a74a516292 100644
+--- a/arch/arm/mach-mvebu/cpu.c
++++ b/arch/arm/mach-mvebu/cpu.c
+@@ -445,19 +445,6 @@ static void setup_usb_phys(void)
+  */
+ int arch_cpu_init(void)
+ {
+-	struct pl310_regs *const pl310 =
+-		(struct pl310_regs *)CONFIG_SYS_PL310_BASE;
+-
+-	if (!IS_ENABLED(CONFIG_ARMADA_XP)) {
+-		/*
+-		 * To fully release / unlock this area from cache, we need
+-		 * to flush all caches and disable the L2 cache.
+-		 */
+-		icache_disable();
+-		dcache_disable();
+-		clrbits_le32(&pl310->pl310_ctrl, L2X0_CTRL_EN);
+-	}
+-
+ 	/*
+ 	 * We need to call mvebu_mbus_probe() before calling
+ 	 * update_sdram_window_sizes() as it disables all previously
+diff --git a/arch/arm/mach-mvebu/lowlevel.S b/arch/arm/mach-mvebu/lowlevel.S
+index b460382c6b..60c2072c35 100644
+--- a/arch/arm/mach-mvebu/lowlevel.S
++++ b/arch/arm/mach-mvebu/lowlevel.S
+@@ -3,6 +3,7 @@
+ #include <config.h>
+ #include <linux/linkage.h>
+ #include <asm/system.h>
++#include <asm/pl310.h>
+ 
+ ENTRY(arch_very_early_init)
+ #ifdef CONFIG_ARMADA_38X
+@@ -11,10 +12,36 @@ ENTRY(arch_very_early_init)
+ 	 * register address on Armada 38x. Without this the SDRAM
+ 	 * located at >= 0x4000.0000 is also not accessible, as its
+ 	 * still locked to cache.
++	 *
++	 * So to fully release / unlock this area from cache, we need
++	 * to first flush all caches, then disable the MMU and
++	 * disable the L2 cache.
+ 	 */
++
++	/* Invalidate L1 I/D */
++	mov	r0, #0			@ set up for MCR
++	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
++	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
++	mcr	p15, 0, r0, c7, c5, 6	@ invalidate BP array
++	mcr	p15, 0, r0, c7, c10, 4	@ DSB
++	mcr	p15, 0, r0, c7, c5, 4	@ ISB
++
++	/* Disable MMU */
+ 	mrc	p15, 0, r0, c1, c0, 0
+ 	bic	r0, #CR_M
+ 	mcr	p15, 0, r0, c1, c0, 0
++
++	/*
++	 * Disable L2 cache
++	 *
++	 * NOTE: Internal registers are still at address INTREG_BASE_ADDR_REG
++	 *       but CONFIG_SYS_PL310_BASE is already calculated from base
++	 *       address SOC_REGS_PHY_BASE.
++	 */
++	ldr	r1, =(CONFIG_SYS_PL310_BASE - SOC_REGS_PHY_BASE + INTREG_BASE_ADDR_REG)
++	ldr	r0, [r1, #L2X0_CTRL_OFF]
++	bic	r0, #L2X0_CTRL_EN
++	str	r0, [r1, #L2X0_CTRL_OFF]
+ #endif
+ 
+ 	/* Move internal registers from INTREG_BASE_ADDR_REG to SOC_REGS_PHY_BASE */
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0006-arm-mvebu-turris_omnia-Allow-to-use-second-serial-po.patch b/package/boot/uboot-mvebu/patches/0006-arm-mvebu-turris_omnia-Allow-to-use-second-serial-po.patch
new file mode 100644
index 0000000000..b8bd7a97fc
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0006-arm-mvebu-turris_omnia-Allow-to-use-second-serial-po.patch
@@ -0,0 +1,59 @@
+From 84369797aea698661249662146a8130c900a31ee Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 9 Sep 2022 14:18:48 +0200
+Subject: [PATCH 06/13] arm: mvebu: turris_omnia: Allow to use second serial
+ port
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Turris Omnia has two serial ports. Both are already specified in device
+tree file. But U-Boot by default does not allow to use more than one serial
+port unless CONFIG_SERIAL_PROBE_ALL is not enabled.
+
+After enabling CONFIG_SERIAL_PROBE_ALL, U-Boot see also second serial port
+(but is inactive by default):
+
+    => coninfo
+    List of available devices:
+    serial@12000 00000007 IO stdin stdout stderr
+    serial@12100 00000007 IO
+
+To allow simultaneously to use more input / output devices it is needed to
+enable CONFIG_CONSOLE_MUX option.
+
+With CONFIG_CONSOLE_MUX it is possible to call:
+
+    => setenv stdout 'serial@12000,serial@12100'
+
+And U-Boot output is then visible on both serial ports.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Reviewed-by: Stefan Roese <sr@denx.de>
+---
+ configs/turris_omnia_defconfig | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/configs/turris_omnia_defconfig b/configs/turris_omnia_defconfig
+index bce14cc69d..ba635feb44 100644
+--- a/configs/turris_omnia_defconfig
++++ b/configs/turris_omnia_defconfig
+@@ -33,6 +33,7 @@ CONFIG_FIT_VERBOSE=y
+ CONFIG_OF_BOARD_SETUP=y
+ CONFIG_BOOTDELAY=3
+ CONFIG_USE_PREBOOT=y
++CONFIG_CONSOLE_MUX=y
+ CONFIG_SYS_CONSOLE_INFO_QUIET=y
+ # CONFIG_DISPLAY_BOARDINFO is not set
+ CONFIG_DISPLAY_BOARDINFO_LATE=y
+@@ -103,6 +104,7 @@ CONFIG_PINCTRL_ARMADA_38X=y
+ CONFIG_DM_RTC=y
+ CONFIG_RTC_ARMADA38X=y
+ CONFIG_SCSI=y
++CONFIG_SERIAL_PROBE_ALL=y
+ CONFIG_SPL_DEBUG_UART_BASE=0xd0012000
+ CONFIG_DEBUG_UART_SHIFT=2
+ CONFIG_SYS_NS16550=y
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0007-arm-mvebu-turris_mox-Add-support-for-distroboot-fdt_.patch b/package/boot/uboot-mvebu/patches/0007-arm-mvebu-turris_mox-Add-support-for-distroboot-fdt_.patch
new file mode 100644
index 0000000000..25c6acfd70
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0007-arm-mvebu-turris_mox-Add-support-for-distroboot-fdt_.patch
@@ -0,0 +1,115 @@
+From 5e7bdf491406971e96931765e5e401cd9828e720 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 29 Aug 2022 15:44:48 +0200
+Subject: [PATCH 07/13] arm: mvebu: turris_mox: Add support for distroboot
+ $fdt_addr
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+$fdt_addr is mandatory for systems which provides DTB in HW (e.g. ROM) and
+wishes to pass that DTB to Linux.
+
+Turris Mox contains DTB binary in SPI NOR memory at "dtb" partition which
+starts at offset 0x7f0000 and is 0x10000 bytes long.
+
+Armada 3700 CPU does not allow mapping SPI NOR memory into physical address
+space like on other architectures and therefore set $fdt_addr variable to
+memory range in RAM and loads this DTB binary from SPI NOR in misc_init_r()
+function.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Reviewed-by: Stefan Roese <sr@denx.de>
+---
+ board/CZ.NIC/turris_mox/turris_mox.c | 48 ++++++++++++++++++++++++++++
+ include/configs/turris_mox.h         |  1 +
+ 2 files changed, 49 insertions(+)
+
+diff --git a/board/CZ.NIC/turris_mox/turris_mox.c b/board/CZ.NIC/turris_mox/turris_mox.c
+index 3dbd68e523..3402515bba 100644
+--- a/board/CZ.NIC/turris_mox/turris_mox.c
++++ b/board/CZ.NIC/turris_mox/turris_mox.c
+@@ -23,6 +23,7 @@
+ #include <linux/string.h>
+ #include <miiphy.h>
+ #include <spi.h>
++#include <spi_flash.h>
+ 
+ #include "mox_sp.h"
+ 
+@@ -339,6 +340,51 @@ static int get_reset_gpio(struct gpio_desc *reset_gpio)
+ 	return 0;
+ }
+ 
++/* Load default system DTB binary to $fdr_addr */
++static void load_spi_dtb(void)
++{
++	const char *const env_name[1] = { "fdt_addr" };
++	unsigned long size, offset;
++	struct udevice *spi_dev;
++	struct spi_flash *flash;
++	const char *addr_str;
++	unsigned long addr;
++	void *buf;
++
++	addr_str = env_get(env_name[0]);
++	if (!addr_str) {
++		env_set_default_vars(1, (char * const *)env_name, 0);
++		addr_str = env_get(env_name[0]);
++	}
++
++	if (!addr_str)
++		return;
++
++	addr = hextoul(addr_str, NULL);
++	if (!addr)
++		return;
++
++	spi_flash_probe_bus_cs(CONFIG_SF_DEFAULT_BUS, CONFIG_SF_DEFAULT_CS, &spi_dev);
++	flash = dev_get_uclass_priv(spi_dev);
++	if (!flash)
++		return;
++
++	/*
++	 * SPI NOR "dtb" partition offset & size hardcoded for now because the
++	 * mtd subsystem does not offer finding the partition yet and we do not
++	 * want to reimplement OF partition parser here.
++	 */
++	offset = 0x7f0000;
++	size = 0x10000;
++
++	buf = map_physmem(addr, size, MAP_WRBACK);
++	if (!buf)
++		return;
++
++	spi_flash_read(flash, offset, size, buf);
++	unmap_physmem(buf, size);
++}
++
+ int misc_init_r(void)
+ {
+ 	u8 mac[2][6];
+@@ -358,6 +404,8 @@ int misc_init_r(void)
+ 			eth_env_set_enetaddr_by_index("eth", i, mac[i]);
+ 	}
+ 
++	load_spi_dtb();
++
+ 	return 0;
+ }
+ 
+diff --git a/include/configs/turris_mox.h b/include/configs/turris_mox.h
+index b8ff705ac9..f549f9f7ad 100644
+--- a/include/configs/turris_mox.h
++++ b/include/configs/turris_mox.h
+@@ -36,6 +36,7 @@
+ 	"bootm 0x5800000"
+ 
+ #define CONFIG_EXTRA_ENV_SETTINGS				\
++	"fdt_addr=0x4c00000\0"					\
+ 	"scriptaddr=0x4d00000\0"				\
+ 	"pxefile_addr_r=0x4e00000\0"				\
+ 	"fdt_addr_r=0x4f00000\0"				\
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0008-board-turris-Initialize-serial-env.patch b/package/boot/uboot-mvebu/patches/0008-board-turris-Initialize-serial-env.patch
new file mode 100644
index 0000000000..9747b02771
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0008-board-turris-Initialize-serial-env.patch
@@ -0,0 +1,143 @@
+From e6543edd90169c10b69eb675da9872e493430314 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Sat, 27 Aug 2022 20:06:30 +0200
+Subject: [PATCH 08/13] board: turris: Initialize serial# env
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Store serial number from atsha cryptochip into the serial# env variable.
+U-Boot automatically puts content of this variable into the root device
+tree property serial-number when booting Linux kernel. Refactor turris
+atsha code and from turris_atsha_otp_get_serial_number() function returns
+directly string suitable for printing or storing into device tree. Because
+during different boot stages is env storage read-only, it is not possible
+to always store serial number into env storage. So introduce a new function
+turris_atsha_otp_init_serial_number() which is called at later stage and
+which ensures that serial number is correctly stored into env.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Reviewed-by: Marek Behún <kabel@kernel.org>
+Reviewed-by: Stefan Roese <sr@denx.de>
+---
+ board/CZ.NIC/turris_atsha_otp.c          | 33 +++++++++++++++++++++---
+ board/CZ.NIC/turris_atsha_otp.h          |  3 ++-
+ board/CZ.NIC/turris_omnia/turris_omnia.c | 11 +++-----
+ 3 files changed, 36 insertions(+), 11 deletions(-)
+
+diff --git a/board/CZ.NIC/turris_atsha_otp.c b/board/CZ.NIC/turris_atsha_otp.c
+index aa4e29b156..a29fe36231 100644
+--- a/board/CZ.NIC/turris_atsha_otp.c
++++ b/board/CZ.NIC/turris_atsha_otp.c
+@@ -93,30 +93,57 @@ int turris_atsha_otp_init_mac_addresses(int first_idx)
+ 	return 0;
+ }
+ 
+-int turris_atsha_otp_get_serial_number(u32 *version_num, u32 *serial_num)
++int turris_atsha_otp_init_serial_number(void)
++{
++	char serial[17];
++	int ret;
++
++	ret = turris_atsha_otp_get_serial_number(serial);
++	if (ret)
++		return ret;
++
++	if (!env_get("serial#"))
++		return -1;
++
++	return 0;
++}
++
++int turris_atsha_otp_get_serial_number(char serial[17])
+ {
+ 	struct udevice *dev = get_atsha204a_dev();
++	u32 version_num, serial_num;
++	const char *serial_env;
+ 	int ret;
+ 
+ 	if (!dev)
+ 		return -1;
+ 
++	serial_env = env_get("serial#");
++	if (serial_env && strlen(serial_env) == 16) {
++		memcpy(serial, serial_env, 17);
++		return 0;
++	}
++
+ 	ret = atsha204a_wakeup(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = atsha204a_read(dev, ATSHA204A_ZONE_OTP, false,
+ 			     TURRIS_ATSHA_OTP_VERSION,
+-			     (u8 *)version_num);
++			     (u8 *)&version_num);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = atsha204a_read(dev, ATSHA204A_ZONE_OTP, false,
+ 			     TURRIS_ATSHA_OTP_SERIAL,
+-			     (u8 *)serial_num);
++			     (u8 *)&serial_num);
+ 	if (ret)
+ 		return ret;
+ 
+ 	atsha204a_sleep(dev);
++
++	sprintf(serial, "%08X%08X", be32_to_cpu(version_num), be32_to_cpu(serial_num));
++	env_set("serial#", serial);
++
+ 	return 0;
+ }
+diff --git a/board/CZ.NIC/turris_atsha_otp.h b/board/CZ.NIC/turris_atsha_otp.h
+index bd4308fdc3..2cfe20bbc3 100644
+--- a/board/CZ.NIC/turris_atsha_otp.h
++++ b/board/CZ.NIC/turris_atsha_otp.h
+@@ -4,6 +4,7 @@
+ #define TURRIS_ATSHA_OTP_H
+ 
+ int turris_atsha_otp_init_mac_addresses(int first_idx);
+-int turris_atsha_otp_get_serial_number(u32 *version_num, u32 *serial_num);
++int turris_atsha_otp_init_serial_number(void);
++int turris_atsha_otp_get_serial_number(char serial[17]);
+ 
+ #endif
+diff --git a/board/CZ.NIC/turris_omnia/turris_omnia.c b/board/CZ.NIC/turris_omnia/turris_omnia.c
+index ab5061ef58..cf8a602670 100644
+--- a/board/CZ.NIC/turris_omnia/turris_omnia.c
++++ b/board/CZ.NIC/turris_omnia/turris_omnia.c
+@@ -963,19 +963,15 @@ int board_late_init(void)
+ 
+ int show_board_info(void)
+ {
+-	u32 version_num, serial_num;
++	char serial[17];
+ 	int err;
+ 
+-	err = turris_atsha_otp_get_serial_number(&version_num, &serial_num);
++	err = turris_atsha_otp_get_serial_number(serial);
+ 	printf("Model: Turris Omnia\n");
+ 	printf("  MCU type: %s\n", omnia_get_mcu_type());
+ 	printf("  MCU version: %s\n", omnia_get_mcu_version());
+ 	printf("  RAM size: %i MiB\n", omnia_get_ram_size_gb() * 1024);
+-	if (err)
+-		printf("  Serial Number: unknown\n");
+-	else
+-		printf("  Serial Number: %08X%08X\n", be32_to_cpu(version_num),
+-		       be32_to_cpu(serial_num));
++	printf("  Serial Number: %s\n", !err ? serial : "unknown");
+ 
+ 	return 0;
+ }
+@@ -983,6 +979,7 @@ int show_board_info(void)
+ int misc_init_r(void)
+ {
+ 	turris_atsha_otp_init_mac_addresses(1);
++	turris_atsha_otp_init_serial_number();
+ 	return 0;
+ }
+ 
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0009-cmd-mvebu-bubt-Check-for-A38x-A37xx-OTP-secure-bits-.patch b/package/boot/uboot-mvebu/patches/0009-cmd-mvebu-bubt-Check-for-A38x-A37xx-OTP-secure-bits-.patch
new file mode 100644
index 0000000000..984d3de6c9
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0009-cmd-mvebu-bubt-Check-for-A38x-A37xx-OTP-secure-bits-.patch
@@ -0,0 +1,226 @@
+From 30d2e3433c61eea8db658d208fb2f0746a58cc63 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 23 Aug 2022 14:52:24 +0200
+Subject: [PATCH 09/13] cmd: mvebu/bubt: Check for A38x/A37xx OTP secure bits
+ and secure boot
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+For obvious reasons BootROMS rejects unsigned images when secure boot is
+enabled in OTP secure bits. So check for OPT secure bits and do not allow
+flashing unsigned images when secure boot is enabled. Access to OTP via
+U-Boot fuse API is currently implemented only for A38x and A37xx SoCs.
+
+Additionally Armada 3700 BootROM rejects signed trusted image when secure
+boot is not enabled in OTP. So add also check for this case. On the other
+hand Armada 38x BootROM acceps images with secure boot header when secure
+boot is not enabled in OTP.
+
+OTP secure bits may have burned also boot device source. Check it also and
+reject flashing images to target storage which does not match OTP.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Reviewed-by: Stefan Roese <sr@denx.de>
+---
+ cmd/mvebu/Kconfig |   1 +
+ cmd/mvebu/bubt.c  | 128 +++++++++++++++++++++++++++++++++++++++++++---
+ 2 files changed, 121 insertions(+), 8 deletions(-)
+
+diff --git a/cmd/mvebu/Kconfig b/cmd/mvebu/Kconfig
+index 120397d6d4..9ec3aa983a 100644
+--- a/cmd/mvebu/Kconfig
++++ b/cmd/mvebu/Kconfig
+@@ -5,6 +5,7 @@ config CMD_MVEBU_BUBT
+ 	bool "bubt"
+ 	select SHA256 if ARMADA_3700
+ 	select SHA512 if ARMADA_3700
++	select MVEBU_EFUSE if ARMADA_38X || ARMADA_3700
+ 	help
+ 	  bubt - Burn a u-boot image to flash
+ 	  For details about bubt command please see the documentation
+diff --git a/cmd/mvebu/bubt.c b/cmd/mvebu/bubt.c
+index 2136af6416..77b6496347 100644
+--- a/cmd/mvebu/bubt.c
++++ b/cmd/mvebu/bubt.c
+@@ -13,6 +13,8 @@
+ #include <vsprintf.h>
+ #include <errno.h>
+ #include <dm.h>
++#include <fuse.h>
++#include <mach/efuse.h>
+ 
+ #include <spi_flash.h>
+ #include <spi.h>
+@@ -121,6 +123,17 @@ struct a38x_main_hdr_v1 {
+ 	u8  checksum;              /* 0x1F      */
+ };
+ 
++/*
++ * Header for the optional headers, version 1 (Armada 370/XP/375/38x/39x)
++ */
++struct a38x_opt_hdr_v1 {
++	u8	headertype;
++	u8	headersz_msb;
++	u16	headersz_lsb;
++	u8	data[0];
++};
++#define A38X_OPT_HDR_V1_SECURE_TYPE	0x1
++
+ struct a38x_boot_mode {
+ 	unsigned int id;
+ 	const char *name;
+@@ -709,6 +722,38 @@ static int check_image_header(void)
+ 	printf("Image checksum...OK!\n");
+ 	return 0;
+ }
++
++#if defined(CONFIG_ARMADA_38X)
++static int a38x_image_is_secure(const struct a38x_main_hdr_v1 *hdr)
++{
++	u32 image_size = a38x_header_size(hdr);
++	struct a38x_opt_hdr_v1 *ohdr;
++	u32 ohdr_size;
++
++	if (hdr->version != 1)
++		return 0;
++
++	if (!hdr->ext)
++		return 0;
++
++	ohdr = (struct a38x_opt_hdr_v1 *)(hdr + 1);
++	do {
++		if (ohdr->headertype == A38X_OPT_HDR_V1_SECURE_TYPE)
++			return 1;
++
++		ohdr_size = (ohdr->headersz_msb << 16) | le16_to_cpu(ohdr->headersz_lsb);
++
++		if (!*((u8 *)ohdr + ohdr_size - 4))
++			break;
++
++		ohdr = (struct a38x_opt_hdr_v1 *)((u8 *)ohdr + ohdr_size);
++		if ((u8 *)ohdr >= (u8 *)hdr + image_size)
++			break;
++	} while (1);
++
++	return 0;
++}
++#endif
+ #else /* Not ARMADA? */
+ static int check_image_header(void)
+ {
+@@ -717,20 +762,60 @@ static int check_image_header(void)
+ }
+ #endif
+ 
++#if defined(CONFIG_ARMADA_3700) || defined(CONFIG_ARMADA_32BIT)
++static u64 fuse_read_u64(u32 bank)
++{
++	u32 val[2];
++	int ret;
++
++	ret = fuse_read(bank, 0, &val[0]);
++	if (ret < 0)
++		return -1;
++
++	ret = fuse_read(bank, 1, &val[1]);
++	if (ret < 0)
++		return -1;
++
++	return ((u64)val[1] << 32) | val[0];
++}
++#endif
++
++#if defined(CONFIG_ARMADA_3700)
++static inline u8 maj3(u8 val)
++{
++	/* return majority vote of 3 bits */
++	return ((val & 0x7) == 3 || (val & 0x7) > 4) ? 1 : 0;
++}
++#endif
++
+ static int bubt_check_boot_mode(const struct bubt_dev *dst)
+ {
+ #if defined(CONFIG_ARMADA_3700) || defined(CONFIG_ARMADA_32BIT)
+-	int mode;
++	int mode, secure_mode;
+ #if defined(CONFIG_ARMADA_3700)
+ 	const struct tim_boot_flash_sign *boot_modes = tim_boot_flash_signs;
+ 	const struct common_tim_data *hdr =
+ 		(struct common_tim_data *)get_load_addr();
+ 	u32 id = hdr->boot_flash_sign;
++	int is_secure = hdr->trusted != 0;
++	u64 otp_secure_bits = fuse_read_u64(1);
++	int otp_secure_boot = ((maj3(otp_secure_bits >> 0) << 0) |
++			       (maj3(otp_secure_bits >> 4) << 1)) == 2;
++	unsigned int otp_boot_device = (maj3(otp_secure_bits >> 48) << 0) |
++				       (maj3(otp_secure_bits >> 52) << 1) |
++				       (maj3(otp_secure_bits >> 56) << 2) |
++				       (maj3(otp_secure_bits >> 60) << 3);
+ #elif defined(CONFIG_ARMADA_32BIT)
+ 	const struct a38x_boot_mode *boot_modes = a38x_boot_modes;
+ 	const struct a38x_main_hdr_v1 *hdr =
+ 		(struct a38x_main_hdr_v1 *)get_load_addr();
+ 	u32 id = hdr->blockid;
++#if defined(CONFIG_ARMADA_38X)
++	int is_secure = a38x_image_is_secure(hdr);
++	u64 otp_secure_bits = fuse_read_u64(EFUSE_LINE_SECURE_BOOT);
++	int otp_secure_boot = otp_secure_bits & 0x1;
++	unsigned int otp_boot_device = (otp_secure_bits >> 8) & 0x7;
++#endif
+ #endif
+ 
+ 	for (mode = 0; boot_modes[mode].name; mode++) {
+@@ -743,15 +828,42 @@ static int bubt_check_boot_mode(const struct bubt_dev *dst)
+ 		return -ENOEXEC;
+ 	}
+ 
+-	if (strcmp(boot_modes[mode].name, dst->name) == 0)
+-		return 0;
++	if (strcmp(boot_modes[mode].name, dst->name) != 0) {
++		printf("Error: image meant to be booted from \"%s\", not \"%s\"!\n",
++		       boot_modes[mode].name, dst->name);
++		return -ENOEXEC;
++	}
+ 
+-	printf("Error: image meant to be booted from \"%s\", not \"%s\"!\n",
+-	       boot_modes[mode].name, dst->name);
+-	return -ENOEXEC;
+-#else
+-	return 0;
++#if defined(CONFIG_ARMADA_38X) || defined(CONFIG_ARMADA_3700)
++	if (otp_secure_bits == (u64)-1) {
++		printf("Error: cannot read OTP secure bits\n");
++		return -ENOEXEC;
++	} else {
++		if (otp_secure_boot && !is_secure) {
++			printf("Error: secure boot is enabled in OTP but image does not have secure boot header!\n");
++			return -ENOEXEC;
++		} else if (!otp_secure_boot && is_secure) {
++#if defined(CONFIG_ARMADA_3700)
++			/*
++			 * Armada 3700 BootROM rejects trusted image when secure boot is not enabled.
++			 * Armada 385 BootROM accepts image with secure boot header also when secure boot is not enabled.
++			 */
++			printf("Error: secure boot is disabled in OTP but image has secure boot header!\n");
++			return -ENOEXEC;
+ #endif
++		} else if (otp_boot_device && otp_boot_device != id) {
++			for (secure_mode = 0; boot_modes[secure_mode].name; secure_mode++) {
++				if (boot_modes[secure_mode].id == otp_boot_device)
++					break;
++			}
++			printf("Error: boot source is set to \"%s\" in OTP but image is for \"%s\"!\n",
++			       boot_modes[secure_mode].name ?: "unknown", dst->name);
++			return -ENOEXEC;
++		}
++	}
++#endif
++#endif
++	return 0;
+ }
+ 
+ static int bubt_verify(const struct bubt_dev *dst)
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0010-cmd-mvebu-bubt-Check-for-A38x-image-data-checksum.patch b/package/boot/uboot-mvebu/patches/0010-cmd-mvebu-bubt-Check-for-A38x-image-data-checksum.patch
new file mode 100644
index 0000000000..494de1cdf4
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0010-cmd-mvebu-bubt-Check-for-A38x-image-data-checksum.patch
@@ -0,0 +1,91 @@
+From e1fcdab6eed01897e5d196a65ab473c4ec2a839b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 23 Aug 2022 14:52:23 +0200
+Subject: [PATCH 10/13] cmd: mvebu/bubt: Check for A38x image data checksum
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Currently for A38x image is checked only header checksum.
+So check also for image data checksum to prevent flashing broken image.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Reviewed-by: Stefan Roese <sr@denx.de>
+---
+ cmd/mvebu/bubt.c | 46 +++++++++++++++++++++++++++++++++++++++++++++-
+ 1 file changed, 45 insertions(+), 1 deletion(-)
+
+diff --git a/cmd/mvebu/bubt.c b/cmd/mvebu/bubt.c
+index 77b6496347..7e6e47f40d 100644
+--- a/cmd/mvebu/bubt.c
++++ b/cmd/mvebu/bubt.c
+@@ -701,9 +701,25 @@ static uint8_t image_checksum8(const void *start, size_t len)
+ 	return csum;
+ }
+ 
++static uint32_t image_checksum32(const void *start, size_t len)
++{
++	u32 csum = 0;
++	const u32 *p = start;
++
++	while (len) {
++		csum += *p;
++		++p;
++		len -= sizeof(u32);
++	}
++
++	return csum;
++}
++
+ static int check_image_header(void)
+ {
+ 	u8 checksum;
++	u32 checksum32, exp_checksum32;
++	u32 offset, size;
+ 	const struct a38x_main_hdr_v1 *hdr =
+ 		(struct a38x_main_hdr_v1 *)get_load_addr();
+ 	const size_t image_size = a38x_header_size(hdr);
+@@ -714,11 +730,39 @@ static int check_image_header(void)
+ 	checksum = image_checksum8(hdr, image_size);
+ 	checksum -= hdr->checksum;
+ 	if (checksum != hdr->checksum) {
+-		printf("Error: Bad A38x image checksum. 0x%x != 0x%x\n",
++		printf("Error: Bad A38x image header checksum. 0x%x != 0x%x\n",
+ 		       checksum, hdr->checksum);
+ 		return -ENOEXEC;
+ 	}
+ 
++	offset = le32_to_cpu(hdr->srcaddr);
++	size = le32_to_cpu(hdr->blocksize);
++
++	if (hdr->blockid == 0x78) { /* SATA id */
++		if (offset < 1) {
++			printf("Error: Bad A38x image srcaddr.\n");
++			return -ENOEXEC;
++		}
++		offset -= 1;
++		offset *= 512;
++	}
++
++	if (hdr->blockid == 0xAE) /* SDIO id */
++		offset *= 512;
++
++	if (offset % 4 != 0 || size < 4 || size % 4 != 0) {
++		printf("Error: Bad A38x image blocksize.\n");
++		return -ENOEXEC;
++	}
++
++	checksum32 = image_checksum32((u8 *)hdr + offset, size - 4);
++	exp_checksum32 = *(u32 *)((u8 *)hdr + offset + size - 4);
++	if (checksum32 != exp_checksum32) {
++		printf("Error: Bad A38x image data checksum. 0x%08x != 0x%08x\n",
++		       checksum32, exp_checksum32);
++		return -ENOEXEC;
++	}
++
+ 	printf("Image checksum...OK!\n");
+ 	return 0;
+ }
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0011-arm-mvebu-turris_-omnia-mox-Reset-bootdelay-env-for-.patch b/package/boot/uboot-mvebu/patches/0011-arm-mvebu-turris_-omnia-mox-Reset-bootdelay-env-for-.patch
new file mode 100644
index 0000000000..af66979f33
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0011-arm-mvebu-turris_-omnia-mox-Reset-bootdelay-env-for-.patch
@@ -0,0 +1,73 @@
+From 00e719173e22fb1d53a985f3c954d5ffb849b66b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Sat, 27 Aug 2022 20:49:20 +0200
+Subject: [PATCH 11/13] arm: mvebu: turris_{omnia, mox}: Reset bootdelay env
+ for rescue
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+When rescue mode was activated reset also bootdelay env variable to its
+default value. This will ensure that reset button works and starts rescue
+mode also in the case when user changed bootdelay env variable to -1 (which
+has meaning to not start autoboot).
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Reviewed-by: Marek Behún <kabel@kernel.org>
+Reviewed-by: Stefan Roese <sr@denx.de>
+---
+ board/CZ.NIC/turris_mox/turris_mox.c     | 5 +++--
+ board/CZ.NIC/turris_omnia/turris_omnia.c | 5 +++--
+ 2 files changed, 6 insertions(+), 4 deletions(-)
+
+diff --git a/board/CZ.NIC/turris_mox/turris_mox.c b/board/CZ.NIC/turris_mox/turris_mox.c
+index 3402515bba..ff1c4cb170 100644
+--- a/board/CZ.NIC/turris_mox/turris_mox.c
++++ b/board/CZ.NIC/turris_mox/turris_mox.c
+@@ -488,8 +488,9 @@ static void handle_reset_button(void)
+ 	env_set_default_vars(1, (char * const *)vars, 0);
+ 
+ 	if (read_reset_button()) {
+-		const char * const vars[2] = {
++		const char * const vars[3] = {
+ 			"bootcmd",
++			"bootdelay",
+ 			"distro_bootcmd",
+ 		};
+ 
+@@ -497,7 +498,7 @@ static void handle_reset_button(void)
+ 		 * Set the above envs to their default values, in case the user
+ 		 * managed to break them.
+ 		 */
+-		env_set_default_vars(2, (char * const *)vars, 0);
++		env_set_default_vars(3, (char * const *)vars, 0);
+ 
+ 		/* Ensure bootcmd_rescue is used by distroboot */
+ 		env_set("boot_targets", "rescue");
+diff --git a/board/CZ.NIC/turris_omnia/turris_omnia.c b/board/CZ.NIC/turris_omnia/turris_omnia.c
+index cf8a602670..a7f96e5b77 100644
+--- a/board/CZ.NIC/turris_omnia/turris_omnia.c
++++ b/board/CZ.NIC/turris_omnia/turris_omnia.c
+@@ -549,8 +549,9 @@ static void handle_reset_button(void)
+ 	env_set_ulong("omnia_reset", reset_status);
+ 
+ 	if (reset_status) {
+-		const char * const vars[2] = {
++		const char * const vars[3] = {
+ 			"bootcmd",
++			"bootdelay",
+ 			"distro_bootcmd",
+ 		};
+ 
+@@ -558,7 +559,7 @@ static void handle_reset_button(void)
+ 		 * Set the above envs to their default values, in case the user
+ 		 * managed to break them.
+ 		 */
+-		env_set_default_vars(2, (char * const *)vars, 0);
++		env_set_default_vars(3, (char * const *)vars, 0);
+ 
+ 		/* Ensure bootcmd_rescue is used by distroboot */
+ 		env_set("boot_targets", "rescue");
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0012-arm-mvebu-Enable-L2-cache-also-on-Armada-38x.patch b/package/boot/uboot-mvebu/patches/0012-arm-mvebu-Enable-L2-cache-also-on-Armada-38x.patch
new file mode 100644
index 0000000000..91916b38bf
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0012-arm-mvebu-Enable-L2-cache-also-on-Armada-38x.patch
@@ -0,0 +1,91 @@
+From a0a34de3640367d830317f408aba551ba6e54a02 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 8 Sep 2022 16:06:53 +0200
+Subject: [PATCH 12/13] arm: mvebu: Enable L2 cache also on Armada 38x
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+For some unknown reason when L2 cache is disabled on Armada 385 then loadb,
+loadx and loady commands do not work with higher baudrates than 115200
+(they just abort transfer) and lzmadec command with lzma image of size
+0x7000000 (maybe even smaller, we tested this one) is doing decompression
+for more than 2 minutes. After enabling L2 cache decompression takes only
+30s and loadb, loadx and loady are stable and working fine.
+
+git bisect identified problematic commit 3308933d2fe9 ("arm: mvebu: Avoid
+reading MVEBU_REG_PCIE_DEVID register too many times"). Before this commit
+above issues were not present.
+
+But investigation showed that above issue was possible to reproduce also by
+reverting that commit and forcing compiler to do inline optimization of
+mvebu_soc_family() function. Which seems that the root of this issue is in
+caches and position of instruction of segments. So currently it is unknown
+what is or was broken, but code movement, code inlining or other compiler
+optimization triggered it.
+
+Commit 3e5ce7ceeb94 ("arm: mvebu: Enable L2 cache on Armada XP") mentioned
+that enabling L2 cache on Armada XP improved performance and that Armada
+38x has L2 disabled (which is default state) and if needed it has to be
+enabled in separate patch. As enabling L2 cache also improve performance
+on Armada 38x, enable it.
+
+Note that Aurora cache in no outer mode is available only on Armada XP,
+hence it is not touched for Armada 38x code.
+
+Fixes: 3308933d2fe9 ("arm: mvebu: Avoid reading MVEBU_REG_PCIE_DEVID register too many times")
+Reported-by: Marek Behún <kabel@kernel.org>
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+Reviewed-by: Stefan Roese <sr@denx.de>
+---
+ arch/arm/mach-mvebu/cpu.c | 22 +++++++++++++++-------
+ 1 file changed, 15 insertions(+), 7 deletions(-)
+
+diff --git a/arch/arm/mach-mvebu/cpu.c b/arch/arm/mach-mvebu/cpu.c
+index a74a516292..9a80440d1a 100644
+--- a/arch/arm/mach-mvebu/cpu.c
++++ b/arch/arm/mach-mvebu/cpu.c
+@@ -658,13 +658,21 @@ void enable_caches(void)
+ 
+ void v7_outer_cache_enable(void)
+ {
++	struct pl310_regs *const pl310 =
++		(struct pl310_regs *)CONFIG_SYS_PL310_BASE;
++
++	/* The L2 cache is already disabled at this point */
++
++	/*
++	 * For now L2 cache will be enabled only for Armada XP and Armada 38x.
++	 * It can be enabled also for other SoCs after testing that it works fine.
++	 */
++	if (!IS_ENABLED(CONFIG_ARMADA_XP) && !IS_ENABLED(CONFIG_ARMADA_38X))
++		return;
++
+ 	if (IS_ENABLED(CONFIG_ARMADA_XP)) {
+-		struct pl310_regs *const pl310 =
+-			(struct pl310_regs *)CONFIG_SYS_PL310_BASE;
+ 		u32 u;
+ 
+-		/* The L2 cache is already disabled at this point */
+-
+ 		/*
+ 		 * For Aurora cache in no outer mode, enable via the CP15
+ 		 * coprocessor broadcasting of cache commands to L2.
+@@ -674,10 +682,10 @@ void v7_outer_cache_enable(void)
+ 		asm volatile("mcr p15, 1, %0, c15, c2, 0" : : "r" (u));
+ 
+ 		isb();
+-
+-		/* Enable the L2 cache */
+-		setbits_le32(&pl310->pl310_ctrl, L2X0_CTRL_EN);
+ 	}
++
++	/* Enable the L2 cache */
++	setbits_le32(&pl310->pl310_ctrl, L2X0_CTRL_EN);
+ }
+ 
+ void v7_outer_cache_disable(void)
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0013-arm-mvebu-Mark-constant-data-with-const-keyword.patch b/package/boot/uboot-mvebu/patches/0013-arm-mvebu-Mark-constant-data-with-const-keyword.patch
new file mode 100644
index 0000000000..23f7823ffd
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0013-arm-mvebu-Mark-constant-data-with-const-keyword.patch
@@ -0,0 +1,114 @@
+From a24240b750718a66787bac0c6b4a24b26ea968af Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 9 Sep 2022 14:41:28 +0200
+Subject: [PATCH 13/13] arm: mvebu: Mark constant data with const keyword
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Reviewed-by: Stefan Roese <sr@denx.de>
+---
+ arch/arm/mach-kirkwood/cpu.c                          | 2 +-
+ arch/arm/mach-kirkwood/include/mach/cpu.h             | 2 +-
+ arch/arm/mach-mvebu/cpu.c                             | 2 +-
+ arch/arm/mach-mvebu/include/mach/cpu.h                | 2 +-
+ arch/arm/mach-mvebu/mbus.c                            | 2 +-
+ arch/arm/mach-mvebu/serdes/a38x/high_speed_env_spec.c | 2 +-
+ arch/arm/mach-mvebu/system-controller.c               | 2 +-
+ 7 files changed, 7 insertions(+), 7 deletions(-)
+
+diff --git a/arch/arm/mach-kirkwood/cpu.c b/arch/arm/mach-kirkwood/cpu.c
+index 80f893ab36..df3e8f1178 100644
+--- a/arch/arm/mach-kirkwood/cpu.c
++++ b/arch/arm/mach-kirkwood/cpu.c
+@@ -52,7 +52,7 @@ unsigned int kw_winctrl_calcsize(unsigned int sizeval)
+ 	return (0x0000ffff & j);
+ }
+ 
+-static struct mbus_win windows[] = {
++static const struct mbus_win windows[] = {
+ 	/* Window 0: PCIE MEM address space */
+ 	{ KW_DEFADR_PCI_MEM, KW_DEFADR_PCI_MEM_SIZE,
+ 	  KWCPU_TARGET_PCIE, KWCPU_ATTR_PCIE_MEM },
+diff --git a/arch/arm/mach-kirkwood/include/mach/cpu.h b/arch/arm/mach-kirkwood/include/mach/cpu.h
+index d8639c6035..9eec786fe8 100644
+--- a/arch/arm/mach-kirkwood/include/mach/cpu.h
++++ b/arch/arm/mach-kirkwood/include/mach/cpu.h
+@@ -150,7 +150,7 @@ struct kwgpio_registers {
+ unsigned int mvebu_sdram_bar(enum memory_bank bank);
+ unsigned int mvebu_sdram_bs(enum memory_bank bank);
+ void mvebu_sdram_size_adjust(enum memory_bank bank);
+-int mvebu_mbus_probe(struct mbus_win windows[], int count);
++int mvebu_mbus_probe(const struct mbus_win windows[], int count);
+ void mvebu_config_gpio(unsigned int gpp0_oe_val, unsigned int gpp1_oe_val,
+ 		unsigned int gpp0_oe, unsigned int gpp1_oe);
+ int kw_config_mpp(unsigned int mpp0_7, unsigned int mpp8_15,
+diff --git a/arch/arm/mach-mvebu/cpu.c b/arch/arm/mach-mvebu/cpu.c
+index 9a80440d1a..1f8cdf8744 100644
+--- a/arch/arm/mach-mvebu/cpu.c
++++ b/arch/arm/mach-mvebu/cpu.c
+@@ -20,7 +20,7 @@
+ #define DDR_BASE_CS_OFF(n)	(0x0000 + ((n) << 3))
+ #define DDR_SIZE_CS_OFF(n)	(0x0004 + ((n) << 3))
+ 
+-static struct mbus_win windows[] = {
++static const struct mbus_win windows[] = {
+ 	/* SPI */
+ 	{ MBUS_SPI_BASE, MBUS_SPI_SIZE,
+ 	  CPU_TARGET_DEVICEBUS_BOOTROM_SPI, CPU_ATTR_SPIFLASH },
+diff --git a/arch/arm/mach-mvebu/include/mach/cpu.h b/arch/arm/mach-mvebu/include/mach/cpu.h
+index d9fa1f32aa..b127fce865 100644
+--- a/arch/arm/mach-mvebu/include/mach/cpu.h
++++ b/arch/arm/mach-mvebu/include/mach/cpu.h
+@@ -128,7 +128,7 @@ struct sar_freq_modes {
+ unsigned int mvebu_sdram_bar(enum memory_bank bank);
+ unsigned int mvebu_sdram_bs(enum memory_bank bank);
+ void mvebu_sdram_size_adjust(enum memory_bank bank);
+-int mvebu_mbus_probe(struct mbus_win windows[], int count);
++int mvebu_mbus_probe(const struct mbus_win windows[], int count);
+ u32 mvebu_get_nand_clock(void);
+ 
+ void __noreturn return_to_bootrom(void);
+diff --git a/arch/arm/mach-mvebu/mbus.c b/arch/arm/mach-mvebu/mbus.c
+index 7092f6cc10..959ca8e926 100644
+--- a/arch/arm/mach-mvebu/mbus.c
++++ b/arch/arm/mach-mvebu/mbus.c
+@@ -469,7 +469,7 @@ int mbus_dt_setup_win(u32 base, u32 size, u8 target, u8 attr)
+ 	return 0;
+ }
+ 
+-int mvebu_mbus_probe(struct mbus_win windows[], int count)
++int mvebu_mbus_probe(const struct mbus_win windows[], int count)
+ {
+ 	int win;
+ 	int ret;
+diff --git a/arch/arm/mach-mvebu/serdes/a38x/high_speed_env_spec.c b/arch/arm/mach-mvebu/serdes/a38x/high_speed_env_spec.c
+index 2e467b546d..943ae01942 100644
+--- a/arch/arm/mach-mvebu/serdes/a38x/high_speed_env_spec.c
++++ b/arch/arm/mach-mvebu/serdes/a38x/high_speed_env_spec.c
+@@ -105,7 +105,7 @@ struct serdes_unit_data {
+ 	u8 serdes_unit_num;
+ };
+ 
+-static struct serdes_unit_data serdes_type_to_unit_info[] = {
++static const struct serdes_unit_data serdes_type_to_unit_info[] = {
+ 	{PEX_UNIT_ID, 0,},
+ 	{PEX_UNIT_ID, 1,},
+ 	{PEX_UNIT_ID, 2,},
+diff --git a/arch/arm/mach-mvebu/system-controller.c b/arch/arm/mach-mvebu/system-controller.c
+index ea858b269e..e90aff0c33 100644
+--- a/arch/arm/mach-mvebu/system-controller.c
++++ b/arch/arm/mach-mvebu/system-controller.c
+@@ -86,7 +86,7 @@ static const struct udevice_id mvebu_reset_of_match[] = {
+ 	{ },
+ };
+ 
+-static struct reset_ops mvebu_reset_ops = {
++static const struct reset_ops mvebu_reset_ops = {
+ 	.of_xlate = mvebu_reset_of_xlate,
+ 	.request = mvebu_reset_request,
+ 	.rfree = mvebu_reset_free,
+-- 
+2.34.1
+
diff --git a/package/boot/uboot-mvebu/patches/0014-arm-mvebu-turris_omnia-Fix-setting-switch-CONFIG-pin.patch b/package/boot/uboot-mvebu/patches/0014-arm-mvebu-turris_omnia-Fix-setting-switch-CONFIG-pin.patch
new file mode 100644
index 0000000000..9c09f67a7f
--- /dev/null
+++ b/package/boot/uboot-mvebu/patches/0014-arm-mvebu-turris_omnia-Fix-setting-switch-CONFIG-pin.patch
@@ -0,0 +1,36 @@
+From ed9a8ef23bfd7da3e4f771051441e3a5164ced8f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Wed, 14 Sep 2022 17:31:24 +0200
+Subject: [PATCH] arm: mvebu: turris_omnia: Fix setting switch CONFIG pins on
+ new board design
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+It seems that waiting only 10 ms after releasing LAN switch from reset
+is not enough for the strapping pins to latch the requested values.
+P6_MODE[0] is latched to 0 instead of 1.
+
+Increasing the delay to 50 ms fixes this issue.
+
+Signed-off-by: Marek Behún <kabel at kernel.org>
+---
+ board/CZ.NIC/turris_omnia/turris_omnia.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/board/CZ.NIC/turris_omnia/turris_omnia.c b/board/CZ.NIC/turris_omnia/turris_omnia.c
+index a7f96e5b77..19c5043fcb 100644
+--- a/board/CZ.NIC/turris_omnia/turris_omnia.c
++++ b/board/CZ.NIC/turris_omnia/turris_omnia.c
+@@ -654,7 +654,7 @@ static void initialize_switch(void)
+ 	ctrl[1] = EXT_CTL_nRES_LAN;
+ 	err = omnia_mcu_write(CMD_EXT_CONTROL, ctrl, sizeof(ctrl));
+ 
+-	mdelay(10);
++	mdelay(50);
+ 
+ 	/* Change RGMII pins back to RGMII mode */
+ 
+-- 
+2.34.1
+
-- 
2.34.1


From 7c466c5b0575cf89bc46b9881343cc5f1461c6b6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
Date: Fri, 23 Sep 2022 20:26:14 +0200
Subject: [PATCH 5/9] kernel: Backport generic-phylink-validation series to
 5.15
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This backports Russell King's patch series generic-phylink-validation
from 5.16:
  34ae2c09d46a ("net: phylink: add generic validate implementation")
  02a0988b9893 ("net: mvneta: use phylink_generic_validate()")
  5038ffea0c6c ("net: mvpp2: use phylink_generic_validate()")

The original cover letter said:
  introduce generic phylink validation

  The various validate method implementations we have in phylink users
  have been quite repetitive but also prone to bugs. These patches
  introduce a generic implementation which relies solely on the
  supported_interfaces bitmap introduced during last cycle, and in the
  first patch, a bit array of MAC capabilities.

  MAC drivers are free to continue to do their own thing if they have
  special requirements - such as mvneta and mvpp2 which do not support
  1000base-X without AN enabled. Most implementations currently in the
  kernel can be converted to call phylink_generic_validate() directly
  from the phylink MAC operations structure once they fill in the
  supported_interfaces and mac_capabilities members of phylink_config.

  This series introduces the generic implementation, and converts mvneta
  and mvpp2 to use it.

Signed-off-by: Marek Beh√∫n <marek.behun@nic.cz>
---
 ...-add-generic-validate-implementation.patch | 348 ++++++++++++++++++
 ...-mvneta-use-phylink_generic_validate.patch |  77 ++++
 ...t-mvpp2-use-phylink_generic_validate.patch | 107 ++++++
 3 files changed, 532 insertions(+)
 create mode 100644 target/linux/generic/backport-5.15/780-v5.16-1-net-phylink-add-generic-validate-implementation.patch
 create mode 100644 target/linux/generic/backport-5.15/780-v5.16-2-net-mvneta-use-phylink_generic_validate.patch
 create mode 100644 target/linux/generic/backport-5.15/780-v5.16-3-net-mvpp2-use-phylink_generic_validate.patch

diff --git a/target/linux/generic/backport-5.15/780-v5.16-1-net-phylink-add-generic-validate-implementation.patch b/target/linux/generic/backport-5.15/780-v5.16-1-net-phylink-add-generic-validate-implementation.patch
new file mode 100644
index 0000000000..22a25f426f
--- /dev/null
+++ b/target/linux/generic/backport-5.15/780-v5.16-1-net-phylink-add-generic-validate-implementation.patch
@@ -0,0 +1,348 @@
+From 792d0a8e185e3ef101e2644503a0828246c8a5b3 Mon Sep 17 00:00:00 2001
+From: "Russell King (Oracle)" <rmk+kernel@armlinux.org.uk>
+Date: Mon, 15 Nov 2021 10:00:27 +0000
+Subject: [PATCH 1/3] net: phylink: add generic validate implementation
+
+Add a generic validate() implementation using the supported_interfaces
+and a bitmask of MAC pause/speed/duplex capabilities. This allows us
+to entirely eliminate many driver private validate() implementations.
+
+We expose the underlying phylink_get_linkmodes() function so that
+drivers which have special needs can still benefit from conversion.
+
+Signed-off-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/phylink.c | 252 ++++++++++++++++++++++++++++++++++++++
+ include/linux/phylink.h   |  31 +++++
+ 2 files changed, 283 insertions(+)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 0720f05ecb02..3e1d7dea616d 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -167,6 +167,258 @@ static const char *phylink_an_mode_str(unsigned int mode)
+ 	return mode < ARRAY_SIZE(modestr) ? modestr[mode] : "unknown";
+ }
+ 
++static void phylink_caps_to_linkmodes(unsigned long *linkmodes,
++				      unsigned long caps)
++{
++	if (caps & MAC_SYM_PAUSE)
++		__set_bit(ETHTOOL_LINK_MODE_Pause_BIT, linkmodes);
++
++	if (caps & MAC_ASYM_PAUSE)
++		__set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, linkmodes);
++
++	if (caps & MAC_10HD)
++		__set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, linkmodes);
++
++	if (caps & MAC_10FD)
++		__set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, linkmodes);
++
++	if (caps & MAC_100HD) {
++		__set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100baseFX_Half_BIT, linkmodes);
++	}
++
++	if (caps & MAC_100FD) {
++		__set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100baseT1_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100baseFX_Full_BIT, linkmodes);
++	}
++
++	if (caps & MAC_1000HD)
++		__set_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT, linkmodes);
++
++	if (caps & MAC_1000FD) {
++		__set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_1000baseT1_Full_BIT, linkmodes);
++	}
++
++	if (caps & MAC_2500FD) {
++		__set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT, linkmodes);
++	}
++
++	if (caps & MAC_5000FD)
++		__set_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT, linkmodes);
++
++	if (caps & MAC_10000FD) {
++		__set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_10000baseKR_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_10000baseR_FEC_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_10000baseCR_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_10000baseSR_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_10000baseLR_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_10000baseER_Full_BIT, linkmodes);
++	}
++
++	if (caps & MAC_25000FD) {
++		__set_bit(ETHTOOL_LINK_MODE_25000baseCR_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_25000baseKR_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_25000baseSR_Full_BIT, linkmodes);
++	}
++
++	if (caps & MAC_40000FD) {
++		__set_bit(ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT, linkmodes);
++	}
++
++	if (caps & MAC_50000FD) {
++		__set_bit(ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_50000baseKR_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_50000baseSR_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_50000baseCR_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT,
++			  linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_50000baseDR_Full_BIT, linkmodes);
++	}
++
++	if (caps & MAC_56000FD) {
++		__set_bit(ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT, linkmodes);
++	}
++
++	if (caps & MAC_100000FD) {
++		__set_bit(ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT,
++			  linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT,
++			  linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100000baseKR_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100000baseSR_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT,
++			  linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100000baseCR_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_100000baseDR_Full_BIT, linkmodes);
++	}
++
++	if (caps & MAC_200000FD) {
++		__set_bit(ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT,
++			  linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT,
++			  linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT, linkmodes);
++	}
++
++	if (caps & MAC_400000FD) {
++		__set_bit(ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT,
++			  linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT,
++			  linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT, linkmodes);
++		__set_bit(ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT, linkmodes);
++	}
++}
++
++/**
++ * phylink_get_linkmodes() - get acceptable link modes
++ * @linkmodes: ethtool linkmode mask (must be already initialised)
++ * @interface: phy interface mode defined by &typedef phy_interface_t
++ * @mac_capabilities: bitmask of MAC capabilities
++ *
++ * Set all possible pause, speed and duplex linkmodes in @linkmodes that
++ * are supported by the @interface mode and @mac_capabilities. @linkmodes
++ * must have been initialised previously.
++ */
++void phylink_get_linkmodes(unsigned long *linkmodes, phy_interface_t interface,
++			   unsigned long mac_capabilities)
++{
++	unsigned long caps = MAC_SYM_PAUSE | MAC_ASYM_PAUSE;
++
++	switch (interface) {
++	case PHY_INTERFACE_MODE_USXGMII:
++		caps |= MAC_10000FD | MAC_5000FD | MAC_2500FD;
++		fallthrough;
++
++	case PHY_INTERFACE_MODE_RGMII_TXID:
++	case PHY_INTERFACE_MODE_RGMII_RXID:
++	case PHY_INTERFACE_MODE_RGMII_ID:
++	case PHY_INTERFACE_MODE_RGMII:
++	case PHY_INTERFACE_MODE_QSGMII:
++	case PHY_INTERFACE_MODE_SGMII:
++	case PHY_INTERFACE_MODE_GMII:
++		caps |= MAC_1000HD | MAC_1000FD;
++		fallthrough;
++
++	case PHY_INTERFACE_MODE_REVRMII:
++	case PHY_INTERFACE_MODE_RMII:
++	case PHY_INTERFACE_MODE_REVMII:
++	case PHY_INTERFACE_MODE_MII:
++		caps |= MAC_10HD | MAC_10FD;
++		fallthrough;
++
++	case PHY_INTERFACE_MODE_100BASEX:
++		caps |= MAC_100HD | MAC_100FD;
++		break;
++
++	case PHY_INTERFACE_MODE_TBI:
++	case PHY_INTERFACE_MODE_MOCA:
++	case PHY_INTERFACE_MODE_RTBI:
++	case PHY_INTERFACE_MODE_1000BASEX:
++		caps |= MAC_1000HD;
++		fallthrough;
++	case PHY_INTERFACE_MODE_TRGMII:
++		caps |= MAC_1000FD;
++		break;
++
++	case PHY_INTERFACE_MODE_2500BASEX:
++		caps |= MAC_2500FD;
++		break;
++
++	case PHY_INTERFACE_MODE_5GBASER:
++		caps |= MAC_5000FD;
++		break;
++
++	case PHY_INTERFACE_MODE_XGMII:
++	case PHY_INTERFACE_MODE_RXAUI:
++	case PHY_INTERFACE_MODE_XAUI:
++	case PHY_INTERFACE_MODE_10GBASER:
++	case PHY_INTERFACE_MODE_10GKR:
++		caps |= MAC_10000FD;
++		break;
++
++	case PHY_INTERFACE_MODE_25GBASER:
++		caps |= MAC_25000FD;
++		break;
++
++	case PHY_INTERFACE_MODE_XLGMII:
++		caps |= MAC_40000FD;
++		break;
++
++	case PHY_INTERFACE_MODE_INTERNAL:
++		caps |= ~0;
++		break;
++
++	case PHY_INTERFACE_MODE_NA:
++	case PHY_INTERFACE_MODE_MAX:
++	case PHY_INTERFACE_MODE_SMII:
++		break;
++	}
++
++	phylink_caps_to_linkmodes(linkmodes, caps & mac_capabilities);
++}
++EXPORT_SYMBOL_GPL(phylink_get_linkmodes);
++
++/**
++ * phylink_generic_validate() - generic validate() callback implementation
++ * @config: a pointer to a &struct phylink_config.
++ * @supported: ethtool bitmask for supported link modes.
++ * @state: a pointer to a &struct phylink_link_state.
++ *
++ * Generic implementation of the validate() callback that MAC drivers can
++ * use when they pass the range of supported interfaces and MAC capabilities.
++ * This makes use of phylink_get_linkmodes().
++ */
++void phylink_generic_validate(struct phylink_config *config,
++			      unsigned long *supported,
++			      struct phylink_link_state *state)
++{
++	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
++
++	phylink_set_port_modes(mask);
++	phylink_set(mask, Autoneg);
++	phylink_get_linkmodes(mask, state->interface, config->mac_capabilities);
++
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
++}
++EXPORT_SYMBOL_GPL(phylink_generic_validate);
++
+ static int phylink_validate_any(struct phylink *pl, unsigned long *supported,
+ 				struct phylink_link_state *state)
+ {
+diff --git a/include/linux/phylink.h b/include/linux/phylink.h
+index f037470b6fb3..3563820a1765 100644
+--- a/include/linux/phylink.h
++++ b/include/linux/phylink.h
+@@ -20,6 +20,29 @@ enum {
+ 	MLO_AN_PHY = 0,	/* Conventional PHY */
+ 	MLO_AN_FIXED,	/* Fixed-link mode */
+ 	MLO_AN_INBAND,	/* In-band protocol */
++
++	MAC_SYM_PAUSE	= BIT(0),
++	MAC_ASYM_PAUSE	= BIT(1),
++	MAC_10HD	= BIT(2),
++	MAC_10FD	= BIT(3),
++	MAC_10		= MAC_10HD | MAC_10FD,
++	MAC_100HD	= BIT(4),
++	MAC_100FD	= BIT(5),
++	MAC_100		= MAC_100HD | MAC_100FD,
++	MAC_1000HD	= BIT(6),
++	MAC_1000FD	= BIT(7),
++	MAC_1000	= MAC_1000HD | MAC_1000FD,
++	MAC_2500FD	= BIT(8),
++	MAC_5000FD	= BIT(9),
++	MAC_10000FD	= BIT(10),
++	MAC_20000FD	= BIT(11),
++	MAC_25000FD	= BIT(12),
++	MAC_40000FD	= BIT(13),
++	MAC_50000FD	= BIT(14),
++	MAC_56000FD	= BIT(15),
++	MAC_100000FD	= BIT(16),
++	MAC_200000FD	= BIT(17),
++	MAC_400000FD	= BIT(18),
+ };
+ 
+ static inline bool phylink_autoneg_inband(unsigned int mode)
+@@ -69,6 +92,7 @@ enum phylink_op_type {
+  *		     if MAC link is at %MLO_AN_FIXED mode.
+  * @supported_interfaces: bitmap describing which PHY_INTERFACE_MODE_xxx
+  *                        are supported by the MAC/PCS.
++ * @mac_capabilities: MAC pause/speed/duplex capabilities.
+  */
+ struct phylink_config {
+ 	struct device *dev;
+@@ -79,6 +103,7 @@ struct phylink_config {
+ 	void (*get_fixed_state)(struct phylink_config *config,
+ 				struct phylink_link_state *state);
+ 	DECLARE_PHY_INTERFACE_MASK(supported_interfaces);
++	unsigned long mac_capabilities;
+ };
+ 
+ /**
+@@ -442,6 +467,12 @@ void pcs_link_up(struct phylink_pcs *pcs, unsigned int mode,
+ 		 phy_interface_t interface, int speed, int duplex);
+ #endif
+ 
++void phylink_get_linkmodes(unsigned long *linkmodes, phy_interface_t interface,
++			   unsigned long mac_capabilities);
++void phylink_generic_validate(struct phylink_config *config,
++			      unsigned long *supported,
++			      struct phylink_link_state *state);
++
+ struct phylink *phylink_create(struct phylink_config *, struct fwnode_handle *,
+ 			       phy_interface_t iface,
+ 			       const struct phylink_mac_ops *mac_ops);
+-- 
+2.35.1
+
diff --git a/target/linux/generic/backport-5.15/780-v5.16-2-net-mvneta-use-phylink_generic_validate.patch b/target/linux/generic/backport-5.15/780-v5.16-2-net-mvneta-use-phylink_generic_validate.patch
new file mode 100644
index 0000000000..af0e06fc0f
--- /dev/null
+++ b/target/linux/generic/backport-5.15/780-v5.16-2-net-mvneta-use-phylink_generic_validate.patch
@@ -0,0 +1,77 @@
+From 50ba86adc61e95d49215c1c089697190a2666e3a Mon Sep 17 00:00:00 2001
+From: "Russell King (Oracle)" <rmk+kernel@armlinux.org.uk>
+Date: Mon, 15 Nov 2021 10:00:32 +0000
+Subject: [PATCH 2/3] net: mvneta: use phylink_generic_validate()
+
+Convert mvneta to use phylink_generic_validate() for the bulk of its
+validate() implementation. This network adapter has a restriction
+that for 802.3z links, autonegotiation must be enabled.
+
+Signed-off-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 34 ++++-----------------------
+ 1 file changed, 4 insertions(+), 30 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 51fe2de0215e..191eef5c26a7 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3851,8 +3851,6 @@ static void mvneta_validate(struct phylink_config *config,
+ 			    unsigned long *supported,
+ 			    struct phylink_link_state *state)
+ {
+-	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+-
+ 	/* We only support QSGMII, SGMII, 802.3z and RGMII modes.
+ 	 * When in 802.3z mode, we must have AN enabled:
+ 	 * "Bit 2 Field InBandAnEn In-band Auto-Negotiation enable. ...
+@@ -3864,34 +3862,7 @@ static void mvneta_validate(struct phylink_config *config,
+ 		return;
+ 	}
+ 
+-	/* Allow all the expected bits */
+-	phylink_set(mask, Autoneg);
+-	phylink_set_port_modes(mask);
+-
+-	/* Asymmetric pause is unsupported */
+-	phylink_set(mask, Pause);
+-
+-	/* Half-duplex at speeds higher than 100Mbit is unsupported */
+-	if (state->interface != PHY_INTERFACE_MODE_2500BASEX) {
+-		phylink_set(mask, 1000baseT_Full);
+-		phylink_set(mask, 1000baseX_Full);
+-	}
+-
+-	if (state->interface == PHY_INTERFACE_MODE_2500BASEX) {
+-		phylink_set(mask, 2500baseT_Full);
+-		phylink_set(mask, 2500baseX_Full);
+-	}
+-
+-	if (!phy_interface_mode_is_8023z(state->interface)) {
+-		/* 10M and 100M are only supported in non-802.3z mode */
+-		phylink_set(mask, 10baseT_Half);
+-		phylink_set(mask, 10baseT_Full);
+-		phylink_set(mask, 100baseT_Half);
+-		phylink_set(mask, 100baseT_Full);
+-	}
+-
+-	linkmode_and(supported, supported, mask);
+-	linkmode_and(state->advertising, state->advertising, mask);
++	phylink_generic_validate(config, supported, state);
+ }
+ 
+ static void mvneta_mac_pcs_get_state(struct phylink_config *config,
+@@ -5295,6 +5266,9 @@ static int mvneta_probe(struct platform_device *pdev)
+ 
+ 	pp->phylink_config.dev = &dev->dev;
+ 	pp->phylink_config.type = PHYLINK_NETDEV;
++	pp->phylink_config.mac_capabilities = MAC_SYM_PAUSE | MAC_10 |
++		MAC_100 | MAC_1000FD | MAC_2500FD;
++
+ 	phy_interface_set_rgmii(pp->phylink_config.supported_interfaces);
+ 	__set_bit(PHY_INTERFACE_MODE_QSGMII,
+ 		  pp->phylink_config.supported_interfaces);
+-- 
+2.35.1
+
diff --git a/target/linux/generic/backport-5.15/780-v5.16-3-net-mvpp2-use-phylink_generic_validate.patch b/target/linux/generic/backport-5.15/780-v5.16-3-net-mvpp2-use-phylink_generic_validate.patch
new file mode 100644
index 0000000000..a41299d778
--- /dev/null
+++ b/target/linux/generic/backport-5.15/780-v5.16-3-net-mvpp2-use-phylink_generic_validate.patch
@@ -0,0 +1,107 @@
+From 7356c6e175210a721310f75915248c3148e3147d Mon Sep 17 00:00:00 2001
+From: "Russell King (Oracle)" <rmk+kernel@armlinux.org.uk>
+Date: Mon, 15 Nov 2021 10:00:37 +0000
+Subject: [PATCH 3/3] net: mvpp2: use phylink_generic_validate()
+
+Convert mvpp2 to use phylink_generic_validate() for the bulk of its
+validate() implementation. This network adapter has a restriction
+that for 802.3z links, autonegotiation must be enabled.
+
+Signed-off-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ .../net/ethernet/marvell/mvpp2/mvpp2_main.c   | 58 +++----------------
+ 1 file changed, 9 insertions(+), 49 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+index be0dcba4649b..2b8293c0c2f9 100644
+--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
++++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+@@ -6262,9 +6262,6 @@ static void mvpp2_phylink_validate(struct phylink_config *config,
+ 				   unsigned long *supported,
+ 				   struct phylink_link_state *state)
+ {
+-	struct mvpp2_port *port = mvpp2_phylink_to_port(config);
+-	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+-
+ 	/* When in 802.3z mode, we must have AN enabled:
+ 	 * Bit 2 Field InBandAnEn In-band Auto-Negotiation enable. ...
+ 	 * When <PortType> = 1 (1000BASE-X) this field must be set to 1.
+@@ -6273,52 +6270,7 @@ static void mvpp2_phylink_validate(struct phylink_config *config,
+ 	    !phylink_test(state->advertising, Autoneg))
+ 		goto empty_set;
+ 
+-	phylink_set(mask, Autoneg);
+-	phylink_set_port_modes(mask);
+-
+-	if (port->priv->global_tx_fc) {
+-		phylink_set(mask, Pause);
+-		phylink_set(mask, Asym_Pause);
+-	}
+-
+-	switch (state->interface) {
+-	case PHY_INTERFACE_MODE_10GBASER:
+-	case PHY_INTERFACE_MODE_XAUI:
+-		if (mvpp2_port_supports_xlg(port)) {
+-			phylink_set_10g_modes(mask);
+-			phylink_set(mask, 10000baseKR_Full);
+-		}
+-		break;
+-
+-	case PHY_INTERFACE_MODE_RGMII:
+-	case PHY_INTERFACE_MODE_RGMII_ID:
+-	case PHY_INTERFACE_MODE_RGMII_RXID:
+-	case PHY_INTERFACE_MODE_RGMII_TXID:
+-	case PHY_INTERFACE_MODE_SGMII:
+-		phylink_set(mask, 10baseT_Half);
+-		phylink_set(mask, 10baseT_Full);
+-		phylink_set(mask, 100baseT_Half);
+-		phylink_set(mask, 100baseT_Full);
+-		phylink_set(mask, 1000baseT_Full);
+-		phylink_set(mask, 1000baseX_Full);
+-		break;
+-
+-	case PHY_INTERFACE_MODE_1000BASEX:
+-		phylink_set(mask, 1000baseT_Full);
+-		phylink_set(mask, 1000baseX_Full);
+-		break;
+-
+-	case PHY_INTERFACE_MODE_2500BASEX:
+-		phylink_set(mask, 2500baseT_Full);
+-		phylink_set(mask, 2500baseX_Full);
+-		break;
+-
+-	default:
+-		goto empty_set;
+-	}
+-
+-	linkmode_and(supported, supported, mask);
+-	linkmode_and(state->advertising, state->advertising, mask);
++	phylink_generic_validate(config, supported, state);
+ 	return;
+ 
+ empty_set:
+@@ -6913,12 +6865,20 @@ static int mvpp2_port_probe(struct platform_device *pdev,
+ 	if (!mvpp2_use_acpi_compat_mode(port_fwnode)) {
+ 		port->phylink_config.dev = &dev->dev;
+ 		port->phylink_config.type = PHYLINK_NETDEV;
++		port->phylink_config.mac_capabilities =
++			MAC_2500FD | MAC_1000FD | MAC_100 | MAC_10;
++
++		if (port->priv->global_tx_fc)
++			port->phylink_config.mac_capabilities |=
++				MAC_SYM_PAUSE | MAC_ASYM_PAUSE;
+ 
+ 		if (mvpp2_port_supports_xlg(port)) {
+ 			__set_bit(PHY_INTERFACE_MODE_10GBASER,
+ 				  port->phylink_config.supported_interfaces);
+ 			__set_bit(PHY_INTERFACE_MODE_XAUI,
+ 				  port->phylink_config.supported_interfaces);
++			port->phylink_config.mac_capabilities |=
++				MAC_10000FD;
+ 		}
+ 
+ 		if (mvpp2_port_supports_rgmii(port))
+-- 
+2.35.1
+
-- 
2.35.1


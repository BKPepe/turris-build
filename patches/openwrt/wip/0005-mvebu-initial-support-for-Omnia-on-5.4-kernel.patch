From 8d0314b394c650a5285ec034e481905ca0541fb0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
Date: Tue, 5 May 2020 20:54:33 +0200
Subject: [PATCH] mvebu: initial support for Omnia on 5.4 kernel

---
 target/linux/mvebu/image/Config.in            |   4 +
 ...mada-385-turris-omnia-separate-dts-f.patch | 232 ++++++++++++
 ...leds-Add-LED-driver-for-Turris-Omnia.patch | 345 ++++++++++++++++++
 ...a-Add-proprietary-part-of-LED-driver.patch | 281 ++++++++++++++
 ...mada-385-turris-omnia-describe-LED-n.patch | 107 ++++++
 ...mada-385-turris-omnia-enable-HW-buff.patch |  76 ++++
 ...net-dsa-allow-for-multiple-CPU-ports.patch | 219 +++++++++++
 ...-ndo-for-setting-the-iflink-property.patch | 101 +++++
 ...t-ndo_set_netlink-for-chaning-port-s.patch |  97 +++++
 ...-dsa-mv88e6xxx-support-multi-CPU-DSA.patch | 116 ++++++
 10 files changed, 1578 insertions(+)
 create mode 100644 target/linux/mvebu/image/Config.in
 create mode 100644 target/linux/mvebu/patches-5.4/8800-ARM-dts-mvebu-armada-385-turris-omnia-separate-dts-f.patch
 create mode 100644 target/linux/mvebu/patches-5.4/8801-leds-Add-LED-driver-for-Turris-Omnia.patch
 create mode 100644 target/linux/mvebu/patches-5.4/8802-leds-omnia-Add-proprietary-part-of-LED-driver.patch
 create mode 100644 target/linux/mvebu/patches-5.4/8803-ARM-dts-mvebu-armada-385-turris-omnia-describe-LED-n.patch
 create mode 100644 target/linux/mvebu/patches-5.4/8804-ARM-dts-mvebu-armada-385-turris-omnia-enable-HW-buff.patch
 create mode 100644 target/linux/mvebu/patches-5.4/9950-net-dsa-allow-for-multiple-CPU-ports.patch
 create mode 100644 target/linux/mvebu/patches-5.4/9951-net-add-ndo-for-setting-the-iflink-property.patch
 create mode 100644 target/linux/mvebu/patches-5.4/9952-net-dsa-implement-ndo_set_netlink-for-chaning-port-s.patch
 create mode 100644 target/linux/mvebu/patches-5.4/9953-net-dsa-mv88e6xxx-support-multi-CPU-DSA.patch

diff --git a/target/linux/mvebu/image/Config.in b/target/linux/mvebu/image/Config.in
new file mode 100644
index 0000000..bf1c0de
--- /dev/null
+++ b/target/linux/mvebu/image/Config.in
@@ -0,0 +1,4 @@
+config KERNEL_LEDS_OMNIA
+	bool "Build Turris Omnia LEDS support to kernel"
+	default y if TARGET_mvebu_cortexa9_DEVICE_cznic_turris-omnia
+	default n
diff --git a/target/linux/mvebu/patches-5.4/8800-ARM-dts-mvebu-armada-385-turris-omnia-separate-dts-f.patch b/target/linux/mvebu/patches-5.4/8800-ARM-dts-mvebu-armada-385-turris-omnia-separate-dts-f.patch
new file mode 100644
index 0000000..61756be
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/8800-ARM-dts-mvebu-armada-385-turris-omnia-separate-dts-f.patch
@@ -0,0 +1,232 @@
+From 4ec877a2516675c96573c3c6ddc71819595dec6c Mon Sep 17 00:00:00 2001
+From: Tomas Hlavacek <tmshlvck@gmail.com>
+Date: Tue, 5 May 2020 20:40:24 +0200
+Subject: [PATCH] ARM: dts: mvebu: armada-385-turris-omnia: separate dts for
+ SFP and PHY
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The Turris Omnia board contains dual-personality ethernet NIC eth2 with
+two operation modes: 1) SFP cage and 2) metalic 1000BASE-X PHY.
+The differential pair carrying SGMII/1000BASE-X of eth2 is wired through
+a multiplexor driven by the module-detect signal from the SFP cage.
+The pin status can be read through I2C GPIO expander chip in userspace
+when the sfp driver module is unloaded and / or in U-Boot prior to the
+start of the kernel and the proper DTS file can be selected for the
+(floolowing) boot.
+
+Split DTS for Turris Omnia (that does not have any support for SFP cage)
+into three files:
+  armada-385-turris-omnia.dtsi - common base
+  armada-385-turris-omnia-sfp.dts - DT with the SFP configuration and
+PHY disabled
+  armada-385-turris-omnia-phy.dts - DT with the PHY configuration and
+SFP disabled
+
+Current DSA driver does not allow multiple CPU ports and Turris Omnia
+has two RGMII iterfaces wired between CPU and DSA switch.
+Disable the second CPU port until there is a suitable driver to use it.
+
+Signed-off-by: Tomas Hlavacek <tmshlvck@gmail.com>
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ arch/arm/boot/dts/Makefile                    |  3 +-
+ .../boot/dts/armada-385-turris-omnia-phy.dts  | 22 ++++++++++
+ .../boot/dts/armada-385-turris-omnia-sfp.dts  | 23 ++++++++++
+ ...omnia.dts => armada-385-turris-omnia.dtsi} | 42 +++++++++++++------
+ 4 files changed, 77 insertions(+), 13 deletions(-)
+ create mode 100644 arch/arm/boot/dts/armada-385-turris-omnia-phy.dts
+ create mode 100644 arch/arm/boot/dts/armada-385-turris-omnia-sfp.dts
+ rename arch/arm/boot/dts/{armada-385-turris-omnia.dts => armada-385-turris-omnia.dtsi} (88%)
+
+diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
+index b21b3a64641a..0ddd11b238ce 100644
+--- a/arch/arm/boot/dts/Makefile
++++ b/arch/arm/boot/dts/Makefile
+@@ -1234,7 +1234,8 @@ dtb-$(CONFIG_MACH_ARMADA_38X) += \
+ 	armada-385-linksys-rango.dtb \
+ 	armada-385-linksys-shelby.dtb \
+ 	armada-385-synology-ds116.dtb \
+-	armada-385-turris-omnia.dtb \
++	armada-385-turris-omnia-phy.dtb \
++	armada-385-turris-omnia-sfp.dtb \
+ 	armada-388-clearfog.dtb \
+ 	armada-388-clearfog-base.dtb \
+ 	armada-388-clearfog-pro.dtb \
+diff --git a/arch/arm/boot/dts/armada-385-turris-omnia-phy.dts b/arch/arm/boot/dts/armada-385-turris-omnia-phy.dts
+new file mode 100644
+index 000000000000..706f6a2f8065
+--- /dev/null
++++ b/arch/arm/boot/dts/armada-385-turris-omnia-phy.dts
+@@ -0,0 +1,22 @@
++// SPDX-License-Identifier: (GPL-2.0 OR MIT)
++/*
++ * Device Tree file for the Turris Omnia
++ *
++ * Copyright (C) 2016 Uwe Kleine-König <uwe@kleine-koenig.org>
++ * Copyright (C) 2016-2019 Tomas Hlavacek <tmshlvkc@gmail.com>
++ *
++ * Schematic available at https://www.turris.cz/doc/_media/rtrom01-schema.pdf
++ */
++
++/dts-v1/;
++
++#include "armada-385-turris-omnia.dtsi"
++
++&phy1 {
++	status = "okay";
++};
++
++&eth2 {
++	phy-mode = "sgmii";
++	phy = <&phy1>;
++};
+diff --git a/arch/arm/boot/dts/armada-385-turris-omnia-sfp.dts b/arch/arm/boot/dts/armada-385-turris-omnia-sfp.dts
+new file mode 100644
+index 000000000000..b9f2b88834be
+--- /dev/null
++++ b/arch/arm/boot/dts/armada-385-turris-omnia-sfp.dts
+@@ -0,0 +1,23 @@
++// SPDX-License-Identifier: (GPL-2.0 OR MIT)
++/*
++ * Device Tree file for the Turris Omnia
++ *
++ * Copyright (C) 2016 Uwe Kleine-König <uwe@kleine-koenig.org>
++ * Copyright (C) 2016-2019 Tomas Hlavacek <tmshlvkc@gmail.com>
++ *
++ * Schematic available at https://www.turris.cz/doc/_media/rtrom01-schema.pdf
++ */
++
++/dts-v1/;
++
++#include "armada-385-turris-omnia.dtsi"
++
++&sfp {
++	status = "okay";
++};
++
++&eth2 {
++	phy-mode = "sgmii";
++	managed = "in-band-status";
++	sfp = <&sfp>;
++};
+diff --git a/arch/arm/boot/dts/armada-385-turris-omnia.dts b/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
+similarity index 88%
+rename from arch/arm/boot/dts/armada-385-turris-omnia.dts
+rename to arch/arm/boot/dts/armada-385-turris-omnia.dtsi
+index 768b6c5d2129..2f7c7da0d7e8 100644
+--- a/arch/arm/boot/dts/armada-385-turris-omnia.dts
++++ b/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
+@@ -3,13 +3,11 @@
+  * Device Tree file for the Turris Omnia
+  *
+  * Copyright (C) 2016 Uwe Kleine-König <uwe@kleine-koenig.org>
+- * Copyright (C) 2016 Tomas Hlavacek <tmshlvkc@gmail.com>
++ * Copyright (C) 2016-2019 Tomas Hlavacek <tmshlvkc@gmail.com>
+  *
+  * Schematic available at https://www.turris.cz/doc/_media/rtrom01-schema.pdf
+  */
+ 
+-/dts-v1/;
+-
+ #include <dt-bindings/gpio/gpio.h>
+ #include <dt-bindings/input/input.h>
+ #include "armada-385.dtsi"
+@@ -82,6 +80,17 @@
+ 			};
+ 		};
+ 	};
++
++	sfp: sfp {
++		compatible = "sff,sfp";
++		status = "disabled";
++		i2c-bus = <&i2csfp>;
++		tx-fault-gpios = <&sfpgpio 0 GPIO_ACTIVE_HIGH>;
++		tx-disable-gpios = <&sfpgpio 1 GPIO_ACTIVE_HIGH>;
++		rate-select0-gpios = <&sfpgpio 2 GPIO_ACTIVE_HIGH>;
++		los-gpios = <&sfpgpio 3 GPIO_ACTIVE_HIGH>;
++		mod-def0-gpios = <&sfpgpio 4 GPIO_ACTIVE_LOW>;
++	};
+ };
+ 
+ /* Connected to 88E6176 switch, port 6 */
+@@ -110,11 +119,10 @@
+ 	};
+ };
+ 
+-/* WAN port */
++/* WAN dual-personality port */
+ &eth2 {
++	phys = <&comphy5 2>;
+ 	status = "okay";
+-	phy-mode = "sgmii";
+-	phy = <&phy1>;
+ };
+ 
+ &i2c0 {
+@@ -177,7 +185,7 @@
+ 			/* routed to PCIe2 connector (CN62A) */
+ 		};
+ 
+-		i2c@4 {
++		i2csfp: i2c@4 {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 			reg = <4>;
+@@ -206,7 +214,7 @@
+ 			#size-cells = <0>;
+ 			reg = <7>;
+ 
+-			pcawan: gpio@71 {
++			sfpgpio: gpio@71 {
+ 				/*
+ 				 * GPIO expander for SFP+ signals and
+ 				 * and phy irq
+@@ -215,7 +223,7 @@
+ 				reg = <0x71>;
+ 
+ 				pinctrl-names = "default";
+-				pinctrl-0 = <&pcawan_pins>;
++				pinctrl-0 = <&wanint_pins>;
+ 
+ 				interrupt-parent = <&gpio1>;
+ 				interrupts = <14 IRQ_TYPE_LEVEL_LOW>;
+@@ -233,7 +241,7 @@
+ 	status = "okay";
+ 
+ 	phy1: phy@1 {
+-		status = "okay";
++		status = "disabled";
+ 		compatible = "ethernet-phy-id0141.0DD1", "ethernet-phy-ieee802.3-c22";
+ 		reg = <1>;
+ 
+@@ -290,13 +298,23 @@
+ 				};
+ 			};
+ 
+-			/* port 6 is connected to eth0 */
++			ports@6 {
++				reg = <6>;
++				label = "cpu";
++				ethernet = <&eth0>;
++				phy-mode = "rgmii-id";
++
++				fixed-link {
++					speed = <1000>;
++					full-duplex;
++				};
++			};
+ 		};
+ 	};
+ };
+ 
+ &pinctrl {
+-	pcawan_pins: pcawan-pins {
++	wanint_pins: wanint-pins {
+ 		marvell,pins = "mpp46";
+ 		marvell,function = "gpio";
+ 	};
+-- 
+2.24.1
+
diff --git a/target/linux/mvebu/patches-5.4/8801-leds-Add-LED-driver-for-Turris-Omnia.patch b/target/linux/mvebu/patches-5.4/8801-leds-Add-LED-driver-for-Turris-Omnia.patch
new file mode 100644
index 0000000..cbf44f9
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/8801-leds-Add-LED-driver-for-Turris-Omnia.patch
@@ -0,0 +1,345 @@
+From 922c4f682d25fe5c364a5cec5d91b6dc62f5d8e3 Mon Sep 17 00:00:00 2001
+From: Tomas Hlavacek <tmshlvck@gmail.com>
+Date: Tue, 5 May 2020 23:37:52 +0200
+Subject: [PATCH 1/3] leds: Add LED driver for Turris Omnia
+
+Add leds-omnia driver that implements plain LED interface.
+
+Turris Omnia board have sophisticated but unfotunatelly completely
+proprietary I2C LED driver implemented in the MCU on the board.
+
+The I2C protocol description will be published in
+https://www.turris.cz/en/hardware.
+
+The driver does not allow to control proprietary functions that are hard
+to map to the Linux LED API:
+
+ * per-led brigtness - the only two states (LED on/off) are supported,
+   even though each LED supports individual PWM based 8-bit RGB
+
+ * global_brightness - fast common PWM for all LEDs (can be
+   decreased/increased by the HW button)
+
+ * color - slow PWM color functionality for each LED (the LEDs are RGB
+   triplets, but the MCU abstraction makes it hard to do the usual RGB
+   mapping)
+
+ * autonomous operation - each LED can operate autonomously (being
+   driven by MCU based on the assigned indicator output from
+   PHY/ethernet switch/PCI cards etc.), autonomous mode is on by default
+   when the Linux led driver is not loaded. Once the Linux LED driver is
+   loaded and once an individual LED is accessed (by setting the
+   brightness) for the first time, it changes to the non-autonomous mode
+   and it can not be set back to autonomous operation mode from the
+   Linux LED driver without unloading it. When this driver is removed
+   all LEDs are set back to autonomous mode.
+
+The MCU supports setting all LEDs at once by setting the virtual 12th
+LED. This (hackish) feature is supported as well.
+
+Signed-off-by: Tomas Hlavacek <tmshlvck@gmail.com>
+---
+ drivers/leds/Kconfig      |   7 ++
+ drivers/leds/Makefile     |   1 +
+ drivers/leds/leds-omnia.c | 259 ++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 267 insertions(+)
+ create mode 100644 drivers/leds/leds-omnia.c
+
+diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
+index 1988de1d64c0..b389384cd617 100644
+--- a/drivers/leds/Kconfig
++++ b/drivers/leds/Kconfig
+@@ -713,6 +713,13 @@ config LEDS_SC27XX_BLTC
+ 	  This driver can also be built as a module. If so the module will be
+ 	  called leds-sc27xx-bltc.
+ 
++config LEDS_OMNIA
++	tristate "LED support for the Turris Omnia board"
++	depends on LEDS_CLASS
++	help
++	  Say Y here to include support for the LED driver on Turris Omnia
++	  board.
++
+ comment "LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)"
+ 
+ config LEDS_BLINKM
+diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
+index 41fb073a39c1..a859b2e74e54 100644
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -79,6 +79,7 @@ obj-$(CONFIG_LEDS_MLXREG)		+= leds-mlxreg.o
+ obj-$(CONFIG_LEDS_NIC78BX)		+= leds-nic78bx.o
+ obj-$(CONFIG_LEDS_SPI_BYTE)		+= leds-spi-byte.o
+ obj-$(CONFIG_LEDS_MT6323)		+= leds-mt6323.o
++obj-$(CONFIG_LEDS_OMNIA)		+= leds-omnia.o
+ obj-$(CONFIG_LEDS_LM3692X)		+= leds-lm3692x.o
+ obj-$(CONFIG_LEDS_SC27XX_BLTC)		+= leds-sc27xx-bltc.o
+ obj-$(CONFIG_LEDS_LM3601X)		+= leds-lm3601x.o
+diff --git a/drivers/leds/leds-omnia.c b/drivers/leds/leds-omnia.c
+new file mode 100644
+index 000000000000..0e10e806556e
+--- /dev/null
++++ b/drivers/leds/leds-omnia.c
+@@ -0,0 +1,259 @@
++/*
++ * Copyright 2016 CZ.NIC, z.s.p.o.
++ *
++ * Author: Tomas Hlavacek <tmshlvck@gmail.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation. 
++ */
++
++#include <linux/module.h>
++#include <linux/delay.h>
++#include <linux/string.h>
++#include <linux/ctype.h>
++#include <linux/leds.h>
++#include <linux/err.h>
++#include <linux/i2c.h>
++#include <linux/slab.h>
++#include <linux/of.h>
++
++#define MAX_LEDS 13
++#define ALL_LEDS_INDEX 12
++
++#define LED_AUTONOMOUS_ADDR 3
++#define LED_ONOFF_ADDR 4
++
++
++
++struct omnia_platform_data {
++        struct led_platform_data leds;
++};
++
++static const struct i2c_device_id omnia_id[] = {
++	{ "omnia", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, omnia_id);
++
++struct omnia_led_mcu {
++	struct mutex mutex;
++	struct i2c_client *client;
++	struct omnia_led *leds;
++};
++
++struct omnia_led {
++	struct omnia_led_mcu *chip;
++	struct led_classdev led_cdev;
++	int led_num; /* 0 .. 11 + 12=ALL */
++	char name[32];
++	u8 autonomous;
++};
++
++static int omnia_led_brightness_set(struct omnia_led *led,
++				enum led_brightness brightness)
++{
++	int ret;
++
++	mutex_lock(&led->chip->mutex);
++
++	ret = i2c_smbus_write_byte_data(led->chip->client, LED_ONOFF_ADDR,
++			(led->led_num | ((brightness != LED_OFF)<<4)));
++
++	mutex_unlock(&led->chip->mutex);
++	return ret;
++}
++
++static int omnia_led_autonomous_set(struct omnia_led *led, int autonomous)
++{
++	int ret, i;
++
++	mutex_lock(&led->chip->mutex);
++
++	if (led->autonomous == (autonomous != 0)) {
++		mutex_unlock(&led->chip->mutex);
++		return 0;
++	}
++
++	led->autonomous = (autonomous != 0);
++
++	if (led->led_num == ALL_LEDS_INDEX) {
++		for (i=0; i<(MAX_LEDS-1); i++)
++			led->chip->leds[i].autonomous = led->autonomous;
++	}
++
++	ret = i2c_smbus_write_byte_data(led->chip->client, LED_AUTONOMOUS_ADDR,
++			(u8)(led->led_num | ((!led->autonomous) << 4)));
++
++	mutex_unlock(&led->chip->mutex);
++	return ret;
++}
++
++static int omnia_led_set(struct led_classdev *led_cdev,
++	enum led_brightness value)
++{
++	struct omnia_led *led;
++	int ret;
++
++	led = container_of(led_cdev, struct omnia_led, led_cdev);
++
++	if (led->autonomous) {
++		ret = omnia_led_autonomous_set(led, 0);
++		if (ret < 0)
++			return ret;
++	}
++
++	return omnia_led_brightness_set(led, value);
++}
++
++static struct omnia_platform_data *
++omnia_dt_init(struct i2c_client *client)
++{
++	struct device_node *np = client->dev.of_node, *child;
++	struct omnia_platform_data *pdata;
++	struct led_info *leds;
++	int count;
++
++	count = of_get_child_count(np);
++	if (!count || count > MAX_LEDS)
++		return ERR_PTR(-ENODEV);
++
++	leds = devm_kzalloc(&client->dev,
++			sizeof(struct led_info) * MAX_LEDS, GFP_KERNEL);
++	if (!leds)
++		return ERR_PTR(-ENOMEM);
++
++	for_each_child_of_node(np, child) {
++		u32 reg;
++		int res;
++
++		res = of_property_read_u32(child, "reg", &reg);
++		if ((res != 0) || (reg >= MAX_LEDS))
++			continue;
++		leds[reg].name =
++			of_get_property(child, "label", NULL) ? : child->name;
++		leds[reg].default_trigger =
++			of_get_property(child, "linux,default-trigger", NULL);
++	}
++	pdata = devm_kzalloc(&client->dev,
++			     sizeof(struct omnia_platform_data), GFP_KERNEL);
++	if (!pdata)
++		return ERR_PTR(-ENOMEM);
++
++	pdata->leds.leds = leds;
++	pdata->leds.num_leds = MAX_LEDS;
++
++	return pdata;
++}
++
++static const struct of_device_id of_omnia_match[] = {
++	{ .compatible = "turris-leds,omnia", },
++	{},
++};
++MODULE_DEVICE_TABLE(of, of_omnia_match);
++
++static int omnia_probe(struct i2c_client *client,
++					const struct i2c_device_id *id)
++{
++	struct omnia_led_mcu *chip;
++	struct omnia_led *leds;
++	struct omnia_platform_data *pdata;
++	int i, err;
++
++	pdata = dev_get_platdata(&client->dev);
++
++	if (!pdata) {
++		pdata = omnia_dt_init(client);
++		if (IS_ERR(pdata)) {
++			dev_warn(&client->dev, "could not parse configuration\n");
++			pdata = NULL;
++		}
++	}
++
++	chip = devm_kzalloc(&client->dev, sizeof(*chip),
++				GFP_KERNEL);
++	if (!chip)
++		return -ENOMEM;
++	leds = devm_kzalloc(&client->dev, MAX_LEDS * sizeof(*leds),
++				GFP_KERNEL);
++	if (!leds)
++		return -ENOMEM;
++
++	i2c_set_clientdata(client, chip);
++
++	mutex_init(&chip->mutex);
++	chip->client = client;
++	chip->leds = leds;
++
++	for (i = 0; i < MAX_LEDS; i++) {
++		leds[i].led_num = i;
++		leds[i].chip = chip;
++
++		/* Platform data can specify LED names and default triggers */
++		if (pdata && i < pdata->leds.num_leds) {
++			if (pdata->leds.leds[i].name)
++				snprintf(leds[i].name,
++					 sizeof(leds[i].name), "omnia-led:%s",
++					 pdata->leds.leds[i].name);
++			if (pdata->leds.leds[i].default_trigger)
++				leds[i].led_cdev.default_trigger =
++					pdata->leds.leds[i].default_trigger;
++		}
++		if (!pdata || i >= pdata->leds.num_leds ||
++						!pdata->leds.leds[i].name)
++			snprintf(leds[i].name, sizeof(leds[i].name),
++				 "omnia-led:%d", i);
++
++		leds[i].led_cdev.name = leds[i].name;
++		leds[i].led_cdev.brightness_set_blocking = omnia_led_set;
++
++		err = led_classdev_register(&client->dev, &leds[i].led_cdev);
++		if (err < 0)
++			goto exit;
++
++		/* Set AUTO for all LEDs by default */
++		leds[i].autonomous = 0;
++		omnia_led_autonomous_set(&leds[i], 1);
++	}
++
++	return 0;
++
++exit:
++	while (i--) {
++		led_classdev_unregister(&leds[i].led_cdev);
++	}
++
++	return err;
++}
++
++static int omnia_remove(struct i2c_client *client)
++{
++	struct omnia_led_mcu *chip = i2c_get_clientdata(client);
++	int i;
++
++	for (i = 0; i < MAX_LEDS; i++) {
++		led_classdev_unregister(&chip->leds[i].led_cdev);
++
++		/* Set AUTO for the LED */
++		omnia_led_autonomous_set(&chip->leds[i], 1);
++	}
++
++	return 0;
++}
++
++static struct i2c_driver omnia_driver = {
++	.driver = {
++		.name	= "leds-omnia",
++		.of_match_table = of_match_ptr(of_omnia_match),
++	},
++	.probe	= omnia_probe,
++	.remove	= omnia_remove,
++	.id_table = omnia_id,
++};
++
++module_i2c_driver(omnia_driver);
++
++MODULE_AUTHOR("Tomas Hlavacek <tmshlvck@gmail.com>");
++MODULE_DESCRIPTION("Turris Omnia LED driver");
++MODULE_LICENSE("GPL v2");
++
+-- 
+2.24.1
+
diff --git a/target/linux/mvebu/patches-5.4/8802-leds-omnia-Add-proprietary-part-of-LED-driver.patch b/target/linux/mvebu/patches-5.4/8802-leds-omnia-Add-proprietary-part-of-LED-driver.patch
new file mode 100644
index 0000000..16ff5e6
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/8802-leds-omnia-Add-proprietary-part-of-LED-driver.patch
@@ -0,0 +1,281 @@
+From 4bd465f6e6a3a1789234113e32dc87f3616b224f Mon Sep 17 00:00:00 2001
+From: Tomas Hlavacek <tmshlvck@gmail.com>
+Date: Tue, 5 May 2020 23:41:08 +0200
+Subject: [PATCH 2/3] leds: omnia: Add proprietary part of LED driver
+
+Add proprietary part of leds-omnia driver that implements Linux LED
+interface.
+
+On top of that driver that is able to set non-autonomous mode and use
+slow PWM to drive individual LEDs and also the 12th virtual ALL LED add
+following sysfs files for setting:
+
+global_brightness - [0..100] = PWM base for all the LEDs. It is the
+maximum intensity. Particular colors on each LED might be decreased
+individually.
+
+color - [0..255] [0..255] [0..255] = PWM for each color on each LED.
+
+autonomous [0|1] = 1=MCU drives the LED according to its default
+function, blink from Linux LED driver is ignored; 0=Linux LED driver
+sets brightness/blink.
+
+Signed-off-by: Tomas Hlavacek <tmshlvck@gmail.com>
+---
+ drivers/leds/leds-omnia.c | 195 ++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 195 insertions(+)
+
+diff --git a/drivers/leds/leds-omnia.c b/drivers/leds/leds-omnia.c
+index 0e10e806556e..38d8c8251b2f 100644
+--- a/drivers/leds/leds-omnia.c
++++ b/drivers/leds/leds-omnia.c
+@@ -23,6 +23,9 @@
+ 
+ #define LED_AUTONOMOUS_ADDR 3
+ #define LED_ONOFF_ADDR 4
++#define LED_COLOR_ADDR 5
++#define GLOB_BRIGHTNESS_READ 8
++#define GLOB_BRIGHTNESS_WRITE 7
+ 
+ 
+ 
+@@ -48,6 +51,9 @@ struct omnia_led {
+ 	int led_num; /* 0 .. 11 + 12=ALL */
+ 	char name[32];
+ 	u8 autonomous;
++	u8 r;
++	u8 g;
++	u8 b;
+ };
+ 
+ static int omnia_led_brightness_set(struct omnia_led *led,
+@@ -89,6 +95,59 @@ static int omnia_led_autonomous_set(struct omnia_led *led, int autonomous)
+ 	return ret;
+ }
+ 
++static int omnia_glob_brightness_set(struct omnia_led_mcu *chip,
++					int glob_brightness)
++{
++	int ret;
++
++	mutex_lock(&chip->mutex);
++
++	ret = i2c_smbus_write_byte_data(chip->client, GLOB_BRIGHTNESS_WRITE,
++						(u8)glob_brightness);
++
++	mutex_unlock(&chip->mutex);
++	return ret;
++}
++
++static int omnia_glob_brightness_get(struct omnia_led_mcu *chip)
++{
++	int ret;
++
++	mutex_lock(&chip->mutex);
++
++	ret = i2c_smbus_read_byte_data(chip->client, GLOB_BRIGHTNESS_READ);
++
++	mutex_unlock(&chip->mutex);
++	return ret;
++}
++
++static int omnia_led_color_set(struct omnia_led *led, u8 r, u8 g, u8 b)
++{
++	int ret, i;
++	u8 buf[5];
++
++	buf[0] = LED_COLOR_ADDR;
++	buf[1] = led->led_num;
++	buf[2] = r;
++	buf[3] = g;
++	buf[4] = b;
++
++	mutex_lock(&led->chip->mutex);
++
++	ret = i2c_master_send(led->chip->client, buf, 5);
++
++	if (led->led_num == ALL_LEDS_INDEX) {
++		for (i=0; i<(MAX_LEDS-1); i++) {
++			led->chip->leds[i].r = led->r;
++			led->chip->leds[i].g = led->g;
++			led->chip->leds[i].b = led->b;
++		}
++	}
++
++	mutex_unlock(&led->chip->mutex);
++	return -(ret<=0);
++}
++
+ static int omnia_led_set(struct led_classdev *led_cdev,
+ 	enum led_brightness value)
+ {
+@@ -146,6 +205,98 @@ omnia_dt_init(struct i2c_client *client)
+ 	return pdata;
+ }
+ 
++static ssize_t global_brightness_show(struct device *d,
++                struct device_attribute *attr, char *buf)
++{
++	struct i2c_client *client = to_i2c_client(d);
++	struct omnia_led_mcu *chip = i2c_get_clientdata(client);
++
++	return scnprintf(buf, PAGE_SIZE, "%d\n",
++				omnia_glob_brightness_get(chip));
++}
++
++static ssize_t global_brightness_store(struct device *d,
++                struct device_attribute *attr, const char *buf, size_t count)
++{
++	struct i2c_client *client = to_i2c_client(d);
++        struct omnia_led_mcu *chip = i2c_get_clientdata(client);
++	int ret;
++	int global_brightness;
++
++	if ((sscanf(buf, "%i", &global_brightness)) != 1)
++		return -EINVAL;
++
++	ret = omnia_glob_brightness_set(chip, global_brightness);
++	if (ret < 0)
++		return ret;
++
++	return count;
++}
++static DEVICE_ATTR_RW(global_brightness);
++
++static ssize_t autonomous_show(struct device *d,
++                struct device_attribute *attr, char *buf)
++{
++	struct led_classdev *led_cdev = dev_get_drvdata(d);
++	struct omnia_led *led =
++			container_of(led_cdev, struct omnia_led, led_cdev);
++
++	return scnprintf(buf, PAGE_SIZE, "%d\n", led->autonomous);
++}
++
++static ssize_t autonomous_store(struct device *d,
++                struct device_attribute *attr, const char *buf, size_t count)
++{
++	int ret, autonomous;
++	struct led_classdev *led_cdev = dev_get_drvdata(d);
++	struct omnia_led *led =
++			container_of(led_cdev, struct omnia_led, led_cdev);
++
++	if ((sscanf(buf, "%i", &autonomous)) != 1)
++		return -EINVAL;
++
++	ret = omnia_led_autonomous_set(led, autonomous);
++	if (ret < 0)
++		return ret;
++
++	led->autonomous = autonomous;
++	return count;
++}
++static DEVICE_ATTR_RW(autonomous);
++
++static ssize_t color_show(struct device *d,
++                struct device_attribute *attr, char *buf)
++{
++	struct led_classdev *led_cdev = dev_get_drvdata(d);
++	struct omnia_led *led =
++			container_of(led_cdev, struct omnia_led, led_cdev);
++
++	return scnprintf(buf, PAGE_SIZE, "%d %d %d\n", led->r, led->g, led->b);
++}
++
++static ssize_t color_store(struct device *d,
++                struct device_attribute *attr, const char *buf, size_t count)
++{
++	int ret, r, g, b;
++	struct led_classdev *led_cdev = dev_get_drvdata(d);
++	struct omnia_led *led =
++			container_of(led_cdev, struct omnia_led, led_cdev);
++
++	if ((sscanf(buf, "%i %i %i", &r, &g, &b)) != 3)
++		return -EINVAL;
++
++	ret = omnia_led_color_set(led, r, g, b);
++	if (ret < 0)
++		return ret;
++
++	led->r = r;
++	led->g = g;
++	led->b = b;
++	return count;
++}
++static DEVICE_ATTR_RW(color);
++
++
+ static const struct of_device_id of_omnia_match[] = {
+ 	{ .compatible = "turris-leds,omnia", },
+ 	{},
+@@ -211,15 +362,52 @@ static int omnia_probe(struct i2c_client *client,
+ 		if (err < 0)
+ 			goto exit;
+ 
++		err = device_create_file(leds[i].led_cdev.dev,
++						&dev_attr_autonomous);
++		if (err < 0) {
++			dev_err(leds[i].led_cdev.dev,
++				"failed to create attribute autonomous\n");
++			goto exit;
++		}
++
++		err = device_create_file(leds[i].led_cdev.dev,
++						&dev_attr_color);
++		if (err < 0) {
++			dev_err(leds[i].led_cdev.dev,
++				"failed to create attribute color\n");
++			goto exit;
++		}
++
+ 		/* Set AUTO for all LEDs by default */
+ 		leds[i].autonomous = 0;
+ 		omnia_led_autonomous_set(&leds[i], 1);
++
++		/* Set brightness to LED_OFF by default */
++		omnia_led_brightness_set(&leds[i], LED_OFF);
++
++		/* MCU default color is white */
++		leds[i].r = 255;
++		leds[i].g = 255;
++		leds[i].b = 255;
++	}
++
++	err = device_create_file(&client->dev, &dev_attr_global_brightness);
++	if (err < 0) {
++		dev_err(&client->dev,
++			"failed to create attribute global_brightness\n");
++		goto exit;
+ 	}
+ 
+ 	return 0;
+ 
+ exit:
++	device_remove_file(&client->dev, &dev_attr_global_brightness);
+ 	while (i--) {
++		device_remove_file(chip->leds[i].led_cdev.dev,
++			&dev_attr_color);
++		device_remove_file(chip->leds[i].led_cdev.dev,
++			&dev_attr_autonomous);
++
+ 		led_classdev_unregister(&leds[i].led_cdev);
+ 	}
+ 
+@@ -231,7 +419,14 @@ static int omnia_remove(struct i2c_client *client)
+ 	struct omnia_led_mcu *chip = i2c_get_clientdata(client);
+ 	int i;
+ 
++	device_remove_file(&client->dev, &dev_attr_global_brightness);
++
+ 	for (i = 0; i < MAX_LEDS; i++) {
++		device_remove_file(chip->leds[i].led_cdev.dev,
++			&dev_attr_color);
++		device_remove_file(chip->leds[i].led_cdev.dev,
++			&dev_attr_autonomous);
++
+ 		led_classdev_unregister(&chip->leds[i].led_cdev);
+ 
+ 		/* Set AUTO for the LED */
+-- 
+2.24.1
+
diff --git a/target/linux/mvebu/patches-5.4/8803-ARM-dts-mvebu-armada-385-turris-omnia-describe-LED-n.patch b/target/linux/mvebu/patches-5.4/8803-ARM-dts-mvebu-armada-385-turris-omnia-describe-LED-n.patch
new file mode 100644
index 0000000..b77d5fd
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/8803-ARM-dts-mvebu-armada-385-turris-omnia-describe-LED-n.patch
@@ -0,0 +1,107 @@
+From 5d6daef2b67ed98a15d0abeacaa08beec7f5953e Mon Sep 17 00:00:00 2001
+From: Tomas Hlavacek <tmshlvck@gmail.com>
+Date: Tue, 5 May 2020 23:44:34 +0200
+Subject: [PATCH 3/3] ARM: dts: mvebu: armada-385-turris-omnia: describe LED
+ nodes
+
+Add configuration for the leds-omnia driver.
+
+Use the labels from enclosure as the LED names. Use I2C address 0x2b.
+
+The MCU on Omnia board have three I2C slave addresses: 0x2a, 0x2b and 0x2c.
+
+0x2a should be used from userspace applications
+0x2b should be used from kernel LED driver
+0x2c is the special address for bootloader image transfer
+
+Signed-off-by: Tomas Hlavacek <tmshlvck@gmail.com>
+---
+ .../arm/boot/dts/armada-385-turris-omnia.dtsi | 72 +++++++++++++++++++
+ 1 file changed, 72 insertions(+)
+
+diff --git a/arch/arm/boot/dts/armada-385-turris-omnia.dtsi b/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
+index 561911feb018..8a189cd5fd4f 100644
+--- a/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
++++ b/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
+@@ -143,6 +143,78 @@
+ 
+ 			/* STM32F0 command interface at address 0x2a */
+ 			/* leds device (in STM32F0) at address 0x2b */
++			leds@2b {
++				compatible = "turris-leds,omnia";
++				reg = <0x2b>;
++
++				#address-cells = <1>;
++				#size-cells = <0>;
++
++				led0 {
++					label = "user2";
++					reg = <0x0>;
++				};
++
++				led1 {
++					label = "user1";
++					reg = <0x1>;
++				};
++
++				led2 {
++					label = "pci3";
++					reg = <0x2>;
++				};
++
++				led3 {
++					label = "pci2";
++					reg = <0x3>;
++				};
++
++				led4 {
++					label = "pci1";
++					reg = <0x4>;
++				};
++
++				led5 {
++					label = "wan";
++					reg = <0x5>;
++				};
++
++				led6 {
++					label = "lan4";
++					reg = <0x6>;
++				};
++
++				led7 {
++					label = "lan3";
++					reg = <0x7>;
++				};
++
++				led8 {
++					label = "lan2";
++					reg = <0x8>;
++				};
++
++				led9 {
++					label = "lan1";
++					reg = <0x9>;
++				};
++
++				led10 {
++					label = "lan0";
++					reg = <0xa>;
++				};
++
++				led11 {
++					label = "power";
++					reg = <0xb>;
++				};
++
++				led12 {
++					label = "all";
++					reg = <0xc>;
++				};
++			};
+ 
+ 			eeprom@54 {
+ 				compatible = "atmel,24c64";
+-- 
+2.24.1
+
diff --git a/target/linux/mvebu/patches-5.4/8804-ARM-dts-mvebu-armada-385-turris-omnia-enable-HW-buff.patch b/target/linux/mvebu/patches-5.4/8804-ARM-dts-mvebu-armada-385-turris-omnia-enable-HW-buff.patch
new file mode 100644
index 0000000..6f98821
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/8804-ARM-dts-mvebu-armada-385-turris-omnia-enable-HW-buff.patch
@@ -0,0 +1,76 @@
+From f4efd080c9e4f5d2c5557c3ba72584b4eb349ccc Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 7 May 2020 17:54:21 +0200
+Subject: [PATCH] ARM: dts: mvebu: armada-385-turris-omnia: enable HW buffer
+ management
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Enable HW buffer management for all three ethernet controllers on Turris
+Omnia.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ .../arm/boot/dts/armada-385-turris-omnia.dtsi | 20 ++++++++++++++++++-
+ 1 file changed, 19 insertions(+), 1 deletion(-)
+
+diff --git a/arch/arm/boot/dts/armada-385-turris-omnia.dtsi b/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
+index 5faecdbfaf8b..967d5bf13b5f 100644
+--- a/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
++++ b/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
+@@ -29,7 +29,8 @@
+ 		ranges = <MBUS_ID(0xf0, 0x01) 0 0xf1000000 0x100000
+ 			  MBUS_ID(0x01, 0x1d) 0 0xfff00000 0x100000
+ 			  MBUS_ID(0x09, 0x19) 0 0xf1100000 0x10000
+-			  MBUS_ID(0x09, 0x15) 0 0xf1110000 0x10000>;
++			  MBUS_ID(0x09, 0x15) 0 0xf1110000 0x10000
++			  MBUS_ID(0x0c, 0x04) 0 0xf1200000 0x100000>;
+ 
+ 		internal-regs {
+ 
+@@ -93,10 +94,21 @@
+ 	};
+ };
+ 
++&bm {
++	status = "okay";
++};
++
++&bm_bppi {
++	status = "okay";
++};
++
+ /* Connected to 88E6176 switch, port 6 */
+ &eth0 {
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&ge0_rgmii_pins>;
++	buffer-manager = <&bm>;
++	bm,pool-long = <0>;
++	bm,pool-short = <3>;
+ 	status = "okay";
+ 	phy-mode = "rgmii";
+ 
+@@ -110,6 +122,9 @@
+ &eth1 {
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&ge1_rgmii_pins>;
++	buffer-manager = <&bm>;
++	bm,pool-long = <1>;
++	bm,pool-short = <3>;
+ 	status = "okay";
+ 	phy-mode = "rgmii";
+ 
+@@ -121,6 +136,9 @@
+ 
+ /* WAN dual-personality port */
+ &eth2 {
++	buffer-manager = <&bm>;
++	bm,pool-long = <2>;
++	bm,pool-short = <3>;
+ 	phys = <&comphy5 2>;
+ 	status = "okay";
+ };
+-- 
+2.24.1
+
diff --git a/target/linux/mvebu/patches-5.4/9950-net-dsa-allow-for-multiple-CPU-ports.patch b/target/linux/mvebu/patches-5.4/9950-net-dsa-allow-for-multiple-CPU-ports.patch
new file mode 100644
index 0000000..1424d17
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/9950-net-dsa-allow-for-multiple-CPU-ports.patch
@@ -0,0 +1,219 @@
+From 3cbd1b83e555e33448f78cbdae3a0b691c8419cf Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Tue, 5 May 2020 19:22:58 +0200
+Subject: [PATCH] net: dsa: allow for multiple CPU ports
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Allow for multiple CPU ports in a DSA switch tree. By default assign the
+CPU ports to user ports in a round robin way, ie. if there are two CPU
+ports connected to eth0 and eth1, and five user ports (lan1..lan5),
+assign them as:
+  lan1 <-> eth0
+  lan2 <-> eth1
+  lan3 <-> eth0
+  lan4 <-> eth1
+  lan5 <-> eth0
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ include/net/dsa.h |  5 +--
+ net/dsa/dsa2.c    | 82 ++++++++++++++++++++++++++++++-----------------
+ 2 files changed, 56 insertions(+), 31 deletions(-)
+
+diff --git a/include/net/dsa.h b/include/net/dsa.h
+index 541fb514e31d..04b2805c3603 100644
+--- a/include/net/dsa.h
++++ b/include/net/dsa.h
+@@ -123,9 +123,10 @@ struct dsa_switch_tree {
+ 	struct dsa_platform_data	*pd;
+ 
+ 	/*
+-	 * The switch port to which the CPU is attached.
++	 * The switch ports to which the CPU is attached.
+ 	 */
+-	struct dsa_port		*cpu_dp;
++	size_t			num_cpu_dps;
++	struct dsa_port		*cpu_dps[DSA_MAX_PORTS];
+ 
+ 	/*
+ 	 * Data for the individual switch chips.
+diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
+index 716d265ba8ca..bb8133e5af0a 100644
+--- a/net/dsa/dsa2.c
++++ b/net/dsa/dsa2.c
+@@ -194,11 +194,12 @@ static bool dsa_tree_setup_routing_table(struct dsa_switch_tree *dst)
+ 	return complete;
+ }
+ 
+-static struct dsa_port *dsa_tree_find_first_cpu(struct dsa_switch_tree *dst)
++static void dsa_tree_fill_cpu_ports(struct dsa_switch_tree *dst)
+ {
+ 	struct dsa_switch *ds;
+ 	struct dsa_port *dp;
+ 	int device, port;
++	int count = 0;
+ 
+ 	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
+ 		ds = dst->ds[device];
+@@ -208,28 +209,37 @@ static struct dsa_port *dsa_tree_find_first_cpu(struct dsa_switch_tree *dst)
+ 		for (port = 0; port < ds->num_ports; port++) {
+ 			dp = &ds->ports[port];
+ 
+-			if (dsa_port_is_cpu(dp))
+-				return dp;
++			if (dsa_port_is_cpu(dp)) {
++				if (count == ARRAY_SIZE(dst->cpu_dps)) {
++					pr_warn("Tree has too many CPU ports\n");
++					dst->num_cpu_dps = count;
++					return;
++				}
++
++				dst->cpu_dps[count++] = dp;
++			}
+ 		}
+ 	}
+ 
+-	return NULL;
++	dst->num_cpu_dps = count;
+ }
+ 
+-static int dsa_tree_setup_default_cpu(struct dsa_switch_tree *dst)
++static int dsa_tree_setup_default_cpus(struct dsa_switch_tree *dst)
+ {
+ 	struct dsa_switch *ds;
+ 	struct dsa_port *dp;
+-	int device, port;
++	int device, port, i;
+ 
+-	/* DSA currently only supports a single CPU port */
+-	dst->cpu_dp = dsa_tree_find_first_cpu(dst);
+-	if (!dst->cpu_dp) {
++	dsa_tree_fill_cpu_ports(dst);
++	if (!dst->num_cpu_dps) {
+ 		pr_warn("Tree has no master device\n");
+ 		return -EINVAL;
+ 	}
+ 
+-	/* Assign the default CPU port to all ports of the fabric */
++	/* Assign the default CPU port to all ports of the fabric in a round
++	 * robin way. This should work nicely for all sane switch tree designs.
++	 */
++	i = 0;
+ 	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
+ 		ds = dst->ds[device];
+ 		if (!ds)
+@@ -238,18 +248,20 @@ static int dsa_tree_setup_default_cpu(struct dsa_switch_tree *dst)
+ 		for (port = 0; port < ds->num_ports; port++) {
+ 			dp = &ds->ports[port];
+ 
+-			if (dsa_port_is_user(dp) || dsa_port_is_dsa(dp))
+-				dp->cpu_dp = dst->cpu_dp;
++			if (dsa_port_is_user(dp) || dsa_port_is_dsa(dp)) {
++				dp->cpu_dp = dst->cpu_dps[i++];
++				if (i == dst->num_cpu_dps)
++					i = 0;
++			}
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+-static void dsa_tree_teardown_default_cpu(struct dsa_switch_tree *dst)
++static void dsa_tree_teardown_default_cpus(struct dsa_switch_tree *dst)
+ {
+-	/* DSA currently only supports a single CPU port */
+-	dst->cpu_dp = NULL;
++	dst->num_cpu_dps = 0;
+ }
+ 
+ static int dsa_port_setup(struct dsa_port *dp)
+@@ -512,21 +524,33 @@ static void dsa_tree_teardown_switches(struct dsa_switch_tree *dst)
+ 	}
+ }
+ 
+-static int dsa_tree_setup_master(struct dsa_switch_tree *dst)
++static int dsa_tree_setup_masters(struct dsa_switch_tree *dst)
+ {
+-	struct dsa_port *cpu_dp = dst->cpu_dp;
+-	struct net_device *master = cpu_dp->master;
++	int i, err;
++
++	for (i = 0; i < dst->num_cpu_dps; ++i) {
++		struct dsa_port *cpu_dp = dst->cpu_dps[i];
++		struct net_device *master = cpu_dp->master;
+ 
+-	/* DSA currently supports a single pair of CPU port and master device */
+-	return dsa_master_setup(master, cpu_dp);
++		err = dsa_master_setup(master, cpu_dp);
++		if (err)
++			goto teardown;
++	}
++
++	return 0;
++teardown:
++	for (--i; i >= 0; --i)
++		dsa_master_teardown(dst->cpu_dps[i]->master);
++
++	return err;
+ }
+ 
+-static void dsa_tree_teardown_master(struct dsa_switch_tree *dst)
++static void dsa_tree_teardown_masters(struct dsa_switch_tree *dst)
+ {
+-	struct dsa_port *cpu_dp = dst->cpu_dp;
+-	struct net_device *master = cpu_dp->master;
++	int i;
+ 
+-	return dsa_master_teardown(master);
++	for (i = 0; i < dst->num_cpu_dps; ++i)
++		dsa_master_teardown(dst->cpu_dps[i]->master);
+ }
+ 
+ static int dsa_tree_setup(struct dsa_switch_tree *dst)
+@@ -544,7 +568,7 @@ static int dsa_tree_setup(struct dsa_switch_tree *dst)
+ 	if (!complete)
+ 		return 0;
+ 
+-	err = dsa_tree_setup_default_cpu(dst);
++	err = dsa_tree_setup_default_cpus(dst);
+ 	if (err)
+ 		return err;
+ 
+@@ -552,7 +576,7 @@ static int dsa_tree_setup(struct dsa_switch_tree *dst)
+ 	if (err)
+ 		goto teardown_default_cpu;
+ 
+-	err = dsa_tree_setup_master(dst);
++	err = dsa_tree_setup_masters(dst);
+ 	if (err)
+ 		goto teardown_switches;
+ 
+@@ -565,7 +589,7 @@ static int dsa_tree_setup(struct dsa_switch_tree *dst)
+ teardown_switches:
+ 	dsa_tree_teardown_switches(dst);
+ teardown_default_cpu:
+-	dsa_tree_teardown_default_cpu(dst);
++	dsa_tree_teardown_default_cpus(dst);
+ 
+ 	return err;
+ }
+@@ -575,11 +599,11 @@ static void dsa_tree_teardown(struct dsa_switch_tree *dst)
+ 	if (!dst->setup)
+ 		return;
+ 
+-	dsa_tree_teardown_master(dst);
++	dsa_tree_teardown_masters(dst);
+ 
+ 	dsa_tree_teardown_switches(dst);
+ 
+-	dsa_tree_teardown_default_cpu(dst);
++	dsa_tree_teardown_default_cpus(dst);
+ 
+ 	pr_info("DSA: tree %d torn down\n", dst->index);
+ 
+-- 
+2.24.1
+
diff --git a/target/linux/mvebu/patches-5.4/9951-net-add-ndo-for-setting-the-iflink-property.patch b/target/linux/mvebu/patches-5.4/9951-net-add-ndo-for-setting-the-iflink-property.patch
new file mode 100644
index 0000000..3b2482d
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/9951-net-add-ndo-for-setting-the-iflink-property.patch
@@ -0,0 +1,101 @@
+From 846d8a31f9cc9048f58358770d20d3153918c93d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Tue, 5 May 2020 19:28:53 +0200
+Subject: [PATCH] net: add ndo for setting the iflink property
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+In DSA the iflink value is used to report to which CPU port a given
+switch port is connected to. Since we want to support multi-CPU DSA, we
+want the user to be able to change this value.
+
+Add ndo_set_iflink method into the ndo strucutre to be a pair to
+ndo_get_iflink. Also create dev_set_iflink and call this from the
+netlink code, so that userspace can change the iflink value.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ include/linux/netdevice.h |  5 +++++
+ net/core/dev.c            | 16 ++++++++++++++++
+ net/core/rtnetlink.c      |  7 +++++++
+ 3 files changed, 28 insertions(+)
+
+diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
+index b580a35f50ea..1a951eca08da 100644
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -1209,6 +1209,8 @@ struct tlsdev_ops;
+  *	TX queue.
+  * int (*ndo_get_iflink)(const struct net_device *dev);
+  *	Called to get the iflink value of this device.
++ * int (*ndo_set_iflink)(struct net_device *dev, int iflink);
++ *	Called to set the iflink value of this device.
+  * void (*ndo_change_proto_down)(struct net_device *dev,
+  *				 bool proto_down);
+  *	This function is used to pass protocol port error state information
+@@ -1428,6 +1430,8 @@ struct net_device_ops {
+ 						      int queue_index,
+ 						      u32 maxrate);
+ 	int			(*ndo_get_iflink)(const struct net_device *dev);
++	int			(*ndo_set_iflink)(struct net_device *dev,
++						  int iflink);
+ 	int			(*ndo_change_proto_down)(struct net_device *dev,
+ 							 bool proto_down);
+ 	int			(*ndo_fill_metadata_dst)(struct net_device *dev,
+@@ -2617,6 +2621,7 @@ void dev_add_offload(struct packet_offload *po);
+ void dev_remove_offload(struct packet_offload *po);
+ 
+ int dev_get_iflink(const struct net_device *dev);
++int dev_set_iflink(struct net_device *dev, int iflink);
+ int dev_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb);
+ struct net_device *__dev_get_by_flags(struct net *net, unsigned short flags,
+ 				      unsigned short mask);
+diff --git a/net/core/dev.c b/net/core/dev.c
+index 8ad1e8f00958..c0bba4ddec21 100644
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -611,6 +611,22 @@ int dev_get_iflink(const struct net_device *dev)
+ }
+ EXPORT_SYMBOL(dev_get_iflink);
+ 
++/**
++ *	dev_set_iflink - set 'iflink' value of an interface
++ *	@dev: target interface
++ *	@iflink: new value
++ *
++ *	Change the interface to which this interface is linked to.
++ */
++int dev_set_iflink(struct net_device *dev, int iflink)
++{
++	if (dev->netdev_ops && dev->netdev_ops->ndo_set_iflink)
++		return dev->netdev_ops->ndo_set_iflink(dev, iflink);
++
++	return -EOPNOTSUPP;
++}
++EXPORT_SYMBOL(dev_set_iflink);
++
+ /**
+  *	dev_fill_metadata_dst - Retrieve tunnel egress information.
+  *	@dev: targeted interface
+diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
+index 944acb1a9f29..b35fc82f032a 100644
+--- a/net/core/rtnetlink.c
++++ b/net/core/rtnetlink.c
+@@ -2529,6 +2529,13 @@ static int do_setlink(const struct sk_buff *skb,
+ 		status |= DO_SETLINK_MODIFIED;
+ 	}
+ 
++	if (tb[IFLA_LINK]) {
++		err = dev_set_iflink(dev, nla_get_u32(tb[IFLA_LINK]));
++		if (err)
++			goto errout;
++		status |= DO_SETLINK_MODIFIED;
++	}
++
+ 	if (tb[IFLA_CARRIER]) {
+ 		err = dev_change_carrier(dev, nla_get_u8(tb[IFLA_CARRIER]));
+ 		if (err)
+-- 
+2.24.1
+
diff --git a/target/linux/mvebu/patches-5.4/9952-net-dsa-implement-ndo_set_netlink-for-chaning-port-s.patch b/target/linux/mvebu/patches-5.4/9952-net-dsa-implement-ndo_set_netlink-for-chaning-port-s.patch
new file mode 100644
index 0000000..7174069
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/9952-net-dsa-implement-ndo_set_netlink-for-chaning-port-s.patch
@@ -0,0 +1,97 @@
+From 801d3c1a412e187242bca86daba77c4a6d7a4d21 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Tue, 5 May 2020 19:33:39 +0200
+Subject: [PATCH] net: dsa: implement ndo_set_netlink for chaning port's
+ CPU port
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Implement ndo_set_iflink for DSA slave device. In multi-CPU port setup
+this should be used to change to which CPU destination port a given port
+should be connected.
+
+This adds a new operation into the DSA switch operations structure,
+port_change_cpu_port. A driver implementing this function has the
+ability to change CPU destination port of a given port.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ include/net/dsa.h |  6 ++++++
+ net/dsa/slave.c   | 36 ++++++++++++++++++++++++++++++++++++
+ 2 files changed, 42 insertions(+)
+
+diff --git a/include/net/dsa.h b/include/net/dsa.h
+index 04b2805c3603..15626a862250 100644
+--- a/include/net/dsa.h
++++ b/include/net/dsa.h
+@@ -544,6 +544,12 @@ struct dsa_switch_ops {
+ 	 */
+ 	netdev_tx_t (*port_deferred_xmit)(struct dsa_switch *ds, int port,
+ 					  struct sk_buff *skb);
++
++	/*
++	 * Multi-CPU port support
++	 */
++	int	(*port_change_cpu_port)(struct dsa_switch *ds, int port,
++					struct dsa_port *new_cpu_dp);
+ };
+ 
+ struct dsa_switch_driver {
+diff --git a/net/dsa/slave.c b/net/dsa/slave.c
+index 23c2210fa7ec..08ec962a6f14 100644
+--- a/net/dsa/slave.c
++++ b/net/dsa/slave.c
+@@ -64,6 +64,41 @@ static int dsa_slave_get_iflink(const struct net_device *dev)
+ 	return dsa_slave_to_master(dev)->ifindex;
+ }
+ 
++static int dsa_slave_set_iflink(struct net_device *dev, int iflink)
++{
++	struct dsa_port *dp = dsa_slave_to_port(dev);
++	struct dsa_slave_priv *p = netdev_priv(dev);
++	struct net_device *new_cpu_dev;
++	struct dsa_port *new_cpu_dp;
++	int err;
++
++	if (!dp->ds->ops->port_change_cpu_port)
++		return -EOPNOTSUPP;
++
++	new_cpu_dev = dev_get_by_index(dev_net(dev), iflink);
++	if (!new_cpu_dev)
++		return -ENODEV;
++
++	new_cpu_dp = new_cpu_dev->dsa_ptr;
++	if (!new_cpu_dp)
++		return -EINVAL;
++
++	/* new CPU port has to be on the same switch tree */
++	if (new_cpu_dp->dst != dp->dst)
++		return -EINVAL;
++
++	/* should this be done atomically? should this return to previous cpu_dp
++	 * in case of error? */
++	dp->cpu_dp = new_cpu_dp;
++	p->xmit = new_cpu_dp->tag_ops->xmit;
++
++	err = dp->ds->ops->port_change_cpu_port(dp->ds, dp->index, new_cpu_dp);
++	if (err)
++		return err;
++
++	return 0;
++}
++
+ static int dsa_slave_open(struct net_device *dev)
+ {
+ 	struct net_device *master = dsa_slave_to_master(dev);
+@@ -1233,6 +1268,7 @@ static const struct net_device_ops dsa_slave_netdev_ops = {
+ 	.ndo_fdb_dump		= dsa_slave_fdb_dump,
+ 	.ndo_do_ioctl		= dsa_slave_ioctl,
+ 	.ndo_get_iflink		= dsa_slave_get_iflink,
++	.ndo_set_iflink		= dsa_slave_set_iflink,
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+ 	.ndo_netpoll_setup	= dsa_slave_netpoll_setup,
+ 	.ndo_netpoll_cleanup	= dsa_slave_netpoll_cleanup,
+-- 
+2.24.1
+
diff --git a/target/linux/mvebu/patches-5.4/9953-net-dsa-mv88e6xxx-support-multi-CPU-DSA.patch b/target/linux/mvebu/patches-5.4/9953-net-dsa-mv88e6xxx-support-multi-CPU-DSA.patch
new file mode 100644
index 0000000..a5bcc4d
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/9953-net-dsa-mv88e6xxx-support-multi-CPU-DSA.patch
@@ -0,0 +1,116 @@
+From a78ac68ff49c14c9ee74782978517e8afc55d942 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Tue, 5 May 2020 20:08:08 +0200
+Subject: [PATCH] net: dsa: mv88e6xxx: support multi-CPU DSA
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add support for multi-CPU DSA for mv88e6xxx.
+Currently only works with multiple CPUs when there is only one switch in
+the switch tree.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 48 ++++++++++++++++++++++++++++++--
+ 1 file changed, 46 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 33b391376352..804ba563540e 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -1080,6 +1080,7 @@ static u16 mv88e6xxx_port_vlan(struct mv88e6xxx_chip *chip, int dev, int port)
+ {
+ 	struct dsa_switch *ds = NULL;
+ 	struct net_device *br;
++	u8 upstream;
+ 	u16 pvlan;
+ 	int i;
+ 
+@@ -1091,17 +1092,36 @@ static u16 mv88e6xxx_port_vlan(struct mv88e6xxx_chip *chip, int dev, int port)
+ 		return 0;
+ 
+ 	/* Frames from DSA links and CPU ports can egress any local port */
+-	if (dsa_is_cpu_port(ds, port) || dsa_is_dsa_port(ds, port))
++	if (dsa_is_dsa_port(ds, port))
+ 		return mv88e6xxx_port_mask(chip);
+ 
++	if (dsa_is_cpu_port(ds, port)) {
++		u16 pmask = mv88e6xxx_port_mask(chip);
++		pvlan = 0;
++
++		for (i = 0; i < mv88e6xxx_num_ports(chip); ++i) {
++			if (dsa_is_cpu_port(ds, i)) {
++				if (i == port)
++					pvlan |= BIT(i);
++				continue;
++			}
++			if ((pmask & BIT(i)) &&
++			    dsa_upstream_port(chip->ds, i) == port)
++				pvlan |= BIT(i);
++		}
++
++		return pvlan;
++	}
++
+ 	br = ds->ports[port].bridge_dev;
+ 	pvlan = 0;
+ 
+ 	/* Frames from user ports can egress any local DSA links and CPU ports,
+ 	 * as well as any local member of their bridge group.
+ 	 */
++	upstream = dsa_upstream_port(chip->ds, port);
+ 	for (i = 0; i < mv88e6xxx_num_ports(chip); ++i)
+-		if (dsa_is_cpu_port(chip->ds, i) ||
++		if ((dsa_is_cpu_port(chip->ds, i) && i == upstream) ||
+ 		    dsa_is_dsa_port(chip->ds, i) ||
+ 		    (br && dsa_to_port(chip->ds, i)->bridge_dev == br))
+ 			pvlan |= BIT(i);
+@@ -2388,6 +2408,7 @@ static int mv88e6xxx_setup_upstream_port(struct mv88e6xxx_chip *chip, int port)
+ 	}
+ 
+ 	if (port == upstream_port) {
++		dev_info(chip->dev, "Setting CPU port as port %i\n", port);
+ 		if (chip->info->ops->set_cpu_port) {
+ 			err = chip->info->ops->set_cpu_port(chip,
+ 							    upstream_port);
+@@ -2406,6 +2427,28 @@ static int mv88e6xxx_setup_upstream_port(struct mv88e6xxx_chip *chip, int port)
+ 	return 0;
+ }
+ 
++static int mv88e6xxx_port_change_cpu_port(struct dsa_switch *ds, int port,
++					  struct dsa_port *new_cpu_dp)
++{
++	struct mv88e6xxx_chip *chip = ds->priv;
++	int err;
++
++	mv88e6xxx_reg_lock(chip);
++
++	err = mv88e6xxx_setup_upstream_port(chip, port);
++	if (err)
++		goto unlock;
++
++	err = mv88e6xxx_port_vlan_map(chip, port);
++	if (err)
++		goto unlock;
++
++unlock:
++	mv88e6xxx_reg_unlock(chip);
++
++	return err;
++}
++
+ static int mv88e6xxx_setup_port(struct mv88e6xxx_chip *chip, int port)
+ {
+ 	struct dsa_switch *ds = chip->ds;
+@@ -4996,6 +5039,7 @@ static const struct dsa_switch_ops mv88e6xxx_switch_ops = {
+ 	.port_hwtstamp_get	= mv88e6xxx_port_hwtstamp_get,
+ 	.port_txtstamp		= mv88e6xxx_port_txtstamp,
+ 	.port_rxtstamp		= mv88e6xxx_port_rxtstamp,
++	.port_change_cpu_port	= mv88e6xxx_port_change_cpu_port,
+ 	.get_ts_info		= mv88e6xxx_get_ts_info,
+ };
+ 
+-- 
+2.24.1
+
-- 
2.26.2


From e936c9827d3b0e90143c5515e1f59a75132318fa Mon Sep 17 00:00:00 2001
From: Michal Hrusecky <Michal@Hrusecky.net>
Date: Wed, 7 Mar 2018 17:10:32 +0100
Subject: [PATCH] mvebu: Basic MoX support

Adding basic support for CZ.NICs MoX board.

Signed-off-by: Michal Hrusecky <Michal@Hrusecky.net>
---
 target/linux/mvebu/config-4.14                |   2 +
 target/linux/mvebu/image/cortex-a53.mk        |  11 +
 ...3-net-mvneta-move-port-configuration.patch | 106 +++
 ...024-net-mvneta-add-1000BaseX-support.patch |  65 ++
 ...7xx-account-for-const-type-of-of_dev.patch |  40 +
 ...3700-Set-frequency-limits-at-startup.patch |  46 +
 ...Allow-to-enable-or-disable-FIFO-mode.patch |  51 ++
 ...28-spi-a3700-Add-full-duplex-support.patch | 169 ++++
 ...-endianness-swapping-functions-when-.patch |  51 ++
 ...-endianness-swapping-for-full-duplex.patch |  66 ++
 ...7xx-Add-edge-both-type-gpio-irq-supp.patch | 109 +++
 ...7xx-Stop-using-struct-gpio_chip.irq_.patch |  49 +
 ...l-armada-37xx-remove-unused-variable.patch |  35 +
 ...mv88e6xxx-Fix-name-of-switch-88E6141.patch |  35 +
 ...d-phy_interface_mode_is_8023z-helper.patch |  59 ++
 ...ecure-remove-null-check-before-kfree.patch |  33 +
 ...cure-do-not-use-areq-result-for-part.patch |  63 ++
 ...nside-secure-remove-extra-empty-line.patch |  28 +
 ...-inside-secure-fix-typo-in-a-comment.patch |  29 +
 ...-inside-secure-remove-useless-memset.patch |  30 +
 ...cure-refrain-from-unneeded-invalidat.patch |  91 ++
 ...cure-EBUSY-is-not-an-error-on-async-.patch |  35 +
 ...cure-move-cipher-crypto-mode-to-requ.patch |  76 ++
 ...cure-remove-unused-parameter-in-inva.patch |  74 ++
 ...cure-move-request-dequeueing-into-a-.patch | 204 +++++
 ...cure-use-threaded-IRQs-for-result-ha.patch | 136 +++
 ...-secure-dequeue-all-requests-at-once.patch | 179 ++++
 ...inside-secure-increase-the-ring-size.patch |  37 +
 ...cure-acknowledge-the-result-requests.patch |  62 ++
 ...cure-handle-more-result-requests-whe.patch |  70 ++
 ...cure-retry-to-proceed-the-request-la.patch | 103 +++
 ...2-crypto-inside-secure-EIP97-support.patch | 841 +++++++++++++++++
 ...cure-make-function-safexcel_try_push.patch |  38 +
 ...cure-do-not-overwrite-the-threshold-.patch |  40 +
 ...cure-keep-the-requests-push-pop-sync.patch | 136 +++
 ...cure-unmap-the-result-in-the-hash-se.patch |  42 +
 ...cure-move-hash-result-dma-mapping-to.patch | 115 +++
 ...cure-move-cache-result-dma-mapping-t.patch | 152 +++
 ...cure-fix-missing-unlock-on-error-in-.patch |  36 +
 ...-secure-improve-clock-initialization.patch |  48 +
 ...cure-fix-clock-resource-by-adding-a-.patch | 146 +++
 ...cure-move-the-digest-to-the-request-.patch | 161 ++++
 ...cure-fix-typo-s-allways-always-in-a-.patch |  45 +
 ...secure-fix-a-typo-in-a-register-name.patch |  45 +
 ...e-secure-improve-the-send-error-path.patch |  50 +
 ...cure-do-not-access-buffers-mapped-to.patch |  46 +
 ...de-secure-improve-the-skcipher-token.patch |  36 +
 ...cure-the-context-ipad-opad-should-us.patch |  42 +
 ...to-inside-secure-hmac-sha256-support.patch | 174 ++++
 ...to-inside-secure-hmac-sha224-support.patch | 110 +++
 ...arvell-armada-37xx-add-a-crypto-node.patch |  42 +
 ...metic-fixes-to-phylink-sfp-sfp-bus.c.patch | 246 +++++
 .../90073-sfp-fix-sparse-warning.patch        |  30 +
 ...rt-for-1000Base-PX-and-1000Base-BX10.patch |  60 ++
 .../90076-From-Ken-Ma-make-marvell.com.patch  |  54 ++
 ...v88e6xxx-88E6141-6341-SERDES-support.patch |  87 ++
 ...etif_receive_skb-instead-of-GRO-on-A.patch |  45 +
 ...support-for-Armada-37xx-CPU-watchdog.patch | 450 +++++++++
 ...l-armada-37xx-add-nodes-to-support-w.patch |  47 +
 ...-support-for-Turris-Mox-SFP-cage-mod.patch | 364 ++++++++
 ...l-Add-DTS-files-for-Turris-Mox-and-i.patch | 864 ++++++++++++++++++
 ...-t-guess-support-from-connector-type.patch |  57 ++
 62 files changed, 6793 insertions(+)
 create mode 100644 target/linux/mvebu/patches-4.14/90023-net-mvneta-move-port-configuration.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90024-net-mvneta-add-1000BaseX-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90025-pinctrl-armada-37xx-account-for-const-type-of-of_dev.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90026-spi-a3700-Set-frequency-limits-at-startup.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90027-spi-a3700-Allow-to-enable-or-disable-FIFO-mode.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90028-spi-a3700-Add-full-duplex-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90029-spi-a3700-Remove-endianness-swapping-functions-when-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90030-spi-a3700-Remove-endianness-swapping-for-full-duplex.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90031-pinctrl-armada-37xx-Add-edge-both-type-gpio-irq-supp.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90032-pinctrl-armada-37xx-Stop-using-struct-gpio_chip.irq_.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90033-pinctrl-armada-37xx-remove-unused-variable.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90034-net-dsa-mv88e6xxx-Fix-name-of-switch-88E6141.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90035-phy-add-phy_interface_mode_is_8023z-helper.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90036-crypto-inside-secure-remove-null-check-before-kfree.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90037-crypto-inside-secure-do-not-use-areq-result-for-part.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90038-crypto-inside-secure-remove-extra-empty-line.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90039-crypto-inside-secure-fix-typo-in-a-comment.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90040-crypto-inside-secure-remove-useless-memset.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90041-crypto-inside-secure-refrain-from-unneeded-invalidat.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90042-crypto-inside-secure-EBUSY-is-not-an-error-on-async-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90043-crypto-inside-secure-move-cipher-crypto-mode-to-requ.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90044-crypto-inside-secure-remove-unused-parameter-in-inva.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90045-crypto-inside-secure-move-request-dequeueing-into-a-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90046-crypto-inside-secure-use-threaded-IRQs-for-result-ha.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90047-crypto-inside-secure-dequeue-all-requests-at-once.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90048-crypto-inside-secure-increase-the-ring-size.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90049-crypto-inside-secure-acknowledge-the-result-requests.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90050-crypto-inside-secure-handle-more-result-requests-whe.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90051-crypto-inside-secure-retry-to-proceed-the-request-la.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90052-crypto-inside-secure-EIP97-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90053-crypto-inside-secure-make-function-safexcel_try_push.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90054-crypto-inside-secure-do-not-overwrite-the-threshold-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90055-crypto-inside-secure-keep-the-requests-push-pop-sync.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90056-crypto-inside-secure-unmap-the-result-in-the-hash-se.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90057-crypto-inside-secure-move-hash-result-dma-mapping-to.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90058-crypto-inside-secure-move-cache-result-dma-mapping-t.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90059-crypto-inside-secure-fix-missing-unlock-on-error-in-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90060-crypto-inside-secure-improve-clock-initialization.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90061-crypto-inside-secure-fix-clock-resource-by-adding-a-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90062-crypto-inside-secure-move-the-digest-to-the-request-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90063-crypto-inside-secure-fix-typo-s-allways-always-in-a-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90064-crypto-inside-secure-fix-a-typo-in-a-register-name.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90065-crypto-inside-secure-improve-the-send-error-path.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90066-crypto-inside-secure-do-not-access-buffers-mapped-to.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90067-crypto-inside-secure-improve-the-skcipher-token.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90068-crypto-inside-secure-the-context-ipad-opad-should-us.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90069-crypto-inside-secure-hmac-sha256-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90070-crypto-inside-secure-hmac-sha224-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90071-arm64-dts-marvell-armada-37xx-add-a-crypto-node.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90072-net-phy-Cosmetic-fixes-to-phylink-sfp-sfp-bus.c.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90073-sfp-fix-sparse-warning.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90075-sfp-add-support-for-1000Base-PX-and-1000Base-BX10.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90076-From-Ken-Ma-make-marvell.com.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90077-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90078-net-mvneta-Use-netif_receive_skb-instead-of-GRO-on-A.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90079-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90080-arm64-dts-marvell-armada-37xx-add-nodes-to-support-w.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90081-drivers-gpio-Add-support-for-Turris-Mox-SFP-cage-mod.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90082-ARM64-dts-marvell-Add-DTS-files-for-Turris-Mox-and-i.patch
 create mode 100644 target/linux/mvebu/patches-4.14/9086-sfp-don-t-guess-support-from-connector-type.patch

diff --git a/target/linux/mvebu/config-4.14 b/target/linux/mvebu/config-4.14
index f5e9876..8c77688 100644
--- a/target/linux/mvebu/config-4.14
+++ b/target/linux/mvebu/config-4.14
@@ -34,6 +34,7 @@ CONFIG_ARM=y
 CONFIG_ARMADA_370_CLK=y
 CONFIG_ARMADA_370_XP_IRQ=y
 CONFIG_ARMADA_370_XP_TIMER=y
+CONFIG_ARMADA_37XX_WATCHDOG=y
 CONFIG_ARMADA_38X_CLK=y
 CONFIG_ARMADA_THERMAL=y
 CONFIG_ARMADA_XP_CLK=y
@@ -223,6 +224,7 @@ CONFIG_GPIOLIB=y
 CONFIG_GPIOLIB_IRQCHIP=y
 CONFIG_GPIO_GENERIC=y
 CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_GPIO_MOX_SFP=y
 CONFIG_GPIO_MVEBU=y
 CONFIG_GPIO_PCA953X=y
 CONFIG_GPIO_PCA953X_IRQ=y
@@ -377,6 +377,7 @@ CONFIG_NEED_DMA_MAP_STATE=y
 CONFIG_NEON=y
 # CONFIG_NET_CLS_CGROUP is not set
 CONFIG_NET_DSA=y
+CONFIG_NET_DSA_MV88E6060=y
 CONFIG_NET_DSA_MV88E6XXX=y
 CONFIG_NET_DSA_MV88E6XXX_GLOBAL2=y
 CONFIG_NET_DSA_TAG_DSA=y
diff --git a/target/linux/mvebu/image/cortex-a53.mk b/target/linux/mvebu/image/cortex-a53.mk
index 89c3363..2095a5c 100644
--- a/target/linux/mvebu/image/cortex-a53.mk
+++ b/target/linux/mvebu/image/cortex-a53.mk
@@ -13,6 +13,17 @@ define Device/globalscale-espressobin
 endef
 TARGET_DEVICES += globalscale-espressobin
 
+define Device/cznic-mox
+  KERNEL_NAME := Image dtbs
+  KERNEL := kernel-bin
+  DEVICE_TITLE := MOX (CZ.NICs Marvell Armada 3720 Based Board)
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2 kmod-usb3 kmod-usb-storage
+  DEVICE_DTS := armada-3720-turris-mox-sd armada-3720-turris-mox-sd-sfp armada-3720-turris-mox-sd-topaz
+  DTS_DIR := $(DTS_DIR)/marvell
+  SUPPORTED_DEVICES := cznic,mox
+endef
+TARGET_DEVICES += cznic-mox
+
 define Device/armada-3720-db
   KERNEL_NAME := Image
   KERNEL := kernel-bin
diff --git a/target/linux/mvebu/patches-4.14/90023-net-mvneta-move-port-configuration.patch b/target/linux/mvebu/patches-4.14/90023-net-mvneta-move-port-configuration.patch
new file mode 100644
index 0000000..e61fa5a
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90023-net-mvneta-move-port-configuration.patch
@@ -0,0 +1,106 @@
+From b7ed73b143133d3abca4a5c777e1f40c19064929 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 2 Jan 2018 17:24:49 +0000
+Subject: [PATCH 23/82] net: mvneta: move port configuration
+
+Move the port configuration and release of reset to mvneta_mac_config()
+along side the rest of the port mode configuration.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 51 +++++++++++----------------
+ 1 file changed, 20 insertions(+), 31 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index f5b6614125a6..2198fb96552f 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3286,7 +3286,8 @@ static void mvneta_mac_config(struct net_device *ndev, unsigned int mode,
+ 	u32 new_an, gmac_an = mvreg_read(pp, MVNETA_GMAC_AUTONEG_CONFIG);
+ 
+ 	new_ctrl0 = gmac_ctrl0 & ~MVNETA_GMAC0_PORT_1000BASE_X;
+-	new_ctrl2 = gmac_ctrl2 & ~MVNETA_GMAC2_INBAND_AN_ENABLE;
++	new_ctrl2 = gmac_ctrl2 & ~(MVNETA_GMAC2_INBAND_AN_ENABLE |
++				   MVNETA_GMAC2_PORT_RESET);
+ 	new_clk = gmac_clk & ~MVNETA_GMAC_1MS_CLOCK_ENABLE;
+ 	new_an = gmac_an & ~(MVNETA_GMAC_INBAND_AN_ENABLE |
+ 			     MVNETA_GMAC_INBAND_RESTART_AN |
+@@ -3304,6 +3305,15 @@ static void mvneta_mac_config(struct net_device *ndev, unsigned int mode,
+ 	if (state->pause & MLO_PAUSE_TXRX_MASK)
+ 		new_an |= MVNETA_GMAC_CONFIG_FLOW_CTRL;
+ 
++	/* Even though it might look weird, when we're configured in
++	 * SGMII or QSGMII mode, the RGMII bit needs to be set.
++	 */
++	new_ctrl2 |= MVNETA_GMAC2_PORT_RGMII;
++
++	if (state->interface == PHY_INTERFACE_MODE_QSGMII ||
++	    state->interface == PHY_INTERFACE_MODE_SGMII)
++		new_ctrl2 |= MVNETA_GMAC2_PCS_ENABLE;
++
+ 	if (!phylink_autoneg_inband(mode)) {
+ 		/* Phy or fixed speed */
+ 		if (state->duplex)
+@@ -3356,6 +3366,12 @@ static void mvneta_mac_config(struct net_device *ndev, unsigned int mode,
+ 		mvreg_write(pp, MVNETA_GMAC_CLOCK_DIVIDER, new_clk);
+ 	if (new_an != gmac_an)
+ 		mvreg_write(pp, MVNETA_GMAC_AUTONEG_CONFIG, new_an);
++
++	if (gmac_ctrl2 & MVNETA_GMAC2_PORT_RESET) {
++		while ((mvreg_read(pp, MVNETA_GMAC_CTRL_2) &
++			MVNETA_GMAC2_PORT_RESET) != 0)
++			continue;
++	}
+ }
+ 
+ static void mvneta_set_eee(struct mvneta_port *pp, bool enable)
+@@ -4231,42 +4247,15 @@ static void mvneta_conf_mbus_windows(struct mvneta_port *pp,
+ /* Power up the port */
+ static int mvneta_port_power_up(struct mvneta_port *pp, int phy_mode)
+ {
+-	u32 ctrl;
+-
+ 	/* MAC Cause register should be cleared */
+ 	mvreg_write(pp, MVNETA_UNIT_INTR_CAUSE, 0);
+ 
+-	ctrl = mvreg_read(pp, MVNETA_GMAC_CTRL_2);
+-
+-	/* Even though it might look weird, when we're configured in
+-	 * SGMII or QSGMII mode, the RGMII bit needs to be set.
+-	 */
+-	switch(phy_mode) {
+-	case PHY_INTERFACE_MODE_QSGMII:
++	if (phy_mode == PHY_INTERFACE_MODE_QSGMII)
+ 		mvreg_write(pp, MVNETA_SERDES_CFG, MVNETA_QSGMII_SERDES_PROTO);
+-		ctrl |= MVNETA_GMAC2_PCS_ENABLE | MVNETA_GMAC2_PORT_RGMII;
+-		break;
+-	case PHY_INTERFACE_MODE_SGMII:
++	else if (phy_mode == PHY_INTERFACE_MODE_SGMII)
+ 		mvreg_write(pp, MVNETA_SERDES_CFG, MVNETA_SGMII_SERDES_PROTO);
+-		ctrl |= MVNETA_GMAC2_PCS_ENABLE | MVNETA_GMAC2_PORT_RGMII;
+-		break;
+-	case PHY_INTERFACE_MODE_RGMII:
+-	case PHY_INTERFACE_MODE_RGMII_ID:
+-	case PHY_INTERFACE_MODE_RGMII_RXID:
+-	case PHY_INTERFACE_MODE_RGMII_TXID:
+-		ctrl |= MVNETA_GMAC2_PORT_RGMII;
+-		break;
+-	default:
++	else if (!phy_interface_mode_is_rgmii(phy_mode))
+ 		return -EINVAL;
+-	}
+-
+-	/* Cancel Port Reset */
+-	ctrl &= ~MVNETA_GMAC2_PORT_RESET;
+-	mvreg_write(pp, MVNETA_GMAC_CTRL_2, ctrl);
+-
+-	while ((mvreg_read(pp, MVNETA_GMAC_CTRL_2) &
+-		MVNETA_GMAC2_PORT_RESET) != 0)
+-		continue;
+ 
+ 	return 0;
+ }
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90024-net-mvneta-add-1000BaseX-support.patch b/target/linux/mvebu/patches-4.14/90024-net-mvneta-add-1000BaseX-support.patch
new file mode 100644
index 0000000..a43027d
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90024-net-mvneta-add-1000BaseX-support.patch
@@ -0,0 +1,65 @@
+From 640b358e8cb989d1da8ddb2cb84da9ad0d112f72 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@arm.linux.org.uk>
+Date: Tue, 2 Jan 2018 17:24:54 +0000
+Subject: [PATCH 24/82] net: mvneta: add 1000BaseX support
+
+Add support for 1000BaseX link modes.
+
+Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 18 +++++++++++++++---
+ 1 file changed, 15 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 2198fb96552f..54be20e3731d 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3213,6 +3213,16 @@ static void mvneta_validate(struct net_device *ndev, unsigned long *supported,
+ {
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 
++	/* We only support QSGMII, SGMII, 802.3z and RGMII modes */
++	if (state->interface != PHY_INTERFACE_MODE_NA &&
++	    state->interface != PHY_INTERFACE_MODE_QSGMII &&
++	    state->interface != PHY_INTERFACE_MODE_SGMII &&
++	    !phy_interface_mode_is_8023z(state->interface) &&
++	    !phy_interface_mode_is_rgmii(state->interface)) {
++		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		return;
++	}
++
+ 	/* Allow all the expected bits */
+ 	phylink_set(mask, Autoneg);
+ 	phylink_set_port_modes(mask);
+@@ -3223,7 +3233,7 @@ static void mvneta_validate(struct net_device *ndev, unsigned long *supported,
+ 	phylink_set(mask, 1000baseT_Full);
+ 	phylink_set(mask, 1000baseX_Full);
+ 
+-	if (state->interface != PHY_INTERFACE_MODE_1000BASEX) {
++	if (!phy_interface_mode_is_8023z(state->interface)) {
+ 		/* 10M and 100M are only supported in non-802.3z mode */
+ 		phylink_set(mask, 10baseT_Half);
+ 		phylink_set(mask, 10baseT_Full);
+@@ -3311,7 +3321,8 @@ static void mvneta_mac_config(struct net_device *ndev, unsigned int mode,
+ 	new_ctrl2 |= MVNETA_GMAC2_PORT_RGMII;
+ 
+ 	if (state->interface == PHY_INTERFACE_MODE_QSGMII ||
+-	    state->interface == PHY_INTERFACE_MODE_SGMII)
++	    state->interface == PHY_INTERFACE_MODE_SGMII ||
++	    phy_interface_mode_is_8023z(state->interface))
+ 		new_ctrl2 |= MVNETA_GMAC2_PCS_ENABLE;
+ 
+ 	if (!phylink_autoneg_inband(mode)) {
+@@ -4252,7 +4263,8 @@ static int mvneta_port_power_up(struct mvneta_port *pp, int phy_mode)
+ 
+ 	if (phy_mode == PHY_INTERFACE_MODE_QSGMII)
+ 		mvreg_write(pp, MVNETA_SERDES_CFG, MVNETA_QSGMII_SERDES_PROTO);
+-	else if (phy_mode == PHY_INTERFACE_MODE_SGMII)
++	else if (phy_mode == PHY_INTERFACE_MODE_SGMII ||
++		 phy_mode == PHY_INTERFACE_MODE_1000BASEX)
+ 		mvreg_write(pp, MVNETA_SERDES_CFG, MVNETA_SGMII_SERDES_PROTO);
+ 	else if (!phy_interface_mode_is_rgmii(phy_mode))
+ 		return -EINVAL;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90025-pinctrl-armada-37xx-account-for-const-type-of-of_dev.patch b/target/linux/mvebu/patches-4.14/90025-pinctrl-armada-37xx-account-for-const-type-of-of_dev.patch
new file mode 100644
index 0000000..97648b5
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90025-pinctrl-armada-37xx-account-for-const-type-of-of_dev.patch
@@ -0,0 +1,40 @@
+From ef56d02d329a46d247654fcfef8bc0c5d1691e7b Mon Sep 17 00:00:00 2001
+From: Julia Lawall <Julia.Lawall@lip6.fr>
+Date: Tue, 2 Jan 2018 14:28:01 +0100
+Subject: [PATCH 25/82] pinctrl: armada-37xx: account for const type of
+ of_device_id.data
+
+The data field of an of_device_id structure has type const void *, so
+there is no need for a const-discarding cast when putting const values
+into such a structure.
+
+Done using Coccinelle.
+
+Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
+Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index c5fe7d4a9065..69bddeaad322 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -944,11 +944,11 @@ static int armada_37xx_pinctrl_register(struct platform_device *pdev,
+ static const struct of_device_id armada_37xx_pinctrl_of_match[] = {
+ 	{
+ 		.compatible = "marvell,armada3710-sb-pinctrl",
+-		.data = (void *)&armada_37xx_pin_sb,
++		.data = &armada_37xx_pin_sb,
+ 	},
+ 	{
+ 		.compatible = "marvell,armada3710-nb-pinctrl",
+-		.data = (void *)&armada_37xx_pin_nb,
++		.data = &armada_37xx_pin_nb,
+ 	},
+ 	{ },
+ };
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90026-spi-a3700-Set-frequency-limits-at-startup.patch b/target/linux/mvebu/patches-4.14/90026-spi-a3700-Set-frequency-limits-at-startup.patch
new file mode 100644
index 0000000..7767bd4
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90026-spi-a3700-Set-frequency-limits-at-startup.patch
@@ -0,0 +1,46 @@
+From 75420a648df7c0a859950bcd6ceffe0a07cfdda9 Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 17 Jan 2018 17:15:26 +0100
+Subject: [PATCH 26/82] spi: a3700: Set frequency limits at startup
+
+Armada 3700 SPI controller has an internal clock divider which can
+divide the parent clock frequency by up to 30.
+
+This patch sets the limits in the spi_controller fields so that we can
+detect when a non-supported frequency is requested by a device for a
+transfer.
+
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index c11ea6c169a4..8048468277f3 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -27,6 +27,8 @@
+ 
+ #define DRIVER_NAME			"armada_3700_spi"
+ 
++#define A3700_SPI_MAX_SPEED_HZ		100000000
++#define A3700_SPI_MAX_PRESCALE		30
+ #define A3700_SPI_TIMEOUT		10
+ 
+ /* SPI Register Offest */
+@@ -823,6 +825,11 @@ static int a3700_spi_probe(struct platform_device *pdev)
+ 		goto error;
+ 	}
+ 
++	master->max_speed_hz = min_t(unsigned long, A3700_SPI_MAX_SPEED_HZ,
++					clk_get_rate(spi->clk));
++	master->min_speed_hz = DIV_ROUND_UP(clk_get_rate(spi->clk),
++						A3700_SPI_MAX_PRESCALE);
++
+ 	ret = a3700_spi_init(spi);
+ 	if (ret)
+ 		goto error_clk;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90027-spi-a3700-Allow-to-enable-or-disable-FIFO-mode.patch b/target/linux/mvebu/patches-4.14/90027-spi-a3700-Allow-to-enable-or-disable-FIFO-mode.patch
new file mode 100644
index 0000000..3a69240
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90027-spi-a3700-Allow-to-enable-or-disable-FIFO-mode.patch
@@ -0,0 +1,51 @@
+From 711dde7188b0124b33ecfde4486bbb1699970367 Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 17 Jan 2018 17:15:27 +0100
+Subject: [PATCH 27/82] spi: a3700: Allow to enable or disable FIFO mode
+
+The armada 3700 SPI controller allows to make transfers without using
+the 32 bytes RFIFO and WFIFO.
+
+This commit enable switching between FIFO and non-FIFO mode, which is
+necessary to implement full-duplex transfers.
+
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 9 ++++++---
+ 1 file changed, 6 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index 8048468277f3..b38730928186 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -186,12 +186,15 @@ static int a3700_spi_pin_mode_set(struct a3700_spi *a3700_spi,
+ 	return 0;
+ }
+ 
+-static void a3700_spi_fifo_mode_set(struct a3700_spi *a3700_spi)
++static void a3700_spi_fifo_mode_set(struct a3700_spi *a3700_spi, bool enable)
+ {
+ 	u32 val;
+ 
+ 	val = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);
+-	val |= A3700_SPI_FIFO_MODE;
++	if (enable)
++		val |= A3700_SPI_FIFO_MODE;
++	else
++		val &= ~A3700_SPI_FIFO_MODE;
+ 	spireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);
+ }
+ 
+@@ -299,7 +302,7 @@ static int a3700_spi_init(struct a3700_spi *a3700_spi)
+ 		a3700_spi_deactivate_cs(a3700_spi, i);
+ 
+ 	/* Enable FIFO mode */
+-	a3700_spi_fifo_mode_set(a3700_spi);
++	a3700_spi_fifo_mode_set(a3700_spi, true);
+ 
+ 	/* Set SPI mode */
+ 	a3700_spi_mode_set(a3700_spi, master->mode_bits);
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90028-spi-a3700-Add-full-duplex-support.patch b/target/linux/mvebu/patches-4.14/90028-spi-a3700-Add-full-duplex-support.patch
new file mode 100644
index 0000000..3b94abb
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90028-spi-a3700-Add-full-duplex-support.patch
@@ -0,0 +1,169 @@
+From 6dc6d6aa331ae15ea5175da46df61f3761c77751 Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 17 Jan 2018 17:15:28 +0100
+Subject: [PATCH 28/82] spi: a3700: Add full-duplex support
+
+The armada 3700 SPI controller has support for full-duplex transfers,
+but it can only be done without using the hardware FIFOs.
+
+A full duplex transfer is done by shifting 4 bytes at a time, or even
+one byte at a time for transfers less than 4 bytes long.
+
+While this method is perfectly suitable for small transfers, it is still
+slower than using the FIFOs.
+
+This commit implement full-duplex support, making sure that half-duplex
+transfers are still done using the FIFOs with the existing method.
+
+Some setup functions were moved around to make sure the controller is
+properly configured before beginning each transfer.
+
+This was tested on EspressoBin with a logical analyser, and a simple
+setup where MISO is connected on MOSI. Transfers were made from
+userspace using spidev and spi-pipe from the spi-tools project
+
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 85 ++++++++++++++++++++++++++++++-----
+ 1 file changed, 73 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index b38730928186..a8576c89f713 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -421,15 +421,20 @@ static void a3700_spi_transfer_setup(struct spi_device *spi,
+ 				     struct spi_transfer *xfer)
+ {
+ 	struct a3700_spi *a3700_spi;
+-	unsigned int byte_len;
+ 
+ 	a3700_spi = spi_master_get_devdata(spi->master);
+ 
+ 	a3700_spi_clock_set(a3700_spi, xfer->speed_hz);
+ 
+-	byte_len = xfer->bits_per_word >> 3;
++	/* Use 4 bytes long transfers. Each transfer method has its way to deal
++	 * with the remaining bytes for non 4-bytes aligned transfers.
++	 */
++	a3700_spi_bytelen_set(a3700_spi, 4);
+ 
+-	a3700_spi_fifo_thres_set(a3700_spi, byte_len);
++	/* Initialize the working buffers */
++	a3700_spi->tx_buf  = xfer->tx_buf;
++	a3700_spi->rx_buf  = xfer->rx_buf;
++	a3700_spi->buf_len = xfer->len;
+ }
+ 
+ static void a3700_spi_set_cs(struct spi_device *spi, bool enable)
+@@ -584,27 +589,26 @@ static int a3700_spi_prepare_message(struct spi_master *master,
+ 	if (ret)
+ 		return ret;
+ 
+-	a3700_spi_bytelen_set(a3700_spi, 4);
+-
+ 	a3700_spi_mode_set(a3700_spi, spi->mode);
+ 
+ 	return 0;
+ }
+ 
+-static int a3700_spi_transfer_one(struct spi_master *master,
++static int a3700_spi_transfer_one_fifo(struct spi_master *master,
+ 				  struct spi_device *spi,
+ 				  struct spi_transfer *xfer)
+ {
+ 	struct a3700_spi *a3700_spi = spi_master_get_devdata(master);
+ 	int ret = 0, timeout = A3700_SPI_TIMEOUT;
+-	unsigned int nbits = 0;
++	unsigned int nbits = 0, byte_len;
+ 	u32 val;
+ 
+-	a3700_spi_transfer_setup(spi, xfer);
++	/* Make sure we use FIFO mode */
++	a3700_spi_fifo_mode_set(a3700_spi, true);
+ 
+-	a3700_spi->tx_buf  = xfer->tx_buf;
+-	a3700_spi->rx_buf  = xfer->rx_buf;
+-	a3700_spi->buf_len = xfer->len;
++	/* Configure FIFO thresholds */
++	byte_len = xfer->bits_per_word >> 3;
++	a3700_spi_fifo_thres_set(a3700_spi, byte_len);
+ 
+ 	if (xfer->tx_buf)
+ 		nbits = xfer->tx_nbits;
+@@ -739,6 +743,64 @@ static int a3700_spi_transfer_one(struct spi_master *master,
+ 	return ret;
+ }
+ 
++static int a3700_spi_transfer_one_full_duplex(struct spi_master *master,
++				  struct spi_device *spi,
++				  struct spi_transfer *xfer)
++{
++	struct a3700_spi *a3700_spi = spi_master_get_devdata(master);
++	u32 val_in, val_out;
++
++	/* Disable FIFO mode */
++	a3700_spi_fifo_mode_set(a3700_spi, false);
++
++	while (a3700_spi->buf_len) {
++
++		/* When we have less than 4 bytes to transfer, switch to 1 byte
++		 * mode. This is reset after each transfer
++		 */
++		if (a3700_spi->buf_len < 4)
++			a3700_spi_bytelen_set(a3700_spi, 1);
++
++		if (a3700_spi->byte_len == 1)
++			val_out = *a3700_spi->tx_buf;
++		else
++			val_out = cpu_to_le32(*(u32 *)a3700_spi->tx_buf);
++
++		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val_out);
++
++		/* Wait for all the data to be shifted in / out */
++		while (!(spireg_read(a3700_spi, A3700_SPI_IF_CTRL_REG) &
++				A3700_SPI_XFER_DONE))
++			cpu_relax();
++
++		val_in = le32_to_cpu(spireg_read(a3700_spi,
++						 A3700_SPI_DATA_IN_REG));
++
++		memcpy(a3700_spi->rx_buf, &val_in, a3700_spi->byte_len);
++
++		a3700_spi->buf_len -= a3700_spi->byte_len;
++		a3700_spi->tx_buf += a3700_spi->byte_len;
++		a3700_spi->rx_buf += a3700_spi->byte_len;
++
++	}
++
++	spi_finalize_current_transfer(master);
++
++	return 0;
++}
++
++static int a3700_spi_transfer_one(struct spi_master *master,
++				  struct spi_device *spi,
++				  struct spi_transfer *xfer)
++{
++	a3700_spi_transfer_setup(spi, xfer);
++
++	if (xfer->tx_buf && xfer->rx_buf)
++		return a3700_spi_transfer_one_full_duplex(master, spi, xfer);
++
++	return a3700_spi_transfer_one_fifo(master, spi, xfer);
++}
++
+ static int a3700_spi_unprepare_message(struct spi_master *master,
+ 				       struct spi_message *message)
+ {
+@@ -788,7 +850,6 @@ static int a3700_spi_probe(struct platform_device *pdev)
+ 	master->transfer_one = a3700_spi_transfer_one;
+ 	master->unprepare_message = a3700_spi_unprepare_message;
+ 	master->set_cs = a3700_spi_set_cs;
+-	master->flags = SPI_MASTER_HALF_DUPLEX;
+ 	master->mode_bits |= (SPI_RX_DUAL | SPI_TX_DUAL |
+ 			      SPI_RX_QUAD | SPI_TX_QUAD);
+ 
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90029-spi-a3700-Remove-endianness-swapping-functions-when-.patch b/target/linux/mvebu/patches-4.14/90029-spi-a3700-Remove-endianness-swapping-functions-when-.patch
new file mode 100644
index 0000000..346f5de
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90029-spi-a3700-Remove-endianness-swapping-functions-when-.patch
@@ -0,0 +1,51 @@
+From d217c182e1e19ac7b3e40e99453c14ac8696dd03 Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 24 Jan 2018 15:10:47 +0100
+Subject: [PATCH 29/82] spi: a3700: Remove endianness swapping functions when
+ accessing FIFOs
+
+Fixes the following sparse warnings :
+line 504: warning: incorrect type in assignment (different base types)
+line 504:    expected unsigned int [unsigned] [usertype] val
+line 504:    got restricted __le32 [usertype] <noident>
+line 527: warning: cast to restricted __le32
+
+This is solved by removing endian-converson functions, since the
+converted values are going through readl/writel anyway, which take care
+of the conversion.
+
+Fixes: 6fd6fd68c9e2 ("spi: armada-3700: Fix padding when sending not 4-byte aligned data")
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Reviewed-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 5 ++---
+ 1 file changed, 2 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index a8576c89f713..43ee0b56fe1c 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -501,7 +501,7 @@ static int a3700_spi_fifo_write(struct a3700_spi *a3700_spi)
+ 	u32 val;
+ 
+ 	while (!a3700_is_wfifo_full(a3700_spi) && a3700_spi->buf_len) {
+-		val = cpu_to_le32(*(u32 *)a3700_spi->tx_buf);
++		val = *(u32 *)a3700_spi->tx_buf;
+ 		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val);
+ 		a3700_spi->buf_len -= 4;
+ 		a3700_spi->tx_buf += 4;
+@@ -524,9 +524,8 @@ static int a3700_spi_fifo_read(struct a3700_spi *a3700_spi)
+ 	while (!a3700_is_rfifo_empty(a3700_spi) && a3700_spi->buf_len) {
+ 		val = spireg_read(a3700_spi, A3700_SPI_DATA_IN_REG);
+ 		if (a3700_spi->buf_len >= 4) {
+-			u32 data = le32_to_cpu(val);
+ 
+-			memcpy(a3700_spi->rx_buf, &data, 4);
++			memcpy(a3700_spi->rx_buf, &val, 4);
+ 
+ 			a3700_spi->buf_len -= 4;
+ 			a3700_spi->rx_buf += 4;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90030-spi-a3700-Remove-endianness-swapping-for-full-duplex.patch b/target/linux/mvebu/patches-4.14/90030-spi-a3700-Remove-endianness-swapping-for-full-duplex.patch
new file mode 100644
index 0000000..a6c1f05
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90030-spi-a3700-Remove-endianness-swapping-for-full-duplex.patch
@@ -0,0 +1,66 @@
+From f3c64df0f7c58d37faf0f3cb71e21cc44a52dde9 Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 24 Jan 2018 15:10:48 +0100
+Subject: [PATCH 30/82] spi: a3700: Remove endianness swapping for full-duplex
+ transfers
+
+Fixes the following sparse warnings :
+line 767: warning: incorrect type in assignment (different base types)
+line 767:    expected unsigned int [unsigned] [assigned] [usertype] val_out
+line 767:    got restricted __le32 [usertype] <noident>
+line 776: warning: cast to restricted __le32
+
+This takes advantage of readl/writel to do the endianness reordering,
+and removes an extra variable in the function.
+
+Fixes: f68a7dcb91b7 ("spi: a3700: Add full-duplex support")
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Reviewed-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 13 ++++++-------
+ 1 file changed, 6 insertions(+), 7 deletions(-)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index 43ee0b56fe1c..7dcb14d303eb 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -747,7 +747,7 @@ static int a3700_spi_transfer_one_full_duplex(struct spi_master *master,
+ 				  struct spi_transfer *xfer)
+ {
+ 	struct a3700_spi *a3700_spi = spi_master_get_devdata(master);
+-	u32 val_in, val_out;
++	u32 val;
+ 
+ 	/* Disable FIFO mode */
+ 	a3700_spi_fifo_mode_set(a3700_spi, false);
+@@ -761,21 +761,20 @@ static int a3700_spi_transfer_one_full_duplex(struct spi_master *master,
+ 			a3700_spi_bytelen_set(a3700_spi, 1);
+ 
+ 		if (a3700_spi->byte_len == 1)
+-			val_out = *a3700_spi->tx_buf;
++			val = *a3700_spi->tx_buf;
+ 		else
+-			val_out = cpu_to_le32(*(u32 *)a3700_spi->tx_buf);
++			val = *(u32 *)a3700_spi->tx_buf;
+ 
+-		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val_out);
++		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val);
+ 
+ 		/* Wait for all the data to be shifted in / out */
+ 		while (!(spireg_read(a3700_spi, A3700_SPI_IF_CTRL_REG) &
+ 				A3700_SPI_XFER_DONE))
+ 			cpu_relax();
+ 
+-		val_in = le32_to_cpu(spireg_read(a3700_spi,
+-						 A3700_SPI_DATA_IN_REG));
++		val = spireg_read(a3700_spi, A3700_SPI_DATA_IN_REG);
+ 
+-		memcpy(a3700_spi->rx_buf, &val_in, a3700_spi->byte_len);
++		memcpy(a3700_spi->rx_buf, &val, a3700_spi->byte_len);
+ 
+ 		a3700_spi->buf_len -= a3700_spi->byte_len;
+ 		a3700_spi->tx_buf += a3700_spi->byte_len;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90031-pinctrl-armada-37xx-Add-edge-both-type-gpio-irq-supp.patch b/target/linux/mvebu/patches-4.14/90031-pinctrl-armada-37xx-Add-edge-both-type-gpio-irq-supp.patch
new file mode 100644
index 0000000..f82d10d
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90031-pinctrl-armada-37xx-Add-edge-both-type-gpio-irq-supp.patch
@@ -0,0 +1,109 @@
+From 90733a1d0c3cf9769275b66f157632fdd4ba88e9 Mon Sep 17 00:00:00 2001
+From: Ken Ma <make@marvell.com>
+Date: Thu, 19 Oct 2017 15:10:03 +0200
+Subject: [PATCH 31/82] pinctrl: armada-37xx: Add edge both type gpio irq
+ support
+
+Current edge both type gpio irqs which need to swap polarity in each
+interrupt are not supported, this patch adds edge both type gpio irq
+support.
+
+Signed-off-by: Ken Ma <make@marvell.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 64 +++++++++++++++++++++
+ 1 file changed, 64 insertions(+)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index 69bddeaad322..2b4261b3c0f7 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -585,6 +585,19 @@ static int armada_37xx_irq_set_type(struct irq_data *d, unsigned int type)
+ 	case IRQ_TYPE_EDGE_FALLING:
+ 		val |= (BIT(d->hwirq % GPIO_PER_REG));
+ 		break;
++	case IRQ_TYPE_EDGE_BOTH: {
++		u32 in_val, in_reg = INPUT_VAL;
++
++		armada_37xx_irq_update_reg(&in_reg, d);
++		regmap_read(info->regmap, in_reg, &in_val);
++
++		/* Set initial polarity based on current input level. */
++		if (in_val & d->mask)
++			val |= d->mask;		/* falling */
++		else
++			val &= ~d->mask;	/* rising */
++		break;
++	}
+ 	default:
+ 		spin_unlock_irqrestore(&info->irq_lock, flags);
+ 		return -EINVAL;
+@@ -595,6 +608,40 @@ static int armada_37xx_irq_set_type(struct irq_data *d, unsigned int type)
+ 	return 0;
+ }
+ 
++static int armada_37xx_edge_both_irq_swap_pol(struct armada_37xx_pinctrl *info,
++					     u32 pin_idx)
++{
++	u32 reg_idx = pin_idx / GPIO_PER_REG;
++	u32 bit_num = pin_idx % GPIO_PER_REG;
++	u32 p, l, ret;
++	unsigned long flags;
++
++	regmap_read(info->regmap, INPUT_VAL + 4*reg_idx, &l);
++
++	spin_lock_irqsave(&info->irq_lock, flags);
++	p = readl(info->base + IRQ_POL + 4 * reg_idx);
++	if ((p ^ l) & (1 << bit_num)) {
++		/*
++		 * For the gpios which are used for both-edge irqs, when their
++		 * interrupts happen, their input levels are changed,
++		 * yet their interrupt polarities are kept in old values, we
++		 * should synchronize their interrupt polarities; for example,
++		 * at first a gpio's input level is low and its interrupt
++		 * polarity control is "Detect rising edge", then the gpio has
++		 * a interrupt , its level turns to high, we should change its
++		 * polarity control to "Detect falling edge" correspondingly.
++		 */
++		p ^= 1 << bit_num;
++		writel(p, info->base + IRQ_POL + 4 * reg_idx);
++		ret = 0;
++	} else {
++		/* Spurious irq */
++		ret = -1;
++	}
++
++	spin_unlock_irqrestore(&info->irq_lock, flags);
++	return ret;
++}
+ 
+ static void armada_37xx_irq_handler(struct irq_desc *desc)
+ {
+@@ -618,6 +665,23 @@ static void armada_37xx_irq_handler(struct irq_desc *desc)
+ 			u32 hwirq = ffs(status) - 1;
+ 			u32 virq = irq_find_mapping(d, hwirq +
+ 						     i * GPIO_PER_REG);
++			u32 t = irq_get_trigger_type(virq);
++
++			if ((t & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
++				/* Swap polarity (race with GPIO line) */
++				if (armada_37xx_edge_both_irq_swap_pol(info,
++					hwirq + i * GPIO_PER_REG)) {
++					/*
++					 * For spurious irq, which gpio level
++					 * is not as expected after incoming
++					 * edge, just ack the gpio irq.
++					 */
++					writel(1 << hwirq,
++					       info->base +
++					       IRQ_STATUS + 4 * i);
++					continue;
++				}
++			}
+ 
+ 			generic_handle_irq(virq);
+ 
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90032-pinctrl-armada-37xx-Stop-using-struct-gpio_chip.irq_.patch b/target/linux/mvebu/patches-4.14/90032-pinctrl-armada-37xx-Stop-using-struct-gpio_chip.irq_.patch
new file mode 100644
index 0000000..6d9829f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90032-pinctrl-armada-37xx-Stop-using-struct-gpio_chip.irq_.patch
@@ -0,0 +1,49 @@
+From 0e8778c32429f7fd1cc77f1e0207c754da620161 Mon Sep 17 00:00:00 2001
+From: Thierry Reding <treding@nvidia.com>
+Date: Mon, 16 Oct 2017 14:40:23 +0200
+Subject: [PATCH 32/82] pinctrl: armada-37xx: Stop using struct
+ gpio_chip.irq_base
+
+The Armada 37xx driver always initializes the IRQ base to 0, hence the
+subtraction is a no-op. Remove the subtraction and thereby the last user
+of struct gpio_chip's .irq_base field.
+
+Note that this was also actually a bug and only worked because of the
+above assumption. If the IRQ base had been dynamically allocated, the
+subtraction would've caused the wrong mask to be generated since the
+struct irq_data.hwirq field is an index local to the IRQ domain. As a
+result, it should now be safe to also allocate this chip's IRQ base
+dynamically, unless there are consumers left that refer to the IRQs by
+their global number.
+
+Signed-off-by: Thierry Reding <treding@nvidia.com>
+Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index 2b4261b3c0f7..639c3836259f 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -700,14 +700,14 @@ static void armada_37xx_irq_handler(struct irq_desc *desc)
+ static unsigned int armada_37xx_irq_startup(struct irq_data *d)
+ {
+ 	struct gpio_chip *chip = irq_data_get_irq_chip_data(d);
+-	int irq = d->hwirq - chip->irq_base;
++
+ 	/*
+ 	 * The mask field is a "precomputed bitmask for accessing the
+ 	 * chip registers" which was introduced for the generic
+ 	 * irqchip framework. As we don't use this framework, we can
+ 	 * reuse this field for our own usage.
+ 	 */
+-	d->mask = BIT(irq % GPIO_PER_REG);
++	d->mask = BIT(d->hwirq % GPIO_PER_REG);
+ 
+ 	armada_37xx_irq_unmask(d);
+ 
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90033-pinctrl-armada-37xx-remove-unused-variable.patch b/target/linux/mvebu/patches-4.14/90033-pinctrl-armada-37xx-remove-unused-variable.patch
new file mode 100644
index 0000000..167b568
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90033-pinctrl-armada-37xx-remove-unused-variable.patch
@@ -0,0 +1,35 @@
+From e9c7212feb2c0fc3229cad99a6a52c35262b8819 Mon Sep 17 00:00:00 2001
+From: Arnd Bergmann <arnd@arndb.de>
+Date: Thu, 2 Nov 2017 15:29:13 +0100
+Subject: [PATCH 33/82] pinctrl: armada-37xx: remove unused variable
+
+A cleanup left behind a temporary variable that is now unused:
+
+drivers/pinctrl/mvebu/pinctrl-armada-37xx.c: In function 'armada_37xx_irq_startup':
+drivers/pinctrl/mvebu/pinctrl-armada-37xx.c:693:20: error: unused variable 'chip' [-Werror=unused-variable]
+
+This removes the declarations as well.
+
+Fixes: 3ee9e605caea ("pinctrl: armada-37xx: Stop using struct gpio_chip.irq_base")
+Signed-off-by: Arnd Bergmann <arnd@arndb.de>
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 2 --
+ 1 file changed, 2 deletions(-)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index 639c3836259f..44897d4b9d88 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -699,8 +699,6 @@ static void armada_37xx_irq_handler(struct irq_desc *desc)
+ 
+ static unsigned int armada_37xx_irq_startup(struct irq_data *d)
+ {
+-	struct gpio_chip *chip = irq_data_get_irq_chip_data(d);
+-
+ 	/*
+ 	 * The mask field is a "precomputed bitmask for accessing the
+ 	 * chip registers" which was introduced for the generic
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90034-net-dsa-mv88e6xxx-Fix-name-of-switch-88E6141.patch b/target/linux/mvebu/patches-4.14/90034-net-dsa-mv88e6xxx-Fix-name-of-switch-88E6141.patch
new file mode 100644
index 0000000..4606453
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90034-net-dsa-mv88e6xxx-Fix-name-of-switch-88E6141.patch
@@ -0,0 +1,35 @@
+From 2026ecb531582f91891b4ea5163e5f510de574e4 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <u.kleine-koenig@pengutronix.de>
+Date: Tue, 20 Mar 2018 10:44:40 +0100
+Subject: [PATCH 34/82] net: dsa: mv88e6xxx: Fix name of switch 88E6141
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The switch name is emitted in the kernel log, so having the right name
+there is nice.
+
+Fixes: 1558727a1c1b ("net: dsa: mv88e6xxx: Add support for ethernet switch 88E6141")
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index eebda5ec9676..bd74c45f5495 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -3204,7 +3204,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 	[MV88E6141] = {
+ 		.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6141,
+ 		.family = MV88E6XXX_FAMILY_6341,
+-		.name = "Marvell 88E6341",
++		.name = "Marvell 88E6141",
+ 		.num_databases = 4096,
+ 		.num_ports = 6,
+ 		.max_vid = 4095,
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90035-phy-add-phy_interface_mode_is_8023z-helper.patch b/target/linux/mvebu/patches-4.14/90035-phy-add-phy_interface_mode_is_8023z-helper.patch
new file mode 100644
index 0000000..7b20c28
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90035-phy-add-phy_interface_mode_is_8023z-helper.patch
@@ -0,0 +1,59 @@
+From 3e2c2128b602919181b720a3449ffa6faefce919 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 1 Dec 2017 10:24:16 +0000
+Subject: [PATCH 35/82] phy: add phy_interface_mode_is_8023z() helper
+
+Add and use phy_interface_mode_is_8023z() helper to identify the
+interface modes that use 802.3z negotiation.  Use it in phylink's
+phylink_mac_an_restart().
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/phylink.c |  3 +--
+ include/linux/phy.h       | 14 ++++++++++++++
+ 2 files changed, 15 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index c0832d7492a2..8b61cb127ef7 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -320,8 +320,7 @@ static void phylink_mac_config(struct phylink *pl,
+ static void phylink_mac_an_restart(struct phylink *pl)
+ {
+ 	if (pl->link_config.an_enabled &&
+-	    (pl->link_config.interface == PHY_INTERFACE_MODE_1000BASEX ||
+-	     pl->link_config.interface == PHY_INTERFACE_MODE_2500BASEX))
++	    phy_interface_mode_is_8023z(pl->link_config.interface))
+ 		pl->ops->mac_an_restart(pl->netdev);
+ }
+ 
+diff --git a/include/linux/phy.h b/include/linux/phy.h
+index dca9e926b88f..6fa62d5f06e6 100644
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -760,6 +760,20 @@ static inline bool phy_interface_mode_is_rgmii(phy_interface_t mode)
+ 		mode <= PHY_INTERFACE_MODE_RGMII_TXID;
+ };
+ 
++/**
++ * phy_interface_mode_is_8023z() - does the phy interface mode use 802.3z
++ *   negotiation
++ * @mode: one of &enum phy_interface_t
++ *
++ * Returns true if the phy interface mode uses the 16-bit negotiation
++ * word as defined in 802.3z. (See 802.3-2015 37.2.1 Config_Reg encoding)
++ */
++static inline bool phy_interface_mode_is_8023z(phy_interface_t mode)
++{
++	return mode == PHY_INTERFACE_MODE_1000BASEX ||
++	       mode == PHY_INTERFACE_MODE_2500BASEX;
++}
++
+ /**
+  * phy_interface_is_rgmii - Convenience function for testing if a PHY interface
+  * is RGMII (all variants)
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90036-crypto-inside-secure-remove-null-check-before-kfree.patch b/target/linux/mvebu/patches-4.14/90036-crypto-inside-secure-remove-null-check-before-kfree.patch
new file mode 100644
index 0000000..6888c92
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90036-crypto-inside-secure-remove-null-check-before-kfree.patch
@@ -0,0 +1,33 @@
+From f546f46310528adb05b9fbbd51b7a17d2e59784f Mon Sep 17 00:00:00 2001
+From: Himanshu Jha <himanshujha199640@gmail.com>
+Date: Sun, 27 Aug 2017 02:45:30 +0530
+Subject: [PATCH 36/82] crypto: inside-secure - remove null check before kfree
+
+Kfree on NULL pointer is a no-op and therefore checking is redundant.
+
+Signed-off-by: Himanshu Jha <himanshujha199640@gmail.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 6 ++----
+ 1 file changed, 2 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 69f29776591a..46c2e15c0931 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -326,10 +326,8 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 		ctx->base.cache_sz = 0;
+ 	}
+ free_cache:
+-	if (ctx->base.cache) {
+-		kfree(ctx->base.cache);
+-		ctx->base.cache = NULL;
+-	}
++	kfree(ctx->base.cache);
++	ctx->base.cache = NULL;
+ 
+ unlock:
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90037-crypto-inside-secure-do-not-use-areq-result-for-part.patch b/target/linux/mvebu/patches-4.14/90037-crypto-inside-secure-do-not-use-areq-result-for-part.patch
new file mode 100644
index 0000000..8de8dc1
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90037-crypto-inside-secure-do-not-use-areq-result-for-part.patch
@@ -0,0 +1,63 @@
+From 9623afc293461e83ecfab48df6334f23ba0eb90e Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Mon, 11 Dec 2017 12:10:58 +0100
+Subject: [PATCH 37/82] crypto: inside-secure - do not use areq->result for
+ partial results
+
+This patches update the SafeXcel driver to stop using the crypto
+ahash_request result field for partial results (i.e. on updates).
+Instead the driver local safexcel_ahash_req state field is used, and
+only on final operations the ahash_request result buffer is updated.
+
+Fixes: 1b44c5a60c13 ("crypto: inside-secure - add SafeXcel EIP197 crypto engine driver")
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 10 +++++-----
+ 1 file changed, 5 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 46c2e15c0931..c20c4db12190 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -37,7 +37,7 @@ struct safexcel_ahash_req {
+ 	int nents;
+ 
+ 	u8 state_sz;    /* expected sate size, only set once */
+-	u32 state[SHA256_DIGEST_SIZE / sizeof(u32)];
++	u32 state[SHA256_DIGEST_SIZE / sizeof(u32)] __aligned(sizeof(u32));
+ 
+ 	u64 len;
+ 	u64 processed;
+@@ -130,7 +130,7 @@ static int safexcel_handle_req_result(struct safexcel_crypto_priv *priv, int rin
+ 	struct ahash_request *areq = ahash_request_cast(async);
+ 	struct crypto_ahash *ahash = crypto_ahash_reqtfm(areq);
+ 	struct safexcel_ahash_req *sreq = ahash_request_ctx(areq);
+-	int cache_len, result_sz = sreq->state_sz;
++	int cache_len;
+ 
+ 	*ret = 0;
+ 
+@@ -151,8 +151,8 @@ static int safexcel_handle_req_result(struct safexcel_crypto_priv *priv, int rin
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+ 
+ 	if (sreq->finish)
+-		result_sz = crypto_ahash_digestsize(ahash);
+-	memcpy(sreq->state, areq->result, result_sz);
++		memcpy(areq->result, sreq->state,
++		       crypto_ahash_digestsize(ahash));
+ 
+ 	if (sreq->nents) {
+ 		dma_unmap_sg(priv->dev, areq->src, sreq->nents, DMA_TO_DEVICE);
+@@ -292,7 +292,7 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 	/* Add the token */
+ 	safexcel_hash_token(first_cdesc, len, req->state_sz);
+ 
+-	ctx->base.result_dma = dma_map_single(priv->dev, areq->result,
++	ctx->base.result_dma = dma_map_single(priv->dev, req->state,
+ 					      req->state_sz, DMA_FROM_DEVICE);
+ 	if (dma_mapping_error(priv->dev, ctx->base.result_dma)) {
+ 		ret = -EINVAL;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90038-crypto-inside-secure-remove-extra-empty-line.patch b/target/linux/mvebu/patches-4.14/90038-crypto-inside-secure-remove-extra-empty-line.patch
new file mode 100644
index 0000000..6d655b3
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90038-crypto-inside-secure-remove-extra-empty-line.patch
@@ -0,0 +1,28 @@
+From 505e74ab4b15db7c9ff13843b1ac3030f905e967 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:43 +0100
+Subject: [PATCH 38/82] crypto: inside-secure - remove extra empty line
+
+Cosmetic patch removing an extra empty line between header inclusions.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index c20c4db12190..37e7fcd2f54b 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -14,7 +14,6 @@
+ #include <linux/dma-mapping.h>
+ #include <linux/dmapool.h>
+ 
+-
+ #include "safexcel.h"
+ 
+ struct safexcel_ahash_ctx {
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90039-crypto-inside-secure-fix-typo-in-a-comment.patch b/target/linux/mvebu/patches-4.14/90039-crypto-inside-secure-fix-typo-in-a-comment.patch
new file mode 100644
index 0000000..f36288f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90039-crypto-inside-secure-fix-typo-in-a-comment.patch
@@ -0,0 +1,29 @@
+From d6f5a9a4252bc5a2fae8cadf1b772ae0b1957f33 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:44 +0100
+Subject: [PATCH 39/82] crypto: inside-secure - fix typo in a comment
+
+Cosmetic patch fixing one typo in one of the driver's comments.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 37e7fcd2f54b..50c28da35b0d 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -522,7 +522,7 @@ static int safexcel_ahash_cache(struct ahash_request *areq)
+ 		return areq->nbytes;
+ 	}
+ 
+-	/* We could'nt cache all the data */
++	/* We couldn't cache all the data */
+ 	return -E2BIG;
+ }
+ 
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90040-crypto-inside-secure-remove-useless-memset.patch b/target/linux/mvebu/patches-4.14/90040-crypto-inside-secure-remove-useless-memset.patch
new file mode 100644
index 0000000..baeb72b
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90040-crypto-inside-secure-remove-useless-memset.patch
@@ -0,0 +1,30 @@
+From 0bfd4e3e21e24ad77b32186d894bd57d08386e20 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:45 +0100
+Subject: [PATCH 40/82] crypto: inside-secure - remove useless memset
+
+This patch removes an useless memset in the ahash_export function, as
+the zeroed buffer will be entirely overridden the next line.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 50c28da35b0d..8ed46ff4cbf9 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -642,7 +642,6 @@ static int safexcel_ahash_export(struct ahash_request *areq, void *out)
+ 	export->processed = req->processed;
+ 
+ 	memcpy(export->state, req->state, req->state_sz);
+-	memset(export->cache, 0, crypto_ahash_blocksize(ahash));
+ 	memcpy(export->cache, req->cache, crypto_ahash_blocksize(ahash));
+ 
+ 	return 0;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90041-crypto-inside-secure-refrain-from-unneeded-invalidat.patch b/target/linux/mvebu/patches-4.14/90041-crypto-inside-secure-refrain-from-unneeded-invalidat.patch
new file mode 100644
index 0000000..f135d20
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90041-crypto-inside-secure-refrain-from-unneeded-invalidat.patch
@@ -0,0 +1,91 @@
+From a05f52e7856dd8f3ca40960ee45807ef6c4b87cf Mon Sep 17 00:00:00 2001
+From: Ofer Heifetz <oferh@marvell.com>
+Date: Thu, 14 Dec 2017 15:26:47 +0100
+Subject: [PATCH 41/82] crypto: inside-secure - refrain from unneeded
+ invalidations
+
+The check to know if an invalidation is needed (i.e. when the context
+changes) is done even if the context does not exist yet. This happens
+when first setting a key for ciphers and/or hmac operations.
+
+This commits adds a check in the _setkey functions to only check if an
+invalidation is needed when a context exists, as there is no need to
+perform this check otherwise.
+
+Signed-off-by: Ofer Heifetz <oferh@marvell.com>
+[Antoine: commit message and added a comment and reworked one of the
+checks]
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ .../crypto/inside-secure/safexcel_cipher.c    | 10 ++++----
+ drivers/crypto/inside-secure/safexcel_hash.c  | 24 ++++++++++++-------
+ 2 files changed, 22 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_cipher.c b/drivers/crypto/inside-secure/safexcel_cipher.c
+index 29cf7e00b574..6d8bc6a3fe5b 100644
+--- a/drivers/crypto/inside-secure/safexcel_cipher.c
++++ b/drivers/crypto/inside-secure/safexcel_cipher.c
+@@ -78,10 +78,12 @@ static int safexcel_aes_setkey(struct crypto_skcipher *ctfm, const u8 *key,
+ 		return ret;
+ 	}
+ 
+-	for (i = 0; i < len / sizeof(u32); i++) {
+-		if (ctx->key[i] != cpu_to_le32(aes.key_enc[i])) {
+-			ctx->base.needs_inv = true;
+-			break;
++	if (ctx->base.ctxr_dma) {
++		for (i = 0; i < len / sizeof(u32); i++) {
++			if (ctx->key[i] != cpu_to_le32(aes.key_enc[i])) {
++				ctx->base.needs_inv = true;
++				break;
++			}
+ 		}
+ 	}
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 8ed46ff4cbf9..955c242da244 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -535,10 +535,16 @@ static int safexcel_ahash_enqueue(struct ahash_request *areq)
+ 
+ 	req->needs_inv = false;
+ 
+-	if (req->processed && ctx->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED)
+-		ctx->base.needs_inv = safexcel_ahash_needs_inv_get(areq);
+-
+ 	if (ctx->base.ctxr) {
++		if (!ctx->base.needs_inv && req->processed &&
++		    ctx->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED)
++			/* We're still setting needs_inv here, even though it is
++			 * cleared right away, because the needs_inv flag can be
++			 * set in other functions and we want to keep the same
++			 * logic.
++			 */
++			ctx->base.needs_inv = safexcel_ahash_needs_inv_get(areq);
++
+ 		if (ctx->base.needs_inv) {
+ 			ctx->base.needs_inv = false;
+ 			req->needs_inv = true;
+@@ -936,11 +942,13 @@ static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
+ 	if (ret)
+ 		return ret;
+ 
+-	for (i = 0; i < SHA1_DIGEST_SIZE / sizeof(u32); i++) {
+-		if (ctx->ipad[i] != le32_to_cpu(istate.state[i]) ||
+-		    ctx->opad[i] != le32_to_cpu(ostate.state[i])) {
+-			ctx->base.needs_inv = true;
+-			break;
++	if (ctx->base.ctxr) {
++		for (i = 0; i < SHA1_DIGEST_SIZE / sizeof(u32); i++) {
++			if (ctx->ipad[i] != le32_to_cpu(istate.state[i]) ||
++			    ctx->opad[i] != le32_to_cpu(ostate.state[i])) {
++				ctx->base.needs_inv = true;
++				break;
++			}
+ 		}
+ 	}
+ 
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90042-crypto-inside-secure-EBUSY-is-not-an-error-on-async-.patch b/target/linux/mvebu/patches-4.14/90042-crypto-inside-secure-EBUSY-is-not-an-error-on-async-.patch
new file mode 100644
index 0000000..3c917bc
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90042-crypto-inside-secure-EBUSY-is-not-an-error-on-async-.patch
@@ -0,0 +1,35 @@
+From ab8541f44b5856339f6ccd3c49b443b25091ff90 Mon Sep 17 00:00:00 2001
+From: Ofer Heifetz <oferh@marvell.com>
+Date: Thu, 14 Dec 2017 15:26:48 +0100
+Subject: [PATCH 42/82] crypto: inside-secure - EBUSY is not an error on async
+ request
+
+When initializing the IVs crypto_ahash_update() is called, which at some
+point will call crypto_enqueue_request(). This function can return
+-EBUSY when no resource is available and the request is queued. Since
+this is a valid case, -EBUSY shouldn't be treated as an error.
+
+Signed-off-by: Ofer Heifetz <oferh@marvell.com>
+[Antoine: commit message]
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 955c242da244..f32985e56668 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -870,7 +870,7 @@ static int safexcel_hmac_init_iv(struct ahash_request *areq,
+ 	req->last_req = true;
+ 
+ 	ret = crypto_ahash_update(areq);
+-	if (ret && ret != -EINPROGRESS)
++	if (ret && ret != -EINPROGRESS && ret != -EBUSY)
+ 		return ret;
+ 
+ 	wait_for_completion_interruptible(&result.completion);
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90043-crypto-inside-secure-move-cipher-crypto-mode-to-requ.patch b/target/linux/mvebu/patches-4.14/90043-crypto-inside-secure-move-cipher-crypto-mode-to-requ.patch
new file mode 100644
index 0000000..a7c8da3
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90043-crypto-inside-secure-move-cipher-crypto-mode-to-requ.patch
@@ -0,0 +1,76 @@
+From 27e6b38e3b123978a1eee928e5b7e5aea9349e31 Mon Sep 17 00:00:00 2001
+From: Ofer Heifetz <oferh@marvell.com>
+Date: Thu, 14 Dec 2017 15:26:49 +0100
+Subject: [PATCH 43/82] crypto: inside-secure - move cipher crypto mode to
+ request context
+
+The cipher direction can be different for requests within the same
+transformation context. This patch moves the direction flag from the
+context to the request scope.
+
+Signed-off-by: Ofer Heifetz <oferh@marvell.com>
+[Antoine: commit message]
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_cipher.c | 11 +++++++----
+ 1 file changed, 7 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_cipher.c b/drivers/crypto/inside-secure/safexcel_cipher.c
+index 6d8bc6a3fe5b..5af0c890646d 100644
+--- a/drivers/crypto/inside-secure/safexcel_cipher.c
++++ b/drivers/crypto/inside-secure/safexcel_cipher.c
+@@ -27,7 +27,6 @@ struct safexcel_cipher_ctx {
+ 	struct safexcel_context base;
+ 	struct safexcel_crypto_priv *priv;
+ 
+-	enum safexcel_cipher_direction direction;
+ 	u32 mode;
+ 
+ 	__le32 key[8];
+@@ -35,6 +34,7 @@ struct safexcel_cipher_ctx {
+ };
+ 
+ struct safexcel_cipher_req {
++	enum safexcel_cipher_direction direction;
+ 	bool needs_inv;
+ };
+ 
+@@ -97,12 +97,15 @@ static int safexcel_aes_setkey(struct crypto_skcipher *ctfm, const u8 *key,
+ }
+ 
+ static int safexcel_context_control(struct safexcel_cipher_ctx *ctx,
++				    struct crypto_async_request *async,
+ 				    struct safexcel_command_desc *cdesc)
+ {
+ 	struct safexcel_crypto_priv *priv = ctx->priv;
++	struct skcipher_request *req = skcipher_request_cast(async);
++	struct safexcel_cipher_req *sreq = skcipher_request_ctx(req);
+ 	int ctrl_size;
+ 
+-	if (ctx->direction == SAFEXCEL_ENCRYPT)
++	if (sreq->direction == SAFEXCEL_ENCRYPT)
+ 		cdesc->control_data.control0 |= CONTEXT_CONTROL_TYPE_CRYPTO_OUT;
+ 	else
+ 		cdesc->control_data.control0 |= CONTEXT_CONTROL_TYPE_CRYPTO_IN;
+@@ -245,7 +248,7 @@ static int safexcel_aes_send(struct crypto_async_request *async,
+ 		n_cdesc++;
+ 
+ 		if (n_cdesc == 1) {
+-			safexcel_context_control(ctx, cdesc);
++			safexcel_context_control(ctx, async, cdesc);
+ 			safexcel_cipher_token(ctx, async, cdesc, req->cryptlen);
+ 		}
+ 
+@@ -469,7 +472,7 @@ static int safexcel_aes(struct skcipher_request *req,
+ 	int ret, ring;
+ 
+ 	sreq->needs_inv = false;
+-	ctx->direction = dir;
++	sreq->direction = dir;
+ 	ctx->mode = mode;
+ 
+ 	if (ctx->base.ctxr) {
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90044-crypto-inside-secure-remove-unused-parameter-in-inva.patch b/target/linux/mvebu/patches-4.14/90044-crypto-inside-secure-remove-unused-parameter-in-inva.patch
new file mode 100644
index 0000000..04ec1ee
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90044-crypto-inside-secure-remove-unused-parameter-in-inva.patch
@@ -0,0 +1,74 @@
+From 66dbe290b05b716faefb8b13064501e4b503bea3 Mon Sep 17 00:00:00 2001
+From: Ofer Heifetz <oferh@marvell.com>
+Date: Thu, 14 Dec 2017 15:26:50 +0100
+Subject: [PATCH 44/82] crypto: inside-secure - remove unused parameter in
+ invalidate_cache
+
+The SafeXcel context isn't used in the cache invalidation function. This
+cosmetic patch removes it (as well as from the function prototype in the
+header file and when the function is called).
+
+Signed-off-by: Ofer Heifetz <oferh@marvell.com>
+[Antoine: commit message]
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c        | 1 -
+ drivers/crypto/inside-secure/safexcel.h        | 1 -
+ drivers/crypto/inside-secure/safexcel_cipher.c | 2 +-
+ drivers/crypto/inside-secure/safexcel_hash.c   | 2 +-
+ 4 files changed, 2 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 3ee68ecde9ec..daeefef76f11 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -549,7 +549,6 @@ void safexcel_inv_complete(struct crypto_async_request *req, int error)
+ }
+ 
+ int safexcel_invalidate_cache(struct crypto_async_request *async,
+-			      struct safexcel_context *ctx,
+ 			      struct safexcel_crypto_priv *priv,
+ 			      dma_addr_t ctxr_dma, int ring,
+ 			      struct safexcel_request *request)
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 304c5838c11a..d12c2b479a5e 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -539,7 +539,6 @@ void safexcel_free_context(struct safexcel_crypto_priv *priv,
+ 				  struct crypto_async_request *req,
+ 				  int result_sz);
+ int safexcel_invalidate_cache(struct crypto_async_request *async,
+-			      struct safexcel_context *ctx,
+ 			      struct safexcel_crypto_priv *priv,
+ 			      dma_addr_t ctxr_dma, int ring,
+ 			      struct safexcel_request *request);
+diff --git a/drivers/crypto/inside-secure/safexcel_cipher.c b/drivers/crypto/inside-secure/safexcel_cipher.c
+index 5af0c890646d..f5ffae2808a8 100644
+--- a/drivers/crypto/inside-secure/safexcel_cipher.c
++++ b/drivers/crypto/inside-secure/safexcel_cipher.c
+@@ -395,7 +395,7 @@ static int safexcel_cipher_send_inv(struct crypto_async_request *async,
+ 	struct safexcel_crypto_priv *priv = ctx->priv;
+ 	int ret;
+ 
+-	ret = safexcel_invalidate_cache(async, &ctx->base, priv,
++	ret = safexcel_invalidate_cache(async, priv,
+ 					ctx->base.ctxr_dma, ring, request);
+ 	if (unlikely(ret))
+ 		return ret;
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index f32985e56668..328ce02ac050 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -435,7 +435,7 @@ static int safexcel_ahash_send_inv(struct crypto_async_request *async,
+ 	struct safexcel_ahash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(areq));
+ 	int ret;
+ 
+-	ret = safexcel_invalidate_cache(async, &ctx->base, ctx->priv,
++	ret = safexcel_invalidate_cache(async, ctx->priv,
+ 					ctx->base.ctxr_dma, ring, request);
+ 	if (unlikely(ret))
+ 		return ret;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90045-crypto-inside-secure-move-request-dequeueing-into-a-.patch b/target/linux/mvebu/patches-4.14/90045-crypto-inside-secure-move-request-dequeueing-into-a-.patch
new file mode 100644
index 0000000..0300b42
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90045-crypto-inside-secure-move-request-dequeueing-into-a-.patch
@@ -0,0 +1,204 @@
+From fb445c38843fa3651d01966c62a443a9435a1449 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:51 +0100
+Subject: [PATCH 45/82] crypto: inside-secure - move request dequeueing into a
+ workqueue
+
+This patch moves the request dequeueing into a workqueue to improve the
+coalescing of interrupts when sending requests to the engine; as the
+engine is capable of having one single interrupt for n requests sent.
+Using a workqueue allows to send more request at once.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c       | 29 ++++++++++---------
+ drivers/crypto/inside-secure/safexcel.h       |  2 +-
+ .../crypto/inside-secure/safexcel_cipher.c    | 12 ++++----
+ drivers/crypto/inside-secure/safexcel_hash.c  | 12 ++++----
+ 4 files changed, 29 insertions(+), 26 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index daeefef76f11..9043ab8c98cb 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -429,8 +429,6 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 	struct safexcel_request *request;
+ 	int ret, nreq = 0, cdesc = 0, rdesc = 0, commands, results;
+ 
+-	priv->ring[ring].need_dequeue = false;
+-
+ 	do {
+ 		spin_lock_bh(&priv->ring[ring].queue_lock);
+ 		backlog = crypto_get_backlog(&priv->ring[ring].queue);
+@@ -445,8 +443,6 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 			spin_lock_bh(&priv->ring[ring].queue_lock);
+ 			crypto_enqueue_request(&priv->ring[ring].queue, req);
+ 			spin_unlock_bh(&priv->ring[ring].queue_lock);
+-
+-			priv->ring[ring].need_dequeue = true;
+ 			goto finalize;
+ 		}
+ 
+@@ -455,7 +451,6 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 		if (ret) {
+ 			kfree(request);
+ 			req->complete(req, ret);
+-			priv->ring[ring].need_dequeue = true;
+ 			goto finalize;
+ 		}
+ 
+@@ -480,9 +475,7 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 	} while (nreq++ < EIP197_MAX_BATCH_SZ);
+ 
+ finalize:
+-	if (nreq == EIP197_MAX_BATCH_SZ)
+-		priv->ring[ring].need_dequeue = true;
+-	else if (!nreq)
++	if (!nreq)
+ 		return;
+ 
+ 	spin_lock_bh(&priv->ring[ring].lock);
+@@ -637,13 +630,18 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ static void safexcel_handle_result_work(struct work_struct *work)
+ {
+ 	struct safexcel_work_data *data =
+-			container_of(work, struct safexcel_work_data, work);
++			container_of(work, struct safexcel_work_data, result_work);
+ 	struct safexcel_crypto_priv *priv = data->priv;
+ 
+ 	safexcel_handle_result_descriptor(priv, data->ring);
++}
++
++static void safexcel_dequeue_work(struct work_struct *work)
++{
++	struct safexcel_work_data *data =
++			container_of(work, struct safexcel_work_data, work);
+ 
+-	if (priv->ring[data->ring].need_dequeue)
+-		safexcel_dequeue(data->priv, data->ring);
++	safexcel_dequeue(data->priv, data->ring);
+ }
+ 
+ struct safexcel_ring_irq_data {
+@@ -674,7 +672,10 @@ static irqreturn_t safexcel_irq_ring(int irq, void *data)
+ 			 */
+ 			dev_err(priv->dev, "RDR: fatal error.");
+ 		} else if (likely(stat & EIP197_xDR_THRESH)) {
+-			queue_work(priv->ring[ring].workqueue, &priv->ring[ring].work_data.work);
++			queue_work(priv->ring[ring].workqueue,
++				   &priv->ring[ring].work_data.result_work);
++			queue_work(priv->ring[ring].workqueue,
++				   &priv->ring[ring].work_data.work);
+ 		}
+ 
+ 		/* ACK the interrupts */
+@@ -855,7 +856,9 @@ static int safexcel_probe(struct platform_device *pdev)
+ 
+ 		priv->ring[i].work_data.priv = priv;
+ 		priv->ring[i].work_data.ring = i;
+-		INIT_WORK(&priv->ring[i].work_data.work, safexcel_handle_result_work);
++		INIT_WORK(&priv->ring[i].work_data.result_work,
++			  safexcel_handle_result_work);
++		INIT_WORK(&priv->ring[i].work_data.work, safexcel_dequeue_work);
+ 
+ 		snprintf(wq_name, 9, "wq_ring%d", i);
+ 		priv->ring[i].workqueue = create_singlethread_workqueue(wq_name);
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index d12c2b479a5e..8e9c65183439 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -459,6 +459,7 @@ struct safexcel_config {
+ 
+ struct safexcel_work_data {
+ 	struct work_struct work;
++	struct work_struct result_work;
+ 	struct safexcel_crypto_priv *priv;
+ 	int ring;
+ };
+@@ -489,7 +490,6 @@ struct safexcel_crypto_priv {
+ 		/* queue */
+ 		struct crypto_queue queue;
+ 		spinlock_t queue_lock;
+-		bool need_dequeue;
+ 	} ring[EIP197_MAX_RINGS];
+ };
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel_cipher.c b/drivers/crypto/inside-secure/safexcel_cipher.c
+index f5ffae2808a8..7c9a2d87135b 100644
+--- a/drivers/crypto/inside-secure/safexcel_cipher.c
++++ b/drivers/crypto/inside-secure/safexcel_cipher.c
+@@ -358,8 +358,8 @@ static int safexcel_handle_inv_result(struct safexcel_crypto_priv *priv,
+ 	if (enq_ret != -EINPROGRESS)
+ 		*ret = enq_ret;
+ 
+-	if (!priv->ring[ring].need_dequeue)
+-		safexcel_dequeue(priv, ring);
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
+ 
+ 	*should_complete = false;
+ 
+@@ -448,8 +448,8 @@ static int safexcel_cipher_exit_inv(struct crypto_tfm *tfm)
+ 	crypto_enqueue_request(&priv->ring[ring].queue, &req->base);
+ 	spin_unlock_bh(&priv->ring[ring].queue_lock);
+ 
+-	if (!priv->ring[ring].need_dequeue)
+-		safexcel_dequeue(priv, ring);
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
+ 
+ 	wait_for_completion(&result.completion);
+ 
+@@ -495,8 +495,8 @@ static int safexcel_aes(struct skcipher_request *req,
+ 	ret = crypto_enqueue_request(&priv->ring[ring].queue, &req->base);
+ 	spin_unlock_bh(&priv->ring[ring].queue_lock);
+ 
+-	if (!priv->ring[ring].need_dequeue)
+-		safexcel_dequeue(priv, ring);
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
+ 
+ 	return ret;
+ }
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 328ce02ac050..6912c032200b 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -399,8 +399,8 @@ static int safexcel_handle_inv_result(struct safexcel_crypto_priv *priv,
+ 	if (enq_ret != -EINPROGRESS)
+ 		*ret = enq_ret;
+ 
+-	if (!priv->ring[ring].need_dequeue)
+-		safexcel_dequeue(priv, ring);
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
+ 
+ 	*should_complete = false;
+ 
+@@ -488,8 +488,8 @@ static int safexcel_ahash_exit_inv(struct crypto_tfm *tfm)
+ 	crypto_enqueue_request(&priv->ring[ring].queue, &req->base);
+ 	spin_unlock_bh(&priv->ring[ring].queue_lock);
+ 
+-	if (!priv->ring[ring].need_dequeue)
+-		safexcel_dequeue(priv, ring);
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
+ 
+ 	wait_for_completion(&result.completion);
+ 
+@@ -564,8 +564,8 @@ static int safexcel_ahash_enqueue(struct ahash_request *areq)
+ 	ret = crypto_enqueue_request(&priv->ring[ring].queue, &areq->base);
+ 	spin_unlock_bh(&priv->ring[ring].queue_lock);
+ 
+-	if (!priv->ring[ring].need_dequeue)
+-		safexcel_dequeue(priv, ring);
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
+ 
+ 	return ret;
+ }
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90046-crypto-inside-secure-use-threaded-IRQs-for-result-ha.patch b/target/linux/mvebu/patches-4.14/90046-crypto-inside-secure-use-threaded-IRQs-for-result-ha.patch
new file mode 100644
index 0000000..3ce4a7f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90046-crypto-inside-secure-use-threaded-IRQs-for-result-ha.patch
@@ -0,0 +1,136 @@
+From d9ed66ebd6731cde146ae4ff47965c91e05e9267 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:52 +0100
+Subject: [PATCH 46/82] crypto: inside-secure - use threaded IRQs for result
+ handling
+
+This patch moves the result handling from an IRQ handler to a threaded
+IRQ handler, to improve the number of complete requests being handled at
+once.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 41 +++++++++++++------------
+ drivers/crypto/inside-secure/safexcel.h |  1 -
+ 2 files changed, 22 insertions(+), 20 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 9043ab8c98cb..4931d21f63f7 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -627,15 +627,6 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 	}
+ }
+ 
+-static void safexcel_handle_result_work(struct work_struct *work)
+-{
+-	struct safexcel_work_data *data =
+-			container_of(work, struct safexcel_work_data, result_work);
+-	struct safexcel_crypto_priv *priv = data->priv;
+-
+-	safexcel_handle_result_descriptor(priv, data->ring);
+-}
+-
+ static void safexcel_dequeue_work(struct work_struct *work)
+ {
+ 	struct safexcel_work_data *data =
+@@ -653,12 +644,12 @@ static irqreturn_t safexcel_irq_ring(int irq, void *data)
+ {
+ 	struct safexcel_ring_irq_data *irq_data = data;
+ 	struct safexcel_crypto_priv *priv = irq_data->priv;
+-	int ring = irq_data->ring;
++	int ring = irq_data->ring, rc = IRQ_NONE;
+ 	u32 status, stat;
+ 
+ 	status = readl(priv->base + EIP197_HIA_AIC_R_ENABLED_STAT(ring));
+ 	if (!status)
+-		return IRQ_NONE;
++		return rc;
+ 
+ 	/* RDR interrupts */
+ 	if (status & EIP197_RDR_IRQ(ring)) {
+@@ -672,10 +663,7 @@ static irqreturn_t safexcel_irq_ring(int irq, void *data)
+ 			 */
+ 			dev_err(priv->dev, "RDR: fatal error.");
+ 		} else if (likely(stat & EIP197_xDR_THRESH)) {
+-			queue_work(priv->ring[ring].workqueue,
+-				   &priv->ring[ring].work_data.result_work);
+-			queue_work(priv->ring[ring].workqueue,
+-				   &priv->ring[ring].work_data.work);
++			rc = IRQ_WAKE_THREAD;
+ 		}
+ 
+ 		/* ACK the interrupts */
+@@ -686,11 +674,26 @@ static irqreturn_t safexcel_irq_ring(int irq, void *data)
+ 	/* ACK the interrupts */
+ 	writel(status, priv->base + EIP197_HIA_AIC_R_ACK(ring));
+ 
++	return rc;
++}
++
++static irqreturn_t safexcel_irq_ring_thread(int irq, void *data)
++{
++	struct safexcel_ring_irq_data *irq_data = data;
++	struct safexcel_crypto_priv *priv = irq_data->priv;
++	int ring = irq_data->ring;
++
++	safexcel_handle_result_descriptor(priv, ring);
++
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
++
+ 	return IRQ_HANDLED;
+ }
+ 
+ static int safexcel_request_ring_irq(struct platform_device *pdev, const char *name,
+ 				     irq_handler_t handler,
++				     irq_handler_t threaded_handler,
+ 				     struct safexcel_ring_irq_data *ring_irq_priv)
+ {
+ 	int ret, irq = platform_get_irq_byname(pdev, name);
+@@ -700,8 +703,9 @@ static int safexcel_request_ring_irq(struct platform_device *pdev, const char *n
+ 		return irq;
+ 	}
+ 
+-	ret = devm_request_irq(&pdev->dev, irq, handler, 0,
+-			       dev_name(&pdev->dev), ring_irq_priv);
++	ret = devm_request_threaded_irq(&pdev->dev, irq, handler,
++					threaded_handler, IRQF_ONESHOT,
++					dev_name(&pdev->dev), ring_irq_priv);
+ 	if (ret) {
+ 		dev_err(&pdev->dev, "unable to request IRQ %d\n", irq);
+ 		return ret;
+@@ -848,6 +852,7 @@ static int safexcel_probe(struct platform_device *pdev)
+ 
+ 		snprintf(irq_name, 6, "ring%d", i);
+ 		irq = safexcel_request_ring_irq(pdev, irq_name, safexcel_irq_ring,
++						safexcel_irq_ring_thread,
+ 						ring_irq);
+ 		if (irq < 0) {
+ 			ret = irq;
+@@ -856,8 +861,6 @@ static int safexcel_probe(struct platform_device *pdev)
+ 
+ 		priv->ring[i].work_data.priv = priv;
+ 		priv->ring[i].work_data.ring = i;
+-		INIT_WORK(&priv->ring[i].work_data.result_work,
+-			  safexcel_handle_result_work);
+ 		INIT_WORK(&priv->ring[i].work_data.work, safexcel_dequeue_work);
+ 
+ 		snprintf(wq_name, 9, "wq_ring%d", i);
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 8e9c65183439..fffddefb0d9b 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -459,7 +459,6 @@ struct safexcel_config {
+ 
+ struct safexcel_work_data {
+ 	struct work_struct work;
+-	struct work_struct result_work;
+ 	struct safexcel_crypto_priv *priv;
+ 	int ring;
+ };
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90047-crypto-inside-secure-dequeue-all-requests-at-once.patch b/target/linux/mvebu/patches-4.14/90047-crypto-inside-secure-dequeue-all-requests-at-once.patch
new file mode 100644
index 0000000..baeccbf
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90047-crypto-inside-secure-dequeue-all-requests-at-once.patch
@@ -0,0 +1,179 @@
+From 475983c763e5d2090a16abf326dc895dd184d3f0 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:53 +0100
+Subject: [PATCH 47/82] crypto: inside-secure - dequeue all requests at once
+
+This patch updates the dequeueing logic to dequeue all requests at once.
+Since we can have many requests in the queue, the interrupt coalescing
+is kept so that the ring interrupt fires every EIP197_MAX_BATCH_SZ at
+most.
+
+To allow dequeueing all requests at once while still using reasonable
+settings for the interrupt coalescing, the result handling function was
+updated to setup the threshold interrupt when needed (i.e. when more
+requests than EIP197_MAX_BATCH_SZ are in the queue). When using this
+capability the ring is marked as busy so that the dequeue function
+enqueue new requests without setting the threshold interrupt.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 60 ++++++++++++++++++++-----
+ drivers/crypto/inside-secure/safexcel.h |  8 ++++
+ 2 files changed, 56 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 4931d21f63f7..2b32ca5eafbd 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -422,6 +422,23 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	return 0;
+ }
+ 
++/* Called with ring's lock taken */
++int safexcel_try_push_requests(struct safexcel_crypto_priv *priv, int ring,
++			       int reqs)
++{
++	int coal = min_t(int, reqs, EIP197_MAX_BATCH_SZ);
++
++	if (!coal)
++		return 0;
++
++	/* Configure when we want an interrupt */
++	writel(EIP197_HIA_RDR_THRESH_PKT_MODE |
++	       EIP197_HIA_RDR_THRESH_PROC_PKT(coal),
++	       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_THRESH);
++
++	return coal;
++}
++
+ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ {
+ 	struct crypto_async_request *req, *backlog;
+@@ -429,7 +446,7 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 	struct safexcel_request *request;
+ 	int ret, nreq = 0, cdesc = 0, rdesc = 0, commands, results;
+ 
+-	do {
++	while (true) {
+ 		spin_lock_bh(&priv->ring[ring].queue_lock);
+ 		backlog = crypto_get_backlog(&priv->ring[ring].queue);
+ 		req = crypto_dequeue_request(&priv->ring[ring].queue);
+@@ -472,18 +489,24 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 
+ 		cdesc += commands;
+ 		rdesc += results;
+-	} while (nreq++ < EIP197_MAX_BATCH_SZ);
++		nreq++;
++	}
+ 
+ finalize:
+ 	if (!nreq)
+ 		return;
+ 
+-	spin_lock_bh(&priv->ring[ring].lock);
++	spin_lock_bh(&priv->ring[ring].egress_lock);
+ 
+-	/* Configure when we want an interrupt */
+-	writel(EIP197_HIA_RDR_THRESH_PKT_MODE |
+-	       EIP197_HIA_RDR_THRESH_PROC_PKT(nreq),
+-	       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_THRESH);
++	if (!priv->ring[ring].busy) {
++		nreq -= safexcel_try_push_requests(priv, ring, nreq);
++		if (nreq)
++			priv->ring[ring].busy = true;
++	}
++
++	priv->ring[ring].requests_left += nreq;
++
++	spin_unlock_bh(&priv->ring[ring].egress_lock);
+ 
+ 	/* let the RDR know we have pending descriptors */
+ 	writel((rdesc * priv->config.rd_offset) << 2,
+@@ -492,8 +515,6 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 	/* let the CDR know we have pending descriptors */
+ 	writel((cdesc * priv->config.cd_offset) << 2,
+ 	       priv->base + EIP197_HIA_CDR(ring) + EIP197_HIA_xDR_PREP_COUNT);
+-
+-	spin_unlock_bh(&priv->ring[ring].lock);
+ }
+ 
+ void safexcel_free_context(struct safexcel_crypto_priv *priv,
+@@ -588,14 +609,14 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ {
+ 	struct safexcel_request *sreq;
+ 	struct safexcel_context *ctx;
+-	int ret, i, nreq, ndesc = 0;
++	int ret, i, nreq, ndesc = 0, done;
+ 	bool should_complete;
+ 
+ 	nreq = readl(priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
+ 	nreq >>= 24;
+ 	nreq &= GENMASK(6, 0);
+ 	if (!nreq)
+-		return;
++		goto requests_left;
+ 
+ 	for (i = 0; i < nreq; i++) {
+ 		spin_lock_bh(&priv->ring[ring].egress_lock);
+@@ -610,7 +631,7 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 		if (ndesc < 0) {
+ 			kfree(sreq);
+ 			dev_err(priv->dev, "failed to handle result (%d)", ndesc);
+-			return;
++			goto requests_left;
+ 		}
+ 
+ 		writel(EIP197_xDR_PROC_xD_PKT(1) |
+@@ -625,6 +646,18 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 
+ 		kfree(sreq);
+ 	}
++
++requests_left:
++	spin_lock_bh(&priv->ring[ring].egress_lock);
++
++	done = safexcel_try_push_requests(priv, ring,
++					  priv->ring[ring].requests_left);
++
++	priv->ring[ring].requests_left -= done;
++	if (!done && !priv->ring[ring].requests_left)
++		priv->ring[ring].busy = false;
++
++	spin_unlock_bh(&priv->ring[ring].egress_lock);
+ }
+ 
+ static void safexcel_dequeue_work(struct work_struct *work)
+@@ -870,6 +903,9 @@ static int safexcel_probe(struct platform_device *pdev)
+ 			goto err_clk;
+ 		}
+ 
++		priv->ring[i].requests_left = 0;
++		priv->ring[i].busy = false;
++
+ 		crypto_init_queue(&priv->ring[i].queue,
+ 				  EIP197_DEFAULT_RING_SIZE);
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index fffddefb0d9b..531e3e9d8384 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -489,6 +489,14 @@ struct safexcel_crypto_priv {
+ 		/* queue */
+ 		struct crypto_queue queue;
+ 		spinlock_t queue_lock;
++
++		/* Number of requests in the engine that needs the threshold
++		 * interrupt to be set up.
++		 */
++		int requests_left;
++
++		/* The ring is currently handling at least one request */
++		bool busy;
+ 	} ring[EIP197_MAX_RINGS];
+ };
+ 
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90048-crypto-inside-secure-increase-the-ring-size.patch b/target/linux/mvebu/patches-4.14/90048-crypto-inside-secure-increase-the-ring-size.patch
new file mode 100644
index 0000000..845ae9a
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90048-crypto-inside-secure-increase-the-ring-size.patch
@@ -0,0 +1,37 @@
+From 0960fa4f79857635412051c61c9fb451a91e79b8 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:54 +0100
+Subject: [PATCH 48/82] crypto: inside-secure - increase the ring size
+
+Increase the ring size to handle more requests in parallel, while
+keeping the batch size (for interrupt coalescing) to its previous value.
+The ring size and batch size are now unlinked.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.h | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 531e3e9d8384..2a0ab6ce716a 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -19,11 +19,11 @@
+ #define EIP197_HIA_VERSION_BE			0x35ca
+ 
+ /* Static configuration */
+-#define EIP197_DEFAULT_RING_SIZE		64
++#define EIP197_DEFAULT_RING_SIZE		400
+ #define EIP197_MAX_TOKENS			5
+ #define EIP197_MAX_RINGS			4
+ #define EIP197_FETCH_COUNT			1
+-#define EIP197_MAX_BATCH_SZ			EIP197_DEFAULT_RING_SIZE
++#define EIP197_MAX_BATCH_SZ			64
+ 
+ #define EIP197_GFP_FLAGS(base)	((base).flags & CRYPTO_TFM_REQ_MAY_SLEEP ? \
+ 				 GFP_KERNEL : GFP_ATOMIC)
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90049-crypto-inside-secure-acknowledge-the-result-requests.patch b/target/linux/mvebu/patches-4.14/90049-crypto-inside-secure-acknowledge-the-result-requests.patch
new file mode 100644
index 0000000..ef01d7b
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90049-crypto-inside-secure-acknowledge-the-result-requests.patch
@@ -0,0 +1,62 @@
+From 28251290d2f7f45e9fc8c9a45d6e60bd5954c78f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:55 +0100
+Subject: [PATCH 49/82] crypto: inside-secure - acknowledge the result requests
+ all at once
+
+This patches moves the result request acknowledgment from a per request
+process to acknowledging all the result requests handled at once.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 16 ++++++++++------
+ 1 file changed, 10 insertions(+), 6 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 2b32ca5eafbd..af79bc751ad1 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -609,7 +609,7 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ {
+ 	struct safexcel_request *sreq;
+ 	struct safexcel_context *ctx;
+-	int ret, i, nreq, ndesc = 0, done;
++	int ret, i, nreq, ndesc = 0, tot_descs = 0, done;
+ 	bool should_complete;
+ 
+ 	nreq = readl(priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
+@@ -631,13 +631,9 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 		if (ndesc < 0) {
+ 			kfree(sreq);
+ 			dev_err(priv->dev, "failed to handle result (%d)", ndesc);
+-			goto requests_left;
++			goto acknowledge;
+ 		}
+ 
+-		writel(EIP197_xDR_PROC_xD_PKT(1) |
+-		       EIP197_xDR_PROC_xD_COUNT(ndesc * priv->config.rd_offset),
+-		       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
+-
+ 		if (should_complete) {
+ 			local_bh_disable();
+ 			sreq->req->complete(sreq->req, ret);
+@@ -645,6 +641,14 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 		}
+ 
+ 		kfree(sreq);
++		tot_descs += ndesc;
++	}
++
++acknowledge:
++	if (i) {
++		writel(EIP197_xDR_PROC_xD_PKT(i) |
++		       EIP197_xDR_PROC_xD_COUNT(tot_descs * priv->config.rd_offset),
++		       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
+ 	}
+ 
+ requests_left:
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90050-crypto-inside-secure-handle-more-result-requests-whe.patch b/target/linux/mvebu/patches-4.14/90050-crypto-inside-secure-handle-more-result-requests-whe.patch
new file mode 100644
index 0000000..df80293
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90050-crypto-inside-secure-handle-more-result-requests-whe.patch
@@ -0,0 +1,70 @@
+From c63ff238eca83cae2e1f69c2ca350d2c1879bcdb Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:56 +0100
+Subject: [PATCH 50/82] crypto: inside-secure - handle more result requests
+ when counter is full
+
+This patch modifies the result handling logic to continue handling
+results when the completed requests counter is full and not showing the
+actual number of requests to handle.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 15 ++++++++++++---
+ drivers/crypto/inside-secure/safexcel.h |  2 ++
+ 2 files changed, 14 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index af79bc751ad1..dec1925cf0ad 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -609,12 +609,15 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ {
+ 	struct safexcel_request *sreq;
+ 	struct safexcel_context *ctx;
+-	int ret, i, nreq, ndesc = 0, tot_descs = 0, done;
++	int ret, i, nreq, ndesc, tot_descs, done;
+ 	bool should_complete;
+ 
++handle_results:
++	tot_descs = 0;
++
+ 	nreq = readl(priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
+-	nreq >>= 24;
+-	nreq &= GENMASK(6, 0);
++	nreq >>= EIP197_xDR_PROC_xD_PKT_OFFSET;
++	nreq &= EIP197_xDR_PROC_xD_PKT_MASK;
+ 	if (!nreq)
+ 		goto requests_left;
+ 
+@@ -651,6 +654,12 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 		       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
+ 	}
+ 
++	/* If the number of requests overflowed the counter, try to proceed more
++	 * requests.
++	 */
++	if (nreq == EIP197_xDR_PROC_xD_PKT_MASK)
++		goto handle_results;
++
+ requests_left:
+ 	spin_lock_bh(&priv->ring[ring].egress_lock);
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 2a0ab6ce716a..0c47e792192d 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -117,6 +117,8 @@
+ #define EIP197_xDR_PREP_CLR_COUNT		BIT(31)
+ 
+ /* EIP197_HIA_xDR_PROC_COUNT */
++#define EIP197_xDR_PROC_xD_PKT_OFFSET		24
++#define EIP197_xDR_PROC_xD_PKT_MASK		GENMASK(6, 0)
+ #define EIP197_xDR_PROC_xD_COUNT(n)		((n) << 2)
+ #define EIP197_xDR_PROC_xD_PKT(n)		((n) << 24)
+ #define EIP197_xDR_PROC_CLR_COUNT		BIT(31)
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90051-crypto-inside-secure-retry-to-proceed-the-request-la.patch b/target/linux/mvebu/patches-4.14/90051-crypto-inside-secure-retry-to-proceed-the-request-la.patch
new file mode 100644
index 0000000..1eb70d4
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90051-crypto-inside-secure-retry-to-proceed-the-request-la.patch
@@ -0,0 +1,103 @@
+From 929a581f8afd82685be4433cf39bcaa70606adce Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:57 +0100
+Subject: [PATCH 51/82] crypto: inside-secure - retry to proceed the request
+ later on fail
+
+The dequeueing function was putting back a request in the crypto queue
+on failure (when not enough resources are available) which is not
+perfect as the request will be handled much later. This patch updates
+this logic by keeping a reference on the failed request to try
+proceeding it later when enough resources are available.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 32 ++++++++++++++++++-------
+ drivers/crypto/inside-secure/safexcel.h |  6 +++++
+ 2 files changed, 29 insertions(+), 9 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index dec1925cf0ad..0c0199a65337 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -446,29 +446,36 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 	struct safexcel_request *request;
+ 	int ret, nreq = 0, cdesc = 0, rdesc = 0, commands, results;
+ 
++	/* If a request wasn't properly dequeued because of a lack of resources,
++	 * proceeded it first,
++	 */
++	req = priv->ring[ring].req;
++	backlog = priv->ring[ring].backlog;
++	if (req)
++		goto handle_req;
++
+ 	while (true) {
+ 		spin_lock_bh(&priv->ring[ring].queue_lock);
+ 		backlog = crypto_get_backlog(&priv->ring[ring].queue);
+ 		req = crypto_dequeue_request(&priv->ring[ring].queue);
+ 		spin_unlock_bh(&priv->ring[ring].queue_lock);
+ 
+-		if (!req)
++		if (!req) {
++			priv->ring[ring].req = NULL;
++			priv->ring[ring].backlog = NULL;
+ 			goto finalize;
++		}
+ 
++handle_req:
+ 		request = kzalloc(sizeof(*request), EIP197_GFP_FLAGS(*req));
+-		if (!request) {
+-			spin_lock_bh(&priv->ring[ring].queue_lock);
+-			crypto_enqueue_request(&priv->ring[ring].queue, req);
+-			spin_unlock_bh(&priv->ring[ring].queue_lock);
+-			goto finalize;
+-		}
++		if (!request)
++			goto request_failed;
+ 
+ 		ctx = crypto_tfm_ctx(req->tfm);
+ 		ret = ctx->send(req, ring, request, &commands, &results);
+ 		if (ret) {
+ 			kfree(request);
+-			req->complete(req, ret);
+-			goto finalize;
++			goto request_failed;
+ 		}
+ 
+ 		if (backlog)
+@@ -492,6 +499,13 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 		nreq++;
+ 	}
+ 
++request_failed:
++	/* Not enough resources to handle all the requests. Bail out and save
++	 * the request and the backlog for the next dequeue call (per-ring).
++	 */
++	priv->ring[ring].req = req;
++	priv->ring[ring].backlog = backlog;
++
+ finalize:
+ 	if (!nreq)
+ 		return;
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 0c47e792192d..d4955abf873b 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -499,6 +499,12 @@ struct safexcel_crypto_priv {
+ 
+ 		/* The ring is currently handling at least one request */
+ 		bool busy;
++
++		/* Store for current requests when bailing out of the dequeueing
++		 * function when no enough resources are available.
++		 */
++		struct crypto_async_request *req;
++		struct crypto_async_request *backlog;
+ 	} ring[EIP197_MAX_RINGS];
+ };
+ 
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90052-crypto-inside-secure-EIP97-support.patch b/target/linux/mvebu/patches-4.14/90052-crypto-inside-secure-EIP97-support.patch
new file mode 100644
index 0000000..fcea29c
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90052-crypto-inside-secure-EIP97-support.patch
@@ -0,0 +1,841 @@
+From 90f63fbb6616deae34fc588b4227a03578c5852a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:58 +0100
+Subject: [PATCH 52/82] crypto: inside-secure - EIP97 support
+
+The Inside Secure SafeXcel driver was firstly designed to support the
+EIP197 cryptographic engine which is an evolution (with much more
+feature, better performances) of the EIP97 cryptographic engine. This
+patch convert the Inside Secure SafeXcel driver to support both engines
+(EIP97 + EIP197).
+
+The main differences are the register offsets and the context
+invalidation process which is EIP197 specific. This patch adds an
+indirection on the register offsets and adds checks not to send any
+invalidation request when driving the EIP97. A new compatible is added
+as well to bind the driver from device trees.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c       | 212 +++++++++++-------
+ drivers/crypto/inside-secure/safexcel.h       | 151 +++++++++----
+ .../crypto/inside-secure/safexcel_cipher.c    |  20 +-
+ drivers/crypto/inside-secure/safexcel_hash.c  |  19 +-
+ 4 files changed, 264 insertions(+), 138 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 0c0199a65337..b0787f5f62ad 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -108,10 +108,10 @@ static void eip197_write_firmware(struct safexcel_crypto_priv *priv,
+ 	writel(EIP197_PE_ICE_x_CTRL_SW_RESET |
+ 	       EIP197_PE_ICE_x_CTRL_CLR_ECC_CORR |
+ 	       EIP197_PE_ICE_x_CTRL_CLR_ECC_NON_CORR,
+-	       priv->base + ctrl);
++	       EIP197_PE(priv) + ctrl);
+ 
+ 	/* Enable access to the program memory */
+-	writel(prog_en, priv->base + EIP197_PE_ICE_RAM_CTRL);
++	writel(prog_en, EIP197_PE(priv) + EIP197_PE_ICE_RAM_CTRL);
+ 
+ 	/* Write the firmware */
+ 	for (i = 0; i < fw->size / sizeof(u32); i++)
+@@ -119,12 +119,12 @@ static void eip197_write_firmware(struct safexcel_crypto_priv *priv,
+ 		       priv->base + EIP197_CLASSIFICATION_RAMS + i * sizeof(u32));
+ 
+ 	/* Disable access to the program memory */
+-	writel(0, priv->base + EIP197_PE_ICE_RAM_CTRL);
++	writel(0, EIP197_PE(priv) + EIP197_PE_ICE_RAM_CTRL);
+ 
+ 	/* Release engine from reset */
+-	val = readl(priv->base + ctrl);
++	val = readl(EIP197_PE(priv) + ctrl);
+ 	val &= ~EIP197_PE_ICE_x_CTRL_SW_RESET;
+-	writel(val, priv->base + ctrl);
++	writel(val, EIP197_PE(priv) + ctrl);
+ }
+ 
+ static int eip197_load_firmwares(struct safexcel_crypto_priv *priv)
+@@ -145,14 +145,14 @@ static int eip197_load_firmwares(struct safexcel_crypto_priv *priv)
+ 	 }
+ 
+ 	/* Clear the scratchpad memory */
+-	val = readl(priv->base + EIP197_PE_ICE_SCRATCH_CTRL);
++	val = readl(EIP197_PE(priv) + EIP197_PE_ICE_SCRATCH_CTRL);
+ 	val |= EIP197_PE_ICE_SCRATCH_CTRL_CHANGE_TIMER |
+ 	       EIP197_PE_ICE_SCRATCH_CTRL_TIMER_EN |
+ 	       EIP197_PE_ICE_SCRATCH_CTRL_SCRATCH_ACCESS |
+ 	       EIP197_PE_ICE_SCRATCH_CTRL_CHANGE_ACCESS;
+-	writel(val, priv->base + EIP197_PE_ICE_SCRATCH_CTRL);
++	writel(val, EIP197_PE(priv) + EIP197_PE_ICE_SCRATCH_CTRL);
+ 
+-	memset(priv->base + EIP197_PE_ICE_SCRATCH_RAM, 0,
++	memset(EIP197_PE(priv) + EIP197_PE_ICE_SCRATCH_RAM, 0,
+ 	       EIP197_NUM_OF_SCRATCH_BLOCKS * sizeof(u32));
+ 
+ 	eip197_write_firmware(priv, fw[FW_IFPP], EIP197_PE_ICE_FPP_CTRL,
+@@ -173,7 +173,7 @@ static int safexcel_hw_setup_cdesc_rings(struct safexcel_crypto_priv *priv)
+ 	u32 hdw, cd_size_rnd, val;
+ 	int i;
+ 
+-	hdw = readl(priv->base + EIP197_HIA_OPTIONS);
++	hdw = readl(EIP197_HIA_AIC_G(priv) + EIP197_HIA_OPTIONS);
+ 	hdw &= GENMASK(27, 25);
+ 	hdw >>= 25;
+ 
+@@ -182,26 +182,25 @@ static int safexcel_hw_setup_cdesc_rings(struct safexcel_crypto_priv *priv)
+ 	for (i = 0; i < priv->config.rings; i++) {
+ 		/* ring base address */
+ 		writel(lower_32_bits(priv->ring[i].cdr.base_dma),
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_RING_BASE_ADDR_LO);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_LO);
+ 		writel(upper_32_bits(priv->ring[i].cdr.base_dma),
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_RING_BASE_ADDR_HI);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_HI);
+ 
+ 		writel(EIP197_xDR_DESC_MODE_64BIT | (priv->config.cd_offset << 16) |
+ 		       priv->config.cd_size,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_DESC_SIZE);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_DESC_SIZE);
+ 		writel(((EIP197_FETCH_COUNT * (cd_size_rnd << hdw)) << 16) |
+ 		       (EIP197_FETCH_COUNT * priv->config.cd_offset),
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_CFG);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_CFG);
+ 
+ 		/* Configure DMA tx control */
+ 		val = EIP197_HIA_xDR_CFG_WR_CACHE(WR_CACHE_3BITS);
+ 		val |= EIP197_HIA_xDR_CFG_RD_CACHE(RD_CACHE_3BITS);
+-		writel(val,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_DMA_CFG);
++		writel(val, EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_DMA_CFG);
+ 
+ 		/* clear any pending interrupt */
+ 		writel(GENMASK(5, 0),
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_STAT);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_STAT);
+ 	}
+ 
+ 	return 0;
+@@ -212,7 +211,7 @@ static int safexcel_hw_setup_rdesc_rings(struct safexcel_crypto_priv *priv)
+ 	u32 hdw, rd_size_rnd, val;
+ 	int i;
+ 
+-	hdw = readl(priv->base + EIP197_HIA_OPTIONS);
++	hdw = readl(EIP197_HIA_AIC_G(priv) + EIP197_HIA_OPTIONS);
+ 	hdw &= GENMASK(27, 25);
+ 	hdw >>= 25;
+ 
+@@ -221,33 +220,33 @@ static int safexcel_hw_setup_rdesc_rings(struct safexcel_crypto_priv *priv)
+ 	for (i = 0; i < priv->config.rings; i++) {
+ 		/* ring base address */
+ 		writel(lower_32_bits(priv->ring[i].rdr.base_dma),
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_RING_BASE_ADDR_LO);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_LO);
+ 		writel(upper_32_bits(priv->ring[i].rdr.base_dma),
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_RING_BASE_ADDR_HI);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_HI);
+ 
+ 		writel(EIP197_xDR_DESC_MODE_64BIT | (priv->config.rd_offset << 16) |
+ 		       priv->config.rd_size,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_DESC_SIZE);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_DESC_SIZE);
+ 
+ 		writel(((EIP197_FETCH_COUNT * (rd_size_rnd << hdw)) << 16) |
+ 		       (EIP197_FETCH_COUNT * priv->config.rd_offset),
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_CFG);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_CFG);
+ 
+ 		/* Configure DMA tx control */
+ 		val = EIP197_HIA_xDR_CFG_WR_CACHE(WR_CACHE_3BITS);
+ 		val |= EIP197_HIA_xDR_CFG_RD_CACHE(RD_CACHE_3BITS);
+ 		val |= EIP197_HIA_xDR_WR_RES_BUF | EIP197_HIA_xDR_WR_CTRL_BUG;
+ 		writel(val,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_DMA_CFG);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_DMA_CFG);
+ 
+ 		/* clear any pending interrupt */
+ 		writel(GENMASK(7, 0),
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_STAT);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_STAT);
+ 
+ 		/* enable ring interrupt */
+-		val = readl(priv->base + EIP197_HIA_AIC_R_ENABLE_CTRL(i));
++		val = readl(EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ENABLE_CTRL(i));
+ 		val |= EIP197_RDR_IRQ(i);
+-		writel(val, priv->base + EIP197_HIA_AIC_R_ENABLE_CTRL(i));
++		writel(val, EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ENABLE_CTRL(i));
+ 	}
+ 
+ 	return 0;
+@@ -259,39 +258,40 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	int i, ret;
+ 
+ 	/* Determine endianess and configure byte swap */
+-	version = readl(priv->base + EIP197_HIA_VERSION);
+-	val = readl(priv->base + EIP197_HIA_MST_CTRL);
++	version = readl(EIP197_HIA_AIC(priv) + EIP197_HIA_VERSION);
++	val = readl(EIP197_HIA_AIC(priv) + EIP197_HIA_MST_CTRL);
+ 
+ 	if ((version & 0xffff) == EIP197_HIA_VERSION_BE)
+ 		val |= EIP197_MST_CTRL_BYTE_SWAP;
+ 	else if (((version >> 16) & 0xffff) == EIP197_HIA_VERSION_LE)
+ 		val |= (EIP197_MST_CTRL_NO_BYTE_SWAP >> 24);
+ 
+-	writel(val, priv->base + EIP197_HIA_MST_CTRL);
+-
++	writel(val, EIP197_HIA_AIC(priv) + EIP197_HIA_MST_CTRL);
+ 
+ 	/* Configure wr/rd cache values */
+ 	writel(EIP197_MST_CTRL_RD_CACHE(RD_CACHE_4BITS) |
+ 	       EIP197_MST_CTRL_WD_CACHE(WR_CACHE_4BITS),
+-	       priv->base + EIP197_MST_CTRL);
++	       EIP197_HIA_GEN_CFG(priv) + EIP197_MST_CTRL);
+ 
+ 	/* Interrupts reset */
+ 
+ 	/* Disable all global interrupts */
+-	writel(0, priv->base + EIP197_HIA_AIC_G_ENABLE_CTRL);
++	writel(0, EIP197_HIA_AIC_G(priv) + EIP197_HIA_AIC_G_ENABLE_CTRL);
+ 
+ 	/* Clear any pending interrupt */
+-	writel(GENMASK(31, 0), priv->base + EIP197_HIA_AIC_G_ACK);
++	writel(GENMASK(31, 0), EIP197_HIA_AIC_G(priv) + EIP197_HIA_AIC_G_ACK);
+ 
+ 	/* Data Fetch Engine configuration */
+ 
+ 	/* Reset all DFE threads */
+ 	writel(EIP197_DxE_THR_CTRL_RESET_PE,
+-	       priv->base + EIP197_HIA_DFE_THR_CTRL);
++	       EIP197_HIA_DFE_THR(priv) + EIP197_HIA_DFE_THR_CTRL);
+ 
+-	/* Reset HIA input interface arbiter */
+-	writel(EIP197_HIA_RA_PE_CTRL_RESET,
+-	       priv->base + EIP197_HIA_RA_PE_CTRL);
++	if (priv->version == EIP197) {
++		/* Reset HIA input interface arbiter */
++		writel(EIP197_HIA_RA_PE_CTRL_RESET,
++		       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL);
++	}
+ 
+ 	/* DMA transfer size to use */
+ 	val = EIP197_HIA_DFE_CFG_DIS_DEBUG;
+@@ -299,29 +299,32 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	val |= EIP197_HIA_DxE_CFG_MIN_CTRL_SIZE(5) | EIP197_HIA_DxE_CFG_MAX_CTRL_SIZE(7);
+ 	val |= EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(RD_CACHE_3BITS);
+ 	val |= EIP197_HIA_DxE_CFG_CTRL_CACHE_CTRL(RD_CACHE_3BITS);
+-	writel(val, priv->base + EIP197_HIA_DFE_CFG);
++	writel(val, EIP197_HIA_DFE(priv) + EIP197_HIA_DFE_CFG);
+ 
+ 	/* Leave the DFE threads reset state */
+-	writel(0, priv->base + EIP197_HIA_DFE_THR_CTRL);
++	writel(0, EIP197_HIA_DFE_THR(priv) + EIP197_HIA_DFE_THR_CTRL);
+ 
+ 	/* Configure the procesing engine thresholds */
+ 	writel(EIP197_PE_IN_xBUF_THRES_MIN(5) | EIP197_PE_IN_xBUF_THRES_MAX(9),
+-	      priv->base + EIP197_PE_IN_DBUF_THRES);
++	       EIP197_PE(priv) + EIP197_PE_IN_DBUF_THRES);
+ 	writel(EIP197_PE_IN_xBUF_THRES_MIN(5) | EIP197_PE_IN_xBUF_THRES_MAX(7),
+-	      priv->base + EIP197_PE_IN_TBUF_THRES);
++	       EIP197_PE(priv) + EIP197_PE_IN_TBUF_THRES);
+ 
+-	/* enable HIA input interface arbiter and rings */
+-	writel(EIP197_HIA_RA_PE_CTRL_EN | GENMASK(priv->config.rings - 1, 0),
+-	       priv->base + EIP197_HIA_RA_PE_CTRL);
++	if (priv->version == EIP197) {
++		/* enable HIA input interface arbiter and rings */
++		writel(EIP197_HIA_RA_PE_CTRL_EN |
++		       GENMASK(priv->config.rings - 1, 0),
++		       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL);
++	}
+ 
+ 	/* Data Store Engine configuration */
+ 
+ 	/* Reset all DSE threads */
+ 	writel(EIP197_DxE_THR_CTRL_RESET_PE,
+-	       priv->base + EIP197_HIA_DSE_THR_CTRL);
++	       EIP197_HIA_DSE_THR(priv) + EIP197_HIA_DSE_THR_CTRL);
+ 
+ 	/* Wait for all DSE threads to complete */
+-	while ((readl(priv->base + EIP197_HIA_DSE_THR_STAT) &
++	while ((readl(EIP197_HIA_DSE_THR(priv) + EIP197_HIA_DSE_THR_STAT) &
+ 		GENMASK(15, 12)) != GENMASK(15, 12))
+ 		;
+ 
+@@ -330,15 +333,19 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	val |= EIP197_HIA_DxE_CFG_MIN_DATA_SIZE(7) | EIP197_HIA_DxE_CFG_MAX_DATA_SIZE(8);
+ 	val |= EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(WR_CACHE_3BITS);
+ 	val |= EIP197_HIA_DSE_CFG_ALLWAYS_BUFFERABLE;
+-	val |= EIP197_HIA_DSE_CFG_EN_SINGLE_WR;
+-	writel(val, priv->base + EIP197_HIA_DSE_CFG);
++	/* FIXME: instability issues can occur for EIP97 but disabling it impact
++	 * performances.
++	 */
++	if (priv->version == EIP197)
++		val |= EIP197_HIA_DSE_CFG_EN_SINGLE_WR;
++	writel(val, EIP197_HIA_DSE(priv) + EIP197_HIA_DSE_CFG);
+ 
+ 	/* Leave the DSE threads reset state */
+-	writel(0, priv->base + EIP197_HIA_DSE_THR_CTRL);
++	writel(0, EIP197_HIA_DSE_THR(priv) + EIP197_HIA_DSE_THR_CTRL);
+ 
+ 	/* Configure the procesing engine thresholds */
+ 	writel(EIP197_PE_OUT_DBUF_THRES_MIN(7) | EIP197_PE_OUT_DBUF_THRES_MAX(8),
+-	       priv->base + EIP197_PE_OUT_DBUF_THRES);
++	       EIP197_PE(priv) + EIP197_PE_OUT_DBUF_THRES);
+ 
+ 	/* Processing Engine configuration */
+ 
+@@ -348,73 +355,75 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	val |= EIP197_ALG_AES_ECB | EIP197_ALG_AES_CBC;
+ 	val |= EIP197_ALG_SHA1 | EIP197_ALG_HMAC_SHA1;
+ 	val |= EIP197_ALG_SHA2;
+-	writel(val, priv->base + EIP197_PE_EIP96_FUNCTION_EN);
++	writel(val, EIP197_PE(priv) + EIP197_PE_EIP96_FUNCTION_EN);
+ 
+ 	/* Command Descriptor Rings prepare */
+ 	for (i = 0; i < priv->config.rings; i++) {
+ 		/* Clear interrupts for this ring */
+ 		writel(GENMASK(31, 0),
+-		       priv->base + EIP197_HIA_AIC_R_ENABLE_CLR(i));
++		       EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ENABLE_CLR(i));
+ 
+ 		/* Disable external triggering */
+-		writel(0, priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_CFG);
++		writel(0, EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_CFG);
+ 
+ 		/* Clear the pending prepared counter */
+ 		writel(EIP197_xDR_PREP_CLR_COUNT,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_PREP_COUNT);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_PREP_COUNT);
+ 
+ 		/* Clear the pending processed counter */
+ 		writel(EIP197_xDR_PROC_CLR_COUNT,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_PROC_COUNT);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_PROC_COUNT);
+ 
+ 		writel(0,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_PREP_PNTR);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_PREP_PNTR);
+ 		writel(0,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_PROC_PNTR);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_PROC_PNTR);
+ 
+ 		writel((EIP197_DEFAULT_RING_SIZE * priv->config.cd_offset) << 2,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_RING_SIZE);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_RING_SIZE);
+ 	}
+ 
+ 	/* Result Descriptor Ring prepare */
+ 	for (i = 0; i < priv->config.rings; i++) {
+ 		/* Disable external triggering*/
+-		writel(0, priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_CFG);
++		writel(0, EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_CFG);
+ 
+ 		/* Clear the pending prepared counter */
+ 		writel(EIP197_xDR_PREP_CLR_COUNT,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_PREP_COUNT);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_PREP_COUNT);
+ 
+ 		/* Clear the pending processed counter */
+ 		writel(EIP197_xDR_PROC_CLR_COUNT,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_PROC_COUNT);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_PROC_COUNT);
+ 
+ 		writel(0,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_PREP_PNTR);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_PREP_PNTR);
+ 		writel(0,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_PROC_PNTR);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_PROC_PNTR);
+ 
+ 		/* Ring size */
+ 		writel((EIP197_DEFAULT_RING_SIZE * priv->config.rd_offset) << 2,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_RING_SIZE);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_RING_SIZE);
+ 	}
+ 
+ 	/* Enable command descriptor rings */
+ 	writel(EIP197_DxE_THR_CTRL_EN | GENMASK(priv->config.rings - 1, 0),
+-	       priv->base + EIP197_HIA_DFE_THR_CTRL);
++	       EIP197_HIA_DFE_THR(priv) + EIP197_HIA_DFE_THR_CTRL);
+ 
+ 	/* Enable result descriptor rings */
+ 	writel(EIP197_DxE_THR_CTRL_EN | GENMASK(priv->config.rings - 1, 0),
+-	       priv->base + EIP197_HIA_DSE_THR_CTRL);
++	       EIP197_HIA_DSE_THR(priv) + EIP197_HIA_DSE_THR_CTRL);
+ 
+ 	/* Clear any HIA interrupt */
+-	writel(GENMASK(30, 20), priv->base + EIP197_HIA_AIC_G_ACK);
++	writel(GENMASK(30, 20), EIP197_HIA_AIC_G(priv) + EIP197_HIA_AIC_G_ACK);
+ 
+-	eip197_trc_cache_init(priv);
++	if (priv->version == EIP197) {
++		eip197_trc_cache_init(priv);
+ 
+-	ret = eip197_load_firmwares(priv);
+-	if (ret)
+-		return ret;
++		ret = eip197_load_firmwares(priv);
++		if (ret)
++			return ret;
++	}
+ 
+ 	safexcel_hw_setup_cdesc_rings(priv);
+ 	safexcel_hw_setup_rdesc_rings(priv);
+@@ -434,7 +443,7 @@ int safexcel_try_push_requests(struct safexcel_crypto_priv *priv, int ring,
+ 	/* Configure when we want an interrupt */
+ 	writel(EIP197_HIA_RDR_THRESH_PKT_MODE |
+ 	       EIP197_HIA_RDR_THRESH_PROC_PKT(coal),
+-	       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_THRESH);
++	       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_THRESH);
+ 
+ 	return coal;
+ }
+@@ -524,11 +533,11 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 
+ 	/* let the RDR know we have pending descriptors */
+ 	writel((rdesc * priv->config.rd_offset) << 2,
+-	       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PREP_COUNT);
++	       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_PREP_COUNT);
+ 
+ 	/* let the CDR know we have pending descriptors */
+ 	writel((cdesc * priv->config.cd_offset) << 2,
+-	       priv->base + EIP197_HIA_CDR(ring) + EIP197_HIA_xDR_PREP_COUNT);
++	       EIP197_HIA_CDR(priv, ring) + EIP197_HIA_xDR_PREP_COUNT);
+ }
+ 
+ void safexcel_free_context(struct safexcel_crypto_priv *priv,
+@@ -629,7 +638,7 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ handle_results:
+ 	tot_descs = 0;
+ 
+-	nreq = readl(priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
++	nreq = readl(EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_PROC_COUNT);
+ 	nreq >>= EIP197_xDR_PROC_xD_PKT_OFFSET;
+ 	nreq &= EIP197_xDR_PROC_xD_PKT_MASK;
+ 	if (!nreq)
+@@ -665,7 +674,7 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 	if (i) {
+ 		writel(EIP197_xDR_PROC_xD_PKT(i) |
+ 		       EIP197_xDR_PROC_xD_COUNT(tot_descs * priv->config.rd_offset),
+-		       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
++		       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_PROC_COUNT);
+ 	}
+ 
+ 	/* If the number of requests overflowed the counter, try to proceed more
+@@ -707,13 +716,13 @@ static irqreturn_t safexcel_irq_ring(int irq, void *data)
+ 	int ring = irq_data->ring, rc = IRQ_NONE;
+ 	u32 status, stat;
+ 
+-	status = readl(priv->base + EIP197_HIA_AIC_R_ENABLED_STAT(ring));
++	status = readl(EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ENABLED_STAT(ring));
+ 	if (!status)
+ 		return rc;
+ 
+ 	/* RDR interrupts */
+ 	if (status & EIP197_RDR_IRQ(ring)) {
+-		stat = readl(priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_STAT);
++		stat = readl(EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_STAT);
+ 
+ 		if (unlikely(stat & EIP197_xDR_ERR)) {
+ 			/*
+@@ -728,11 +737,11 @@ static irqreturn_t safexcel_irq_ring(int irq, void *data)
+ 
+ 		/* ACK the interrupts */
+ 		writel(stat & 0xff,
+-		       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_STAT);
++		       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_STAT);
+ 	}
+ 
+ 	/* ACK the interrupts */
+-	writel(status, priv->base + EIP197_HIA_AIC_R_ACK(ring));
++	writel(status, EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ACK(ring));
+ 
+ 	return rc;
+ }
+@@ -828,11 +837,11 @@ static void safexcel_configure(struct safexcel_crypto_priv *priv)
+ {
+ 	u32 val, mask;
+ 
+-	val = readl(priv->base + EIP197_HIA_OPTIONS);
++	val = readl(EIP197_HIA_AIC_G(priv) + EIP197_HIA_OPTIONS);
+ 	val = (val & GENMASK(27, 25)) >> 25;
+ 	mask = BIT(val) - 1;
+ 
+-	val = readl(priv->base + EIP197_HIA_OPTIONS);
++	val = readl(EIP197_HIA_AIC_G(priv) + EIP197_HIA_OPTIONS);
+ 	priv->config.rings = min_t(u32, val & GENMASK(3, 0), max_rings);
+ 
+ 	priv->config.cd_size = (sizeof(struct safexcel_command_desc) / sizeof(u32));
+@@ -842,6 +851,35 @@ static void safexcel_configure(struct safexcel_crypto_priv *priv)
+ 	priv->config.rd_offset = (priv->config.rd_size + mask) & ~mask;
+ }
+ 
++static void safexcel_init_register_offsets(struct safexcel_crypto_priv *priv)
++{
++	struct safexcel_register_offsets *offsets = &priv->offsets;
++
++	if (priv->version == EIP197) {
++		offsets->hia_aic	= EIP197_HIA_AIC_BASE;
++		offsets->hia_aic_g	= EIP197_HIA_AIC_G_BASE;
++		offsets->hia_aic_r	= EIP197_HIA_AIC_R_BASE;
++		offsets->hia_aic_xdr	= EIP197_HIA_AIC_xDR_BASE;
++		offsets->hia_dfe	= EIP197_HIA_DFE_BASE;
++		offsets->hia_dfe_thr	= EIP197_HIA_DFE_THR_BASE;
++		offsets->hia_dse	= EIP197_HIA_DSE_BASE;
++		offsets->hia_dse_thr	= EIP197_HIA_DSE_THR_BASE;
++		offsets->hia_gen_cfg	= EIP197_HIA_GEN_CFG_BASE;
++		offsets->pe		= EIP197_PE_BASE;
++	} else {
++		offsets->hia_aic	= EIP97_HIA_AIC_BASE;
++		offsets->hia_aic_g	= EIP97_HIA_AIC_G_BASE;
++		offsets->hia_aic_r	= EIP97_HIA_AIC_R_BASE;
++		offsets->hia_aic_xdr	= EIP97_HIA_AIC_xDR_BASE;
++		offsets->hia_dfe	= EIP97_HIA_DFE_BASE;
++		offsets->hia_dfe_thr	= EIP97_HIA_DFE_THR_BASE;
++		offsets->hia_dse	= EIP97_HIA_DSE_BASE;
++		offsets->hia_dse_thr	= EIP97_HIA_DSE_THR_BASE;
++		offsets->hia_gen_cfg	= EIP97_HIA_GEN_CFG_BASE;
++		offsets->pe		= EIP97_PE_BASE;
++	}
++}
++
+ static int safexcel_probe(struct platform_device *pdev)
+ {
+ 	struct device *dev = &pdev->dev;
+@@ -854,6 +892,9 @@ static int safexcel_probe(struct platform_device *pdev)
+ 		return -ENOMEM;
+ 
+ 	priv->dev = dev;
++	priv->version = (enum safexcel_eip_version)of_device_get_match_data(dev);
++
++	safexcel_init_register_offsets(priv);
+ 
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	priv->base = devm_ioremap_resource(dev, res);
+@@ -980,7 +1021,14 @@ static int safexcel_remove(struct platform_device *pdev)
+ }
+ 
+ static const struct of_device_id safexcel_of_match_table[] = {
+-	{ .compatible = "inside-secure,safexcel-eip197" },
++	{
++		.compatible = "inside-secure,safexcel-eip97",
++		.data = (void *)EIP97,
++	},
++	{
++		.compatible = "inside-secure,safexcel-eip197",
++		.data = (void *)EIP197,
++	},
+ 	{},
+ };
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index d4955abf873b..4e219c21608b 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -28,55 +28,94 @@
+ #define EIP197_GFP_FLAGS(base)	((base).flags & CRYPTO_TFM_REQ_MAY_SLEEP ? \
+ 				 GFP_KERNEL : GFP_ATOMIC)
+ 
++/* Register base offsets */
++#define EIP197_HIA_AIC(priv)		((priv)->base + (priv)->offsets.hia_aic)
++#define EIP197_HIA_AIC_G(priv)		((priv)->base + (priv)->offsets.hia_aic_g)
++#define EIP197_HIA_AIC_R(priv)		((priv)->base + (priv)->offsets.hia_aic_r)
++#define EIP197_HIA_AIC_xDR(priv)	((priv)->base + (priv)->offsets.hia_aic_xdr)
++#define EIP197_HIA_DFE(priv)		((priv)->base + (priv)->offsets.hia_dfe)
++#define EIP197_HIA_DFE_THR(priv)	((priv)->base + (priv)->offsets.hia_dfe_thr)
++#define EIP197_HIA_DSE(priv)		((priv)->base + (priv)->offsets.hia_dse)
++#define EIP197_HIA_DSE_THR(priv)	((priv)->base + (priv)->offsets.hia_dse_thr)
++#define EIP197_HIA_GEN_CFG(priv)	((priv)->base + (priv)->offsets.hia_gen_cfg)
++#define EIP197_PE(priv)			((priv)->base + (priv)->offsets.pe)
++
++/* EIP197 base offsets */
++#define EIP197_HIA_AIC_BASE		0x90000
++#define EIP197_HIA_AIC_G_BASE		0x90000
++#define EIP197_HIA_AIC_R_BASE		0x90800
++#define EIP197_HIA_AIC_xDR_BASE		0x80000
++#define EIP197_HIA_DFE_BASE		0x8c000
++#define EIP197_HIA_DFE_THR_BASE		0x8c040
++#define EIP197_HIA_DSE_BASE		0x8d000
++#define EIP197_HIA_DSE_THR_BASE		0x8d040
++#define EIP197_HIA_GEN_CFG_BASE		0xf0000
++#define EIP197_PE_BASE			0xa0000
++
++/* EIP97 base offsets */
++#define EIP97_HIA_AIC_BASE		0x0
++#define EIP97_HIA_AIC_G_BASE		0x0
++#define EIP97_HIA_AIC_R_BASE		0x0
++#define EIP97_HIA_AIC_xDR_BASE		0x0
++#define EIP97_HIA_DFE_BASE		0xf000
++#define EIP97_HIA_DFE_THR_BASE		0xf200
++#define EIP97_HIA_DSE_BASE		0xf400
++#define EIP97_HIA_DSE_THR_BASE		0xf600
++#define EIP97_HIA_GEN_CFG_BASE		0x10000
++#define EIP97_PE_BASE			0x10000
++
+ /* CDR/RDR register offsets */
+-#define EIP197_HIA_xDR_OFF(r)			(0x80000 + (r) * 0x1000)
+-#define EIP197_HIA_CDR(r)			(EIP197_HIA_xDR_OFF(r))
+-#define EIP197_HIA_RDR(r)			(EIP197_HIA_xDR_OFF(r) + 0x800)
+-#define EIP197_HIA_xDR_RING_BASE_ADDR_LO	0x0
+-#define EIP197_HIA_xDR_RING_BASE_ADDR_HI	0x4
+-#define EIP197_HIA_xDR_RING_SIZE		0x18
+-#define EIP197_HIA_xDR_DESC_SIZE		0x1c
+-#define EIP197_HIA_xDR_CFG			0x20
+-#define EIP197_HIA_xDR_DMA_CFG			0x24
+-#define EIP197_HIA_xDR_THRESH			0x28
+-#define EIP197_HIA_xDR_PREP_COUNT		0x2c
+-#define EIP197_HIA_xDR_PROC_COUNT		0x30
+-#define EIP197_HIA_xDR_PREP_PNTR		0x34
+-#define EIP197_HIA_xDR_PROC_PNTR		0x38
+-#define EIP197_HIA_xDR_STAT			0x3c
++#define EIP197_HIA_xDR_OFF(priv, r)		(EIP197_HIA_AIC_xDR(priv) + (r) * 0x1000)
++#define EIP197_HIA_CDR(priv, r)			(EIP197_HIA_xDR_OFF(priv, r))
++#define EIP197_HIA_RDR(priv, r)			(EIP197_HIA_xDR_OFF(priv, r) + 0x800)
++#define EIP197_HIA_xDR_RING_BASE_ADDR_LO	0x0000
++#define EIP197_HIA_xDR_RING_BASE_ADDR_HI	0x0004
++#define EIP197_HIA_xDR_RING_SIZE		0x0018
++#define EIP197_HIA_xDR_DESC_SIZE		0x001c
++#define EIP197_HIA_xDR_CFG			0x0020
++#define EIP197_HIA_xDR_DMA_CFG			0x0024
++#define EIP197_HIA_xDR_THRESH			0x0028
++#define EIP197_HIA_xDR_PREP_COUNT		0x002c
++#define EIP197_HIA_xDR_PROC_COUNT		0x0030
++#define EIP197_HIA_xDR_PREP_PNTR		0x0034
++#define EIP197_HIA_xDR_PROC_PNTR		0x0038
++#define EIP197_HIA_xDR_STAT			0x003c
+ 
+ /* register offsets */
+-#define EIP197_HIA_DFE_CFG			0x8c000
+-#define EIP197_HIA_DFE_THR_CTRL			0x8c040
+-#define EIP197_HIA_DFE_THR_STAT			0x8c044
+-#define EIP197_HIA_DSE_CFG			0x8d000
+-#define EIP197_HIA_DSE_THR_CTRL			0x8d040
+-#define EIP197_HIA_DSE_THR_STAT			0x8d044
+-#define EIP197_HIA_RA_PE_CTRL			0x90010
+-#define EIP197_HIA_RA_PE_STAT			0x90014
++#define EIP197_HIA_DFE_CFG			0x0000
++#define EIP197_HIA_DFE_THR_CTRL			0x0000
++#define EIP197_HIA_DFE_THR_STAT			0x0004
++#define EIP197_HIA_DSE_CFG			0x0000
++#define EIP197_HIA_DSE_THR_CTRL			0x0000
++#define EIP197_HIA_DSE_THR_STAT			0x0004
++#define EIP197_HIA_RA_PE_CTRL			0x0010
++#define EIP197_HIA_RA_PE_STAT			0x0014
+ #define EIP197_HIA_AIC_R_OFF(r)			((r) * 0x1000)
+-#define EIP197_HIA_AIC_R_ENABLE_CTRL(r)		(0x9e808 - EIP197_HIA_AIC_R_OFF(r))
+-#define EIP197_HIA_AIC_R_ENABLED_STAT(r)	(0x9e810 - EIP197_HIA_AIC_R_OFF(r))
+-#define EIP197_HIA_AIC_R_ACK(r)			(0x9e810 - EIP197_HIA_AIC_R_OFF(r))
+-#define EIP197_HIA_AIC_R_ENABLE_CLR(r)		(0x9e814 - EIP197_HIA_AIC_R_OFF(r))
+-#define EIP197_HIA_AIC_G_ENABLE_CTRL		0x9f808
+-#define EIP197_HIA_AIC_G_ENABLED_STAT		0x9f810
+-#define EIP197_HIA_AIC_G_ACK			0x9f810
+-#define EIP197_HIA_MST_CTRL			0x9fff4
+-#define EIP197_HIA_OPTIONS			0x9fff8
+-#define EIP197_HIA_VERSION			0x9fffc
+-#define EIP197_PE_IN_DBUF_THRES			0xa0000
+-#define EIP197_PE_IN_TBUF_THRES			0xa0100
+-#define EIP197_PE_ICE_SCRATCH_RAM		0xa0800
+-#define EIP197_PE_ICE_PUE_CTRL			0xa0c80
+-#define EIP197_PE_ICE_SCRATCH_CTRL		0xa0d04
+-#define EIP197_PE_ICE_FPP_CTRL			0xa0d80
+-#define EIP197_PE_ICE_RAM_CTRL			0xa0ff0
+-#define EIP197_PE_EIP96_FUNCTION_EN		0xa1004
+-#define EIP197_PE_EIP96_CONTEXT_CTRL		0xa1008
+-#define EIP197_PE_EIP96_CONTEXT_STAT		0xa100c
+-#define EIP197_PE_OUT_DBUF_THRES		0xa1c00
+-#define EIP197_PE_OUT_TBUF_THRES		0xa1d00
++#define EIP197_HIA_AIC_R_ENABLE_CTRL(r)		(0xe008 - EIP197_HIA_AIC_R_OFF(r))
++#define EIP197_HIA_AIC_R_ENABLED_STAT(r)	(0xe010 - EIP197_HIA_AIC_R_OFF(r))
++#define EIP197_HIA_AIC_R_ACK(r)			(0xe010 - EIP197_HIA_AIC_R_OFF(r))
++#define EIP197_HIA_AIC_R_ENABLE_CLR(r)		(0xe014 - EIP197_HIA_AIC_R_OFF(r))
++#define EIP197_HIA_AIC_G_ENABLE_CTRL		0xf808
++#define EIP197_HIA_AIC_G_ENABLED_STAT		0xf810
++#define EIP197_HIA_AIC_G_ACK			0xf810
++#define EIP197_HIA_MST_CTRL			0xfff4
++#define EIP197_HIA_OPTIONS			0xfff8
++#define EIP197_HIA_VERSION			0xfffc
++#define EIP197_PE_IN_DBUF_THRES			0x0000
++#define EIP197_PE_IN_TBUF_THRES			0x0100
++#define EIP197_PE_ICE_SCRATCH_RAM		0x0800
++#define EIP197_PE_ICE_PUE_CTRL			0x0c80
++#define EIP197_PE_ICE_SCRATCH_CTRL		0x0d04
++#define EIP197_PE_ICE_FPP_CTRL			0x0d80
++#define EIP197_PE_ICE_RAM_CTRL			0x0ff0
++#define EIP197_PE_EIP96_FUNCTION_EN		0x1004
++#define EIP197_PE_EIP96_CONTEXT_CTRL		0x1008
++#define EIP197_PE_EIP96_CONTEXT_STAT		0x100c
++#define EIP197_PE_OUT_DBUF_THRES		0x1c00
++#define EIP197_PE_OUT_TBUF_THRES		0x1d00
++#define EIP197_MST_CTRL				0xfff4
++
++/* EIP197-specific registers, no indirection */
+ #define EIP197_CLASSIFICATION_RAMS		0xe0000
+ #define EIP197_TRC_CTRL				0xf0800
+ #define EIP197_TRC_LASTRES			0xf0804
+@@ -90,7 +129,6 @@
+ #define EIP197_TRC_ECCDATASTAT			0xf083c
+ #define EIP197_TRC_ECCDATA			0xf0840
+ #define EIP197_CS_RAM_CTRL			0xf7ff0
+-#define EIP197_MST_CTRL				0xffff4
+ 
+ /* EIP197_HIA_xDR_DESC_SIZE */
+ #define EIP197_xDR_DESC_MODE_64BIT		BIT(31)
+@@ -465,12 +503,33 @@ struct safexcel_work_data {
+ 	int ring;
+ };
+ 
++enum safexcel_eip_version {
++	EIP97,
++	EIP197,
++};
++
++struct safexcel_register_offsets {
++	u32 hia_aic;
++	u32 hia_aic_g;
++	u32 hia_aic_r;
++	u32 hia_aic_xdr;
++	u32 hia_dfe;
++	u32 hia_dfe_thr;
++	u32 hia_dse;
++	u32 hia_dse_thr;
++	u32 hia_gen_cfg;
++	u32 pe;
++};
++
+ struct safexcel_crypto_priv {
+ 	void __iomem *base;
+ 	struct device *dev;
+ 	struct clk *clk;
+ 	struct safexcel_config config;
+ 
++	enum safexcel_eip_version version;
++	struct safexcel_register_offsets offsets;
++
+ 	/* context DMA pool */
+ 	struct dma_pool *context_pool;
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel_cipher.c b/drivers/crypto/inside-secure/safexcel_cipher.c
+index 7c9a2d87135b..17a7725a6f6d 100644
+--- a/drivers/crypto/inside-secure/safexcel_cipher.c
++++ b/drivers/crypto/inside-secure/safexcel_cipher.c
+@@ -69,6 +69,7 @@ static int safexcel_aes_setkey(struct crypto_skcipher *ctfm, const u8 *key,
+ {
+ 	struct crypto_tfm *tfm = crypto_skcipher_tfm(ctfm);
+ 	struct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);
++	struct safexcel_crypto_priv *priv = ctx->priv;
+ 	struct crypto_aes_ctx aes;
+ 	int ret, i;
+ 
+@@ -78,7 +79,7 @@ static int safexcel_aes_setkey(struct crypto_skcipher *ctfm, const u8 *key,
+ 		return ret;
+ 	}
+ 
+-	if (ctx->base.ctxr_dma) {
++	if (priv->version == EIP197 && ctx->base.ctxr_dma) {
+ 		for (i = 0; i < len / sizeof(u32); i++) {
+ 			if (ctx->key[i] != cpu_to_le32(aes.key_enc[i])) {
+ 				ctx->base.needs_inv = true;
+@@ -411,9 +412,13 @@ static int safexcel_send(struct crypto_async_request *async,
+ 			 int *commands, int *results)
+ {
+ 	struct skcipher_request *req = skcipher_request_cast(async);
++	struct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+ 	struct safexcel_cipher_req *sreq = skcipher_request_ctx(req);
++	struct safexcel_crypto_priv *priv = ctx->priv;
+ 	int ret;
+ 
++	BUG_ON(priv->version == EIP97 && sreq->needs_inv);
++
+ 	if (sreq->needs_inv)
+ 		ret = safexcel_cipher_send_inv(async, ring, request,
+ 					       commands, results);
+@@ -476,7 +481,7 @@ static int safexcel_aes(struct skcipher_request *req,
+ 	ctx->mode = mode;
+ 
+ 	if (ctx->base.ctxr) {
+-		if (ctx->base.needs_inv) {
++		if (priv->version == EIP197 && ctx->base.needs_inv) {
+ 			sreq->needs_inv = true;
+ 			ctx->base.needs_inv = false;
+ 		}
+@@ -544,9 +549,14 @@ static void safexcel_skcipher_cra_exit(struct crypto_tfm *tfm)
+ 
+ 	memzero_explicit(ctx->base.ctxr->data, 8 * sizeof(u32));
+ 
+-	ret = safexcel_cipher_exit_inv(tfm);
+-	if (ret)
+-		dev_warn(priv->dev, "cipher: invalidation error %d\n", ret);
++	if (priv->version == EIP197) {
++		ret = safexcel_cipher_exit_inv(tfm);
++		if (ret)
++			dev_warn(priv->dev, "cipher: invalidation error %d\n", ret);
++	} else {
++		dma_pool_free(priv->context_pool, ctx->base.ctxr,
++			      ctx->base.ctxr_dma);
++	}
+ }
+ 
+ struct safexcel_alg_template safexcel_alg_ecb_aes = {
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 6912c032200b..b9a2bfd91c20 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -415,6 +415,8 @@ static int safexcel_handle_result(struct safexcel_crypto_priv *priv, int ring,
+ 	struct safexcel_ahash_req *req = ahash_request_ctx(areq);
+ 	int err;
+ 
++	BUG_ON(priv->version == EIP97 && req->needs_inv);
++
+ 	if (req->needs_inv) {
+ 		req->needs_inv = false;
+ 		err = safexcel_handle_inv_result(priv, ring, async,
+@@ -536,7 +538,8 @@ static int safexcel_ahash_enqueue(struct ahash_request *areq)
+ 	req->needs_inv = false;
+ 
+ 	if (ctx->base.ctxr) {
+-		if (!ctx->base.needs_inv && req->processed &&
++		if (priv->version == EIP197 &&
++		    !ctx->base.needs_inv && req->processed &&
+ 		    ctx->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED)
+ 			/* We're still setting needs_inv here, even though it is
+ 			 * cleared right away, because the needs_inv flag can be
+@@ -729,9 +732,14 @@ static void safexcel_ahash_cra_exit(struct crypto_tfm *tfm)
+ 	if (!ctx->base.ctxr)
+ 		return;
+ 
+-	ret = safexcel_ahash_exit_inv(tfm);
+-	if (ret)
+-		dev_warn(priv->dev, "hash: invalidation error %d\n", ret);
++	if (priv->version == EIP197) {
++		ret = safexcel_ahash_exit_inv(tfm);
++		if (ret)
++			dev_warn(priv->dev, "hash: invalidation error %d\n", ret);
++	} else {
++		dma_pool_free(priv->context_pool, ctx->base.ctxr,
++			      ctx->base.ctxr_dma);
++	}
+ }
+ 
+ struct safexcel_alg_template safexcel_alg_sha1 = {
+@@ -935,6 +943,7 @@ static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
+ 				     unsigned int keylen)
+ {
+ 	struct safexcel_ahash_ctx *ctx = crypto_tfm_ctx(crypto_ahash_tfm(tfm));
++	struct safexcel_crypto_priv *priv = ctx->priv;
+ 	struct safexcel_ahash_export_state istate, ostate;
+ 	int ret, i;
+ 
+@@ -942,7 +951,7 @@ static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
+ 	if (ret)
+ 		return ret;
+ 
+-	if (ctx->base.ctxr) {
++	if (priv->version == EIP197 && ctx->base.ctxr) {
+ 		for (i = 0; i < SHA1_DIGEST_SIZE / sizeof(u32); i++) {
+ 			if (ctx->ipad[i] != le32_to_cpu(istate.state[i]) ||
+ 			    ctx->opad[i] != le32_to_cpu(ostate.state[i])) {
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90053-crypto-inside-secure-make-function-safexcel_try_push.patch b/target/linux/mvebu/patches-4.14/90053-crypto-inside-secure-make-function-safexcel_try_push.patch
new file mode 100644
index 0000000..a96dfd4
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90053-crypto-inside-secure-make-function-safexcel_try_push.patch
@@ -0,0 +1,38 @@
+From a7586ad9713b6eafecb6e6724c75a4c4071c9a23 Mon Sep 17 00:00:00 2001
+From: Colin Ian King <colin.king@canonical.com>
+Date: Tue, 16 Jan 2018 08:41:58 +0100
+Subject: [PATCH 53/82] crypto: inside-secure - make function
+ safexcel_try_push_requests static
+
+The function safexcel_try_push_requests  is local to the source and does
+not need to be in global scope, so make it static.
+
+Cleans up sparse warning:
+symbol 'safexcel_try_push_requests' was not declared. Should it be static?
+
+Signed-off-by: Colin Ian King <colin.king@canonical.com>
+[Antoine: fixed alignment]
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index b0787f5f62ad..46b691aae475 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -432,8 +432,8 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ }
+ 
+ /* Called with ring's lock taken */
+-int safexcel_try_push_requests(struct safexcel_crypto_priv *priv, int ring,
+-			       int reqs)
++static int safexcel_try_push_requests(struct safexcel_crypto_priv *priv,
++				      int ring, int reqs)
+ {
+ 	int coal = min_t(int, reqs, EIP197_MAX_BATCH_SZ);
+ 
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90054-crypto-inside-secure-do-not-overwrite-the-threshold-.patch b/target/linux/mvebu/patches-4.14/90054-crypto-inside-secure-do-not-overwrite-the-threshold-.patch
new file mode 100644
index 0000000..ac393b5
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90054-crypto-inside-secure-do-not-overwrite-the-threshold-.patch
@@ -0,0 +1,40 @@
+From e0080b4984f85b8cb0b824528b562d3b126e7607 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Tue, 13 Feb 2018 09:26:51 +0100
+Subject: [PATCH 54/82] crypto: inside-secure - do not overwrite the threshold
+ value
+
+This patch fixes the Inside Secure SafeXcel driver not to overwrite the
+interrupt threshold value. In certain cases the value of this register,
+which controls when to fire an interrupt, was overwritten. This lead to
+packet not being processed or acked as the driver never was aware of
+their completion.
+
+This patch fixes this behaviour by not setting the threshold when
+requests are being processed by the engine.
+
+Fixes: dc7e28a3286e ("crypto: inside-secure - dequeue all requests at once")
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 46b691aae475..f4a76971b4ac 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -523,8 +523,7 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 
+ 	if (!priv->ring[ring].busy) {
+ 		nreq -= safexcel_try_push_requests(priv, ring, nreq);
+-		if (nreq)
+-			priv->ring[ring].busy = true;
++		priv->ring[ring].busy = true;
+ 	}
+ 
+ 	priv->ring[ring].requests_left += nreq;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90055-crypto-inside-secure-keep-the-requests-push-pop-sync.patch b/target/linux/mvebu/patches-4.14/90055-crypto-inside-secure-keep-the-requests-push-pop-sync.patch
new file mode 100644
index 0000000..686a598
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90055-crypto-inside-secure-keep-the-requests-push-pop-sync.patch
@@ -0,0 +1,136 @@
+From c5caee0a5c026f0c3a9605a113e16cd691d3428f Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Tue, 13 Feb 2018 09:26:56 +0100
+Subject: [PATCH 55/82] crypto: inside-secure - keep the requests push/pop
+ synced
+
+This patch updates the Inside Secure SafeXcel driver to avoid being
+out-of-sync between the number of requests sent and the one being
+completed.
+
+The number of requests acknowledged by the driver can be different than
+the threshold that was configured if new requests were being pushed to
+the h/w in the meantime. The driver wasn't taking those into account,
+and the number of remaining requests to handled (to reconfigure the
+interrupt threshold) could be out-of sync.
+
+This patch fixes it by not taking in account the number of requests
+left, but by taking in account the total number of requests being sent
+to the hardware, so that new requests are being taken into account.
+
+Fixes: dc7e28a3286e ("crypto: inside-secure - dequeue all requests at once")
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 28 ++++++++++++-------------
+ drivers/crypto/inside-secure/safexcel.h |  6 ++----
+ 2 files changed, 15 insertions(+), 19 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index f4a76971b4ac..fe1f55c3e501 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -432,20 +432,18 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ }
+ 
+ /* Called with ring's lock taken */
+-static int safexcel_try_push_requests(struct safexcel_crypto_priv *priv,
+-				      int ring, int reqs)
++static void safexcel_try_push_requests(struct safexcel_crypto_priv *priv,
++				       int ring)
+ {
+-	int coal = min_t(int, reqs, EIP197_MAX_BATCH_SZ);
++	int coal = min_t(int, priv->ring[ring].requests, EIP197_MAX_BATCH_SZ);
+ 
+ 	if (!coal)
+-		return 0;
++		return;
+ 
+ 	/* Configure when we want an interrupt */
+ 	writel(EIP197_HIA_RDR_THRESH_PKT_MODE |
+ 	       EIP197_HIA_RDR_THRESH_PROC_PKT(coal),
+ 	       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_THRESH);
+-
+-	return coal;
+ }
+ 
+ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+@@ -521,13 +519,13 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 
+ 	spin_lock_bh(&priv->ring[ring].egress_lock);
+ 
++	priv->ring[ring].requests += nreq;
++
+ 	if (!priv->ring[ring].busy) {
+-		nreq -= safexcel_try_push_requests(priv, ring, nreq);
++		safexcel_try_push_requests(priv, ring);
+ 		priv->ring[ring].busy = true;
+ 	}
+ 
+-	priv->ring[ring].requests_left += nreq;
+-
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+ 
+ 	/* let the RDR know we have pending descriptors */
+@@ -631,7 +629,7 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ {
+ 	struct safexcel_request *sreq;
+ 	struct safexcel_context *ctx;
+-	int ret, i, nreq, ndesc, tot_descs, done;
++	int ret, i, nreq, ndesc, tot_descs, handled = 0;
+ 	bool should_complete;
+ 
+ handle_results:
+@@ -667,6 +665,7 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 
+ 		kfree(sreq);
+ 		tot_descs += ndesc;
++		handled++;
+ 	}
+ 
+ acknowledge:
+@@ -685,11 +684,10 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ requests_left:
+ 	spin_lock_bh(&priv->ring[ring].egress_lock);
+ 
+-	done = safexcel_try_push_requests(priv, ring,
+-					  priv->ring[ring].requests_left);
++	priv->ring[ring].requests -= handled;
++	safexcel_try_push_requests(priv, ring);
+ 
+-	priv->ring[ring].requests_left -= done;
+-	if (!done && !priv->ring[ring].requests_left)
++	if (!priv->ring[ring].requests)
+ 		priv->ring[ring].busy = false;
+ 
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+@@ -970,7 +968,7 @@ static int safexcel_probe(struct platform_device *pdev)
+ 			goto err_clk;
+ 		}
+ 
+-		priv->ring[i].requests_left = 0;
++		priv->ring[i].requests = 0;
+ 		priv->ring[i].busy = false;
+ 
+ 		crypto_init_queue(&priv->ring[i].queue,
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 4e219c21608b..caaf6a81b162 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -551,10 +551,8 @@ struct safexcel_crypto_priv {
+ 		struct crypto_queue queue;
+ 		spinlock_t queue_lock;
+ 
+-		/* Number of requests in the engine that needs the threshold
+-		 * interrupt to be set up.
+-		 */
+-		int requests_left;
++		/* Number of requests in the engine. */
++		int requests;
+ 
+ 		/* The ring is currently handling at least one request */
+ 		bool busy;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90056-crypto-inside-secure-unmap-the-result-in-the-hash-se.patch b/target/linux/mvebu/patches-4.14/90056-crypto-inside-secure-unmap-the-result-in-the-hash-se.patch
new file mode 100644
index 0000000..407b8a7
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90056-crypto-inside-secure-unmap-the-result-in-the-hash-se.patch
@@ -0,0 +1,42 @@
+From 832e97cc80a5bf9992edbc6178de62d63ef9ad77 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Tue, 13 Feb 2018 09:26:57 +0100
+Subject: [PATCH 56/82] crypto: inside-secure - unmap the result in the hash
+ send error path
+
+This patch adds a label to unmap the result buffer in the hash send
+function error path.
+
+Fixes: 1b44c5a60c13 ("crypto: inside-secure - add SafeXcel EIP197 crypto engine driver")
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index b9a2bfd91c20..7b181bd6959f 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -303,7 +303,7 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 				   req->state_sz);
+ 	if (IS_ERR(rdesc)) {
+ 		ret = PTR_ERR(rdesc);
+-		goto cdesc_rollback;
++		goto unmap_result;
+ 	}
+ 
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+@@ -315,6 +315,8 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 	*results = 1;
+ 	return 0;
+ 
++unmap_result:
++	dma_unmap_sg(priv->dev, areq->src, req->nents, DMA_TO_DEVICE);
+ cdesc_rollback:
+ 	for (i = 0; i < n_cdesc; i++)
+ 		safexcel_ring_rollback_wptr(priv, &priv->ring[ring].cdr);
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90057-crypto-inside-secure-move-hash-result-dma-mapping-to.patch b/target/linux/mvebu/patches-4.14/90057-crypto-inside-secure-move-hash-result-dma-mapping-to.patch
new file mode 100644
index 0000000..505aef4
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90057-crypto-inside-secure-move-hash-result-dma-mapping-to.patch
@@ -0,0 +1,115 @@
+From a7476abde5ff9f8b7c6eaa2df0e2b8aadba4a705 Mon Sep 17 00:00:00 2001
+From: Ofer Heifetz <oferh@marvell.com>
+Date: Mon, 26 Feb 2018 14:45:10 +0100
+Subject: [PATCH 57/82] crypto: inside-secure - move hash result dma mapping to
+ request
+
+In heavy traffic the DMA mapping is overwritten by multiple requests as
+the DMA address is stored in a global context. This patch moves this
+information to the per-hash request context so that it can't be
+overwritten.
+
+Fixes: 1b44c5a60c13 ("crypto: inside-secure - add SafeXcel EIP197 crypto engine driver")
+Signed-off-by: Ofer Heifetz <oferh@marvell.com>
+[Antoine: rebased the patch, small fixes, commit message.]
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c      |  7 +------
+ drivers/crypto/inside-secure/safexcel.h      |  4 +---
+ drivers/crypto/inside-secure/safexcel_hash.c | 17 ++++++++++++-----
+ 3 files changed, 14 insertions(+), 14 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index fe1f55c3e501..97cd64041189 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -538,15 +538,10 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ }
+ 
+ void safexcel_free_context(struct safexcel_crypto_priv *priv,
+-			   struct crypto_async_request *req,
+-			   int result_sz)
++			   struct crypto_async_request *req)
+ {
+ 	struct safexcel_context *ctx = crypto_tfm_ctx(req->tfm);
+ 
+-	if (ctx->result_dma)
+-		dma_unmap_single(priv->dev, ctx->result_dma, result_sz,
+-				 DMA_FROM_DEVICE);
+-
+ 	if (ctx->cache) {
+ 		dma_unmap_single(priv->dev, ctx->cache_dma, ctx->cache_sz,
+ 				 DMA_TO_DEVICE);
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index caaf6a81b162..4e14c7e730c4 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -580,7 +580,6 @@ struct safexcel_context {
+ 	bool exit_inv;
+ 
+ 	/* Used for ahash requests */
+-	dma_addr_t result_dma;
+ 	void *cache;
+ 	dma_addr_t cache_dma;
+ 	unsigned int cache_sz;
+@@ -608,8 +607,7 @@ struct safexcel_inv_result {
+ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring);
+ void safexcel_complete(struct safexcel_crypto_priv *priv, int ring);
+ void safexcel_free_context(struct safexcel_crypto_priv *priv,
+-				  struct crypto_async_request *req,
+-				  int result_sz);
++				  struct crypto_async_request *req);
+ int safexcel_invalidate_cache(struct crypto_async_request *async,
+ 			      struct safexcel_crypto_priv *priv,
+ 			      dma_addr_t ctxr_dma, int ring,
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 7b181bd6959f..a31837f3b506 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -34,6 +34,7 @@ struct safexcel_ahash_req {
+ 	bool needs_inv;
+ 
+ 	int nents;
++	dma_addr_t result_dma;
+ 
+ 	u8 state_sz;    /* expected sate size, only set once */
+ 	u32 state[SHA256_DIGEST_SIZE / sizeof(u32)] __aligned(sizeof(u32));
+@@ -158,7 +159,13 @@ static int safexcel_handle_req_result(struct safexcel_crypto_priv *priv, int rin
+ 		sreq->nents = 0;
+ 	}
+ 
+-	safexcel_free_context(priv, async, sreq->state_sz);
++	if (sreq->result_dma) {
++		dma_unmap_single(priv->dev, sreq->result_dma, sreq->state_sz,
++				 DMA_FROM_DEVICE);
++		sreq->result_dma = 0;
++	}
++
++	safexcel_free_context(priv, async);
+ 
+ 	cache_len = sreq->len - sreq->processed;
+ 	if (cache_len)
+@@ -291,15 +298,15 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 	/* Add the token */
+ 	safexcel_hash_token(first_cdesc, len, req->state_sz);
+ 
+-	ctx->base.result_dma = dma_map_single(priv->dev, req->state,
+-					      req->state_sz, DMA_FROM_DEVICE);
+-	if (dma_mapping_error(priv->dev, ctx->base.result_dma)) {
++	req->result_dma = dma_map_single(priv->dev, req->state, req->state_sz,
++					 DMA_FROM_DEVICE);
++	if (dma_mapping_error(priv->dev, req->result_dma)) {
+ 		ret = -EINVAL;
+ 		goto cdesc_rollback;
+ 	}
+ 
+ 	/* Add a result descriptor */
+-	rdesc = safexcel_add_rdesc(priv, ring, 1, 1, ctx->base.result_dma,
++	rdesc = safexcel_add_rdesc(priv, ring, 1, 1, req->result_dma,
+ 				   req->state_sz);
+ 	if (IS_ERR(rdesc)) {
+ 		ret = PTR_ERR(rdesc);
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90058-crypto-inside-secure-move-cache-result-dma-mapping-t.patch b/target/linux/mvebu/patches-4.14/90058-crypto-inside-secure-move-cache-result-dma-mapping-t.patch
new file mode 100644
index 0000000..d5df622
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90058-crypto-inside-secure-move-cache-result-dma-mapping-t.patch
@@ -0,0 +1,152 @@
+From 4ec1e0702a31576a91eb6cd9ace703ae7acd99c1 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 26 Feb 2018 14:45:11 +0100
+Subject: [PATCH 58/82] crypto: inside-secure - move cache result dma mapping
+ to request
+
+In heavy traffic the DMA mapping is overwritten by multiple requests as
+the DMA address is stored in a global context. This patch moves this
+information to the per-hash request context so that it can't be
+overwritten.
+
+Fixes: 1b44c5a60c13 ("crypto: inside-secure - add SafeXcel EIP197 crypto engine driver")
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c      | 14 -------
+ drivers/crypto/inside-secure/safexcel.h      |  7 ----
+ drivers/crypto/inside-secure/safexcel_hash.c | 42 +++++++++-----------
+ 3 files changed, 18 insertions(+), 45 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 97cd64041189..09adeaa0da6b 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -537,20 +537,6 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 	       EIP197_HIA_CDR(priv, ring) + EIP197_HIA_xDR_PREP_COUNT);
+ }
+ 
+-void safexcel_free_context(struct safexcel_crypto_priv *priv,
+-			   struct crypto_async_request *req)
+-{
+-	struct safexcel_context *ctx = crypto_tfm_ctx(req->tfm);
+-
+-	if (ctx->cache) {
+-		dma_unmap_single(priv->dev, ctx->cache_dma, ctx->cache_sz,
+-				 DMA_TO_DEVICE);
+-		kfree(ctx->cache);
+-		ctx->cache = NULL;
+-		ctx->cache_sz = 0;
+-	}
+-}
+-
+ void safexcel_complete(struct safexcel_crypto_priv *priv, int ring)
+ {
+ 	struct safexcel_command_desc *cdesc;
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 4e14c7e730c4..d8dff65fc311 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -578,11 +578,6 @@ struct safexcel_context {
+ 	int ring;
+ 	bool needs_inv;
+ 	bool exit_inv;
+-
+-	/* Used for ahash requests */
+-	void *cache;
+-	dma_addr_t cache_dma;
+-	unsigned int cache_sz;
+ };
+ 
+ /*
+@@ -606,8 +601,6 @@ struct safexcel_inv_result {
+ 
+ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring);
+ void safexcel_complete(struct safexcel_crypto_priv *priv, int ring);
+-void safexcel_free_context(struct safexcel_crypto_priv *priv,
+-				  struct crypto_async_request *req);
+ int safexcel_invalidate_cache(struct crypto_async_request *async,
+ 			      struct safexcel_crypto_priv *priv,
+ 			      dma_addr_t ctxr_dma, int ring,
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index a31837f3b506..9703a4063cfc 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -43,6 +43,9 @@ struct safexcel_ahash_req {
+ 	u64 processed;
+ 
+ 	u8 cache[SHA256_BLOCK_SIZE] __aligned(sizeof(u32));
++	dma_addr_t cache_dma;
++	unsigned int cache_sz;
++
+ 	u8 cache_next[SHA256_BLOCK_SIZE] __aligned(sizeof(u32));
+ };
+ 
+@@ -165,7 +168,11 @@ static int safexcel_handle_req_result(struct safexcel_crypto_priv *priv, int rin
+ 		sreq->result_dma = 0;
+ 	}
+ 
+-	safexcel_free_context(priv, async);
++	if (sreq->cache_dma) {
++		dma_unmap_single(priv->dev, sreq->cache_dma, sreq->cache_sz,
++				 DMA_TO_DEVICE);
++		sreq->cache_dma = 0;
++	}
+ 
+ 	cache_len = sreq->len - sreq->processed;
+ 	if (cache_len)
+@@ -227,24 +234,15 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 
+ 	/* Add a command descriptor for the cached data, if any */
+ 	if (cache_len) {
+-		ctx->base.cache = kzalloc(cache_len, EIP197_GFP_FLAGS(*async));
+-		if (!ctx->base.cache) {
+-			ret = -ENOMEM;
+-			goto unlock;
+-		}
+-		memcpy(ctx->base.cache, req->cache, cache_len);
+-		ctx->base.cache_dma = dma_map_single(priv->dev, ctx->base.cache,
+-						     cache_len, DMA_TO_DEVICE);
+-		if (dma_mapping_error(priv->dev, ctx->base.cache_dma)) {
+-			ret = -EINVAL;
+-			goto free_cache;
+-		}
++		req->cache_dma = dma_map_single(priv->dev, req->cache,
++						cache_len, DMA_TO_DEVICE);
++		if (dma_mapping_error(priv->dev, req->cache_dma))
++			return -EINVAL;
+ 
+-		ctx->base.cache_sz = cache_len;
++		req->cache_sz = cache_len;
+ 		first_cdesc = safexcel_add_cdesc(priv, ring, 1,
+ 						 (cache_len == len),
+-						 ctx->base.cache_dma,
+-						 cache_len, len,
++						 req->cache_dma, cache_len, len,
+ 						 ctx->base.ctxr_dma);
+ 		if (IS_ERR(first_cdesc)) {
+ 			ret = PTR_ERR(first_cdesc);
+@@ -328,16 +326,12 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 	for (i = 0; i < n_cdesc; i++)
+ 		safexcel_ring_rollback_wptr(priv, &priv->ring[ring].cdr);
+ unmap_cache:
+-	if (ctx->base.cache_dma) {
+-		dma_unmap_single(priv->dev, ctx->base.cache_dma,
+-				 ctx->base.cache_sz, DMA_TO_DEVICE);
+-		ctx->base.cache_sz = 0;
++	if (req->cache_dma) {
++		dma_unmap_single(priv->dev, req->cache_dma, req->cache_sz,
++				 DMA_TO_DEVICE);
++		req->cache_sz = 0;
+ 	}
+-free_cache:
+-	kfree(ctx->base.cache);
+-	ctx->base.cache = NULL;
+ 
+-unlock:
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+ 	return ret;
+ }
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90059-crypto-inside-secure-fix-missing-unlock-on-error-in-.patch b/target/linux/mvebu/patches-4.14/90059-crypto-inside-secure-fix-missing-unlock-on-error-in-.patch
new file mode 100644
index 0000000..edeceb2
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90059-crypto-inside-secure-fix-missing-unlock-on-error-in-.patch
@@ -0,0 +1,36 @@
+From d26b54baf430da2d33288d62e0e3bff07e02c28d Mon Sep 17 00:00:00 2001
+From: "weiyongjun \\(A\\)" <weiyongjun1@huawei.com>
+Date: Tue, 13 Mar 2018 14:54:03 +0000
+Subject: [PATCH 59/82] crypto: inside-secure - fix missing unlock on error in
+ safexcel_ahash_send_req()
+
+Add the missing unlock before return from function
+safexcel_ahash_send_req() in the error handling case.
+
+Fixes: cff9a17545a3 ("crypto: inside-secure - move cache result dma mapping to request")
+Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
+Acked-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 9703a4063cfc..a7702da92b02 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -236,8 +236,10 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 	if (cache_len) {
+ 		req->cache_dma = dma_map_single(priv->dev, req->cache,
+ 						cache_len, DMA_TO_DEVICE);
+-		if (dma_mapping_error(priv->dev, req->cache_dma))
++		if (dma_mapping_error(priv->dev, req->cache_dma)) {
++			spin_unlock_bh(&priv->ring[ring].egress_lock);
+ 			return -EINVAL;
++		}
+ 
+ 		req->cache_sz = cache_len;
+ 		first_cdesc = safexcel_add_cdesc(priv, ring, 1,
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90060-crypto-inside-secure-improve-clock-initialization.patch b/target/linux/mvebu/patches-4.14/90060-crypto-inside-secure-improve-clock-initialization.patch
new file mode 100644
index 0000000..7ad5898
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90060-crypto-inside-secure-improve-clock-initialization.patch
@@ -0,0 +1,48 @@
+From b2da8a42670c569d084fbfb92ffde36cc7524f53 Mon Sep 17 00:00:00 2001
+From: Gregory CLEMENT <gregory.clement@bootlin.com>
+Date: Tue, 13 Mar 2018 17:48:41 +0100
+Subject: [PATCH 60/82] crypto: inside-secure - improve clock initialization
+
+The clock is optional, but if it is present we should managed it. If
+there is an error while trying getting it, we should exit and report this
+error.
+
+So instead of returning an error only in the -EPROBE case, turn it in an
+other way and ignore the clock only if it is not present (-ENOENT case).
+
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 11 ++++++-----
+ 1 file changed, 6 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 09adeaa0da6b..cbcb5d9f17bd 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -882,16 +882,17 @@ static int safexcel_probe(struct platform_device *pdev)
+ 	}
+ 
+ 	priv->clk = devm_clk_get(&pdev->dev, NULL);
+-	if (!IS_ERR(priv->clk)) {
++	ret = PTR_ERR_OR_ZERO(priv->clk);
++	/* The clock isn't mandatory */
++	if  (ret != -ENOENT) {
++		if (ret)
++			return ret;
++
+ 		ret = clk_prepare_enable(priv->clk);
+ 		if (ret) {
+ 			dev_err(dev, "unable to enable clk (%d)\n", ret);
+ 			return ret;
+ 		}
+-	} else {
+-		/* The clock isn't mandatory */
+-		if (PTR_ERR(priv->clk) == -EPROBE_DEFER)
+-			return -EPROBE_DEFER;
+ 	}
+ 
+ 	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90061-crypto-inside-secure-fix-clock-resource-by-adding-a-.patch b/target/linux/mvebu/patches-4.14/90061-crypto-inside-secure-fix-clock-resource-by-adding-a-.patch
new file mode 100644
index 0000000..eda9f44
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90061-crypto-inside-secure-fix-clock-resource-by-adding-a-.patch
@@ -0,0 +1,146 @@
+From 9f9f1c49dcce9bef968bcef522f78048255a7416 Mon Sep 17 00:00:00 2001
+From: Gregory CLEMENT <gregory.clement@bootlin.com>
+Date: Tue, 13 Mar 2018 17:48:42 +0100
+Subject: [PATCH 61/82] crypto: inside-secure - fix clock resource by adding a
+ register clock
+
+On Armada 7K/8K we need to explicitly enable the register clock. This
+clock is optional because not all the SoCs using this IP need it but at
+least for Armada 7K/8K it is actually mandatory.
+
+The binding documentation is updated accordingly.
+
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ .../crypto/inside-secure-safexcel.txt         |  6 +++-
+ drivers/crypto/inside-secure/safexcel.c       | 34 ++++++++++++++-----
+ drivers/crypto/inside-secure/safexcel.h       |  1 +
+ 3 files changed, 31 insertions(+), 10 deletions(-)
+
+diff --git a/Documentation/devicetree/bindings/crypto/inside-secure-safexcel.txt b/Documentation/devicetree/bindings/crypto/inside-secure-safexcel.txt
+index fbc07d12322f..5a3d0829ddf2 100644
+--- a/Documentation/devicetree/bindings/crypto/inside-secure-safexcel.txt
++++ b/Documentation/devicetree/bindings/crypto/inside-secure-safexcel.txt
+@@ -7,7 +7,11 @@ Required properties:
+ - interrupt-names: Should be "ring0", "ring1", "ring2", "ring3", "eip", "mem".
+ 
+ Optional properties:
+-- clocks: Reference to the crypto engine clock.
++- clocks: Reference to the crypto engine clocks, the second clock is
++          needed for the Armada 7K/8K SoCs.
++- clock-names: mandatory if there is a second clock, in this case the
++               name must be "core" for the first clock and "reg" for
++               the second one.
+ 
+ Example:
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index cbcb5d9f17bd..2f68b4ed5500 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -895,16 +895,30 @@ static int safexcel_probe(struct platform_device *pdev)
+ 		}
+ 	}
+ 
++	priv->reg_clk = devm_clk_get(&pdev->dev, "reg");
++	ret = PTR_ERR_OR_ZERO(priv->reg_clk);
++	/* The clock isn't mandatory */
++	if  (ret != -ENOENT) {
++		if (ret)
++			goto err_core_clk;
++
++		ret = clk_prepare_enable(priv->reg_clk);
++		if (ret) {
++			dev_err(dev, "unable to enable reg clk (%d)\n", ret);
++			goto err_core_clk;
++		}
++	}
++
+ 	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));
+ 	if (ret)
+-		goto err_clk;
++		goto err_reg_clk;
+ 
+ 	priv->context_pool = dmam_pool_create("safexcel-context", dev,
+ 					      sizeof(struct safexcel_context_record),
+ 					      1, 0);
+ 	if (!priv->context_pool) {
+ 		ret = -ENOMEM;
+-		goto err_clk;
++		goto err_reg_clk;
+ 	}
+ 
+ 	safexcel_configure(priv);
+@@ -919,12 +933,12 @@ static int safexcel_probe(struct platform_device *pdev)
+ 						     &priv->ring[i].cdr,
+ 						     &priv->ring[i].rdr);
+ 		if (ret)
+-			goto err_clk;
++			goto err_reg_clk;
+ 
+ 		ring_irq = devm_kzalloc(dev, sizeof(*ring_irq), GFP_KERNEL);
+ 		if (!ring_irq) {
+ 			ret = -ENOMEM;
+-			goto err_clk;
++			goto err_reg_clk;
+ 		}
+ 
+ 		ring_irq->priv = priv;
+@@ -936,7 +950,7 @@ static int safexcel_probe(struct platform_device *pdev)
+ 						ring_irq);
+ 		if (irq < 0) {
+ 			ret = irq;
+-			goto err_clk;
++			goto err_reg_clk;
+ 		}
+ 
+ 		priv->ring[i].work_data.priv = priv;
+@@ -947,7 +961,7 @@ static int safexcel_probe(struct platform_device *pdev)
+ 		priv->ring[i].workqueue = create_singlethread_workqueue(wq_name);
+ 		if (!priv->ring[i].workqueue) {
+ 			ret = -ENOMEM;
+-			goto err_clk;
++			goto err_reg_clk;
+ 		}
+ 
+ 		priv->ring[i].requests = 0;
+@@ -968,18 +982,20 @@ static int safexcel_probe(struct platform_device *pdev)
+ 	ret = safexcel_hw_init(priv);
+ 	if (ret) {
+ 		dev_err(dev, "EIP h/w init failed (%d)\n", ret);
+-		goto err_clk;
++		goto err_reg_clk;
+ 	}
+ 
+ 	ret = safexcel_register_algorithms(priv);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to register algorithms (%d)\n", ret);
+-		goto err_clk;
++		goto err_reg_clk;
+ 	}
+ 
+ 	return 0;
+ 
+-err_clk:
++err_reg_clk:
++	clk_disable_unprepare(priv->reg_clk);
++err_core_clk:
+ 	clk_disable_unprepare(priv->clk);
+ 	return ret;
+ }
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index d8dff65fc311..4efeb0251daf 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -525,6 +525,7 @@ struct safexcel_crypto_priv {
+ 	void __iomem *base;
+ 	struct device *dev;
+ 	struct clk *clk;
++	struct clk *reg_clk;
+ 	struct safexcel_config config;
+ 
+ 	enum safexcel_eip_version version;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90062-crypto-inside-secure-move-the-digest-to-the-request-.patch b/target/linux/mvebu/patches-4.14/90062-crypto-inside-secure-move-the-digest-to-the-request-.patch
new file mode 100644
index 0000000..c403a9a
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90062-crypto-inside-secure-move-the-digest-to-the-request-.patch
@@ -0,0 +1,161 @@
+From ba9692358a5cba4770b5230d31e71944f517a06c Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:13 +0100
+Subject: [PATCH 62/82] crypto: inside-secure - move the digest to the request
+ context
+
+This patches moves the digest information from the transformation
+context to the request context. This fixes cases where HMAC init
+functions were called and override the digest value for a short period
+of time, as the HMAC init functions call the SHA init one which reset
+the value. This lead to a small percentage of HMAC being incorrectly
+computed under heavy load.
+
+Fixes: 1b44c5a60c13 ("crypto: inside-secure - add SafeXcel EIP197 crypto engine driver")
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+[Ofer here did all the work, from seeing the issue to understanding the
+root cause. I only made the patch.]
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 30 ++++++++++++--------
+ 1 file changed, 18 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index a7702da92b02..cfcae5e51b9d 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -21,7 +21,6 @@ struct safexcel_ahash_ctx {
+ 	struct safexcel_crypto_priv *priv;
+ 
+ 	u32 alg;
+-	u32 digest;
+ 
+ 	u32 ipad[SHA1_DIGEST_SIZE / sizeof(u32)];
+ 	u32 opad[SHA1_DIGEST_SIZE / sizeof(u32)];
+@@ -36,6 +35,8 @@ struct safexcel_ahash_req {
+ 	int nents;
+ 	dma_addr_t result_dma;
+ 
++	u32 digest;
++
+ 	u8 state_sz;    /* expected sate size, only set once */
+ 	u32 state[SHA256_DIGEST_SIZE / sizeof(u32)] __aligned(sizeof(u32));
+ 
+@@ -53,6 +54,8 @@ struct safexcel_ahash_export_state {
+ 	u64 len;
+ 	u64 processed;
+ 
++	u32 digest;
++
+ 	u32 state[SHA256_DIGEST_SIZE / sizeof(u32)];
+ 	u8 cache[SHA256_BLOCK_SIZE];
+ };
+@@ -86,9 +89,9 @@ static void safexcel_context_control(struct safexcel_ahash_ctx *ctx,
+ 
+ 	cdesc->control_data.control0 |= CONTEXT_CONTROL_TYPE_HASH_OUT;
+ 	cdesc->control_data.control0 |= ctx->alg;
+-	cdesc->control_data.control0 |= ctx->digest;
++	cdesc->control_data.control0 |= req->digest;
+ 
+-	if (ctx->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED) {
++	if (req->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED) {
+ 		if (req->processed) {
+ 			if (ctx->alg == CONTEXT_CONTROL_CRYPTO_ALG_SHA1)
+ 				cdesc->control_data.control0 |= CONTEXT_CONTROL_SIZE(6);
+@@ -116,7 +119,7 @@ static void safexcel_context_control(struct safexcel_ahash_ctx *ctx,
+ 			if (req->finish)
+ 				ctx->base.ctxr->data[i] = cpu_to_le32(req->processed / blocksize);
+ 		}
+-	} else if (ctx->digest == CONTEXT_CONTROL_DIGEST_HMAC) {
++	} else if (req->digest == CONTEXT_CONTROL_DIGEST_HMAC) {
+ 		cdesc->control_data.control0 |= CONTEXT_CONTROL_SIZE(10);
+ 
+ 		memcpy(ctx->base.ctxr->data, ctx->ipad, digestsize);
+@@ -545,7 +548,7 @@ static int safexcel_ahash_enqueue(struct ahash_request *areq)
+ 	if (ctx->base.ctxr) {
+ 		if (priv->version == EIP197 &&
+ 		    !ctx->base.needs_inv && req->processed &&
+-		    ctx->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED)
++		    req->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED)
+ 			/* We're still setting needs_inv here, even though it is
+ 			 * cleared right away, because the needs_inv flag can be
+ 			 * set in other functions and we want to keep the same
+@@ -580,7 +583,6 @@ static int safexcel_ahash_enqueue(struct ahash_request *areq)
+ 
+ static int safexcel_ahash_update(struct ahash_request *areq)
+ {
+-	struct safexcel_ahash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(areq));
+ 	struct safexcel_ahash_req *req = ahash_request_ctx(areq);
+ 	struct crypto_ahash *ahash = crypto_ahash_reqtfm(areq);
+ 
+@@ -596,7 +598,7 @@ static int safexcel_ahash_update(struct ahash_request *areq)
+ 	 * We're not doing partial updates when performing an hmac request.
+ 	 * Everything will be handled by the final() call.
+ 	 */
+-	if (ctx->digest == CONTEXT_CONTROL_DIGEST_HMAC)
++	if (req->digest == CONTEXT_CONTROL_DIGEST_HMAC)
+ 		return 0;
+ 
+ 	if (req->hmac)
+@@ -655,6 +657,8 @@ static int safexcel_ahash_export(struct ahash_request *areq, void *out)
+ 	export->len = req->len;
+ 	export->processed = req->processed;
+ 
++	export->digest = req->digest;
++
+ 	memcpy(export->state, req->state, req->state_sz);
+ 	memcpy(export->cache, req->cache, crypto_ahash_blocksize(ahash));
+ 
+@@ -675,6 +679,8 @@ static int safexcel_ahash_import(struct ahash_request *areq, const void *in)
+ 	req->len = export->len;
+ 	req->processed = export->processed;
+ 
++	req->digest = export->digest;
++
+ 	memcpy(req->cache, export->cache, crypto_ahash_blocksize(ahash));
+ 	memcpy(req->state, export->state, req->state_sz);
+ 
+@@ -711,7 +717,7 @@ static int safexcel_sha1_init(struct ahash_request *areq)
+ 	req->state[4] = SHA1_H4;
+ 
+ 	ctx->alg = CONTEXT_CONTROL_CRYPTO_ALG_SHA1;
+-	ctx->digest = CONTEXT_CONTROL_DIGEST_PRECOMPUTED;
++	req->digest = CONTEXT_CONTROL_DIGEST_PRECOMPUTED;
+ 	req->state_sz = SHA1_DIGEST_SIZE;
+ 
+ 	return 0;
+@@ -778,10 +784,10 @@ struct safexcel_alg_template safexcel_alg_sha1 = {
+ 
+ static int safexcel_hmac_sha1_init(struct ahash_request *areq)
+ {
+-	struct safexcel_ahash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(areq));
++	struct safexcel_ahash_req *req = ahash_request_ctx(areq);
+ 
+ 	safexcel_sha1_init(areq);
+-	ctx->digest = CONTEXT_CONTROL_DIGEST_HMAC;
++	req->digest = CONTEXT_CONTROL_DIGEST_HMAC;
+ 	return 0;
+ }
+ 
+@@ -1019,7 +1025,7 @@ static int safexcel_sha256_init(struct ahash_request *areq)
+ 	req->state[7] = SHA256_H7;
+ 
+ 	ctx->alg = CONTEXT_CONTROL_CRYPTO_ALG_SHA256;
+-	ctx->digest = CONTEXT_CONTROL_DIGEST_PRECOMPUTED;
++	req->digest = CONTEXT_CONTROL_DIGEST_PRECOMPUTED;
+ 	req->state_sz = SHA256_DIGEST_SIZE;
+ 
+ 	return 0;
+@@ -1081,7 +1087,7 @@ static int safexcel_sha224_init(struct ahash_request *areq)
+ 	req->state[7] = SHA224_H7;
+ 
+ 	ctx->alg = CONTEXT_CONTROL_CRYPTO_ALG_SHA224;
+-	ctx->digest = CONTEXT_CONTROL_DIGEST_PRECOMPUTED;
++	req->digest = CONTEXT_CONTROL_DIGEST_PRECOMPUTED;
+ 	req->state_sz = SHA256_DIGEST_SIZE;
+ 
+ 	return 0;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90063-crypto-inside-secure-fix-typo-s-allways-always-in-a-.patch b/target/linux/mvebu/patches-4.14/90063-crypto-inside-secure-fix-typo-s-allways-always-in-a-.patch
new file mode 100644
index 0000000..3dc0361
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90063-crypto-inside-secure-fix-typo-s-allways-always-in-a-.patch
@@ -0,0 +1,45 @@
+From 3648bce52f9a3f432a12c2bd0453019a90341660 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:14 +0100
+Subject: [PATCH 63/82] crypto: inside-secure - fix typo s/allways/always/ in a
+ define
+
+Small cosmetic patch fixing one typo in the
+EIP197_HIA_DSE_CFG_ALLWAYS_BUFFERABLE macro, it should be _ALWAYS_.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 2 +-
+ drivers/crypto/inside-secure/safexcel.h | 2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 2f68b4ed5500..cc9d2e9126b4 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -332,7 +332,7 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	val = EIP197_HIA_DSE_CFG_DIS_DEBUG;
+ 	val |= EIP197_HIA_DxE_CFG_MIN_DATA_SIZE(7) | EIP197_HIA_DxE_CFG_MAX_DATA_SIZE(8);
+ 	val |= EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(WR_CACHE_3BITS);
+-	val |= EIP197_HIA_DSE_CFG_ALLWAYS_BUFFERABLE;
++	val |= EIP197_HIA_DSE_CFG_ALWAYS_BUFFERABLE;
+ 	/* FIXME: instability issues can occur for EIP97 but disabling it impact
+ 	 * performances.
+ 	 */
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 4efeb0251daf..9ca1654136e0 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -179,7 +179,7 @@
+ #define EIP197_HIA_DxE_CFG_MIN_DATA_SIZE(n)	((n) << 0)
+ #define EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(n)	(((n) & 0x7) << 4)
+ #define EIP197_HIA_DxE_CFG_MAX_DATA_SIZE(n)	((n) << 8)
+-#define EIP197_HIA_DSE_CFG_ALLWAYS_BUFFERABLE	GENMASK(15, 14)
++#define EIP197_HIA_DSE_CFG_ALWAYS_BUFFERABLE	GENMASK(15, 14)
+ #define EIP197_HIA_DxE_CFG_MIN_CTRL_SIZE(n)	((n) << 16)
+ #define EIP197_HIA_DxE_CFG_CTRL_CACHE_CTRL(n)	(((n) & 0x7) << 20)
+ #define EIP197_HIA_DxE_CFG_MAX_CTRL_SIZE(n)	((n) << 24)
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90064-crypto-inside-secure-fix-a-typo-in-a-register-name.patch b/target/linux/mvebu/patches-4.14/90064-crypto-inside-secure-fix-a-typo-in-a-register-name.patch
new file mode 100644
index 0000000..52a50f6
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90064-crypto-inside-secure-fix-a-typo-in-a-register-name.patch
@@ -0,0 +1,45 @@
+From 5883f9a3c4d207518860ee05ec3c8ba6ffb2454c Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:15 +0100
+Subject: [PATCH 64/82] crypto: inside-secure - fix a typo in a register name
+
+This patch fixes a typo in the EIP197_HIA_xDR_WR_CTRL_BUG register name,
+as it should be EIP197_HIA_xDR_WR_CTRL_BUF. This is a cosmetic only
+change.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 2 +-
+ drivers/crypto/inside-secure/safexcel.h | 2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index cc9d2e9126b4..f7d7293de699 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -235,7 +235,7 @@ static int safexcel_hw_setup_rdesc_rings(struct safexcel_crypto_priv *priv)
+ 		/* Configure DMA tx control */
+ 		val = EIP197_HIA_xDR_CFG_WR_CACHE(WR_CACHE_3BITS);
+ 		val |= EIP197_HIA_xDR_CFG_RD_CACHE(RD_CACHE_3BITS);
+-		val |= EIP197_HIA_xDR_WR_RES_BUF | EIP197_HIA_xDR_WR_CTRL_BUG;
++		val |= EIP197_HIA_xDR_WR_RES_BUF | EIP197_HIA_xDR_WR_CTRL_BUF;
+ 		writel(val,
+ 		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_DMA_CFG);
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 9ca1654136e0..295813920618 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -135,7 +135,7 @@
+ 
+ /* EIP197_HIA_xDR_DMA_CFG */
+ #define EIP197_HIA_xDR_WR_RES_BUF		BIT(22)
+-#define EIP197_HIA_xDR_WR_CTRL_BUG		BIT(23)
++#define EIP197_HIA_xDR_WR_CTRL_BUF		BIT(23)
+ #define EIP197_HIA_xDR_WR_OWN_BUF		BIT(24)
+ #define EIP197_HIA_xDR_CFG_WR_CACHE(n)		(((n) & 0x7) << 25)
+ #define EIP197_HIA_xDR_CFG_RD_CACHE(n)		(((n) & 0x7) << 29)
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90065-crypto-inside-secure-improve-the-send-error-path.patch b/target/linux/mvebu/patches-4.14/90065-crypto-inside-secure-improve-the-send-error-path.patch
new file mode 100644
index 0000000..90d91ce
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90065-crypto-inside-secure-improve-the-send-error-path.patch
@@ -0,0 +1,50 @@
+From 7a3daac97ede7897225c206389230bbcc265e834 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:16 +0100
+Subject: [PATCH 65/82] crypto: inside-secure - improve the send error path
+
+This patch improves the send error path as it wasn't handling all error
+cases. A new label is added, and some of the goto are updated to point
+to the right labels, so that the code is more robust to errors.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 7 +++++--
+ 1 file changed, 5 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index cfcae5e51b9d..4ff3f7615b3d 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -281,7 +281,7 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 					   sglen, len, ctx->base.ctxr_dma);
+ 		if (IS_ERR(cdesc)) {
+ 			ret = PTR_ERR(cdesc);
+-			goto cdesc_rollback;
++			goto unmap_sg;
+ 		}
+ 		n_cdesc++;
+ 
+@@ -305,7 +305,7 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 					 DMA_FROM_DEVICE);
+ 	if (dma_mapping_error(priv->dev, req->result_dma)) {
+ 		ret = -EINVAL;
+-		goto cdesc_rollback;
++		goto unmap_sg;
+ 	}
+ 
+ 	/* Add a result descriptor */
+@@ -326,6 +326,9 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 	return 0;
+ 
+ unmap_result:
++	dma_unmap_single(priv->dev, req->result_dma, req->state_sz,
++			 DMA_FROM_DEVICE);
++unmap_sg:
+ 	dma_unmap_sg(priv->dev, areq->src, req->nents, DMA_TO_DEVICE);
+ cdesc_rollback:
+ 	for (i = 0; i < n_cdesc; i++)
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90066-crypto-inside-secure-do-not-access-buffers-mapped-to.patch b/target/linux/mvebu/patches-4.14/90066-crypto-inside-secure-do-not-access-buffers-mapped-to.patch
new file mode 100644
index 0000000..26de242
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90066-crypto-inside-secure-do-not-access-buffers-mapped-to.patch
@@ -0,0 +1,46 @@
+From 89099c389a04fb6d049cdad85cbcd5d5447fb1d1 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:17 +0100
+Subject: [PATCH 66/82] crypto: inside-secure - do not access buffers mapped to
+ the device
+
+This patches update the way the digest is copied from the state buffer
+to the result buffer, so that the copy only happen after the state
+buffer was DMA unmapped, as otherwise the buffer would be owned by the
+device.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 4ff3f7615b3d..573b12e4d9dd 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -156,10 +156,6 @@ static int safexcel_handle_req_result(struct safexcel_crypto_priv *priv, int rin
+ 	safexcel_complete(priv, ring);
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+ 
+-	if (sreq->finish)
+-		memcpy(areq->result, sreq->state,
+-		       crypto_ahash_digestsize(ahash));
+-
+ 	if (sreq->nents) {
+ 		dma_unmap_sg(priv->dev, areq->src, sreq->nents, DMA_TO_DEVICE);
+ 		sreq->nents = 0;
+@@ -177,6 +173,10 @@ static int safexcel_handle_req_result(struct safexcel_crypto_priv *priv, int rin
+ 		sreq->cache_dma = 0;
+ 	}
+ 
++	if (sreq->finish)
++		memcpy(areq->result, sreq->state,
++		       crypto_ahash_digestsize(ahash));
++
+ 	cache_len = sreq->len - sreq->processed;
+ 	if (cache_len)
+ 		memcpy(sreq->cache, sreq->cache_next, cache_len);
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90067-crypto-inside-secure-improve-the-skcipher-token.patch b/target/linux/mvebu/patches-4.14/90067-crypto-inside-secure-improve-the-skcipher-token.patch
new file mode 100644
index 0000000..ac09d7f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90067-crypto-inside-secure-improve-the-skcipher-token.patch
@@ -0,0 +1,36 @@
+From 65c1ad099b6fab06cf04e1a0d797f490aa02719b Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:18 +0100
+Subject: [PATCH 67/82] crypto: inside-secure - improve the skcipher token
+
+The token used for encryption and decryption of skcipher algorithms sets
+its stat field to "last packet". As it's a cipher only algorithm, there
+is not hash operation and thus the "last hash" bit should be set to tell
+the internal engine no hash operation should be performed.
+
+This does not fix a bug, but improves the token definition to follow
+exactly what's advised by the datasheet.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_cipher.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_cipher.c b/drivers/crypto/inside-secure/safexcel_cipher.c
+index 17a7725a6f6d..bafb60505fab 100644
+--- a/drivers/crypto/inside-secure/safexcel_cipher.c
++++ b/drivers/crypto/inside-secure/safexcel_cipher.c
+@@ -58,7 +58,8 @@ static void safexcel_cipher_token(struct safexcel_cipher_ctx *ctx,
+ 
+ 	token[0].opcode = EIP197_TOKEN_OPCODE_DIRECTION;
+ 	token[0].packet_length = length;
+-	token[0].stat = EIP197_TOKEN_STAT_LAST_PACKET;
++	token[0].stat = EIP197_TOKEN_STAT_LAST_PACKET |
++			EIP197_TOKEN_STAT_LAST_HASH;
+ 	token[0].instructions = EIP197_TOKEN_INS_LAST |
+ 				EIP197_TOKEN_INS_TYPE_CRYTO |
+ 				EIP197_TOKEN_INS_TYPE_OUTPUT;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90068-crypto-inside-secure-the-context-ipad-opad-should-us.patch b/target/linux/mvebu/patches-4.14/90068-crypto-inside-secure-the-context-ipad-opad-should-us.patch
new file mode 100644
index 0000000..e4d5c8b
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90068-crypto-inside-secure-the-context-ipad-opad-should-us.patch
@@ -0,0 +1,42 @@
+From f8fcb222ce5f865703d89bdc9ebc4b30e6e32110 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:19 +0100
+Subject: [PATCH 68/82] crypto: inside-secure - the context ipad/opad should
+ use the state sz
+
+This patches uses the state size of the algorithms instead of their
+digest size to copy the ipad and opad in the context. This doesn't fix
+anything as the state and digest size are the same for many algorithms,
+and for all the hmac currently supported by this driver. However
+hmac(sha224) use the sha224 hash function which has a different digest
+and state size. This commit prepares the addition of such algorithms.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 573b12e4d9dd..d152f2eb0271 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -120,11 +120,11 @@ static void safexcel_context_control(struct safexcel_ahash_ctx *ctx,
+ 				ctx->base.ctxr->data[i] = cpu_to_le32(req->processed / blocksize);
+ 		}
+ 	} else if (req->digest == CONTEXT_CONTROL_DIGEST_HMAC) {
+-		cdesc->control_data.control0 |= CONTEXT_CONTROL_SIZE(10);
++		cdesc->control_data.control0 |= CONTEXT_CONTROL_SIZE(2 * req->state_sz / sizeof(u32));
+ 
+-		memcpy(ctx->base.ctxr->data, ctx->ipad, digestsize);
+-		memcpy(ctx->base.ctxr->data + digestsize / sizeof(u32),
+-		       ctx->opad, digestsize);
++		memcpy(ctx->base.ctxr->data, ctx->ipad, req->state_sz);
++		memcpy(ctx->base.ctxr->data + req->state_sz / sizeof(u32),
++		       ctx->opad, req->state_sz);
+ 	}
+ }
+ 
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90069-crypto-inside-secure-hmac-sha256-support.patch b/target/linux/mvebu/patches-4.14/90069-crypto-inside-secure-hmac-sha256-support.patch
new file mode 100644
index 0000000..0d5246b
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90069-crypto-inside-secure-hmac-sha256-support.patch
@@ -0,0 +1,174 @@
+From 97eb1ecf57d126f52e1974fb0f9e2c17dc3ea0a0 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:20 +0100
+Subject: [PATCH 69/82] crypto: inside-secure - hmac(sha256) support
+
+This patch adds the hmac(sha256) support to the Inside Secure
+cryptographic engine driver.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c      |  3 +-
+ drivers/crypto/inside-secure/safexcel.h      |  1 +
+ drivers/crypto/inside-secure/safexcel_hash.c | 80 ++++++++++++++++++--
+ 3 files changed, 75 insertions(+), 9 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index f7d7293de699..33595f41586f 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -354,7 +354,7 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	val |= EIP197_PROTOCOL_ENCRYPT_ONLY | EIP197_PROTOCOL_HASH_ONLY;
+ 	val |= EIP197_ALG_AES_ECB | EIP197_ALG_AES_CBC;
+ 	val |= EIP197_ALG_SHA1 | EIP197_ALG_HMAC_SHA1;
+-	val |= EIP197_ALG_SHA2;
++	val |= EIP197_ALG_SHA2 | EIP197_ALG_HMAC_SHA2;
+ 	writel(val, EIP197_PE(priv) + EIP197_PE_EIP96_FUNCTION_EN);
+ 
+ 	/* Command Descriptor Rings prepare */
+@@ -768,6 +768,7 @@ static struct safexcel_alg_template *safexcel_algs[] = {
+ 	&safexcel_alg_sha224,
+ 	&safexcel_alg_sha256,
+ 	&safexcel_alg_hmac_sha1,
++	&safexcel_alg_hmac_sha256,
+ };
+ 
+ static int safexcel_register_algorithms(struct safexcel_crypto_priv *priv)
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 295813920618..99e0f32452ff 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -633,5 +633,6 @@ extern struct safexcel_alg_template safexcel_alg_sha1;
+ extern struct safexcel_alg_template safexcel_alg_sha224;
+ extern struct safexcel_alg_template safexcel_alg_sha256;
+ extern struct safexcel_alg_template safexcel_alg_hmac_sha1;
++extern struct safexcel_alg_template safexcel_alg_hmac_sha256;
+ 
+ #endif
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index d152f2eb0271..2917a902596d 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -22,8 +22,8 @@ struct safexcel_ahash_ctx {
+ 
+ 	u32 alg;
+ 
+-	u32 ipad[SHA1_DIGEST_SIZE / sizeof(u32)];
+-	u32 opad[SHA1_DIGEST_SIZE / sizeof(u32)];
++	u32 ipad[SHA256_DIGEST_SIZE / sizeof(u32)];
++	u32 opad[SHA256_DIGEST_SIZE / sizeof(u32)];
+ };
+ 
+ struct safexcel_ahash_req {
+@@ -953,20 +953,21 @@ static int safexcel_hmac_setkey(const char *alg, const u8 *key,
+ 	return ret;
+ }
+ 
+-static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
+-				     unsigned int keylen)
++static int safexcel_hmac_alg_setkey(struct crypto_ahash *tfm, const u8 *key,
++				    unsigned int keylen, const char *alg,
++				    unsigned int state_sz)
+ {
+ 	struct safexcel_ahash_ctx *ctx = crypto_tfm_ctx(crypto_ahash_tfm(tfm));
+ 	struct safexcel_crypto_priv *priv = ctx->priv;
+ 	struct safexcel_ahash_export_state istate, ostate;
+ 	int ret, i;
+ 
+-	ret = safexcel_hmac_setkey("safexcel-sha1", key, keylen, &istate, &ostate);
++	ret = safexcel_hmac_setkey(alg, key, keylen, &istate, &ostate);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (priv->version == EIP197 && ctx->base.ctxr) {
+-		for (i = 0; i < SHA1_DIGEST_SIZE / sizeof(u32); i++) {
++		for (i = 0; i < state_sz / sizeof(u32); i++) {
+ 			if (ctx->ipad[i] != le32_to_cpu(istate.state[i]) ||
+ 			    ctx->opad[i] != le32_to_cpu(ostate.state[i])) {
+ 				ctx->base.needs_inv = true;
+@@ -975,12 +976,19 @@ static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
+ 		}
+ 	}
+ 
+-	memcpy(ctx->ipad, &istate.state, SHA1_DIGEST_SIZE);
+-	memcpy(ctx->opad, &ostate.state, SHA1_DIGEST_SIZE);
++	memcpy(ctx->ipad, &istate.state, state_sz);
++	memcpy(ctx->opad, &ostate.state, state_sz);
+ 
+ 	return 0;
+ }
+ 
++static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
++				     unsigned int keylen)
++{
++	return safexcel_hmac_alg_setkey(tfm, key, keylen, "safexcel-sha1",
++					SHA1_DIGEST_SIZE);
++}
++
+ struct safexcel_alg_template safexcel_alg_hmac_sha1 = {
+ 	.type = SAFEXCEL_ALG_TYPE_AHASH,
+ 	.alg.ahash = {
+@@ -1134,3 +1142,59 @@ struct safexcel_alg_template safexcel_alg_sha224 = {
+ 		},
+ 	},
+ };
++
++static int safexcel_hmac_sha256_setkey(struct crypto_ahash *tfm, const u8 *key,
++				     unsigned int keylen)
++{
++	return safexcel_hmac_alg_setkey(tfm, key, keylen, "safexcel-sha256",
++					SHA256_DIGEST_SIZE);
++}
++
++static int safexcel_hmac_sha256_init(struct ahash_request *areq)
++{
++	struct safexcel_ahash_req *req = ahash_request_ctx(areq);
++
++	safexcel_sha256_init(areq);
++	req->digest = CONTEXT_CONTROL_DIGEST_HMAC;
++	return 0;
++}
++
++static int safexcel_hmac_sha256_digest(struct ahash_request *areq)
++{
++	int ret = safexcel_hmac_sha256_init(areq);
++
++	if (ret)
++		return ret;
++
++	return safexcel_ahash_finup(areq);
++}
++
++struct safexcel_alg_template safexcel_alg_hmac_sha256 = {
++	.type = SAFEXCEL_ALG_TYPE_AHASH,
++	.alg.ahash = {
++		.init = safexcel_hmac_sha256_init,
++		.update = safexcel_ahash_update,
++		.final = safexcel_ahash_final,
++		.finup = safexcel_ahash_finup,
++		.digest = safexcel_hmac_sha256_digest,
++		.setkey = safexcel_hmac_sha256_setkey,
++		.export = safexcel_ahash_export,
++		.import = safexcel_ahash_import,
++		.halg = {
++			.digestsize = SHA256_DIGEST_SIZE,
++			.statesize = sizeof(struct safexcel_ahash_export_state),
++			.base = {
++				.cra_name = "hmac(sha256)",
++				.cra_driver_name = "safexcel-hmac-sha256",
++				.cra_priority = 300,
++				.cra_flags = CRYPTO_ALG_ASYNC |
++					     CRYPTO_ALG_KERN_DRIVER_ONLY,
++				.cra_blocksize = SHA256_BLOCK_SIZE,
++				.cra_ctxsize = sizeof(struct safexcel_ahash_ctx),
++				.cra_init = safexcel_ahash_cra_init,
++				.cra_exit = safexcel_ahash_cra_exit,
++				.cra_module = THIS_MODULE,
++			},
++		},
++	},
++};
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90070-crypto-inside-secure-hmac-sha224-support.patch b/target/linux/mvebu/patches-4.14/90070-crypto-inside-secure-hmac-sha224-support.patch
new file mode 100644
index 0000000..92a09c3
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90070-crypto-inside-secure-hmac-sha224-support.patch
@@ -0,0 +1,110 @@
+From 3fcdf8383e1154e89056636a57124401df552e29 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:21 +0100
+Subject: [PATCH 70/82] crypto: inside-secure - hmac(sha224) support
+
+This patch adds the hmac(sha224) support to the Inside Secure
+cryptographic engine driver.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c      |  1 +
+ drivers/crypto/inside-secure/safexcel.h      |  1 +
+ drivers/crypto/inside-secure/safexcel_hash.c | 56 ++++++++++++++++++++
+ 3 files changed, 58 insertions(+)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 33595f41586f..d4a81be0d7d2 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -768,6 +768,7 @@ static struct safexcel_alg_template *safexcel_algs[] = {
+ 	&safexcel_alg_sha224,
+ 	&safexcel_alg_sha256,
+ 	&safexcel_alg_hmac_sha1,
++	&safexcel_alg_hmac_sha224,
+ 	&safexcel_alg_hmac_sha256,
+ };
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 99e0f32452ff..b470a849721f 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -633,6 +633,7 @@ extern struct safexcel_alg_template safexcel_alg_sha1;
+ extern struct safexcel_alg_template safexcel_alg_sha224;
+ extern struct safexcel_alg_template safexcel_alg_sha256;
+ extern struct safexcel_alg_template safexcel_alg_hmac_sha1;
++extern struct safexcel_alg_template safexcel_alg_hmac_sha224;
+ extern struct safexcel_alg_template safexcel_alg_hmac_sha256;
+ 
+ #endif
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 2917a902596d..d9ddf776c799 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -1143,6 +1143,62 @@ struct safexcel_alg_template safexcel_alg_sha224 = {
+ 	},
+ };
+ 
++static int safexcel_hmac_sha224_setkey(struct crypto_ahash *tfm, const u8 *key,
++				       unsigned int keylen)
++{
++	return safexcel_hmac_alg_setkey(tfm, key, keylen, "safexcel-sha224",
++					SHA256_DIGEST_SIZE);
++}
++
++static int safexcel_hmac_sha224_init(struct ahash_request *areq)
++{
++	struct safexcel_ahash_req *req = ahash_request_ctx(areq);
++
++	safexcel_sha224_init(areq);
++	req->digest = CONTEXT_CONTROL_DIGEST_HMAC;
++	return 0;
++}
++
++static int safexcel_hmac_sha224_digest(struct ahash_request *areq)
++{
++	int ret = safexcel_hmac_sha224_init(areq);
++
++	if (ret)
++		return ret;
++
++	return safexcel_ahash_finup(areq);
++}
++
++struct safexcel_alg_template safexcel_alg_hmac_sha224 = {
++	.type = SAFEXCEL_ALG_TYPE_AHASH,
++	.alg.ahash = {
++		.init = safexcel_hmac_sha224_init,
++		.update = safexcel_ahash_update,
++		.final = safexcel_ahash_final,
++		.finup = safexcel_ahash_finup,
++		.digest = safexcel_hmac_sha224_digest,
++		.setkey = safexcel_hmac_sha224_setkey,
++		.export = safexcel_ahash_export,
++		.import = safexcel_ahash_import,
++		.halg = {
++			.digestsize = SHA224_DIGEST_SIZE,
++			.statesize = sizeof(struct safexcel_ahash_export_state),
++			.base = {
++				.cra_name = "hmac(sha224)",
++				.cra_driver_name = "safexcel-hmac-sha224",
++				.cra_priority = 300,
++				.cra_flags = CRYPTO_ALG_ASYNC |
++					     CRYPTO_ALG_KERN_DRIVER_ONLY,
++				.cra_blocksize = SHA224_BLOCK_SIZE,
++				.cra_ctxsize = sizeof(struct safexcel_ahash_ctx),
++				.cra_init = safexcel_ahash_cra_init,
++				.cra_exit = safexcel_ahash_cra_exit,
++				.cra_module = THIS_MODULE,
++			},
++		},
++	},
++};
++
+ static int safexcel_hmac_sha256_setkey(struct crypto_ahash *tfm, const u8 *key,
+ 				     unsigned int keylen)
+ {
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90071-arm64-dts-marvell-armada-37xx-add-a-crypto-node.patch b/target/linux/mvebu/patches-4.14/90071-arm64-dts-marvell-armada-37xx-add-a-crypto-node.patch
new file mode 100644
index 0000000..c2b762b
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90071-arm64-dts-marvell-armada-37xx-add-a-crypto-node.patch
@@ -0,0 +1,42 @@
+From d2c023f2d1c7158ea315853a7b1e175c75641ca6 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@free-electrons.com>
+Date: Tue, 26 Dec 2017 17:16:53 +0100
+Subject: [PATCH 71/82] arm64: dts: marvell: armada-37xx: add a crypto node
+
+This patch adds a crypto node describing the EIP97 engine found in
+Armada 37xx SoCs. The cryptographic engine is enabled by default.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 14 ++++++++++++++
+ 1 file changed, 14 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index a5fe6c60cd0a..8cd43ce38571 100644
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -302,6 +302,20 @@
+ 				};
+ 			};
+ 
++			crypto: crypto@90000 {
++				compatible = "inside-secure,safexcel-eip97";
++				reg = <0x90000 0x20000>;
++				interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "mem", "ring0", "ring1",
++						  "ring2", "ring3", "eip";
++				clocks = <&nb_periph_clk 15>;
++			};
++
+ 			sdhci1: sdhci@d0000 {
+ 				compatible = "marvell,armada-3700-sdhci",
+ 					     "marvell,sdhci-xenon";
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90072-net-phy-Cosmetic-fixes-to-phylink-sfp-sfp-bus.c.patch b/target/linux/mvebu/patches-4.14/90072-net-phy-Cosmetic-fixes-to-phylink-sfp-sfp-bus.c.patch
new file mode 100644
index 0000000..d8090d5
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90072-net-phy-Cosmetic-fixes-to-phylink-sfp-sfp-bus.c.patch
@@ -0,0 +1,246 @@
+From ae5fc9630b4c1e727445b400dd125069cfa4c40f Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Mon, 30 Oct 2017 21:42:57 -0700
+Subject: [PATCH 72/82] net: phy: Cosmetic fixes to phylink/sfp/sfp-bus.c
+
+Perform a number of stylistic changes to phylink.c, sfp.c and sfp-bus.c:
+
+- align with netdev-style comments
+- align function arguments to the opening parenthesis
+- remove blank lines
+- fixup a few lines over 80 columns
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/phylink.c | 13 ++++++-------
+ drivers/net/phy/sfp-bus.c | 11 +++--------
+ drivers/net/phy/sfp.c     | 27 +++++++++++++--------------
+ 3 files changed, 22 insertions(+), 29 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 8b61cb127ef7..eadd046c2168 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -356,7 +356,7 @@ static void phylink_get_fixed_state(struct phylink *pl, struct phylink_link_stat
+  *    1     1       0     1     TX
+  */
+ static void phylink_resolve_flow(struct phylink *pl,
+-	struct phylink_link_state *state)
++				 struct phylink_link_state *state)
+ {
+ 	int new_pause = 0;
+ 
+@@ -505,7 +505,8 @@ static int phylink_register_sfp(struct phylink *pl, struct device_node *np)
+ }
+ 
+ struct phylink *phylink_create(struct net_device *ndev, struct device_node *np,
+-	phy_interface_t iface, const struct phylink_mac_ops *ops)
++			       phy_interface_t iface,
++			       const struct phylink_mac_ops *ops)
+ {
+ 	struct phylink *pl;
+ 	int ret;
+@@ -585,7 +586,7 @@ void phylink_phy_change(struct phy_device *phydev, bool up, bool do_carrier)
+ 	phylink_run_resolve(pl);
+ 
+ 	netdev_dbg(pl->netdev, "phy link %s %s/%s/%s\n", up ? "up" : "down",
+-	           phy_modes(phydev->interface),
++		   phy_modes(phydev->interface),
+ 		   phy_speed_to_str(phydev->speed),
+ 		   phy_duplex_to_str(phydev->duplex));
+ }
+@@ -824,7 +825,7 @@ static void phylink_get_ksettings(const struct phylink_link_state *state,
+ }
+ 
+ int phylink_ethtool_ksettings_get(struct phylink *pl,
+-	struct ethtool_link_ksettings *kset)
++				  struct ethtool_link_ksettings *kset)
+ {
+ 	struct phylink_link_state link_state;
+ 
+@@ -871,7 +872,7 @@ int phylink_ethtool_ksettings_get(struct phylink *pl,
+ EXPORT_SYMBOL_GPL(phylink_ethtool_ksettings_get);
+ 
+ int phylink_ethtool_ksettings_set(struct phylink *pl,
+-	const struct ethtool_link_ksettings *kset)
++				  const struct ethtool_link_ksettings *kset)
+ {
+ 	struct ethtool_link_ksettings our_kset;
+ 	struct phylink_link_state config;
+@@ -1311,8 +1312,6 @@ int phylink_mii_ioctl(struct phylink *pl, struct ifreq *ifr, int cmd)
+ }
+ EXPORT_SYMBOL_GPL(phylink_mii_ioctl);
+ 
+-
+-
+ static int phylink_sfp_module_insert(void *upstream,
+ 				     const struct sfp_eeprom_id *id)
+ {
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index faa8fddde29c..f8c0327e6ad7 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -26,7 +26,6 @@ struct sfp_bus {
+ 	bool started;
+ };
+ 
+-
+ int sfp_parse_port(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		   unsigned long *support)
+ {
+@@ -208,7 +207,6 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ }
+ EXPORT_SYMBOL_GPL(sfp_parse_support);
+ 
+-
+ static LIST_HEAD(sfp_buses);
+ static DEFINE_MUTEX(sfp_mutex);
+ 
+@@ -297,7 +295,6 @@ static void sfp_unregister_bus(struct sfp_bus *bus)
+ 	bus->registered = false;
+ }
+ 
+-
+ int sfp_get_module_info(struct sfp_bus *bus, struct ethtool_modinfo *modinfo)
+ {
+ 	return bus->socket_ops->module_info(bus->sfp, modinfo);
+@@ -305,7 +302,7 @@ int sfp_get_module_info(struct sfp_bus *bus, struct ethtool_modinfo *modinfo)
+ EXPORT_SYMBOL_GPL(sfp_get_module_info);
+ 
+ int sfp_get_module_eeprom(struct sfp_bus *bus, struct ethtool_eeprom *ee,
+-	u8 *data)
++			  u8 *data)
+ {
+ 	return bus->socket_ops->module_eeprom(bus->sfp, ee, data);
+ }
+@@ -328,8 +325,8 @@ void sfp_upstream_stop(struct sfp_bus *bus)
+ EXPORT_SYMBOL_GPL(sfp_upstream_stop);
+ 
+ struct sfp_bus *sfp_register_upstream(struct device_node *np,
+-	struct net_device *ndev, void *upstream,
+-	const struct sfp_upstream_ops *ops)
++				      struct net_device *ndev, void *upstream,
++				      const struct sfp_upstream_ops *ops)
+ {
+ 	struct sfp_bus *bus = sfp_bus_get(np);
+ 	int ret = 0;
+@@ -367,7 +364,6 @@ void sfp_unregister_upstream(struct sfp_bus *bus)
+ }
+ EXPORT_SYMBOL_GPL(sfp_unregister_upstream);
+ 
+-
+ /* Socket driver entry points */
+ int sfp_add_phy(struct sfp_bus *bus, struct phy_device *phydev)
+ {
+@@ -394,7 +390,6 @@ void sfp_remove_phy(struct sfp_bus *bus)
+ }
+ EXPORT_SYMBOL_GPL(sfp_remove_phy);
+ 
+-
+ void sfp_link_up(struct sfp_bus *bus)
+ {
+ 	const struct sfp_upstream_ops *ops = sfp_get_upstream_ops(bus);
+diff --git a/drivers/net/phy/sfp.c b/drivers/net/phy/sfp.c
+index d8073311345c..3b765d44e220 100644
+--- a/drivers/net/phy/sfp.c
++++ b/drivers/net/phy/sfp.c
+@@ -88,15 +88,12 @@ static const enum gpiod_flags gpio_flags[] = {
+ #define T_PROBE_INIT	msecs_to_jiffies(300)
+ #define T_PROBE_RETRY	msecs_to_jiffies(100)
+ 
+-/*
+- * SFP modules appear to always have their PHY configured for bus address
++/* SFP modules appear to always have their PHY configured for bus address
+  * 0x56 (which with mdio-i2c, translates to a PHY address of 22).
+  */
+ #define SFP_PHY_ADDR	22
+ 
+-/*
+- * Give this long for the PHY to reset.
+- */
++/* Give this long for the PHY to reset. */
+ #define T_PHY_RESET_MS	50
+ 
+ static DEFINE_MUTEX(sfp_mutex);
+@@ -150,10 +147,10 @@ static void sfp_gpio_set_state(struct sfp *sfp, unsigned int state)
+ 		/* If the module is present, drive the signals */
+ 		if (sfp->gpio[GPIO_TX_DISABLE])
+ 			gpiod_direction_output(sfp->gpio[GPIO_TX_DISABLE],
+-						state & SFP_F_TX_DISABLE);
++					       state & SFP_F_TX_DISABLE);
+ 		if (state & SFP_F_RATE_SELECT)
+ 			gpiod_direction_output(sfp->gpio[GPIO_RATE_SELECT],
+-						state & SFP_F_RATE_SELECT);
++					       state & SFP_F_RATE_SELECT);
+ 	} else {
+ 		/* Otherwise, let them float to the pull-ups */
+ 		if (sfp->gpio[GPIO_TX_DISABLE])
+@@ -164,7 +161,7 @@ static void sfp_gpio_set_state(struct sfp *sfp, unsigned int state)
+ }
+ 
+ static int sfp__i2c_read(struct i2c_adapter *i2c, u8 bus_addr, u8 dev_addr,
+-	void *buf, size_t len)
++			 void *buf, size_t len)
+ {
+ 	struct i2c_msg msgs[2];
+ 	int ret;
+@@ -186,7 +183,7 @@ static int sfp__i2c_read(struct i2c_adapter *i2c, u8 bus_addr, u8 dev_addr,
+ }
+ 
+ static int sfp_i2c_read(struct sfp *sfp, bool a2, u8 addr, void *buf,
+-	size_t len)
++			size_t len)
+ {
+ 	return sfp__i2c_read(sfp->i2c, a2 ? 0x51 : 0x50, addr, buf, len);
+ }
+@@ -220,7 +217,6 @@ static int sfp_i2c_configure(struct sfp *sfp, struct i2c_adapter *i2c)
+ 	return 0;
+ }
+ 
+-
+ /* Interface */
+ static unsigned int sfp_get_state(struct sfp *sfp)
+ {
+@@ -473,7 +469,8 @@ static void sfp_sm_next(struct sfp *sfp, unsigned int state,
+ 	sfp_sm_set_timer(sfp, timeout);
+ }
+ 
+-static void sfp_sm_ins_next(struct sfp *sfp, unsigned int state, unsigned int timeout)
++static void sfp_sm_ins_next(struct sfp *sfp, unsigned int state,
++			    unsigned int timeout)
+ {
+ 	sfp->sm_mod_state = state;
+ 	sfp_sm_set_timer(sfp, timeout);
+@@ -548,7 +545,8 @@ static void sfp_sm_link_check_los(struct sfp *sfp)
+ static void sfp_sm_fault(struct sfp *sfp, bool warn)
+ {
+ 	if (sfp->sm_retries && !--sfp->sm_retries) {
+-		dev_err(sfp->dev, "module persistently indicates fault, disabling\n");
++		dev_err(sfp->dev,
++			"module persistently indicates fault, disabling\n");
+ 		sfp_sm_next(sfp, SFP_S_TX_DISABLE, 0);
+ 	} else {
+ 		if (warn)
+@@ -647,7 +645,8 @@ static int sfp_sm_mod_probe(struct sfp *sfp)
+ 	date[7] = sfp->id.ext.datecode[1];
+ 	date[8] = '\0';
+ 
+-	dev_info(sfp->dev, "module %s %s rev %s sn %s dc %s\n", vendor, part, rev, sn, date);
++	dev_info(sfp->dev, "module %s %s rev %s sn %s dc %s\n",
++		 vendor, part, rev, sn, date);
+ 	dev_info(sfp->dev, "  %s connector, encoding %s, nominal bitrate %u.%uGbps +%u%% -%u%%\n",
+ 		 sfp_connector(sfp->id.base.connector),
+ 		 sfp_encoding(sfp->id.base.encoding),
+@@ -905,7 +904,7 @@ static int sfp_module_info(struct sfp *sfp, struct ethtool_modinfo *modinfo)
+ }
+ 
+ static int sfp_module_eeprom(struct sfp *sfp, struct ethtool_eeprom *ee,
+-	u8 *data)
++			     u8 *data)
+ {
+ 	unsigned int first, last, len;
+ 	int ret;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90073-sfp-fix-sparse-warning.patch b/target/linux/mvebu/patches-4.14/90073-sfp-fix-sparse-warning.patch
new file mode 100644
index 0000000..35321f9
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90073-sfp-fix-sparse-warning.patch
@@ -0,0 +1,30 @@
+From 90aacbb9c6e7287da553b71d49d5d3579155f8ca Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 1 Dec 2017 10:24:58 +0000
+Subject: [PATCH 73/82] sfp: fix sparse warning
+
+drivers/net/phy/sfp-bus.c:298:13: warning: context imbalance in 'sfp_bus_release' - wrong count at exit
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/sfp-bus.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index f8c0327e6ad7..f2513b9e00cd 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -246,7 +246,7 @@ static struct sfp_bus *sfp_bus_get(struct device_node *np)
+ 	return found;
+ }
+ 
+-static void sfp_bus_release(struct kref *kref) __releases(sfp_mutex)
++static void sfp_bus_release(struct kref *kref)
+ {
+ 	struct sfp_bus *bus = container_of(kref, struct sfp_bus, kref);
+ 
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90075-sfp-add-support-for-1000Base-PX-and-1000Base-BX10.patch b/target/linux/mvebu/patches-4.14/90075-sfp-add-support-for-1000Base-PX-and-1000Base-BX10.patch
new file mode 100644
index 0000000..15b677a
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90075-sfp-add-support-for-1000Base-PX-and-1000Base-BX10.patch
@@ -0,0 +1,60 @@
+From b6e26c994ae12beb9e8d4819f986354b4bd29fec Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 29 Dec 2017 12:15:23 +0000
+Subject: [PATCH 75/82] sfp: add support for 1000Base-PX and 1000Base-BX10
+
+Add support for decoding the transceiver information for 1000Base-PX and
+1000Base-BX10.  These use 1000BASE-X protocol.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/sfp-bus.c | 21 +++++++++++++++++++++
+ 1 file changed, 21 insertions(+)
+
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index 43dfe187378f..deade7d45331 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -120,10 +120,26 @@ EXPORT_SYMBOL_GPL(sfp_parse_interface);
+ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		       unsigned long *support)
+ {
++	unsigned int br_min, br_nom, br_max;
++
+ 	phylink_set(support, Autoneg);
+ 	phylink_set(support, Pause);
+ 	phylink_set(support, Asym_Pause);
+ 
++	/* Decode the bitrate information to MBd */
++	br_min = br_nom = br_max = 0;
++	if (id->base.br_nominal) {
++		if (id->base.br_nominal != 255) {
++			br_nom = id->base.br_nominal * 100;
++			br_min = br_nom + id->base.br_nominal * id->ext.br_min;
++			br_max = br_nom + id->base.br_nominal * id->ext.br_max;
++		} else if (id->ext.br_max) {
++			br_nom = 250 * id->ext.br_max;
++			br_max = br_nom + br_nom * id->ext.br_min / 100;
++			br_min = br_nom - br_nom * id->ext.br_min / 100;
++		}
++	}
++
+ 	/* Set ethtool support from the compliance fields. */
+ 	if (id->base.e10g_base_sr)
+ 		phylink_set(support, 10000baseSR_Full);
+@@ -142,6 +158,11 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		phylink_set(support, 1000baseT_Full);
+ 	}
+ 
++	/* 1000Base-PX or 1000Base-BX10 */
++	if ((id->base.e_base_px || id->base.e_base_bx10) &&
++	    br_min <= 1300 && br_max >= 1200)
++		phylink_set(support, 1000baseX_Full);
++
+ 	switch (id->base.extended_cc) {
+ 	case 0x00: /* Unspecified */
+ 		break;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90076-From-Ken-Ma-make-marvell.com.patch b/target/linux/mvebu/patches-4.14/90076-From-Ken-Ma-make-marvell.com.patch
new file mode 100644
index 0000000..599e971
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90076-From-Ken-Ma-make-marvell.com.patch
@@ -0,0 +1,54 @@
+From b3c33dca1724609d1bebfa013224e9b3dbdf484d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 3 May 2018 14:31:41 +0200
+Subject: [PATCH 76/82] From: Ken Ma <make@marvell.com>
+
+pinctrl: armada-37xx: Correct mpp definitions
+
+This patch corrects below mpp definitions:
+ - The sdio_sb group is composed of 6 pins and not 5;
+ - The rgmii group contains pins mpp2[17:6] and not mpp2[19:6];
+ - Pin of group "pmic0" is mpp1[6] but not mpp1[16];
+ - Pin of group "pmic1" is mpp1[7] but not mpp1[17];
+ - A new group "smi" is added in A0 with 2 pins - mpp2[19:18], its
+   bitmask is bit4;
+ - Group "pcie1" has 3 pins in A0 - mpp2[5:3], its bit mask is
+   bit5 | bit9 | bit10 but not bit4;
+ - Group "ptp" has 3 pins in A0 as Z1, but its bitmask is changed to
+   bit11 | bit12 | bit13.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 9 +++++----
+ 1 file changed, 5 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index 44897d4b9d88..67a9a747a1b9 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -157,8 +157,8 @@ static struct armada_37xx_pin_group armada_37xx_nb_groups[] = {
+ 	PIN_GRP_GPIO("pwm1", 12, 1, BIT(4), "pwm"),
+ 	PIN_GRP_GPIO("pwm2", 13, 1, BIT(5), "pwm"),
+ 	PIN_GRP_GPIO("pwm3", 14, 1, BIT(6), "pwm"),
+-	PIN_GRP_GPIO("pmic1", 17, 1, BIT(7), "pmic"),
+-	PIN_GRP_GPIO("pmic0", 16, 1, BIT(8), "pmic"),
++	PIN_GRP_GPIO("pmic1", 7, 1, BIT(7), "pmic"),
++	PIN_GRP_GPIO("pmic0", 6, 1, BIT(8), "pmic"),
+ 	PIN_GRP_GPIO("i2c2", 2, 2, BIT(9), "i2c"),
+ 	PIN_GRP_GPIO("i2c1", 0, 2, BIT(10), "i2c"),
+ 	PIN_GRP_GPIO("spi_cs1", 17, 1, BIT(12), "spi"),
+@@ -182,8 +182,9 @@ static struct armada_37xx_pin_group armada_37xx_sb_groups[] = {
+ 	PIN_GRP_GPIO("usb2_drvvbus1", 1, 1, BIT(1), "drvbus"),
+ 	PIN_GRP_GPIO("sdio_sb", 24, 6, BIT(2), "sdio"),
+ 	PIN_GRP_GPIO("rgmii", 6, 12, BIT(3), "mii"),
+-	PIN_GRP_GPIO("pcie1", 3, 2, BIT(4), "pcie"),
+-	PIN_GRP_GPIO("ptp", 20, 3, BIT(5), "ptp"),
++	PIN_GRP_GPIO("smi", 18, 2, BIT(4), "smi"),
++	PIN_GRP_GPIO("pcie1", 3, 3, BIT(5) | BIT(9) | BIT(10), "pcie"),
++	PIN_GRP_GPIO("ptp", 20, 3, BIT(11) | BIT(12) | BIT(13), "ptp"),
+ 	PIN_GRP("ptp_clk", 21, 1, BIT(6), "ptp", "mii"),
+ 	PIN_GRP("ptp_trig", 22, 1, BIT(7), "ptp", "mii"),
+ 	PIN_GRP_GPIO_3("mii_col", 23, 1, BIT(8) | BIT(14), 0, BIT(8), BIT(14),
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90077-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch b/target/linux/mvebu/patches-4.14/90077-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch
new file mode 100644
index 0000000..6f683e4
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90077-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch
@@ -0,0 +1,87 @@
+From 69d9d5b8e4b086fee0ec4509c137b3d91aad9f1f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 3 May 2018 16:23:53 +0200
+Subject: [PATCH 77/82] net: dsa: mv88e6xxx: 88E6141/6341 SERDES support
+
+The 88E6141/6341 switches (also known as Topaz) have 1 SGMII lane,
+which can be configured the same way as the SERDES lane on 88E6390.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c   |  2 ++
+ drivers/net/dsa/mv88e6xxx/serdes.c | 20 ++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/serdes.h |  3 +++
+ 3 files changed, 25 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index bd74c45f5495..fae362020305 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -2426,6 +2426,7 @@ static const struct mv88e6xxx_ops mv88e6141_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.serdes_power = mv88e6341_serdes_power,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6161_ops = {
+@@ -2924,6 +2925,7 @@ static const struct mv88e6xxx_ops mv88e6341_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.serdes_power = mv88e6341_serdes_power,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6350_ops = {
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index f3c01119b3d1..bfecbdf5f64d 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -227,3 +227,23 @@ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 
+ 	return 0;
+ }
++
++int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
++{
++	int err;
++	u8 cmode;
++
++	if (port != 5)
++		return 0;
++
++	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
++	if (err)
++		return err;
++
++	if ((cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X) ||
++	     (cmode == MV88E6XXX_PORT_STS_CMODE_SGMII) ||
++	     (cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX))
++		return mv88e6390_serdes_sgmii(chip, MV88E6341_ADDR_SERDES, on);
++
++	return 0;
++}
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.h b/drivers/net/dsa/mv88e6xxx/serdes.h
+index 5c1cd6d8e9a5..87bfafc5fb29 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.h
++++ b/drivers/net/dsa/mv88e6xxx/serdes.h
+@@ -19,6 +19,8 @@
+ #define MV88E6352_ADDR_SERDES		0x0f
+ #define MV88E6352_SERDES_PAGE_FIBER	0x01
+ 
++#define MV88E6341_ADDR_SERDES		0x15
++
+ #define MV88E6390_PORT9_LANE0		0x09
+ #define MV88E6390_PORT9_LANE1		0x12
+ #define MV88E6390_PORT9_LANE2		0x13
+@@ -42,6 +44,7 @@
+ #define MV88E6390_SGMII_CONTROL_LOOPBACK	BIT(14)
+ #define MV88E6390_SGMII_CONTROL_PDOWN		BIT(11)
+ 
++int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ 
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90078-net-mvneta-Use-netif_receive_skb-instead-of-GRO-on-A.patch b/target/linux/mvebu/patches-4.14/90078-net-mvneta-Use-netif_receive_skb-instead-of-GRO-on-A.patch
new file mode 100644
index 0000000..a2618cd
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90078-net-mvneta-Use-netif_receive_skb-instead-of-GRO-on-A.patch
@@ -0,0 +1,45 @@
+From 1380aaa747666987f2caf71552e3d1ec9be223d6 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 3 May 2018 15:28:00 +0200
+Subject: [PATCH 78/82] net: mvneta: Use netif_receive_skb instead of GRO on
+ Armada 3720
+
+This solves slow receive on Armada 3720 when receiving fragmented
+frames.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 10 ++++++++--
+ 1 file changed, 8 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 54be20e3731d..94afad5cd33f 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -1963,7 +1963,10 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
+ 
+ 			skb->protocol = eth_type_trans(skb, dev);
+ 			mvneta_rx_csum(pp, rx_status, skb);
+-			napi_gro_receive(&port->napi, skb);
++			if (pp->neta_armada3700)
++				netif_receive_skb(skb);
++			else
++				napi_gro_receive(&port->napi, skb);
+ 
+ 			rcvd_pkts++;
+ 			rcvd_bytes += rx_bytes;
+@@ -2005,7 +2008,10 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
+ 
+ 		mvneta_rx_csum(pp, rx_status, skb);
+ 
+-		napi_gro_receive(&port->napi, skb);
++		if (pp->neta_armada3700)
++			netif_receive_skb(skb);
++		else
++			napi_gro_receive(&port->napi, skb);
+ 	}
+ 
+ 	if (rcvd_pkts) {
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90079-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch b/target/linux/mvebu/patches-4.14/90079-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch
new file mode 100644
index 0000000..421f7b0
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90079-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch
@@ -0,0 +1,450 @@
+From 4bbb5e688cafce661ccc0738d6c8a81eae8cd590 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Fri, 23 Mar 2018 17:37:12 +0100
+Subject: [PATCH 79/82] watchdog: Add support for Armada 37xx CPU watchdog
+
+This adds support for the CPU watchdog found on Marvell Armada 37xx
+SoCs.
+
+There are 4 counters which can be set as CPU watchdog counters.
+This driver uses the second counter (ID 1, counting from 0)
+(Marvell's Linux also uses second counter by default).
+In the future it could be adapted to use other counters, with
+definition in the device tree.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+Tested-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ .../bindings/watchdog/armada-37xx-wdt.txt     |  23 ++
+ drivers/watchdog/Kconfig                      |  11 +
+ drivers/watchdog/Makefile                     |   1 +
+ drivers/watchdog/armada_37xx_wdt.c            | 353 ++++++++++++++++++
+ 4 files changed, 388 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/watchdog/armada-37xx-wdt.txt
+ create mode 100644 drivers/watchdog/armada_37xx_wdt.c
+
+diff --git a/Documentation/devicetree/bindings/watchdog/armada-37xx-wdt.txt b/Documentation/devicetree/bindings/watchdog/armada-37xx-wdt.txt
+new file mode 100644
+index 000000000000..4ba9e40ad386
+--- /dev/null
++++ b/Documentation/devicetree/bindings/watchdog/armada-37xx-wdt.txt
+@@ -0,0 +1,23 @@
++* Armada 37xx CPU Watchdog Timer Controller
++
++Required properties:
++- compatible : must be "marvell,armada-3700-wdt"
++- reg : base physical address of the controller and length of memory mapped
++	region.
++- clocks : the clock feeding the watchdog timer. See clock-bindings.txt
++- marvell,system-controller : reference to syscon node for the CPU Miscellaneous
++	Registers
++
++Example:
++
++	cpu_misc: system-controller@d000 {
++		compatible = "syscon", "simple-mfd";
++		reg = <0xd000 0x1000>;
++	};
++
++	wdt: watchdog-timer@8300 {
++		compatible = "marvell,armada-3700-wdt";
++		reg = <0x8300 0x40>;
++		marvell,system-controller = <&cpu_misc>;
++		clocks = <&xtalclk>;
++	};
+diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
+index 3ece1335ba84..4ca96c5a10bc 100644
+--- a/drivers/watchdog/Kconfig
++++ b/drivers/watchdog/Kconfig
+@@ -255,6 +255,17 @@ config ARM_SBSA_WATCHDOG
+ 	  To compile this driver as module, choose M here: The module
+ 	  will be called sbsa_gwdt.
+ 
++config ARMADA_37XX_WATCHDOG
++	tristate "Armada 37xx watchdog"
++	depends on ARCH_MVEBU || COMPILE_TEST
++	select MFD_SYSCON
++	select WATCHDOG_CORE
++	help
++	  Say Y here to include support for the watchdog timer found on
++	  Marvell Armada 37xx SoCs.
++	  To compile this driver as a module, choose M here: the
++	  module will be called armada_37xx_wdt.
++
+ config ASM9260_WATCHDOG
+ 	tristate "Alphascale ASM9260 watchdog"
+ 	depends on MACH_ASM9260 || COMPILE_TEST
+diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
+index 715a21078e0c..eae72c5fa1e0 100644
+--- a/drivers/watchdog/Makefile
++++ b/drivers/watchdog/Makefile
+@@ -38,6 +38,7 @@ obj-$(CONFIG_USBPCWATCHDOG) += pcwd_usb.o
+ # ARM Architecture
+ obj-$(CONFIG_ARM_SP805_WATCHDOG) += sp805_wdt.o
+ obj-$(CONFIG_ARM_SBSA_WATCHDOG) += sbsa_gwdt.o
++obj-$(CONFIG_ARMADA_37XX_WATCHDOG) += armada_37xx_wdt.o
+ obj-$(CONFIG_ASM9260_WATCHDOG) += asm9260_wdt.o
+ obj-$(CONFIG_AT91RM9200_WATCHDOG) += at91rm9200_wdt.o
+ obj-$(CONFIG_AT91SAM9X_WATCHDOG) += at91sam9_wdt.o
+diff --git a/drivers/watchdog/armada_37xx_wdt.c b/drivers/watchdog/armada_37xx_wdt.c
+new file mode 100644
+index 000000000000..24af496103c6
+--- /dev/null
++++ b/drivers/watchdog/armada_37xx_wdt.c
+@@ -0,0 +1,353 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * Watchdog driver for Marvell Armada 37xx SoCs
++ *
++ * Author: Marek Behun <marek.behun@nic.cz>
++ */
++
++#include <asm/io.h>
++#include <linux/clk.h>
++#include <linux/err.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/mfd/syscon.h>
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/of.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/regmap.h>
++#include <linux/types.h>
++#include <linux/watchdog.h>
++
++/*
++ * There are four counters that can be used for watchdog on Armada 37xx.
++ * The addresses for counter control registers are register base plus ID*0x10,
++ * where ID is 0, 1, 2 or 3.
++ * In this driver we use ID 1. Marvell's Linux also uses this ID by default,
++ * and the U-Boot driver written simultaneosly by the same author as this
++ * driver also uses ID 1.
++ * Maybe in the future we could change this driver to support other counters,
++ * depending on the device tree, but I don't think this is necessary.
++ *
++ * Note that CNTR_ID cannot be 3, because the third counter is an increment
++ * counter, and this driver is written to support decrementing counters only.
++ */
++
++/* relative to cpu_misc */
++#define WDT_TIMER_SELECT		0x64
++#define WDT_TIMER_SELECT_MASK		0xf
++#define WDT_TIMER_SELECT_VAL		BIT(CNTR_ID)
++
++/* relative to reg */
++#define CNTR_ID				1
++
++#define CNTR_CTRL			(CNTR_ID * 0x10)
++#define CNTR_CTRL_ENABLE		0x0001
++#define CNTR_CTRL_ACTIVE		0x0002
++#define CNTR_CTRL_MODE_MASK		0x000c
++#define CNTR_CTRL_MODE_ONESHOT		0x0000
++#define CNTR_CTRL_PRESCALE_MASK		0xff00
++#define CNTR_CTRL_PRESCALE_MIN		2
++#define CNTR_CTRL_PRESCALE_SHIFT	8
++
++#define CNTR_COUNT_LOW			(CNTR_CTRL + 0x4)
++#define CNTR_COUNT_HIGH			(CNTR_CTRL + 0x8)
++
++#define WATCHDOG_TIMEOUT		120
++
++static unsigned int timeout = WATCHDOG_TIMEOUT;
++module_param(timeout, int, 0);
++MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds (default="
++			  __MODULE_STRING(WATCHDOG_TIMEOUT) ")");
++
++static bool nowayout = WATCHDOG_NOWAYOUT;
++module_param(nowayout, bool, 0);
++MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default="
++			   __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
++
++struct armada_37xx_watchdog {
++	struct watchdog_device wdt;
++	struct regmap *cpu_misc;
++	void __iomem *reg;
++	u64 timeout; /* in clock ticks */
++	unsigned long clk_rate;
++	struct clk *clk;
++};
++
++static u64 get_counter_value(struct armada_37xx_watchdog *dev)
++{
++	u64 val;
++
++	val = readl(dev->reg + CNTR_COUNT_HIGH);
++	val = (val << 32) | readl(dev->reg + CNTR_COUNT_LOW);
++
++	return val;
++}
++
++static void set_counter_value(struct armada_37xx_watchdog *dev)
++{
++	writel(dev->timeout & 0xffffffff, dev->reg + CNTR_COUNT_LOW);
++	writel(dev->timeout >> 32, dev->reg + CNTR_COUNT_HIGH);
++}
++
++static void armada_37xx_wdt_counter_enable(struct armada_37xx_watchdog *dev)
++{
++	u32 reg;
++
++	reg = readl(dev->reg + CNTR_CTRL);
++	reg |= CNTR_CTRL_ENABLE;
++	writel(reg, dev->reg + CNTR_CTRL);
++}
++
++static void armada_37xx_wdt_counter_disable(struct armada_37xx_watchdog *dev)
++{
++	u32 reg;
++
++	reg = readl(dev->reg + CNTR_CTRL);
++	reg &= ~CNTR_CTRL_ENABLE;
++	writel(reg, dev->reg + CNTR_CTRL);
++}
++
++static int armada_37xx_wdt_ping(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	armada_37xx_wdt_counter_disable(dev);
++	set_counter_value(dev);
++	armada_37xx_wdt_counter_enable(dev);
++
++	return 0;
++}
++
++static unsigned int armada_37xx_wdt_get_timeleft(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++	unsigned int res;
++
++	res = get_counter_value(dev) * CNTR_CTRL_PRESCALE_MIN / dev->clk_rate;
++
++	return res;
++}
++
++static int armada_37xx_wdt_set_timeout(struct watchdog_device *wdt,
++				       unsigned int timeout)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	wdt->timeout = timeout;
++
++	/*
++	 * Compute the timeout in clock rate. We use smallest possible prescaler,
++	 * which divides the clock rate by 2 (CNTR_CTRL_PRESCALE_MIN).
++	 */
++	dev->timeout = (u64)dev->clk_rate * timeout / CNTR_CTRL_PRESCALE_MIN;
++
++	return 0;
++}
++
++static bool armada_37xx_wdt_is_running(struct armada_37xx_watchdog *dev)
++{
++	u32 reg;
++
++	regmap_read(dev->cpu_misc, WDT_TIMER_SELECT, &reg);
++	if ((reg & WDT_TIMER_SELECT_MASK) != WDT_TIMER_SELECT_VAL)
++		return false;
++
++	reg = readl(dev->reg + CNTR_CTRL);
++	return !!(reg & CNTR_CTRL_ACTIVE);
++}
++
++static int armada_37xx_wdt_start(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++	u32 reg;
++
++	reg = readl(dev->reg + CNTR_CTRL);
++
++	if (reg & CNTR_CTRL_ACTIVE)
++		return -EBUSY;
++
++	/* set mode */
++	reg = (reg & ~CNTR_CTRL_MODE_MASK) | CNTR_CTRL_MODE_ONESHOT;
++
++	/* set prescaler to the min value of 2 */
++	reg &= ~CNTR_CTRL_PRESCALE_MASK;
++	reg |= CNTR_CTRL_PRESCALE_MIN << CNTR_CTRL_PRESCALE_SHIFT;
++
++	writel(reg, dev->reg + CNTR_CTRL);
++
++	set_counter_value(dev);
++
++	regmap_write(dev->cpu_misc, WDT_TIMER_SELECT, WDT_TIMER_SELECT_VAL);
++	armada_37xx_wdt_counter_enable(dev);
++
++	return 0;
++}
++
++static int armada_37xx_wdt_stop(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	armada_37xx_wdt_counter_disable(dev);
++	regmap_write(dev->cpu_misc, WDT_TIMER_SELECT, 0);
++
++	return 0;
++}
++
++static const struct watchdog_info armada_37xx_wdt_info = {
++	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,
++	.identity = "Armada 37xx Watchdog",
++};
++
++static const struct watchdog_ops armada_37xx_wdt_ops = {
++	.owner = THIS_MODULE,
++	.start = armada_37xx_wdt_start,
++	.stop = armada_37xx_wdt_stop,
++	.ping = armada_37xx_wdt_ping,
++	.set_timeout = armada_37xx_wdt_set_timeout,
++	.get_timeleft = armada_37xx_wdt_get_timeleft,
++};
++
++static int armada_37xx_wdt_probe(struct platform_device *pdev)
++{
++	struct armada_37xx_watchdog *dev;
++	struct resource *res;
++	struct regmap *regmap;
++	int ret;
++
++	dev = devm_kzalloc(&pdev->dev, sizeof(struct armada_37xx_watchdog),
++			   GFP_KERNEL);
++	if (!dev)
++		return -ENOMEM;
++
++	dev->wdt.info = &armada_37xx_wdt_info;
++	dev->wdt.ops = &armada_37xx_wdt_ops;
++	dev->wdt.min_timeout = 1;
++
++	regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
++						 "marvell,system-controller");
++	if (IS_ERR(regmap))
++		return PTR_ERR(regmap);
++	dev->cpu_misc = regmap;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res)
++		return -ENODEV;
++	dev->reg = devm_ioremap(&pdev->dev, res->start, resource_size(res));
++
++	/* init clock */
++	dev->clk = devm_clk_get(&pdev->dev, NULL);
++	if (IS_ERR(dev->clk))
++		return PTR_ERR(dev->clk);
++
++	ret = clk_prepare_enable(dev->clk);
++	if (ret)
++		return ret;
++
++	dev->clk_rate = clk_get_rate(dev->clk);
++
++	/*
++	 * Since the timeout in seconds is given as 32 bit unsigned int, and
++	 * the counters hold 64 bit values, even after multiplication by clock
++	 * rate the counter can hold timeout of UINT_MAX seconds.
++	 */
++	dev->wdt.min_timeout = 0;
++	dev->wdt.max_timeout = UINT_MAX;
++	dev->wdt.parent = &pdev->dev;
++
++	/* default value, possibly override by module parameter or dtb */
++	dev->wdt.timeout = WATCHDOG_TIMEOUT;
++	watchdog_init_timeout(&dev->wdt, timeout, &pdev->dev);
++
++	platform_set_drvdata(pdev, &dev->wdt);
++	watchdog_set_drvdata(&dev->wdt, dev);
++
++	armada_37xx_wdt_set_timeout(&dev->wdt, dev->wdt.timeout);
++
++	if (armada_37xx_wdt_is_running(dev))
++		set_bit(WDOG_HW_RUNNING, &dev->wdt.status);
++	else
++		armada_37xx_wdt_stop(&dev->wdt);
++
++	watchdog_set_nowayout(&dev->wdt, nowayout);
++	ret = watchdog_register_device(&dev->wdt);
++	if (ret)
++		goto disable_clk;
++
++	dev_info(&pdev->dev, "Initial timeout %d sec%s\n",
++		 dev->wdt.timeout, nowayout ? ", nowayout" : "");
++
++	return 0;
++
++disable_clk:
++	clk_disable_unprepare(dev->clk);
++	return ret;
++}
++
++static int armada_37xx_wdt_remove(struct platform_device *pdev)
++{
++	struct watchdog_device *wdt = platform_get_drvdata(pdev);
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	watchdog_unregister_device(wdt);
++	clk_disable_unprepare(dev->clk);
++	return 0;
++}
++
++static void armada_37xx_wdt_shutdown(struct platform_device *pdev)
++{
++	struct watchdog_device *wdt = platform_get_drvdata(pdev);
++
++	armada_37xx_wdt_stop(wdt);
++}
++
++static int __maybe_unused armada_37xx_wdt_suspend(struct device *dev)
++{
++	struct watchdog_device *wdt = dev_get_drvdata(dev);
++
++	return armada_37xx_wdt_stop(wdt);
++}
++
++static int __maybe_unused armada_37xx_wdt_resume(struct device *dev)
++{
++	struct watchdog_device *wdt = dev_get_drvdata(dev);
++
++	if (watchdog_active(wdt))
++		return armada_37xx_wdt_start(wdt);
++
++	return 0;
++}
++
++static const struct dev_pm_ops armada_37xx_wdt_dev_pm_ops = {
++	SET_SYSTEM_SLEEP_PM_OPS(armada_37xx_wdt_suspend,
++				armada_37xx_wdt_resume)
++};
++
++#ifdef CONFIG_OF
++static const struct of_device_id armada_37xx_wdt_match[] = {
++	{ .compatible = "marvell,armada-3700-wdt", },
++	{},
++};
++MODULE_DEVICE_TABLE(of, armada_37xx_wdt_match);
++#endif
++
++static struct platform_driver armada_37xx_wdt_driver = {
++	.probe		= armada_37xx_wdt_probe,
++	.remove		= armada_37xx_wdt_remove,
++	.shutdown	= armada_37xx_wdt_shutdown,
++	.driver		= {
++		.name	= "armada_37xx_wdt",
++		.of_match_table = of_match_ptr(armada_37xx_wdt_match),
++		.pm = &armada_37xx_wdt_dev_pm_ops,
++	},
++};
++
++module_platform_driver(armada_37xx_wdt_driver);
++
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
++MODULE_DESCRIPTION("Armada 37xx CPU Watchdog");
++
++MODULE_LICENSE("GPL v2");
++MODULE_ALIAS("platform:armada_37xx_wdt");
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90080-arm64-dts-marvell-armada-37xx-add-nodes-to-support-w.patch b/target/linux/mvebu/patches-4.14/90080-arm64-dts-marvell-armada-37xx-add-nodes-to-support-w.patch
new file mode 100644
index 0000000..5582d02
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90080-arm64-dts-marvell-armada-37xx-add-nodes-to-support-w.patch
@@ -0,0 +1,47 @@
+From c29f09496a40351a708e45e1ab6a67095d329796 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Tue, 5 Jun 2018 16:36:40 +0200
+Subject: [PATCH 80/82] arm64: dts: marvell: armada-37xx: add nodes to support
+ watchdog
+
+This adds the system controller node for CPU Miscellaneous Registers
+(which is needed for the watchdog node) and the watchdog node.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index 8cd43ce38571..8388793f10ac 100644
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -101,6 +101,11 @@
+ 			/* 32M internal register @ 0xd000_0000 */
+ 			ranges = <0x0 0x0 0xd0000000 0x2000000>;
+ 
++			cpu_misc: system-controller@d000 {
++				compatible = "syscon", "simple-mfd";
++				reg = <0xd000 0x1000>;
++			};
++
+ 			spi0: spi@10600 {
+ 				compatible = "marvell,armada-3700-spi";
+ 				#address-cells = <1>;
+@@ -142,6 +147,13 @@
+ 				status = "disabled";
+ 			};
+ 
++			wdt: watchdog-timer@8300 {
++				compatible = "marvell,armada-3700-wdt";
++				reg = <0x8300 0x40>;
++				marvell,system-controller = <&cpu_misc>;
++				clocks = <&xtalclk>;
++			};
++
+ 			nb_periph_clk: nb-periph-clk@13000 {
+ 				compatible = "marvell,armada-3700-periph-clock-nb";
+ 				reg = <0x13000 0x100>;
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90081-drivers-gpio-Add-support-for-Turris-Mox-SFP-cage-mod.patch b/target/linux/mvebu/patches-4.14/90081-drivers-gpio-Add-support-for-Turris-Mox-SFP-cage-mod.patch
new file mode 100644
index 0000000..370b7b6
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90081-drivers-gpio-Add-support-for-Turris-Mox-SFP-cage-mod.patch
@@ -0,0 +1,364 @@
+From 98c4a01301a3223620b767dc1b3b81c80f41ce4d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Mon, 23 Jul 2018 02:33:42 +0200
+Subject: [PATCH 81/82] drivers: gpio: Add support for Turris Mox SFP cage
+ module GPIOs
+
+The SFP GPIOs on the SFP cage module of Turris Mox can be configured
+via SPI bus (the same one which describes the topology of Mox modules).
+
+This driver finds out if the SFP cage module index (if it is present)
+and then exports GPIOs which can be used by phylink.
+
+It also creates a sysfs file from which module topology can be read.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ .../bindings/gpio/gpio-turris-mox-sfp.txt     |  19 ++
+ drivers/gpio/Kconfig                          |   6 +
+ drivers/gpio/Makefile                         |   1 +
+ drivers/gpio/gpio-turris-mox-sfp.c            | 277 ++++++++++++++++++
+ 4 files changed, 303 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/gpio/gpio-turris-mox-sfp.txt
+ create mode 100644 drivers/gpio/gpio-turris-mox-sfp.c
+
+diff --git a/Documentation/devicetree/bindings/gpio/gpio-turris-mox-sfp.txt b/Documentation/devicetree/bindings/gpio/gpio-turris-mox-sfp.txt
+new file mode 100644
+index 000000000000..19cb4320faf4
+--- /dev/null
++++ b/Documentation/devicetree/bindings/gpio/gpio-turris-mox-sfp.txt
+@@ -0,0 +1,19 @@
++Turris Mox SFP module GPIO Driver (over SPI)
++
++Required properties:
++ - compatible		: Should be "cznic,turris-mox-sfp".
++ - gpio-controller	: Marks the device node as a GPIO controller.
++ - #gpio-cells		: Should be two. For consumer use see gpio.txt.
++
++For other required and optional properties of SPI slave
++nodes please refer to ../spi/spi-bus.txt.
++
++Example:
++
++	gpio_sfp: gpio_sfp@0 {
++		compatible = "cznic,turris-mox-sfp";
++		gpio-controller;
++		#gpio-cells = <2>;
++		reg = <1>;
++		spi-max-frequency = <50000000>;
++	};
+diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
+index 3f80f167ed56..697c14d07881 100644
+--- a/drivers/gpio/Kconfig
++++ b/drivers/gpio/Kconfig
+@@ -1268,6 +1268,12 @@ config GPIO_MC33880
+ 	  SPI driver for Freescale MC33880 high-side/low-side switch.
+ 	  This provides GPIO interface supporting inputs and outputs.
+ 
++config GPIO_MOX_SFP
++	tristate "Turris Mox SFP GPIO expander"
++	help
++	  This is the driver needed for configuring the SFP cage found
++	  on Turris Mox SFP module.
++
+ config GPIO_PISOSR
+ 	tristate "Generic parallel-in/serial-out shift register"
+ 	help
+diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
+index 8a2dfba3b231..20b24b8fd8b2 100644
+--- a/drivers/gpio/Makefile
++++ b/drivers/gpio/Makefile
+@@ -95,6 +95,7 @@ obj-$(CONFIG_GPIO_PCA953X)	+= gpio-pca953x.o
+ obj-$(CONFIG_GPIO_PCF857X)	+= gpio-pcf857x.o
+ obj-$(CONFIG_GPIO_PCH)		+= gpio-pch.o
+ obj-$(CONFIG_GPIO_PCI_IDIO_16)	+= gpio-pci-idio-16.o
++obj-$(CONFIG_GPIO_MOX_SFP)	+= gpio-turris-mox-sfp.o
+ obj-$(CONFIG_GPIO_PISOSR)	+= gpio-pisosr.o
+ obj-$(CONFIG_GPIO_PL061)	+= gpio-pl061.o
+ obj-$(CONFIG_GPIO_PXA)		+= gpio-pxa.o
+diff --git a/drivers/gpio/gpio-turris-mox-sfp.c b/drivers/gpio/gpio-turris-mox-sfp.c
+new file mode 100644
+index 000000000000..d471eea3f9f2
+--- /dev/null
++++ b/drivers/gpio/gpio-turris-mox-sfp.c
+@@ -0,0 +1,277 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ *  Turris Mox SFP - GPIOs on the SFP cage found on Turris Mox SFP module
++ *
++ *  Copyright (C) 2018 Marek Behun <marek.behun@nic.cz>
++ */
++
++#include <linux/gpio/consumer.h>
++#include <linux/init.h>
++#include <linux/mutex.h>
++#include <linux/spi/spi.h>
++#include <linux/gpio.h>
++#include <linux/of_gpio.h>
++#include <linux/slab.h>
++#include <linux/module.h>
++
++struct mox_sfp_chip {
++	struct gpio_chip	gpio_chip;
++	struct mutex		lock;
++	u8			state;
++	int			sfp_idx;
++	struct gpio_desc	*gpiod_oe;
++	char			module_topology[128];
++};
++
++static int mox_sfp_find(struct mox_sfp_chip *chip) {
++	static const char hex[16] = "0123456789ABCDEF";
++	static const char *module_names[] = {
++		[0x0] = "0x00 ",
++		[0x1] = "sfp ",
++		[0x2] = "pci ",
++		[0x3] = "topaz ",
++		[0x4] = "peridot ",
++	};
++	struct spi_transfer t;
++	u8 rx[10], tx[10];
++	size_t len = 0;
++	int i, res;
++
++	memset(rx, 0, 10);
++	memset(tx, 0, 10);
++
++	memset(&t, 0, sizeof(t));
++
++	t.rx_buf = rx;
++	t.tx_buf = tx;
++	t.len = 10;
++
++	res = spi_sync_transfer(to_spi_device(chip->gpio_chip.parent), &t, 1);
++	if (res < 0)
++		return res;
++
++	if (rx[0] != 0xff && rx[0] != 0x00 && rx[0] != 0x10)
++		return -ENODEV;
++
++	chip->sfp_idx = 0;
++
++	for (i = 1; i < 10; ++i) {
++		int midx = rx[i] & 0xf, stridx = 0;
++		size_t mlen;
++
++		if (!chip->sfp_idx && midx == 0x1)
++			chip->sfp_idx = i;
++
++		if (0x1 <= midx && midx <= 0x4)
++			stridx = midx;
++
++		mlen = strlen(module_names[stridx]);
++
++		if (len + mlen < sizeof(chip->module_topology)) {
++			strcpy(&chip->module_topology[len],
++			       module_names[stridx]);
++
++			if (stridx != midx)
++				chip->module_topology[len+3] = hex[midx];
++
++			len += mlen;
++		}
++	}
++	chip->module_topology[len > 0 ? len - 1 : 0] = '\0';
++
++	return 0;
++}
++
++static int mox_sfp_do_spi(struct mox_sfp_chip *chip) {
++	struct spi_transfer t;
++	u8 rx[10], tx[10], val;
++	int res;
++
++	val = (chip->state >> 3);
++
++	memset(tx, 0, 10);
++	tx[chip->sfp_idx] = val;
++
++	memset(&t, 0, sizeof(t));
++	t.rx_buf = rx;
++	t.tx_buf = tx;
++	t.len = 10;
++
++	res = spi_sync_transfer(to_spi_device(chip->gpio_chip.parent), &t, 1);
++	if (res < 0)
++		return res;
++
++	if ((rx[0] != 0xff && rx[0] != 0x00 && rx[0] != 0x10)
++	    || (rx[chip->sfp_idx] & 0xf) != 0x1)
++		return -ENODEV;
++
++	chip->state = (chip->state & ~7) | ((rx[chip->sfp_idx] >> 4) & 7);
++
++	return 0;
++}
++
++static int mox_sfp_get_value(struct gpio_chip *gc, unsigned offset)
++{
++	struct mox_sfp_chip *chip = gpiochip_get_data(gc);
++	int ret;
++
++	if (offset <= 2) {
++		mutex_lock(&chip->lock);
++		ret = mox_sfp_do_spi(chip);
++		mutex_unlock(&chip->lock);
++
++		if (ret < 0)
++			return ret;
++	}
++
++	return (chip->state >> offset) & 1;
++}
++
++static void mox_sfp_set_value(struct gpio_chip *gc,
++		unsigned offset, int val)
++{
++	struct mox_sfp_chip *chip = gpiochip_get_data(gc);
++
++	if (offset <= 2)
++		return;
++
++	mutex_lock(&chip->lock);
++	if (val)
++		chip->state |= (1 << offset);
++	else
++		chip->state &= ~(1 << offset);
++
++	(void) mox_sfp_do_spi(chip);
++
++	mutex_unlock(&chip->lock);
++}
++
++static int mox_sfp_get_direction(struct gpio_chip *gc, unsigned offset)
++{
++	return offset <= 2;
++}
++
++static int mox_sfp_direction_input(struct gpio_chip *gc, unsigned offset)
++{
++	if (offset > 2)
++		return -EINVAL;
++	return 0;
++}
++
++static int mox_sfp_direction_output(struct gpio_chip *gc,
++		unsigned offset, int val)
++{
++	if (offset <= 2 || offset > 4)
++		return -EINVAL;
++	mox_sfp_set_value(gc, offset, val);
++	return 0;
++}
++
++static ssize_t module_topology_show(struct device *dev,
++				    struct device_attribute *attr, char *buf)
++{
++	struct mox_sfp_chip *chip = dev_get_drvdata(dev);
++	return sprintf(buf, "%s\n", chip->module_topology);
++}
++static DEVICE_ATTR_RO(module_topology);
++
++static int mox_sfp_probe(struct spi_device *spi)
++{
++	struct mox_sfp_chip *chip;
++	int ret;
++
++	spi->max_speed_hz = 20000000;
++	spi->bits_per_word = 8;
++
++	ret = spi_setup(spi);
++	if (ret < 0)
++		return ret;
++
++	chip = devm_kzalloc(&spi->dev, sizeof(*chip), GFP_KERNEL);
++	if (!chip)
++		return -ENOMEM;
++
++	chip->gpio_chip.parent = &spi->dev;
++
++	ret = mox_sfp_find(chip);
++	if (ret < 0) {
++		dev_err(&spi->dev, "Failed finding MOX bus: %d\n", ret);
++		return ret;
++	}
++
++	device_create_file(&spi->dev, &dev_attr_module_topology);
++	spi_set_drvdata(spi, chip);
++	mutex_init(&chip->lock);
++
++	if (chip->sfp_idx) {
++		chip->gpiod_oe = devm_gpiod_get_optional(&spi->dev, "enable",
++							 GPIOD_OUT_LOW);
++		if (IS_ERR(chip->gpiod_oe)) {
++			ret = PTR_ERR(chip->gpiod_oe);
++			goto exit_destroy;
++		}
++
++		gpiod_set_value_cansleep(chip->gpiod_oe, 1);
++
++		chip->gpio_chip.label = spi->modalias;
++		chip->gpio_chip.get_direction = mox_sfp_get_direction;
++		chip->gpio_chip.direction_input = mox_sfp_direction_input;
++		chip->gpio_chip.direction_output = mox_sfp_direction_output;
++		chip->gpio_chip.get = mox_sfp_get_value;
++		chip->gpio_chip.set = mox_sfp_set_value;
++		chip->gpio_chip.base = -1;
++
++		chip->gpio_chip.ngpio = 5;
++
++		chip->gpio_chip.can_sleep = true;
++		chip->gpio_chip.owner = THIS_MODULE;
++
++		ret = gpiochip_add_data(&chip->gpio_chip, chip);
++		if (ret)
++			goto exit_destroy;
++	}
++
++	return 0;
++
++exit_destroy:
++	device_remove_file(&spi->dev, &dev_attr_module_topology);
++	mutex_destroy(&chip->lock);
++
++	return ret;
++}
++
++static int mox_sfp_remove(struct spi_device *spi)
++{
++	struct mox_sfp_chip *chip = spi_get_drvdata(spi);
++
++	device_remove_file(&spi->dev, &dev_attr_module_topology);
++
++	if (chip->sfp_idx) {
++		gpiod_set_value_cansleep(chip->gpiod_oe, 0);
++		gpiochip_remove(&chip->gpio_chip);
++	}
++
++	mutex_destroy(&chip->lock);
++
++	return 0;
++}
++
++static const struct of_device_id mox_sfp_dt_ids[] = {
++	{ .compatible = "cznic,turris-mox-bus" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, mox_sfp_dt_ids);
++
++static struct spi_driver mox_sfp_driver = {
++	.driver = {
++		.name		= "mox-sfp",
++		.of_match_table	= mox_sfp_dt_ids,
++	},
++	.probe		= mox_sfp_probe,
++	.remove		= mox_sfp_remove,
++};
++module_spi_driver(mox_sfp_driver);
++
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
++MODULE_DESCRIPTION("GPIO configuration of the SFP cage found on Turris Mox");
++MODULE_LICENSE("GPL v2");
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/90082-ARM64-dts-marvell-Add-DTS-files-for-Turris-Mox-and-i.patch b/target/linux/mvebu/patches-4.14/90082-ARM64-dts-marvell-Add-DTS-files-for-Turris-Mox-and-i.patch
new file mode 100644
index 0000000..015ab7b
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90082-ARM64-dts-marvell-Add-DTS-files-for-Turris-Mox-and-i.patch
@@ -0,0 +1,864 @@
+From 5b96c4bb5aee068b4319a7a03a3a525c40c1386f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Mon, 23 Jul 2018 02:38:50 +0200
+Subject: [PATCH 82/82] ARM64: dts: marvell: Add DTS files for Turris Mox and
+ its modules
+
+This adds basic support for the Turris Mox board from CZ.NIC.
+
+Turris Mox is as modular router based on the Armada 3720 SOC (same as
+EspressoBin).
+
+The basic module can be extended by different modules. The device tree
+binary for the kernel can be dependent on which modules are connected,
+and in what order. Because of this, the board specific code creates
+in U-Boot a variable called module_topology, which carries this
+information.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ arch/arm64/boot/dts/marvell/Makefile          |   6 +
+ ...20-turris-mox-peridot-peridot-peridot.dtsi | 127 +++++++++++
+ ...rmada-3720-turris-mox-peridot-peridot.dtsi | 119 ++++++++++
+ .../armada-3720-turris-mox-peridot.dtsi       | 111 +++++++++
+ ...-turris-mox-sd-peridot-peridot-peridot.dts |   8 +
+ ...ada-3720-turris-mox-sd-peridot-peridot.dts |   8 +
+ .../armada-3720-turris-mox-sd-peridot.dts     |   8 +
+ .../marvell/armada-3720-turris-mox-sd-sfp.dts |   8 +
+ .../armada-3720-turris-mox-sd-topaz.dts       |   8 +
+ .../dts/marvell/armada-3720-turris-mox-sd.dts |  16 ++
+ .../marvell/armada-3720-turris-mox-sfp.dtsi   |  24 ++
+ .../marvell/armada-3720-turris-mox-topaz.dtsi |  75 ++++++
+ .../dts/marvell/armada-3720-turris-mox.dtsi   | 214 ++++++++++++++++++
+ 13 files changed, 732 insertions(+)
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-peridot-peridot-peridot.dtsi
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-peridot-peridot.dtsi
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-peridot.dtsi
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-peridot-peridot-peridot.dts
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-peridot-peridot.dts
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-peridot.dts
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-sfp.dts
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-topaz.dts
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd.dts
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sfp.dtsi
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-topaz.dtsi
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dtsi
+
+diff --git a/arch/arm64/boot/dts/marvell/Makefile b/arch/arm64/boot/dts/marvell/Makefile
+index 5633676fa9d0..fd5531a9dda4 100644
+--- a/arch/arm64/boot/dts/marvell/Makefile
++++ b/arch/arm64/boot/dts/marvell/Makefile
+@@ -6,6 +6,12 @@ dtb-$(CONFIG_ARCH_BERLIN) += berlin4ct-stb.dtb
+ # Mvebu SoC Family
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-espressobin.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox-sd-peridot.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox-sd-peridot-peridot.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox-sd-peridot-peridot-peridot.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox-sd-sfp.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox-sd-topaz.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox-sd.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-7040-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-8040-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-8040-mcbin.dtb
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-peridot-peridot-peridot.dtsi b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-peridot-peridot-peridot.dtsi
+new file mode 100644
+index 000000000000..8bf54e7a0796
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-peridot-peridot-peridot.dtsi
+@@ -0,0 +1,127 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board Topaz switch module
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox-peridot-peridot.dtsi"
++
++&switch0 {
++	ports {
++		switch0port10: port@10 {
++			link = <&switch1port9 &switch2port9>;
++		};
++	};
++};
++
++&switch1 {
++	ports {
++		switch1port10: port@10 {
++			reg = <10>;
++			label = "dsa";
++			phy-mode = "2500base-x";
++			link = <&switch2port9>;
++		};
++	};
++};
++
++&mdio {
++	switch2: switch2@12 {
++		compatible = "marvell,mv88e6190";
++		#address-cells = <1>;
++		#size-cells = <0>;
++		reg = <0x12>;
++
++		dsa,member = <0 2>;
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <1>;
++				label = "lan17";
++				phy-handle = <&switch2phy1>;
++			};
++
++			port@2 {
++				reg = <2>;
++				label = "lan18";
++				phy-handle = <&switch2phy2>;
++			};
++
++			port@3 {
++				reg = <3>;
++				label = "lan19";
++				phy-handle = <&switch2phy3>;
++			};
++
++			port@4 {
++				reg = <4>;
++				label = "lan20";
++				phy-handle = <&switch2phy4>;
++			};
++
++			port@5 {
++				reg = <5>;
++				label = "lan21";
++				phy-handle = <&switch2phy5>;
++			};
++
++			port@6 {
++				reg = <6>;
++				label = "lan22";
++				phy-handle = <&switch2phy6>;
++			};
++
++			port@7 {
++				reg = <7>;
++				label = "lan23";
++				phy-handle = <&switch2phy7>;
++			};
++
++			port@8 {
++				reg = <8>;
++				label = "lan24";
++				phy-handle = <&switch2phy8>;
++			};
++
++			switch2port9: port@9 {
++				reg = <9>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch1port10 &switch0port10>;
++			};
++		};
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch2phy1: switch2phy1@1 {
++				reg = <0x1>;
++			};
++			switch2phy2: switch2phy2@2 {
++				reg = <0x2>;
++			};
++			switch2phy3: switch2phy3@3 {
++				reg = <0x3>;
++			};
++			switch2phy4: switch2phy4@4 {
++				reg = <0x4>;
++			};
++			switch2phy5: switch2phy5@5 {
++				reg = <0x5>;
++			};
++			switch2phy6: switch2phy6@6 {
++				reg = <0x6>;
++			};
++			switch2phy7: switch2phy7@7 {
++				reg = <0x7>;
++			};
++			switch2phy8: switch2phy8@8 {
++				reg = <0x8>;
++			};
++		};
++	};
++};
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-peridot-peridot.dtsi b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-peridot-peridot.dtsi
+new file mode 100644
+index 000000000000..1c1b9e974352
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-peridot-peridot.dtsi
+@@ -0,0 +1,119 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board Topaz switch module
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox-peridot.dtsi"
++
++&switch0 {
++	ports {
++		switch0port10: port@10 {
++			reg = <10>;
++			label = "dsa";
++			phy-mode = "2500base-x";
++			link = <&switch1port9>;
++		};
++	};
++};
++
++&mdio {
++	switch1: switch1@11 {
++		compatible = "marvell,mv88e6190";
++		#address-cells = <1>;
++		#size-cells = <0>;
++		reg = <0x11>;
++
++		dsa,member = <0 1>;
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <1>;
++				label = "lan9";
++				phy-handle = <&switch1phy1>;
++			};
++
++			port@2 {
++				reg = <2>;
++				label = "lan10";
++				phy-handle = <&switch1phy2>;
++			};
++
++			port@3 {
++				reg = <3>;
++				label = "lan11";
++				phy-handle = <&switch1phy3>;
++			};
++
++			port@4 {
++				reg = <4>;
++				label = "lan12";
++				phy-handle = <&switch1phy4>;
++			};
++
++			port@5 {
++				reg = <5>;
++				label = "lan13";
++				phy-handle = <&switch1phy5>;
++			};
++
++			port@6 {
++				reg = <6>;
++				label = "lan14";
++				phy-handle = <&switch1phy6>;
++			};
++
++			port@7 {
++				reg = <7>;
++				label = "lan15";
++				phy-handle = <&switch1phy7>;
++			};
++
++			port@8 {
++				reg = <8>;
++				label = "lan16";
++				phy-handle = <&switch1phy8>;
++			};
++
++			switch1port9: port@9 {
++				reg = <9>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch0port10>;
++			};
++		};
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch1phy1: switch1phy1@1 {
++				reg = <0x1>;
++			};
++			switch1phy2: switch1phy2@2 {
++				reg = <0x2>;
++			};
++			switch1phy3: switch1phy3@3 {
++				reg = <0x3>;
++			};
++			switch1phy4: switch1phy4@4 {
++				reg = <0x4>;
++			};
++			switch1phy5: switch1phy5@5 {
++				reg = <0x5>;
++			};
++			switch1phy6: switch1phy6@6 {
++				reg = <0x6>;
++			};
++			switch1phy7: switch1phy7@7 {
++				reg = <0x7>;
++			};
++			switch1phy8: switch1phy8@8 {
++				reg = <0x8>;
++			};
++		};
++	};
++};
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-peridot.dtsi b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-peridot.dtsi
+new file mode 100644
+index 000000000000..f2dab1432bf7
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-peridot.dtsi
+@@ -0,0 +1,111 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board Topaz switch module
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++&eth1 {
++	status = "okay";
++	phy-mode = "1000base-x";
++	managed = "in-band-status";
++};
++
++&mdio {
++	switch0: switch0@10 {
++		compatible = "marvell,mv88e6190";
++		#address-cells = <1>;
++		#size-cells = <0>;
++		reg = <0x10>;
++
++		dsa,member = <0 0>;
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <1>;
++				label = "lan1";
++				phy-handle = <&switch0phy1>;
++			};
++
++			port@2 {
++				reg = <2>;
++				label = "lan2";
++				phy-handle = <&switch0phy2>;
++			};
++
++			port@3 {
++				reg = <3>;
++				label = "lan3";
++				phy-handle = <&switch0phy3>;
++			};
++
++			port@4 {
++				reg = <4>;
++				label = "lan4";
++				phy-handle = <&switch0phy4>;
++			};
++
++			port@5 {
++				reg = <5>;
++				label = "lan5";
++				phy-handle = <&switch0phy5>;
++			};
++
++			port@6 {
++				reg = <6>;
++				label = "lan6";
++				phy-handle = <&switch0phy6>;
++			};
++
++			port@7 {
++				reg = <7>;
++				label = "lan7";
++				phy-handle = <&switch0phy7>;
++			};
++
++			port@8 {
++				reg = <8>;
++				label = "lan8";
++				phy-handle = <&switch0phy8>;
++			};
++
++			port@9 {
++				reg = <9>;
++				label = "cpu";
++				ethernet = <&eth1>;
++			};
++		};
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch0phy1: switch0phy1@1 {
++				reg = <0x1>;
++			};
++			switch0phy2: switch0phy2@2 {
++				reg = <0x2>;
++			};
++			switch0phy3: switch0phy3@3 {
++				reg = <0x3>;
++			};
++			switch0phy4: switch0phy4@4 {
++				reg = <0x4>;
++			};
++			switch0phy5: switch0phy5@5 {
++				reg = <0x5>;
++			};
++			switch0phy6: switch0phy6@6 {
++				reg = <0x6>;
++			};
++			switch0phy7: switch0phy7@7 {
++				reg = <0x7>;
++			};
++			switch0phy8: switch0phy8@8 {
++				reg = <0x8>;
++			};
++		};
++	};
++};
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-peridot-peridot-peridot.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-peridot-peridot-peridot.dts
+new file mode 100644
+index 000000000000..4fae23cd8313
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-peridot-peridot-peridot.dts
+@@ -0,0 +1,8 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox-sd.dts"
++#include "armada-3720-turris-mox-peridot-peridot-peridot.dtsi"
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-peridot-peridot.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-peridot-peridot.dts
+new file mode 100644
+index 000000000000..72cdac876fdf
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-peridot-peridot.dts
+@@ -0,0 +1,8 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox-sd.dts"
++#include "armada-3720-turris-mox-peridot-peridot.dtsi"
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-peridot.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-peridot.dts
+new file mode 100644
+index 000000000000..43e8c9ff47c3
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-peridot.dts
+@@ -0,0 +1,8 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox-sd.dts"
++#include "armada-3720-turris-mox-peridot.dtsi"
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-sfp.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-sfp.dts
+new file mode 100644
+index 000000000000..ea7069571498
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-sfp.dts
+@@ -0,0 +1,8 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board 
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox-sd.dts"
++#include "armada-3720-turris-mox-sfp.dtsi"
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-topaz.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-topaz.dts
+new file mode 100644
+index 000000000000..ecfdfe51fd12
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-topaz.dts
+@@ -0,0 +1,8 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox-sd.dts"
++#include "armada-3720-turris-mox-topaz.dtsi"
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd.dts
+new file mode 100644
+index 000000000000..078ce5b8cfea
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd.dts
+@@ -0,0 +1,16 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board with SD card slot
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox.dtsi"
++
++&sdhci0 {
++	wp-inverted;
++	bus-width = <4>;
++	cd-gpios = <&gpionb 10 GPIO_ACTIVE_HIGH>;
++	vqmmc-supply = <&vsdc_reg>;
++	marvell,pad-type = "sd";
++	status = "okay";
++};
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sfp.dtsi b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sfp.dtsi
+new file mode 100644
+index 000000000000..6f881d383ce5
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sfp.dtsi
+@@ -0,0 +1,24 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board SFP cage module
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++/ {
++	sfp: sfp {
++		compatible = "sff,sfp+";
++		i2c-bus = <&i2c0>;
++		mod-def0-gpio = <&mox_spi_bus 2 GPIO_ACTIVE_LOW>;
++		los-gpio = <&mox_spi_bus 0 GPIO_ACTIVE_HIGH>;
++		tx-fault-gpio = <&mox_spi_bus 1 GPIO_ACTIVE_HIGH>;
++		tx-disable-gpio = <&mox_spi_bus 3 GPIO_ACTIVE_HIGH>;
++		rate-select0-gpio = <&mox_spi_bus 4 GPIO_ACTIVE_HIGH>;
++	};
++};
++
++&eth1 {
++	status = "okay";
++	phy-mode = "sgmii";
++	sfp = <&sfp>;
++	managed = "in-band-status";
++};
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-topaz.dtsi b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-topaz.dtsi
+new file mode 100644
+index 000000000000..f4b7dee142e6
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-topaz.dtsi
+@@ -0,0 +1,75 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board Topaz switch module
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++&eth1 {
++	status = "okay";
++	phy-mode = "1000base-x";
++	managed = "in-band-status";
++};
++
++&mdio {
++	switch0: switch0@2 {
++		compatible = "marvell,mv88e6141";
++		#address-cells = <1>;
++		#size-cells = <0>;
++		reg = <0x2>;
++
++		dsa,member = <0 0>;
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <1>;
++				label = "lan1";
++				phy-handle = <&switch0phy1>;
++			};
++
++			port@2 {
++				reg = <2>;
++				label = "lan2";
++				phy-handle = <&switch0phy2>;
++			};
++
++			port@3 {
++				reg = <3>;
++				label = "lan3";
++				phy-handle = <&switch0phy3>;
++			};
++
++			port@4 {
++				reg = <4>;
++				label = "lan4";
++				phy-handle = <&switch0phy4>;
++			};
++
++			port@5 {
++				reg = <5>;
++				label = "cpu";
++				ethernet = <&eth1>;
++			};
++		};
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch0phy1: switch0phy1@11 {
++				reg = <0x11>;
++			};
++			switch0phy2: switch0phy2@12 {
++				reg = <0x12>;
++			};
++			switch0phy3: switch0phy3@13 {
++				reg = <0x13>;
++			};
++			switch0phy4: switch0phy4@14 {
++				reg = <0x14>;
++			};
++		};
++	};
++};
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dtsi b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dtsi
+new file mode 100644
+index 000000000000..ec306f4a872f
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dtsi
+@@ -0,0 +1,214 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++/dts-v1/;
++
++#include <dt-bindings/gpio/gpio.h>
++#include <dt-bindings/input/input.h>
++#include "armada-372x.dtsi"
++
++/ {
++	model = "CZ.NIC Turris Mox Board";
++	compatible = "cznic,turris-mox", "marvell,armada3720", "marvell,armada3710";
++
++	aliases {
++		spi0 = &spi0;
++	};
++
++	chosen {
++		stdout-path = "serial0:115200n8";
++	};
++
++	memory@0 {
++		device_type = "memory";
++		reg = <0x00000000 0x00000000 0x00000000 0x20000000>;
++	};
++
++	leds {
++		compatible = "gpio-leds";
++		red {
++			gpios = <&gpiosb 21 GPIO_ACTIVE_LOW>;
++			linux,default-trigger = "heartbeat";
++		};
++	};
++
++	gpio_keys {
++		compatible = "gpio-keys";
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		button@0 {
++			label = "reset";
++			linux,code = <BTN_MISC>;
++			gpios = <&gpiosb 20 GPIO_ACTIVE_LOW>;
++			debounce-interval = <60>;
++		};
++	};
++
++	exp_usb3_vbus: usb3-vbus {
++		compatible = "regulator-fixed";
++		regulator-name = "usb3-vbus";
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++		enable-active-high;
++		regulator-always-on;
++		gpio = <&gpiosb 0 GPIO_ACTIVE_HIGH>;
++	};
++
++	usb3_phy: usb3-phy {
++		compatible = "usb-nop-xceiv";
++		vcc-supply = <&exp_usb3_vbus>;
++	};
++
++	vsdc_reg: regulator@1 {
++		compatible = "regulator-gpio";
++		regulator-name = "vsdc";
++		regulator-min-microvolt = <1800000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-boot-on;
++
++		gpios = <&gpiosb 23 GPIO_ACTIVE_HIGH>;
++		gpios-states = <0>;
++		states = <1800000 0x1
++			  3300000 0x0>;
++		enable-active-high;
++	};
++
++	vsdio_reg: regulator@2 {
++		compatible = "regulator-gpio";
++		regulator-name = "vsdio";
++		regulator-min-microvolt = <1800000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-boot-on;
++
++		gpios = <&gpiosb 22 GPIO_ACTIVE_HIGH>;
++		gpios-states = <0>;
++		states = <1800000 0x1
++			  3300000 0x0>;
++		enable-active-high;
++	};
++};
++
++&pinctrl_nb {
++	spi_cs1_pins: spi-cs1-pins {
++		groups = "spi_cs1";
++		function = "spi";
++	};
++
++	sdio0_pins: sdio0-pins {
++		groups = "sdio0";
++		function = "sdio";
++	};
++};
++
++&pinctrl_sb {
++	sdio_sb_pins: sdio-sb-pins {
++		groups = "sdio_sb";
++		function = "sdio";
++	};
++
++	smi_pins: smi-pins {
++		groups = "smi";
++		function = "smi";
++	};
++
++	pcie_pins: pcie1-pins {
++		groups = "pcie1";
++		function = "gpio";
++	};
++};
++
++&i2c0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&i2c1_pins>;
++	status = "okay";
++
++	rtc@6f {
++		compatible = "microchip,mcp7940x";
++		reg = <0x6f>;
++	};
++};
++
++&pcie0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pcie_pins>;
++	status = "okay";
++	max-link-speed = <2>;
++};
++
++&uart0 {
++	status = "okay";
++};
++
++&eth0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&rgmii_pins>;
++	phy-mode = "rgmii-id";
++	phy = <&phy1>;
++	status = "okay";
++};
++
++&mdio {
++	pinctrl-names = "default";
++	pinctrl-0 = <&smi_pins>;
++	status = "okay";
++
++	phy1: ethernet-phy@1 {
++		reg = <1>;
++	};
++};
++
++&sdhci1 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdio0_pins &sdio_sb_pins>;
++	non-removable;
++	bus-width = <4>;
++	marvell,pad-type = "sd";
++	vqmmc-supply = <&vsdio_reg>;
++	status = "okay";
++};
++
++&spi0 {
++	status = "okay";
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi_quad_pins &spi_cs1_pins>;
++
++	spi-flash@0 {
++		#address-cells = <1>;
++		#size-cells = <1>;
++		compatible = "jedec,spi-nor";
++		reg = <0>;
++		spi-max-frequency = <50000000>;
++
++		partition@0 {
++			label = "u-boot";
++			reg = <0x0 0x3f0000>;
++		};
++
++		partition@3f0000 {
++			label = "u-boot-env";
++			reg = <0x180000 0x10000>;
++		};
++
++		partition@400000 {
++			label = "Rescue system";
++			reg = <0x190000 0x670000>;
++		};
++	};
++
++	mox_spi_bus: mox_spi_bus@0 {
++		compatible = "cznic,turris-mox-bus";
++		gpio-controller;
++		#gpio-cells = <2>;
++		reg = <1>;
++		spi-max-frequency = <50000000>;
++	};
++};
++
++&usb3 {
++	status = "okay";
++	usb-phy = <&usb3_phy>;
++};
+-- 
+2.18.0
+
diff --git a/target/linux/mvebu/patches-4.14/9086-sfp-don-t-guess-support-from-connector-type.patch b/target/linux/mvebu/patches-4.14/9086-sfp-don-t-guess-support-from-connector-type.patch
new file mode 100644
index 0000000..1de9002
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/9086-sfp-don-t-guess-support-from-connector-type.patch
@@ -0,0 +1,57 @@
+From bcd854af26d87f8b5b874ec0a97b7fd1b7365223 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 29 Dec 2017 12:15:17 +0000
+Subject: [PATCH 86/90] sfp: don't guess support from connector type
+
+Don't try to guess the support mask from the connector type - this is
+mostly irrelevant to the speeds that the transceiver supports.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/sfp-bus.c | 29 -----------------------------
+ 1 file changed, 29 deletions(-)
+
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index f2513b9e00cd..43dfe187378f 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -175,35 +175,6 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		if (id->base.br_nominal >= 12)
+ 			phylink_set(support, 1000baseX_Full);
+ 	}
+-
+-	switch (id->base.connector) {
+-	case SFP_CONNECTOR_SC:
+-	case SFP_CONNECTOR_FIBERJACK:
+-	case SFP_CONNECTOR_LC:
+-	case SFP_CONNECTOR_MT_RJ:
+-	case SFP_CONNECTOR_MU:
+-	case SFP_CONNECTOR_OPTICAL_PIGTAIL:
+-		break;
+-
+-	case SFP_CONNECTOR_UNSPEC:
+-		if (id->base.e1000_base_t)
+-			break;
+-
+-	case SFP_CONNECTOR_SG: /* guess */
+-	case SFP_CONNECTOR_MPO_1X12:
+-	case SFP_CONNECTOR_MPO_2X16:
+-	case SFP_CONNECTOR_HSSDC_II:
+-	case SFP_CONNECTOR_COPPER_PIGTAIL:
+-	case SFP_CONNECTOR_NOSEPARATE:
+-	case SFP_CONNECTOR_MXC_2X16:
+-	default:
+-		/* a guess at the supported link modes */
+-		dev_warn(bus->sfp_dev,
+-			 "Guessing link modes, please report...\n");
+-		phylink_set(support, 1000baseT_Half);
+-		phylink_set(support, 1000baseT_Full);
+-		break;
+-	}
+ }
+ EXPORT_SYMBOL_GPL(sfp_parse_support);
+ 
+-- 
+2.17.1
+
-- 
2.18.0


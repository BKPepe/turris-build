From 77409341f7d1f95f068587e3a86ae4c4128c8b0f Mon Sep 17 00:00:00 2001
From: Michal Hrusecky <Michal@Hrusecky.net>
Date: Wed, 7 Mar 2018 17:10:32 +0100
Subject: [PATCH] mvebu: Basic MoX support

Adding basic support for CZ.NICs MoX board.

Signed-off-by: Michal Hrusecky <Michal@Hrusecky.net>
---
 target/linux/mvebu/config-4.14                |   2 +
 target/linux/mvebu/image/cortex-a53.mk        |  11 +
 .../0034-From-Ken-Ma-make-marvell.com.patch   |  54 ++
 ...v88e6xxx-88E6141-6341-SERDES-support.patch |  87 ++++
 ...-support-for-Turris-Mox-SFP-cage-mod.patch | 316 ++++++++++++
 ...etif_receive_skb-instead-of-GRO-on-A.patch |  45 ++
 ...support-for-Armada-37xx-CPU-watchdog.patch | 440 +++++++++++++++++
 ...no-uhs-voltage-cap-to-MMC-host-struc.patch |  57 +++
 ...l-Add-DTS-files-for-Turris-Mox-and-i.patch | 463 ++++++++++++++++++
 9 files changed, 1475 insertions(+)
 create mode 100644 target/linux/mvebu/patches-4.14/0034-From-Ken-Ma-make-marvell.com.patch
 create mode 100644 target/linux/mvebu/patches-4.14/0036-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/0037-drivers-gpio-Add-support-for-Turris-Mox-SFP-cage-mod.patch
 create mode 100644 target/linux/mvebu/patches-4.14/0038-net-mvneta-Use-netif_receive_skb-instead-of-GRO-on-A.patch
 create mode 100644 target/linux/mvebu/patches-4.14/0039-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch
 create mode 100644 target/linux/mvebu/patches-4.14/0040-drivers-mmc-Add-no-uhs-voltage-cap-to-MMC-host-struc.patch
 create mode 100644 target/linux/mvebu/patches-4.14/0041-ARM64-dts-marvell-Add-DTS-files-for-Turris-Mox-and-i.patch

diff --git a/target/linux/mvebu/config-4.14 b/target/linux/mvebu/config-4.14
index f5e9876..8c77688 100644
--- a/target/linux/mvebu/config-4.14
+++ b/target/linux/mvebu/config-4.14
@@ -34,6 +34,7 @@ CONFIG_ARM=y
 CONFIG_ARMADA_370_CLK=y
 CONFIG_ARMADA_370_XP_IRQ=y
 CONFIG_ARMADA_370_XP_TIMER=y
+CONFIG_ARMADA_37XX_WATCHDOG=y
 CONFIG_ARMADA_38X_CLK=y
 CONFIG_ARMADA_THERMAL=y
 CONFIG_ARMADA_XP_CLK=y
@@ -223,6 +224,7 @@ CONFIG_GPIOLIB=y
 CONFIG_GPIOLIB_IRQCHIP=y
 CONFIG_GPIO_GENERIC=y
 CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_GPIO_MOX_SFP=y
 CONFIG_GPIO_MVEBU=y
 CONFIG_GPIO_PCA953X=y
 CONFIG_GPIO_PCA953X_IRQ=y
diff --git a/target/linux/mvebu/image/cortex-a53.mk b/target/linux/mvebu/image/cortex-a53.mk
index 89c3363..2095a5c 100644
--- a/target/linux/mvebu/image/cortex-a53.mk
+++ b/target/linux/mvebu/image/cortex-a53.mk
@@ -13,6 +13,17 @@ define Device/globalscale-espressobin
 endef
 TARGET_DEVICES += globalscale-espressobin
 
+define Device/cznic-mox
+  KERNEL_NAME := Image dtbs
+  KERNEL := kernel-bin
+  DEVICE_TITLE := MOX (CZ.NICs Marvell Armada 3720 Based Board)
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2 kmod-usb3 kmod-usb-storage
+  DEVICE_DTS := armada-3720-turris-mox-sd armada-3720-turris-mox-sd-sfp armada-3720-turris-mox-sd-topaz
+  DTS_DIR := $(DTS_DIR)/marvell
+  SUPPORTED_DEVICES := cznic,mox
+endef
+TARGET_DEVICES += cznic-mox
+
 define Device/armada-3720-db
   KERNEL_NAME := Image
   KERNEL := kernel-bin
diff --git a/target/linux/mvebu/patches-4.14/0034-From-Ken-Ma-make-marvell.com.patch b/target/linux/mvebu/patches-4.14/0034-From-Ken-Ma-make-marvell.com.patch
new file mode 100644
index 0000000..3d670dd
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/0034-From-Ken-Ma-make-marvell.com.patch
@@ -0,0 +1,54 @@
+From 866ee62843120457bd14a3a3ce534040ab75ef4b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 3 May 2018 14:31:41 +0200
+Subject: [PATCH 34/90] From: Ken Ma <make@marvell.com>
+
+pinctrl: armada-37xx: Correct mpp definitions
+
+This patch corrects below mpp definitions:
+ - The sdio_sb group is composed of 6 pins and not 5;
+ - The rgmii group contains pins mpp2[17:6] and not mpp2[19:6];
+ - Pin of group "pmic0" is mpp1[6] but not mpp1[16];
+ - Pin of group "pmic1" is mpp1[7] but not mpp1[17];
+ - A new group "smi" is added in A0 with 2 pins - mpp2[19:18], its
+   bitmask is bit4;
+ - Group "pcie1" has 3 pins in A0 - mpp2[5:3], its bit mask is
+   bit5 | bit9 | bit10 but not bit4;
+ - Group "ptp" has 3 pins in A0 as Z1, but its bitmask is changed to
+   bit11 | bit12 | bit13.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 9 +++++----
+ 1 file changed, 5 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index 44897d4b9d88..67a9a747a1b9 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -157,8 +157,8 @@ static struct armada_37xx_pin_group armada_37xx_nb_groups[] = {
+ 	PIN_GRP_GPIO("pwm1", 12, 1, BIT(4), "pwm"),
+ 	PIN_GRP_GPIO("pwm2", 13, 1, BIT(5), "pwm"),
+ 	PIN_GRP_GPIO("pwm3", 14, 1, BIT(6), "pwm"),
+-	PIN_GRP_GPIO("pmic1", 17, 1, BIT(7), "pmic"),
+-	PIN_GRP_GPIO("pmic0", 16, 1, BIT(8), "pmic"),
++	PIN_GRP_GPIO("pmic1", 7, 1, BIT(7), "pmic"),
++	PIN_GRP_GPIO("pmic0", 6, 1, BIT(8), "pmic"),
+ 	PIN_GRP_GPIO("i2c2", 2, 2, BIT(9), "i2c"),
+ 	PIN_GRP_GPIO("i2c1", 0, 2, BIT(10), "i2c"),
+ 	PIN_GRP_GPIO("spi_cs1", 17, 1, BIT(12), "spi"),
+@@ -182,8 +182,9 @@ static struct armada_37xx_pin_group armada_37xx_sb_groups[] = {
+ 	PIN_GRP_GPIO("usb2_drvvbus1", 1, 1, BIT(1), "drvbus"),
+ 	PIN_GRP_GPIO("sdio_sb", 24, 6, BIT(2), "sdio"),
+ 	PIN_GRP_GPIO("rgmii", 6, 12, BIT(3), "mii"),
+-	PIN_GRP_GPIO("pcie1", 3, 2, BIT(4), "pcie"),
+-	PIN_GRP_GPIO("ptp", 20, 3, BIT(5), "ptp"),
++	PIN_GRP_GPIO("smi", 18, 2, BIT(4), "smi"),
++	PIN_GRP_GPIO("pcie1", 3, 3, BIT(5) | BIT(9) | BIT(10), "pcie"),
++	PIN_GRP_GPIO("ptp", 20, 3, BIT(11) | BIT(12) | BIT(13), "ptp"),
+ 	PIN_GRP("ptp_clk", 21, 1, BIT(6), "ptp", "mii"),
+ 	PIN_GRP("ptp_trig", 22, 1, BIT(7), "ptp", "mii"),
+ 	PIN_GRP_GPIO_3("mii_col", 23, 1, BIT(8) | BIT(14), 0, BIT(8), BIT(14),
+-- 
+2.17.1
+
diff --git a/target/linux/mvebu/patches-4.14/0036-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch b/target/linux/mvebu/patches-4.14/0036-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch
new file mode 100644
index 0000000..18f6a74
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/0036-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch
@@ -0,0 +1,87 @@
+From f36645628fa16eda119347d1619c97e4b4cdaf91 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 3 May 2018 16:23:53 +0200
+Subject: [PATCH 36/90] net: dsa: mv88e6xxx: 88E6141/6341 SERDES support
+
+The 88E6141/6341 switches (also known as Topaz) have 1 SGMII lane,
+which can be configured the same way as the SERDES lane on 88E6390.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c   |  2 ++
+ drivers/net/dsa/mv88e6xxx/serdes.c | 20 ++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/serdes.h |  3 +++
+ 3 files changed, 25 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index bd74c45f5495..fae362020305 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -2426,6 +2426,7 @@ static const struct mv88e6xxx_ops mv88e6141_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.serdes_power = mv88e6341_serdes_power,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6161_ops = {
+@@ -2924,6 +2925,7 @@ static const struct mv88e6xxx_ops mv88e6341_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.serdes_power = mv88e6341_serdes_power,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6350_ops = {
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index f3c01119b3d1..bfecbdf5f64d 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -227,3 +227,23 @@ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 
+ 	return 0;
+ }
++
++int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
++{
++	int err;
++	u8 cmode;
++
++	if (port != 5)
++		return 0;
++
++	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
++	if (err)
++		return err;
++
++	if ((cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X) ||
++	     (cmode == MV88E6XXX_PORT_STS_CMODE_SGMII) ||
++	     (cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX))
++		return mv88e6390_serdes_sgmii(chip, MV88E6341_ADDR_SERDES, on);
++
++	return 0;
++}
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.h b/drivers/net/dsa/mv88e6xxx/serdes.h
+index 5c1cd6d8e9a5..87bfafc5fb29 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.h
++++ b/drivers/net/dsa/mv88e6xxx/serdes.h
+@@ -19,6 +19,8 @@
+ #define MV88E6352_ADDR_SERDES		0x0f
+ #define MV88E6352_SERDES_PAGE_FIBER	0x01
+ 
++#define MV88E6341_ADDR_SERDES		0x15
++
+ #define MV88E6390_PORT9_LANE0		0x09
+ #define MV88E6390_PORT9_LANE1		0x12
+ #define MV88E6390_PORT9_LANE2		0x13
+@@ -42,6 +44,7 @@
+ #define MV88E6390_SGMII_CONTROL_LOOPBACK	BIT(14)
+ #define MV88E6390_SGMII_CONTROL_PDOWN		BIT(11)
+ 
++int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ 
+-- 
+2.17.1
+
diff --git a/target/linux/mvebu/patches-4.14/0037-drivers-gpio-Add-support-for-Turris-Mox-SFP-cage-mod.patch b/target/linux/mvebu/patches-4.14/0037-drivers-gpio-Add-support-for-Turris-Mox-SFP-cage-mod.patch
new file mode 100644
index 0000000..30d7a58
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/0037-drivers-gpio-Add-support-for-Turris-Mox-SFP-cage-mod.patch
@@ -0,0 +1,316 @@
+From 005ed67f8eea65bc5f90b0b32fe232de20652f99 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 3 May 2018 15:22:21 +0200
+Subject: [PATCH 37/90] drivers: gpio: Add support for Turris Mox SFP cage
+ module GPIOs
+
+The SFP GPIOs on the SFP cage module of Turris Mox can be configured
+via SPI bus (the same one which describes the topology of Mox modules).
+
+This driver finds out if the SFP cage module index (if it is present)
+and then exports GPIOs which can be used by phylink.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ .../bindings/gpio/gpio-turris-mox-sfp.txt     |  19 ++
+ drivers/gpio/Kconfig                          |   6 +
+ drivers/gpio/Makefile                         |   1 +
+ drivers/gpio/gpio-turris-mox-sfp.c            | 231 ++++++++++++++++++
+ 4 files changed, 257 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/gpio/gpio-turris-mox-sfp.txt
+ create mode 100644 drivers/gpio/gpio-turris-mox-sfp.c
+
+diff --git a/Documentation/devicetree/bindings/gpio/gpio-turris-mox-sfp.txt b/Documentation/devicetree/bindings/gpio/gpio-turris-mox-sfp.txt
+new file mode 100644
+index 000000000000..19cb4320faf4
+--- /dev/null
++++ b/Documentation/devicetree/bindings/gpio/gpio-turris-mox-sfp.txt
+@@ -0,0 +1,19 @@
++Turris Mox SFP module GPIO Driver (over SPI)
++
++Required properties:
++ - compatible		: Should be "cznic,turris-mox-sfp".
++ - gpio-controller	: Marks the device node as a GPIO controller.
++ - #gpio-cells		: Should be two. For consumer use see gpio.txt.
++
++For other required and optional properties of SPI slave
++nodes please refer to ../spi/spi-bus.txt.
++
++Example:
++
++	gpio_sfp: gpio_sfp@0 {
++		compatible = "cznic,turris-mox-sfp";
++		gpio-controller;
++		#gpio-cells = <2>;
++		reg = <1>;
++		spi-max-frequency = <50000000>;
++	};
+diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
+index 3f80f167ed56..697c14d07881 100644
+--- a/drivers/gpio/Kconfig
++++ b/drivers/gpio/Kconfig
+@@ -1268,6 +1268,12 @@ config GPIO_MC33880
+ 	  SPI driver for Freescale MC33880 high-side/low-side switch.
+ 	  This provides GPIO interface supporting inputs and outputs.
+ 
++config GPIO_MOX_SFP
++	tristate "Turris Mox SFP GPIO expander"
++	help
++	  This is the driver needed for configuring the SFP cage found
++	  on Turris Mox SFP module.
++
+ config GPIO_PISOSR
+ 	tristate "Generic parallel-in/serial-out shift register"
+ 	help
+diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
+index 8a2dfba3b231..20b24b8fd8b2 100644
+--- a/drivers/gpio/Makefile
++++ b/drivers/gpio/Makefile
+@@ -95,6 +95,7 @@ obj-$(CONFIG_GPIO_PCA953X)	+= gpio-pca953x.o
+ obj-$(CONFIG_GPIO_PCF857X)	+= gpio-pcf857x.o
+ obj-$(CONFIG_GPIO_PCH)		+= gpio-pch.o
+ obj-$(CONFIG_GPIO_PCI_IDIO_16)	+= gpio-pci-idio-16.o
++obj-$(CONFIG_GPIO_MOX_SFP)	+= gpio-turris-mox-sfp.o
+ obj-$(CONFIG_GPIO_PISOSR)	+= gpio-pisosr.o
+ obj-$(CONFIG_GPIO_PL061)	+= gpio-pl061.o
+ obj-$(CONFIG_GPIO_PXA)		+= gpio-pxa.o
+diff --git a/drivers/gpio/gpio-turris-mox-sfp.c b/drivers/gpio/gpio-turris-mox-sfp.c
+new file mode 100644
+index 000000000000..e09aefcb2cba
+--- /dev/null
++++ b/drivers/gpio/gpio-turris-mox-sfp.c
+@@ -0,0 +1,231 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ *  Turris Mox SFP - GPIOs on the SFP cage found on Turris Mox SFP module
++ *
++ *  Copyright (C) 2018 Marek Behun <marek.behun@nic.cz>
++ */
++
++#include <linux/gpio/consumer.h>
++#include <linux/init.h>
++#include <linux/mutex.h>
++#include <linux/spi/spi.h>
++#include <linux/gpio.h>
++#include <linux/of_gpio.h>
++#include <linux/slab.h>
++#include <linux/module.h>
++
++struct mox_sfp_chip {
++	struct gpio_chip	gpio_chip;
++	struct mutex		lock;
++	u8			state;
++	int			sfp_idx;
++	struct gpio_desc	*gpiod_oe;
++};
++
++static int mox_sfp_find(struct mox_sfp_chip *chip) {
++	struct spi_transfer t;
++	u8 rx[5], tx[5];
++	int i, res, idx = -1;
++
++	memset(rx, 0, 5);
++	memset(tx, 1, 5); /* DET has to be set to 1 for current boards */
++
++	memset(&t, 0, sizeof(t));
++
++	t.rx_buf = rx;
++	t.tx_buf = tx;
++	t.len = 5;
++
++	res = spi_sync_transfer(to_spi_device(chip->gpio_chip.parent), &t, 1);
++	if (res < 0)
++		return res;
++
++	if (rx[0] != 0xff && rx[0] != 0)
++		return -ENODEV;
++
++	for (i = 1; i < 5; ++i) {
++		if ((rx[i] & 0xf) == 0x1) {
++			idx = i;
++			break;
++		}
++	}
++
++	if (idx < 0)
++		return -ENODEV;
++
++	chip->sfp_idx = idx;
++
++	return 0;
++}
++
++static int mox_sfp_do_spi(struct mox_sfp_chip *chip) {
++	struct spi_transfer t;
++	u8 rx[5], tx[5], val;
++	int res;
++
++	val = (chip->state >> 2);
++	val |= 1; /* DET has to be set to 1 for current boards */
++
++	memset(tx, 0, 5);
++	tx[chip->sfp_idx] = val;
++
++	memset(&t, 0, sizeof(t));
++	t.rx_buf = rx;
++	t.tx_buf = tx;
++	t.len = 5;
++
++	res = spi_sync_transfer(to_spi_device(chip->gpio_chip.parent), &t, 1);
++	if (res < 0)
++		return res;
++
++	if ((rx[0] != 0xff && rx[0] != 0) || (rx[chip->sfp_idx] & 0xf) != 0x1)
++		return -ENODEV;
++
++	chip->state = (chip->state & ~3) | ((rx[1] >> 4) & 3);
++
++	return 0;
++}
++
++static int mox_sfp_get_value(struct gpio_chip *gc, unsigned offset)
++{
++	struct mox_sfp_chip *chip = gpiochip_get_data(gc);
++	int ret;
++
++	if (offset < 2) {
++		mutex_lock(&chip->lock);
++		ret = mox_sfp_do_spi(chip);
++		mutex_unlock(&chip->lock);
++
++		if (ret < 0)
++			return ret;
++	}
++
++	return (chip->state >> offset) & 1;
++}
++
++static void mox_sfp_set_value(struct gpio_chip *gc,
++		unsigned offset, int val)
++{
++	struct mox_sfp_chip *chip = gpiochip_get_data(gc);
++
++	mutex_lock(&chip->lock);
++	if (val)
++		chip->state |= (1 << offset);
++	else
++		chip->state &= ~(1 << offset);
++
++	if (offset > 2)
++		(void) mox_sfp_do_spi(chip);
++
++	mutex_unlock(&chip->lock);
++}
++
++static int mox_sfp_get_direction(struct gpio_chip *gc, unsigned offset)
++{
++	return offset < 3;
++}
++
++static int mox_sfp_direction_input(struct gpio_chip *gc, unsigned offset)
++{
++	if (offset > 2)
++		return -EINVAL;
++	return 0;
++}
++
++static int mox_sfp_direction_output(struct gpio_chip *gc,
++		unsigned offset, int val)
++{
++	if (offset < 3 || offset > 4)
++		return -EINVAL;
++	mox_sfp_set_value(gc, offset, val);
++	return 0;
++}
++
++static int mox_sfp_probe(struct spi_device *spi)
++{
++	struct mox_sfp_chip *chip;
++	int ret;
++
++	spi->max_speed_hz = 20000000;
++	spi->bits_per_word = 8;
++	spi->mode = SPI_CPHA;
++
++	ret = spi_setup(spi);
++	if (ret < 0)
++		return ret;
++
++	chip = devm_kzalloc(&spi->dev, sizeof(*chip), GFP_KERNEL);
++	if (!chip)
++		return -ENOMEM;
++
++	chip->gpiod_oe = devm_gpiod_get_optional(&spi->dev, "enable",
++						 GPIOD_OUT_LOW);
++	if (IS_ERR(chip->gpiod_oe))
++		return PTR_ERR(chip->gpiod_oe);
++
++	gpiod_set_value_cansleep(chip->gpiod_oe, 1);
++
++	spi_set_drvdata(spi, chip);
++
++	chip->gpio_chip.label = spi->modalias;
++	chip->gpio_chip.get_direction = mox_sfp_get_direction;
++	chip->gpio_chip.direction_input = mox_sfp_direction_input;
++	chip->gpio_chip.direction_output = mox_sfp_direction_output;
++	chip->gpio_chip.get = mox_sfp_get_value;
++	chip->gpio_chip.set = mox_sfp_set_value;
++	chip->gpio_chip.base = -1;
++
++	chip->gpio_chip.ngpio = 5;
++
++	chip->gpio_chip.can_sleep = true;
++	chip->gpio_chip.parent = &spi->dev;
++	chip->gpio_chip.owner = THIS_MODULE;
++
++	mutex_init(&chip->lock);
++
++	ret = mox_sfp_find(chip);
++	if (ret < 0) {
++		dev_err(&spi->dev, "Failed writing: %d\n", ret);
++		goto exit_destroy;
++	}
++
++	ret = gpiochip_add_data(&chip->gpio_chip, chip);
++	if (!ret)
++		return 0;
++
++exit_destroy:
++	mutex_destroy(&chip->lock);
++
++	return ret;
++}
++
++static int mox_sfp_remove(struct spi_device *spi)
++{
++	struct mox_sfp_chip *chip = spi_get_drvdata(spi);
++
++	gpiod_set_value_cansleep(chip->gpiod_oe, 0);
++	gpiochip_remove(&chip->gpio_chip);
++	mutex_destroy(&chip->lock);
++
++	return 0;
++}
++
++static const struct of_device_id mox_sfp_dt_ids[] = {
++	{ .compatible = "cznic,turris-mox-sfp" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, mox_sfp_dt_ids);
++
++static struct spi_driver mox_sfp_driver = {
++	.driver = {
++		.name		= "mox-sfp",
++		.of_match_table	= mox_sfp_dt_ids,
++	},
++	.probe		= mox_sfp_probe,
++	.remove		= mox_sfp_remove,
++};
++module_spi_driver(mox_sfp_driver);
++
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
++MODULE_DESCRIPTION("GPIO configuration of the SFP cage found on Turris Mox");
++MODULE_LICENSE("GPL v2");
+-- 
+2.17.1
+
diff --git a/target/linux/mvebu/patches-4.14/0038-net-mvneta-Use-netif_receive_skb-instead-of-GRO-on-A.patch b/target/linux/mvebu/patches-4.14/0038-net-mvneta-Use-netif_receive_skb-instead-of-GRO-on-A.patch
new file mode 100644
index 0000000..e2b23f0
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/0038-net-mvneta-Use-netif_receive_skb-instead-of-GRO-on-A.patch
@@ -0,0 +1,45 @@
+From 357370f5c7cf07a0dd42edbbe204eb6a898355af Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 3 May 2018 15:28:00 +0200
+Subject: [PATCH 38/90] net: mvneta: Use netif_receive_skb instead of GRO on
+ Armada 3720
+
+This solves slow receive on Armada 3720 when receiving fragmented
+frames.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 10 ++++++++--
+ 1 file changed, 8 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index dd5a627739c6..0d1351d57ef5 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -1962,7 +1962,10 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
+ 
+ 			skb->protocol = eth_type_trans(skb, dev);
+ 			mvneta_rx_csum(pp, rx_status, skb);
+-			napi_gro_receive(&port->napi, skb);
++			if (pp->neta_armada3700)
++				netif_receive_skb(skb);
++			else
++				napi_gro_receive(&port->napi, skb);
+ 
+ 			rcvd_pkts++;
+ 			rcvd_bytes += rx_bytes;
+@@ -2004,7 +2007,10 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
+ 
+ 		mvneta_rx_csum(pp, rx_status, skb);
+ 
+-		napi_gro_receive(&port->napi, skb);
++		if (pp->neta_armada3700)
++			netif_receive_skb(skb);
++		else
++			napi_gro_receive(&port->napi, skb);
+ 	}
+ 
+ 	if (rcvd_pkts) {
+-- 
+2.17.1
+
diff --git a/target/linux/mvebu/patches-4.14/0039-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch b/target/linux/mvebu/patches-4.14/0039-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch
new file mode 100644
index 0000000..f645155
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/0039-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch
@@ -0,0 +1,440 @@
+From 2d10a65b50ac73ce37316b9f3f2cb23d02cdbcef Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Fri, 23 Mar 2018 17:37:12 +0100
+Subject: [PATCH 39/90] watchdog: Add support for Armada 37xx CPU watchdog
+
+This adds support for the CPU watchdog found on Marvell Armada 37xx
+SoCs.
+
+There are 4 counters which can be set as CPU watchdog counters.
+This driver uses the second counter (ID 1, counting from 0)
+(Marvell's Linux also uses second counter by default).
+In the future it could be adapted to use other counters, with
+definition in the device tree.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi |   7 +
+ drivers/watchdog/Kconfig                     |  11 +
+ drivers/watchdog/Makefile                    |   1 +
+ drivers/watchdog/armada_37xx_wdt.c           | 356 +++++++++++++++++++
+ 4 files changed, 375 insertions(+)
+ create mode 100644 drivers/watchdog/armada_37xx_wdt.c
+
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index a5fe6c60cd0a..309da3501171 100644
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -142,6 +142,13 @@
+ 				status = "disabled";
+ 			};
+ 
++			wdt: watchdog-timer@8300 {
++				compatible = "marvell,armada-3700-wdt";
++				reg = <0xd064 0x4>,
++				      <0x8300 0x40>;
++				clocks = <&xtalclk>;
++			};
++
+ 			nb_periph_clk: nb-periph-clk@13000 {
+ 				compatible = "marvell,armada-3700-periph-clock-nb";
+ 				reg = <0x13000 0x100>;
+diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
+index 3ece1335ba84..77c1b4b540e2 100644
+--- a/drivers/watchdog/Kconfig
++++ b/drivers/watchdog/Kconfig
+@@ -255,6 +255,17 @@ config ARM_SBSA_WATCHDOG
+ 	  To compile this driver as module, choose M here: The module
+ 	  will be called sbsa_gwdt.
+ 
++config ARMADA_37XX_WATCHDOG
++	tristate "Armada 37xx watchdog"
++	depends on ARCH_MVEBU || COMPILE_TEST
++	depends on ARM64
++	select WATCHDOG_CORE
++	help
++	  Say Y here to include support for the watchdog timer found on
++	  Marvell Armada 37xx SoCs.
++	  To compile this driver as a module, choose M here: the
++	  module will be called armada_37xx_wdt.
++
+ config ASM9260_WATCHDOG
+ 	tristate "Alphascale ASM9260 watchdog"
+ 	depends on MACH_ASM9260 || COMPILE_TEST
+diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
+index 715a21078e0c..eae72c5fa1e0 100644
+--- a/drivers/watchdog/Makefile
++++ b/drivers/watchdog/Makefile
+@@ -38,6 +38,7 @@ obj-$(CONFIG_USBPCWATCHDOG) += pcwd_usb.o
+ # ARM Architecture
+ obj-$(CONFIG_ARM_SP805_WATCHDOG) += sp805_wdt.o
+ obj-$(CONFIG_ARM_SBSA_WATCHDOG) += sbsa_gwdt.o
++obj-$(CONFIG_ARMADA_37XX_WATCHDOG) += armada_37xx_wdt.o
+ obj-$(CONFIG_ASM9260_WATCHDOG) += asm9260_wdt.o
+ obj-$(CONFIG_AT91RM9200_WATCHDOG) += at91rm9200_wdt.o
+ obj-$(CONFIG_AT91SAM9X_WATCHDOG) += at91sam9_wdt.o
+diff --git a/drivers/watchdog/armada_37xx_wdt.c b/drivers/watchdog/armada_37xx_wdt.c
+new file mode 100644
+index 000000000000..99145168e93e
+--- /dev/null
++++ b/drivers/watchdog/armada_37xx_wdt.c
+@@ -0,0 +1,356 @@
++/*
++ * drivers/watchdog/armada_37xx_wdt.c
++ *
++ * Watchdog driver for Marvell Armada 37xx SoCs
++ *
++ * Author: Marek Behun <marek.behun@nic.cz>
++ *
++ * This file is licensed under  the terms of the GNU General Public
++ * License version 2. This program is licensed "as is" without any
++ * warranty of any kind, whether express or implied.
++ */
++
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/types.h>
++#include <linux/kernel.h>
++#include <linux/platform_device.h>
++#include <linux/watchdog.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/clk.h>
++#include <linux/err.h>
++#include <linux/of.h>
++#include <linux/of_device.h>
++#include <asm/io.h>
++
++/*
++ * There are four counters that can be used for watchdog on Armada 37xx.
++ * The adresses for counter control registers are register base plus ID*0x10,
++ * where ID is 0, 1, 2 or 3.
++ * In this driver we use ID 1. Marvell's Linux also uses this ID by default,
++ * and the U-Boot driver written simultaneosly by the same author as this
++ * driver also uses ID 1.
++ * Maybe in the future we could change this driver to support other counters,
++ * depending on the device tree, but I don't think this is necessary.
++ *
++ * Note that CNTR_ID cannot be 3, because the third counter is an increment
++ * counter, and this driver is written to support decrementing counters only.
++ */
++
++#define CNTR_ID				1
++
++#define CNTR_CTRL			(CNTR_ID * 0x10)
++#define CNTR_CTRL_ENABLE		0x0001
++#define CNTR_CTRL_ACTIVE		0x0002
++#define CNTR_CTRL_MODE_MASK		0x000c
++#define CNTR_CTRL_MODE_ONESHOT		0x0000
++#define CNTR_CTRL_PRESCALE_MASK		0xff00
++#define CNTR_CTRL_PRESCALE_MIN		2
++#define CNTR_CTRL_PRESCALE_SHIFT	8
++
++#define CNTR_COUNT_LOW			(CNTR_CTRL + 0x4)
++#define CNTR_COUNT_HIGH			(CNTR_CTRL + 0x8)
++
++#define WDT_TIMER_SELECT_MASK		0xf
++#define WDT_TIMER_SELECT		(1 << CNTR_ID)
++
++#define WATCHDOG_TIMEOUT		120
++
++static unsigned int timeout = WATCHDOG_TIMEOUT;
++module_param(timeout, int, 0);
++MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds (default="
++			  __MODULE_STRING(WATCHDOG_TIMEOUT) ")");
++
++static bool nowayout = WATCHDOG_NOWAYOUT;
++module_param(nowayout, bool, 0);
++MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default="
++			   __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
++
++struct armada_37xx_watchdog {
++	struct watchdog_device wdt;
++	void __iomem *sel_reg;
++	void __iomem *reg;
++	u64 timeout; /* in clock ticks */
++	unsigned long clk_rate;
++	struct clk *clk;
++};
++
++static u64 get_counter_value(struct armada_37xx_watchdog *dev)
++{
++	u64 val;
++
++	val = readl(dev->reg + CNTR_COUNT_HIGH);
++	val = (val << 32) | readl(dev->reg + CNTR_COUNT_LOW);
++
++	return val;
++}
++
++static void set_counter_value(struct armada_37xx_watchdog *dev)
++{
++	writel(dev->timeout & 0xffffffff, dev->reg + CNTR_COUNT_LOW);
++	writel(dev->timeout >> 32, dev->reg + CNTR_COUNT_HIGH);
++}
++
++static void armada_37xx_wdt_counter_enable(struct armada_37xx_watchdog *dev)
++{
++	u32 reg;
++
++	reg = readl(dev->reg + CNTR_CTRL);
++	reg |= CNTR_CTRL_ENABLE;
++	writel(reg, dev->reg + CNTR_CTRL);
++}
++
++static void armada_37xx_wdt_counter_disable(struct armada_37xx_watchdog *dev)
++{
++	u32 reg;
++
++	reg = readl(dev->reg + CNTR_CTRL);
++	reg &= ~CNTR_CTRL_ENABLE;
++	writel(reg, dev->reg + CNTR_CTRL);
++}
++
++static int armada_37xx_wdt_ping(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	armada_37xx_wdt_counter_disable(dev);
++	set_counter_value(dev);
++	armada_37xx_wdt_counter_enable(dev);
++
++	return 0;
++}
++
++static unsigned int armada_37xx_wdt_get_timeleft(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++	unsigned int res;
++
++	res = get_counter_value(dev) * CNTR_CTRL_PRESCALE_MIN / dev->clk_rate;
++
++	return res;
++}
++
++static int armada_37xx_wdt_set_timeout(struct watchdog_device *wdt,
++				       unsigned int timeout)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	wdt->timeout = timeout;
++
++	/*
++	 * Compute the timeout in clock rate. We use smallest possible prescaler,
++	 * which divides the clock rate by 2 (CNTR_CTRL_PRESCALE_MIN).
++	 */
++	dev->timeout = (u64)dev->clk_rate * timeout / CNTR_CTRL_PRESCALE_MIN;
++
++	return 0;
++}
++
++static bool armada_37xx_wdt_is_running(struct armada_37xx_watchdog *dev)
++{
++	u32 reg;
++
++	reg = readl(dev->sel_reg);
++	if ((reg & WDT_TIMER_SELECT_MASK) != WDT_TIMER_SELECT)
++		return false;
++
++	reg = readl(dev->reg + CNTR_CTRL);
++	return !!(reg & CNTR_CTRL_ACTIVE);
++}
++
++static int armada_37xx_wdt_start(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++	u32 reg;
++
++	reg = readl(dev->reg + CNTR_CTRL);
++
++	if (reg & CNTR_CTRL_ACTIVE)
++		return -EBUSY;
++
++	/* set mode */
++	reg = (reg & ~CNTR_CTRL_MODE_MASK) | CNTR_CTRL_MODE_ONESHOT;
++
++	/* set prescaler to the min value of 2 */
++	reg &= ~CNTR_CTRL_PRESCALE_MASK;
++	reg |= CNTR_CTRL_PRESCALE_MIN << CNTR_CTRL_PRESCALE_SHIFT;
++
++	writel(reg, dev->reg + CNTR_CTRL);
++
++	set_counter_value(dev);
++
++	writel(WDT_TIMER_SELECT, dev->sel_reg);
++	armada_37xx_wdt_counter_enable(dev);
++
++	return 0;
++}
++
++static int armada_37xx_wdt_stop(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	armada_37xx_wdt_counter_disable(dev);
++	writel(0, dev->sel_reg);
++
++	return 0;
++}
++
++static const struct watchdog_info armada_37xx_wdt_info = {
++	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,
++	.identity = "Armada 37xx Watchdog",
++};
++
++static const struct watchdog_ops armada_37xx_wdt_ops = {
++	.owner = THIS_MODULE,
++	.start = armada_37xx_wdt_start,
++	.stop = armada_37xx_wdt_stop,
++	.ping = armada_37xx_wdt_ping,
++	.set_timeout = armada_37xx_wdt_set_timeout,
++	.get_timeleft = armada_37xx_wdt_get_timeleft,
++};
++
++static int armada_37xx_wdt_probe(struct platform_device *pdev)
++{
++	struct armada_37xx_watchdog *dev;
++	struct resource *res;
++	int ret;
++
++	dev = devm_kzalloc(&pdev->dev, sizeof(struct armada_37xx_watchdog),
++			   GFP_KERNEL);
++	if (!dev)
++		return -ENOMEM;
++
++	dev->wdt.info = &armada_37xx_wdt_info;
++	dev->wdt.ops = &armada_37xx_wdt_ops;
++	dev->wdt.min_timeout = 1;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res)
++		return -ENODEV;
++	dev->sel_reg = devm_ioremap(&pdev->dev, res->start,
++				    resource_size(res));
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
++	if (!res)
++		return -ENODEV;
++	dev->reg = devm_ioremap(&pdev->dev, res->start, resource_size(res));
++
++	/* init clock */
++	dev->clk = clk_get(&pdev->dev, NULL);
++	if (IS_ERR(dev->clk))
++		return PTR_ERR(dev->clk);
++
++	ret = clk_prepare_enable(dev->clk);
++	if (ret) {
++		clk_put(dev->clk);
++		return ret;
++	}
++
++	dev->clk_rate = clk_get_rate(dev->clk);
++
++	/*
++	 * Since the timeout in seconds is given as 32 bit unsigned int, and
++	 * the counters hold 64 bit values, even after multiplication by clock
++	 * rate the counter can hold timeout of UINT_MAX seconds.
++	 */
++	dev->wdt.min_timeout = 0;
++	dev->wdt.max_timeout = UINT_MAX;
++	dev->wdt.parent = &pdev->dev;
++
++	/* default value, possibly override by module parameter or dtb */
++	dev->wdt.timeout = WATCHDOG_TIMEOUT;
++	watchdog_init_timeout(&dev->wdt, timeout, &pdev->dev);
++
++	platform_set_drvdata(pdev, &dev->wdt);
++	watchdog_set_drvdata(&dev->wdt, dev);
++
++	armada_37xx_wdt_set_timeout(&dev->wdt, dev->wdt.timeout);
++
++	if (armada_37xx_wdt_is_running(dev))
++		set_bit(WDOG_HW_RUNNING, &dev->wdt.status);
++	else
++		armada_37xx_wdt_stop(&dev->wdt);
++
++	watchdog_set_nowayout(&dev->wdt, nowayout);
++	ret = watchdog_register_device(&dev->wdt);
++	if (ret)
++		goto disable_clk;
++
++	dev_info(&pdev->dev, "Initial timeout %d sec%s\n",
++		 dev->wdt.timeout, nowayout ? ", nowayout" : "");
++
++	return 0;
++
++disable_clk:
++	clk_disable_unprepare(dev->clk);
++	clk_put(dev->clk);
++	return ret;
++}
++
++static int armada_37xx_wdt_remove(struct platform_device *pdev)
++{
++	struct watchdog_device *wdt = platform_get_drvdata(pdev);
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	watchdog_unregister_device(wdt);
++	clk_disable_unprepare(dev->clk);
++	clk_put(dev->clk);
++	return 0;
++}
++
++static void armada_37xx_wdt_shutdown(struct platform_device *pdev)
++{
++	struct watchdog_device *wdt = platform_get_drvdata(pdev);
++
++	armada_37xx_wdt_stop(wdt);
++}
++
++static int __maybe_unused armada_37xx_wdt_suspend(struct device *dev)
++{
++	struct watchdog_device *wdt = dev_get_drvdata(dev);
++
++	return armada_37xx_wdt_stop(wdt);
++}
++
++static int __maybe_unused armada_37xx_wdt_resume(struct device *dev)
++{
++	struct watchdog_device *wdt = dev_get_drvdata(dev);
++
++	if (watchdog_active(wdt))
++		return armada_37xx_wdt_start(wdt);
++
++	return 0;
++}
++
++static const struct dev_pm_ops armada_37xx_wdt_dev_pm_ops = {
++	SET_SYSTEM_SLEEP_PM_OPS(armada_37xx_wdt_suspend,
++				armada_37xx_wdt_resume)
++};
++
++#ifdef CONFIG_OF
++static const struct of_device_id armada_37xx_wdt_match[] = {
++	{ .compatible = "marvell,armada-3700-wdt", },
++	{},
++};
++MODULE_DEVICE_TABLE(of, armada_37xx_wdt_match);
++#endif
++
++static struct platform_driver armada_37xx_wdt_driver = {
++	.probe		= armada_37xx_wdt_probe,
++	.remove		= armada_37xx_wdt_remove,
++	.shutdown	= armada_37xx_wdt_shutdown,
++	.driver		= {
++		.name	= "armada_37xx_wdt",
++		.of_match_table = of_match_ptr(armada_37xx_wdt_match),
++		.pm = &armada_37xx_wdt_dev_pm_ops,
++	},
++};
++
++module_platform_driver(armada_37xx_wdt_driver);
++
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
++MODULE_DESCRIPTION("Armada 37xx CPU Watchdog");
++
++MODULE_LICENSE("GPL v2");
++MODULE_ALIAS("platform:armada_37xx_wdt");
+-- 
+2.17.1
+
diff --git a/target/linux/mvebu/patches-4.14/0040-drivers-mmc-Add-no-uhs-voltage-cap-to-MMC-host-struc.patch b/target/linux/mvebu/patches-4.14/0040-drivers-mmc-Add-no-uhs-voltage-cap-to-MMC-host-struc.patch
new file mode 100644
index 0000000..64b572e
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/0040-drivers-mmc-Add-no-uhs-voltage-cap-to-MMC-host-struc.patch
@@ -0,0 +1,57 @@
+From 004ccecb55538e776bc9364492718bc5cf667b1e Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 3 May 2018 15:55:35 +0200
+Subject: [PATCH 40/90] drivers: mmc: Add no-uhs-voltage cap to MMC host struct
+
+This is needed for Turris Mox, where calling mmc_set_uhs_voltage
+causes failure on the SD card.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ drivers/mmc/core/core.c  | 3 ++-
+ drivers/mmc/core/host.c  | 2 ++
+ include/linux/mmc/host.h | 1 +
+ 3 files changed, 5 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
+index 29bfff2ed4d3..bc3e038bfeae 100644
+--- a/drivers/mmc/core/core.c
++++ b/drivers/mmc/core/core.c
+@@ -1494,7 +1494,8 @@ int mmc_set_uhs_voltage(struct mmc_host *host, u32 ocr)
+ 	 * If we cannot switch voltages, return failure so the caller
+ 	 * can continue without UHS mode
+ 	 */
+-	if (!host->ops->start_signal_voltage_switch)
++	if (!host->ops->start_signal_voltage_switch ||
++	    host->caps2 & MMC_CAP2_NO_UHS_VOLTAGE)
+ 		return -EPERM;
+ 	if (!host->ops->card_busy)
+ 		pr_warn("%s: cannot verify signal voltage switch\n",
+diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
+index ad88deb2e8f3..b51db1d968c3 100644
+--- a/drivers/mmc/core/host.c
++++ b/drivers/mmc/core/host.c
+@@ -325,6 +325,8 @@ int mmc_of_parse(struct mmc_host *host)
+ 		host->caps2 |= MMC_CAP2_NO_SD;
+ 	if (device_property_read_bool(dev, "no-mmc"))
+ 		host->caps2 |= MMC_CAP2_NO_MMC;
++	if (device_property_read_bool(dev, "no-uhs-voltage"))
++		host->caps2 |= MMC_CAP2_NO_UHS_VOLTAGE;
+ 
+ 	host->dsr_req = !device_property_read_u32(dev, "dsr", &host->dsr);
+ 	if (host->dsr_req && (host->dsr & ~0xffff)) {
+diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
+index 9a43763a68ad..336893a60e04 100644
+--- a/include/linux/mmc/host.h
++++ b/include/linux/mmc/host.h
+@@ -349,6 +349,7 @@ struct mmc_host {
+ #define MMC_CAP2_NO_MMC		(1 << 22)	/* Do not send (e)MMC commands during initialization */
+ #define MMC_CAP2_CQE		(1 << 23)	/* Has eMMC command queue engine */
+ #define MMC_CAP2_CQE_DCMD	(1 << 24)	/* CQE can issue a direct command */
++#define MMC_CAP2_NO_UHS_VOLTAGE	(1 << 25)	/* Do not switch to UHS voltage during initialization */
+ 
+ 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
+ 
+-- 
+2.17.1
+
diff --git a/target/linux/mvebu/patches-4.14/0041-ARM64-dts-marvell-Add-DTS-files-for-Turris-Mox-and-i.patch b/target/linux/mvebu/patches-4.14/0041-ARM64-dts-marvell-Add-DTS-files-for-Turris-Mox-and-i.patch
new file mode 100644
index 0000000..131d732
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/0041-ARM64-dts-marvell-Add-DTS-files-for-Turris-Mox-and-i.patch
@@ -0,0 +1,463 @@
+From 7a94abe0d3460ce95928596ec9f2782abb4b6350 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 3 May 2018 15:59:46 +0200
+Subject: [PATCH 41/90] ARM64: dts: marvell: Add DTS files for Turris Mox and
+ its modules
+
+This adds basic support for the Turris Mox board from CZ.NIC, which is
+currently being crowdfunded on Indiegogo.
+
+Turris Mox is as modular router based on the Armada 3720 SOC (same as
+EspressoBin).
+
+The basic module can be extended by different modules. The device tree
+binary for the kernel can be dependent on which modules are connected,
+and in what order. Because of this, the board specific code creates
+in U-Boot a variable called module_topology, which carries this
+information.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ arch/arm64/boot/dts/marvell/Makefile          |   6 +
+ .../armada-3720-turris-mox-emmc-sfp.dts       |   8 +
+ .../armada-3720-turris-mox-emmc-topaz.dts     |   8 +
+ .../marvell/armada-3720-turris-mox-emmc.dts   |  14 ++
+ .../marvell/armada-3720-turris-mox-sd-sfp.dts |   8 +
+ .../armada-3720-turris-mox-sd-topaz.dts       |   8 +
+ .../dts/marvell/armada-3720-turris-mox-sd.dts |  16 ++
+ .../marvell/armada-3720-turris-mox-sfp.dtsi   |  34 ++++
+ .../marvell/armada-3720-turris-mox-topaz.dtsi |  75 ++++++++
+ .../dts/marvell/armada-3720-turris-mox.dtsi   | 177 ++++++++++++++++++
+ 10 files changed, 354 insertions(+)
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-emmc-sfp.dts
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-emmc-topaz.dts
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-emmc.dts
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-sfp.dts
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-topaz.dts
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd.dts
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sfp.dtsi
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox-topaz.dtsi
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dtsi
+
+diff --git a/arch/arm64/boot/dts/marvell/Makefile b/arch/arm64/boot/dts/marvell/Makefile
+index 5633676fa9d0..b1e6a803b2a6 100644
+--- a/arch/arm64/boot/dts/marvell/Makefile
++++ b/arch/arm64/boot/dts/marvell/Makefile
+@@ -6,6 +6,12 @@ dtb-$(CONFIG_ARCH_BERLIN) += berlin4ct-stb.dtb
+ # Mvebu SoC Family
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-espressobin.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox-emmc-sfp.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox-emmc-topaz.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox-emmc.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox-sd-sfp.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox-sd-topaz.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox-sd.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-7040-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-8040-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-8040-mcbin.dtb
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-emmc-sfp.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-emmc-sfp.dts
+new file mode 100644
+index 000000000000..71de376e1394
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-emmc-sfp.dts
+@@ -0,0 +1,8 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board 
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox-emmc.dts"
++#include "armada-3720-turris-mox-sfp.dtsi"
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-emmc-topaz.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-emmc-topaz.dts
+new file mode 100644
+index 000000000000..53e73552c081
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-emmc-topaz.dts
+@@ -0,0 +1,8 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board 
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox-emmc.dts"
++#include "armada-3720-turris-mox-topaz.dtsi"
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-emmc.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-emmc.dts
+new file mode 100644
+index 000000000000..b995f25f5d58
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-emmc.dts
+@@ -0,0 +1,14 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board with eMMC card
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox.dtsi"
++
++&sdhci0 {
++	non-removable;
++	bus-width = <4>;
++	marvell,pad-type = "fixed-1-8v";
++	status = "okay";
++};
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-sfp.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-sfp.dts
+new file mode 100644
+index 000000000000..ea7069571498
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-sfp.dts
+@@ -0,0 +1,8 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board 
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox-sd.dts"
++#include "armada-3720-turris-mox-sfp.dtsi"
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-topaz.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-topaz.dts
+new file mode 100644
+index 000000000000..ecfdfe51fd12
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd-topaz.dts
+@@ -0,0 +1,8 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox-sd.dts"
++#include "armada-3720-turris-mox-topaz.dtsi"
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd.dts
+new file mode 100644
+index 000000000000..6e98d82ad654
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sd.dts
+@@ -0,0 +1,16 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board with SD card slot
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++#include "armada-3720-turris-mox.dtsi"
++
++&sdhci0 {
++	wp-inverted;
++	bus-width = <4>;
++	cd-gpios = <&gpionb 10 GPIO_ACTIVE_HIGH>;
++	no-uhs-voltage;
++	marvell,pad-type = "fixed-1-8v";
++	status = "okay";
++};
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sfp.dtsi b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sfp.dtsi
+new file mode 100644
+index 000000000000..1769750a6e57
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-sfp.dtsi
+@@ -0,0 +1,34 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board SFP cage module
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++/ {
++	sfp: sfp {
++		compatible = "sff,sfp+";
++		i2c-bus = <&i2c0>;
++		mod-def0-gpio = <&gpio_spi 2 GPIO_ACTIVE_LOW>;
++		los-gpio = <&gpio_spi 0 GPIO_ACTIVE_HIGH>;
++		tx-fault-gpio = <&gpio_spi 1 GPIO_ACTIVE_HIGH>;
++		tx-disable-gpio = <&gpio_spi 3 GPIO_ACTIVE_HIGH>;
++		rate-select0-gpio = <&gpio_spi 4 GPIO_ACTIVE_HIGH>;
++	};
++};
++
++&eth1 {
++	status = "okay";
++	phy-mode = "sgmii";
++	sfp = <&sfp>;
++	managed = "in-band-status";
++};
++
++&spi0 {
++	gpio_spi: gpio_spi@0 {
++		compatible = "cznic,turris-mox-sfp";
++		gpio-controller;
++		#gpio-cells = <2>;
++		reg = <1>;
++		spi-max-frequency = <50000000>;
++	};
++};
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-topaz.dtsi b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-topaz.dtsi
+new file mode 100644
+index 000000000000..2dcae0deef7f
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox-topaz.dtsi
+@@ -0,0 +1,75 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board Topaz switch module
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++&eth1 {
++	status = "okay";
++	phy-mode = "1000base-x";
++	managed = "in-band-status";
++};
++
++&mdio {
++	switch0: switch0@0 {
++		compatible = "marvell,mv88e6085";
++		#address-cells = <1>;
++		#size-cells = <0>;
++		reg = <2 0>;
++
++		dsa,member = <0 0>;
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <1>;
++				label = "lan1";
++				phy-handle = <&switch0phy1>;
++			};
++
++			port@2 {
++				reg = <2>;
++				label = "lan2";
++				phy-handle = <&switch0phy2>;
++			};
++
++			port@3 {
++				reg = <3>;
++				label = "lan3";
++				phy-handle = <&switch0phy3>;
++			};
++
++			port@4 {
++				reg = <4>;
++				label = "lan4";
++				phy-handle = <&switch0phy4>;
++			};
++
++			port@5 {
++				reg = <5>;
++				label = "cpu";
++				ethernet = <&eth1>;
++			};
++		};
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch0phy1: switch0phy1@11 {
++				reg = <0x11>;
++			};
++			switch0phy2: switch0phy2@12 {
++				reg = <0x12>;
++			};
++			switch0phy3: switch0phy3@13 {
++				reg = <0x13>;
++			};
++			switch0phy4: switch0phy4@14 {
++				reg = <0x14>;
++			};
++		};
++	};
++};
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dtsi b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dtsi
+new file mode 100644
+index 000000000000..f17d9737e1ba
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dtsi
+@@ -0,0 +1,177 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++/dts-v1/;
++
++#include <dt-bindings/gpio/gpio.h>
++#include <dt-bindings/input/input.h>
++#include "armada-372x.dtsi"
++
++/ {
++	model = "CZ.NIC Turris Mox Board";
++	compatible = "cznic,turris-mox", "marvell,armada3720", "marvell,armada3710";
++
++	aliases {
++		spi0 = &spi0;
++	};
++
++	chosen {
++		stdout-path = "serial0:115200n8";
++	};
++
++	memory@0 {
++		device_type = "memory";
++		reg = <0x00000000 0x00000000 0x00000000 0x20000000>;
++	};
++
++	leds {
++		compatible = "gpio-leds";
++		red {
++			gpios = <&gpionb 11 GPIO_ACTIVE_LOW>;
++			linux,default-trigger = "heartbeat";
++		};
++	};
++
++	gpio_keys {
++		compatible = "gpio-keys";
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		button@0 {
++			label = "reset";
++			linux,code = <BTN_MISC>;
++			gpios = <&gpiosb 20 GPIO_ACTIVE_LOW>;
++			debounce-interval = <60>;
++		};
++	};
++
++	exp_usb3_vbus: usb3-vbus {
++		compatible = "regulator-fixed";
++		regulator-name = "usb3-vbus";
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++		enable-active-high;
++		regulator-always-on;
++		gpio = <&gpiosb 0 GPIO_ACTIVE_HIGH>;
++	};
++
++	usb3_phy: usb3-phy {
++		compatible = "usb-nop-xceiv";
++		vcc-supply = <&exp_usb3_vbus>;
++	};
++};
++
++&pinctrl_nb {
++	spi_cs1_pins: spi-cs1-pins {
++		groups = "spi_cs1";
++		function = "spi";
++	};
++
++	sdio0_pins: sdio0-pins {
++		groups = "sdio0";
++		function = "sdio";
++	};
++};
++
++&pinctrl_sb {
++	sdio_sb_pins: sdio-sb-pins {
++		groups = "sdio_sb";
++		function = "sdio";
++	};
++
++	smi_pins: smi-pins {
++		groups = "smi";
++		function = "smi";
++	};
++
++	pcie1_pins: pcie1-pins {
++		groups = "pcie1";
++		function = "pcie";
++	};
++};
++
++&i2c0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&i2c1_pins>;
++	status = "okay";
++
++	rtc@51 {
++		compatible = "nxp,pcf85063";
++		reg = <0x51>;
++	};
++};
++
++&pcie0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pcie1_pins>;
++	status = "okay";
++};
++
++&uart0 {
++	status = "okay";
++};
++
++&eth0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&rgmii_pins>;
++	phy-mode = "rgmii-id";
++	phy = <&phy1>;
++
++	status = "okay";
++};
++
++&mdio {
++	pinctrl-names = "default";
++	pinctrl-0 = <&smi_pins>;
++	status = "okay";
++
++	phy1: ethernet-phy@1 {
++		reg = <1>;
++	};
++};
++
++&sdhci1 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdio0_pins &sdio_sb_pins>;
++	non-removable;
++	bus-width = <1>;
++	marvell,pad-type = "fixed-1-8v";
++	status = "okay";
++};
++
++&spi0 {
++	status = "okay";
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi_quad_pins &spi_cs1_pins>;
++
++	spi-flash@0 {
++		#address-cells = <1>;
++		#size-cells = <1>;
++		compatible = "jedec,spi-nor";
++		reg = <0>;
++		spi-max-frequency = <50000000>;
++
++		partition@0 {
++			label = "u-boot";
++			reg = <0x0 0x3f0000>;
++		};
++
++		partition@3f0000 {
++			label = "u-boot-env";
++			reg = <0x180000 0x10000>;
++		};
++
++		partition@400000 {
++			label = "Rescue system";
++			reg = <0x190000 0x670000>;
++		};
++	};
++};
++
++&usb3 {
++	status = "okay";
++	usb-phy = <&usb3_phy>;
++};
+-- 
+2.17.1
+
-- 
2.17.1


From 90390d782d8e2e2f4f705c48e4f160ae52b559dd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
Date: Thu, 30 Apr 2020 00:18:17 +0200
Subject: [PATCH] mvebu: initial support for MOX on 5.4 kernel

---
 .../base-files/etc/board.d/02_network         |   3 +
 target/linux/mvebu/cortexa53/config-5.4       |  13 ++
 target/linux/mvebu/image/cortexa53.mk         |  12 +
 ...is-mox-rwtm-support-ECDSA-signatures.patch | 159 +++++++++++++
 ...da-3720-turris-mox-add-firmware-node.patch |  38 ++++
 ...in-link-immediately-after-enabling-t.patch |  61 +++++
 ...Zero-max-link-speed-value-is-invalid.patch |  32 +++
 ...9-PCI-aardvark-Improve-link-training.patch | 208 ++++++++++++++++++
 ...10-PCI-aardvark-Issue-PERST-via-GPIO.patch | 114 ++++++++++
 .../9911-PCI-aardvark-Add-PHY-support.patch   | 152 +++++++++++++
 ...x-implement-phylink-AN-restart-on-Se.patch | 137 ++++++++++++
 ...m64-restart-Armada-3700-restart-code.patch |  44 ++++
 12 files changed, 973 insertions(+)
 create mode 100644 target/linux/mvebu/patches-5.4/9903-firmware-turris-mox-rwtm-support-ECDSA-signatures.patch
 create mode 100644 target/linux/mvebu/patches-5.4/9904-arm64-dts-armada-3720-turris-mox-add-firmware-node.patch
 create mode 100644 target/linux/mvebu/patches-5.4/9908-PCI-of-Zero-max-link-speed-value-is-invalid.patch
 create mode 100644 target/linux/mvebu/patches-5.4/9912-net-dsa-mv88e6xxx-implement-phylink-AN-restart-on-Se.patch
 create mode 100644 target/linux/mvebu/patches-5.4/9999-arm64-restart-Armada-3700-restart-code.patch

diff --git a/target/linux/mvebu/cortexa53/base-files/etc/board.d/02_network b/target/linux/mvebu/cortexa53/base-files/etc/board.d/02_network
index 0a2a2b1..315d7d3 100755
--- a/target/linux/mvebu/cortexa53/base-files/etc/board.d/02_network
+++ b/target/linux/mvebu/cortexa53/base-files/etc/board.d/02_network
@@ -11,6 +11,9 @@ board_config_update
 board=$(board_name)
 
 case "$board" in
+cznic,turris-mox)
+	ucidef_set_interface_lan_wan "$(cd /sys/class/net/; echo lan*)" "eth0"
+	;;
 glinet,gl-mv1000|\
 globalscale,espressobin|\
 globalscale,espressobin-emmc|\
diff --git a/target/linux/mvebu/cortexa53/config-5.4 b/target/linux/mvebu/cortexa53/config-5.4
index 40253e5..68e2445 100644
--- a/target/linux/mvebu/cortexa53/config-5.4
+++ b/target/linux/mvebu/cortexa53/config-5.4
@@ -87,6 +87,8 @@ CONFIG_ARM64_VA_BITS_39=y
 # CONFIG_ARM64_VA_BITS_48 is not set
 # CONFIG_ARM64_VHE is not set
 CONFIG_ARMADA_37XX_CLK=y
+CONFIG_ARMADA_37XX_RWTM_MBOX=y
+CONFIG_ARMADA_37XX_WATCHDOG=y
 CONFIG_ARMADA_AP806_SYSCON=y
 CONFIG_ARMADA_AP_CP_HELPER=y
 CONFIG_ARMADA_CP110_SYSCON=y
@@ -134,6 +136,7 @@ CONFIG_GENERIC_CSUM=y
 CONFIG_GENERIC_GETTIMEOFDAY=y
 CONFIG_GENERIC_PINCONF=y
 CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GPIO_MOXTET=y
 CONFIG_HAVE_ALIGNED_STRUCT_PAGE=y
 CONFIG_HAVE_ARCH_HUGE_VMAP=y
 CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE=y
@@ -156,6 +159,8 @@ CONFIG_HAVE_PATA_PLATFORM=y
 CONFIG_HAVE_RCU_TABLE_FREE=y
 CONFIG_HOLES_IN_ZONE=y
 # CONFIG_HUGETLBFS is not set
+CONFIG_I2C_PXA=y
+# CONFIG_I2C_PXA_SLAVE is not set
 CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
 CONFIG_INLINE_READ_LOCK=y
 CONFIG_INLINE_READ_LOCK_BH=y
@@ -178,10 +183,16 @@ CONFIG_INLINE_WRITE_LOCK_IRQSAVE=y
 CONFIG_INLINE_WRITE_UNLOCK_BH=y
 CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE=y
 CONFIG_KASAN_STACK=1
+CONFIG_MAILBOX=y
+# CONFIG_MAILBOX_TEST is not set
 # CONFIG_MEMORY_HOTPLUG is not set
 CONFIG_MFD_SYSCON=y
 CONFIG_MMC_SDHCI_XENON=y
 CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_MOXTET=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=y
 CONFIG_MVEBU_GICP=y
 CONFIG_MVEBU_ICU=y
 CONFIG_MVEBU_ODMI=y
@@ -208,6 +219,7 @@ CONFIG_QUEUED_SPINLOCKS=y
 # CONFIG_RANDOMIZE_BASE is not set
 CONFIG_REGULATOR_GPIO=y
 CONFIG_RODATA_FULL_DEFAULT_ENABLED=y
+CONFIG_RTC_DRV_DS1307=y
 CONFIG_SERIAL_8250_FSL=y
 # CONFIG_SERIAL_AMBA_PL011 is not set
 CONFIG_SPARSEMEM=y
@@ -220,6 +232,7 @@ CONFIG_SWIOTLB=y
 CONFIG_SYSCTL_EXCEPTION_TRACE=y
 CONFIG_SYS_SUPPORTS_HUGETLBFS=y
 CONFIG_THREAD_INFO_IN_TASK=y
+CONFIG_TURRIS_MOX_RWTM=y
 CONFIG_UBSAN_ALIGNMENT=y
 CONFIG_UNMAP_KERNEL_AT_EL0=y
 CONFIG_VMAP_STACK=y
diff --git a/target/linux/mvebu/image/cortexa53.mk b/target/linux/mvebu/image/cortexa53.mk
index ff8f2c0..5371a48 100644
--- a/target/linux/mvebu/image/cortexa53.mk
+++ b/target/linux/mvebu/image/cortexa53.mk
@@ -1,3 +1,15 @@
+define Device/cznic-mox
+  KERNEL_NAME := Image dtbs
+  KERNEL := kernel-bin
+  DEVICE_VENDOR := CZ.NIC
+  DEVICE_MODEL := Turris MOX
+  DEVICE_DTS := armada-3720-turris-mox
+  DEVICE_PACKAGES := kmod-usb2 kmod-gpio-button-hotplug
+  DEVICE_DTS_DIR := $(DTS_DIR)/marvell
+  SUPPORTED_DEVICES := cznic,mox
+endef
+TARGET_DEVICES += cznic-mox
+
 define Device/glinet_gl-mv1000
   $(call Device/Default-arm64)
   DEVICE_VENDOR := GL.iNet
diff --git a/target/linux/mvebu/patches-5.4/9903-firmware-turris-mox-rwtm-support-ECDSA-signatures.patch b/target/linux/mvebu/patches-5.4/9903-firmware-turris-mox-rwtm-support-ECDSA-signatures.patch
new file mode 100644
index 0000000..2675558
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/9903-firmware-turris-mox-rwtm-support-ECDSA-signatures.patch
@@ -0,0 +1,159 @@
+From 2cce7cc15a531c2e7c708040dc5aab269e8bb543 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 29 Apr 2020 19:11:48 +0200
+Subject: [PATCH] firmware: turris-mox-rwtm: support ECDSA signatures
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The firmware on Turris MOX secure processor also offers signing messages
+with ECDSA with the private key burned into OTP. This patch adds support
+for this.
+
+Signed-off-by: Marek Beh√∫n <marek.behun@nic.cz>
+---
+ drivers/firmware/turris-mox-rwtm.c | 108 ++++++++++++++++++++++++++---
+ 1 file changed, 100 insertions(+), 8 deletions(-)
+
+diff --git a/drivers/firmware/turris-mox-rwtm.c b/drivers/firmware/turris-mox-rwtm.c
+index 72be58960e54..d2bf8cd624ac 100644
+--- a/drivers/firmware/turris-mox-rwtm.c
++++ b/drivers/firmware/turris-mox-rwtm.c
+@@ -69,6 +69,10 @@ struct mox_rwtm {
+ 	/* public key burned in eFuse */
+ 	int has_pubkey;
+ 	u8 pubkey[135];
++
++	/* signature process */
++	u32 last_sig[34];
++	int last_sig_done;
+ };
+ 
+ struct mox_kobject {
+@@ -132,17 +136,93 @@ MOX_ATTR_RO(mac_address1, "%pM\n", board_info);
+ MOX_ATTR_RO(mac_address2, "%pM\n", board_info);
+ MOX_ATTR_RO(pubkey, "%s\n", pubkey);
+ 
+-static int mox_get_status(enum mbox_cmd cmd, u32 retval)
++static ssize_t
++do_sign_show(struct kobject *kobj, struct kobj_attribute *a, char *buf)
+ {
+-	if (MBOX_STS_CMD(retval) != cmd ||
+-	    MBOX_STS_ERROR(retval) != MBOX_STS_SUCCESS)
+-		return -EIO;
+-	else if (MBOX_STS_ERROR(retval) == MBOX_STS_FAIL)
+-		return -(int)MBOX_STS_VALUE(retval);
+-	else
+-		return MBOX_STS_VALUE(retval);
++	struct mox_rwtm *rwtm = to_rwtm(kobj);
++
++	if (!rwtm->last_sig_done)
++		return -ENODATA;
++
++	rwtm->last_sig_done = 0;
++	memcpy(buf, rwtm->last_sig, 136);
++
++	/* 2 arrays of 17 32-bit words are 136 bytes */
++	return 136;
++}
++
++static ssize_t
++do_sign_store(struct kobject *kobj, struct kobj_attribute *a, const char *buf,
++	      size_t count)
++{
++	struct mox_rwtm *rwtm = to_rwtm(kobj);
++	struct armada_37xx_rwtm_rx_msg *reply = &rwtm->reply;
++	struct armada_37xx_rwtm_tx_msg msg;
++	int ret;
++
++	/* the input is a SHA-512 hash, so exactly 64 bytes have to be read */
++	if (count != 64)
++		return -EINVAL;
++
++	/* if last result is not zero user has not read that information yet */
++	if (rwtm->last_sig_done)
++		return -EBUSY;
++
++	if (!mutex_trylock(&rwtm->busy))
++		return -EBUSY;
++
++	/*
++	 * Here we have to send:
++	 *   1. Address of the input to sign.
++	 *      The input is an array of 17 32-bit words, the first (most
++	 *      significat) is 0, the rest 16 words are copied from the SHA-512
++	 *      hash given by the user and converted from BE to LE.
++	 *   2. Address of the buffer where ECDSA signature value R shall be
++	 *      stored by the rWTM firmware.
++	 *   3. Address of the buffer where ECDSA signature value S shall be
++	 *      stored by the rWTM firmware.
++	 */
++	memset(rwtm->buf, 0, 4);
++	memcpy(rwtm->buf + 4, buf, 64);
++	be32_to_cpu_array(rwtm->buf, rwtm->buf, 17);
++
++	msg.command = MBOX_CMD_SIGN;
++	msg.args[0] = 1;
++	msg.args[1] = rwtm->buf_phys;
++	msg.args[2] = rwtm->buf_phys + 68;
++	msg.args[3] = rwtm->buf_phys + 2 * 68;
++	ret = mbox_send_message(rwtm->mbox, &msg);
++	if (ret < 0)
++		goto unlock_mutex;
++
++	ret = wait_for_completion_interruptible(&rwtm->cmd_done);
++	if (ret < 0)
++		goto unlock_mutex;
++
++	ret = MBOX_STS_VALUE(reply->retval);
++	if (MBOX_STS_ERROR(reply->retval) != MBOX_STS_SUCCESS)
++		goto unlock_mutex;
++
++	/*
++	 * Here we read the R and S values of the ECDSA signature
++	 * computed by the rWTM firmware and convert their words from
++	 * LE to BE.
++	 */
++	memcpy(rwtm->last_sig, rwtm->buf + 68, 136);
++	cpu_to_be32_array(rwtm->last_sig, rwtm->last_sig, 34);
++	rwtm->last_sig_done = 1;
++
++	mutex_unlock(&rwtm->busy);
++	return count;
++unlock_mutex:
++	mutex_unlock(&rwtm->busy);
++	return ret;
+ }
+ 
++/* only root should be able to sign */
++static struct kobj_attribute mox_attr_do_sign =
++	__ATTR(do_sign, 0600, do_sign_show, do_sign_store);
++
+ static const struct attribute *mox_rwtm_attrs[] = {
+ 	&mox_attr_serial_number.attr,
+ 	&mox_attr_board_version.attr,
+@@ -150,9 +230,21 @@ static const struct attribute *mox_rwtm_attrs[] = {
+ 	&mox_attr_mac_address1.attr,
+ 	&mox_attr_mac_address2.attr,
+ 	&mox_attr_pubkey.attr,
++	&mox_attr_do_sign.attr,
+ 	NULL
+ };
+ 
++static int mox_get_status(enum mbox_cmd cmd, u32 retval)
++{
++	if (MBOX_STS_CMD(retval) != cmd ||
++	    MBOX_STS_ERROR(retval) != MBOX_STS_SUCCESS)
++		return -EIO;
++	else if (MBOX_STS_ERROR(retval) == MBOX_STS_FAIL)
++		return -(int)MBOX_STS_VALUE(retval);
++	else
++		return MBOX_STS_VALUE(retval);
++}
++
+ static void mox_rwtm_rx_callback(struct mbox_client *cl, void *data)
+ {
+ 	struct mox_rwtm *rwtm = dev_get_drvdata(cl->dev);
+-- 
+2.24.1
+
diff --git a/target/linux/mvebu/patches-5.4/9904-arm64-dts-armada-3720-turris-mox-add-firmware-node.patch b/target/linux/mvebu/patches-5.4/9904-arm64-dts-armada-3720-turris-mox-add-firmware-node.patch
new file mode 100644
index 0000000..8adaa26
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/9904-arm64-dts-armada-3720-turris-mox-add-firmware-node.patch
@@ -0,0 +1,38 @@
+From ef32204560c1542862471ca3e27414b03ba1ef8b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 29 Apr 2020 19:13:57 +0200
+Subject: [PATCH] arm64: dts: armada-3720-turris-mox: add firmware node
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add the node representing the firmware running on the secure processor.
+
+Signed-off-by: Marek Beh√∫n <marek.behun@nic.cz>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
+index 5f350cc71a2f..bb42d1e6a4e9 100644
+--- a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
+@@ -106,6 +106,14 @@
+ 		/* enabled by U-Boot if SFP module is present */
+ 		status = "disabled";
+ 	};
++
++	firmware {
++		turris-mox-rwtm {
++			compatible = "cznic,turris-mox-rwtm";
++			mboxes = <&rwtm 0>;
++			status = "okay";
++		};
++	};
+ };
+ 
+ &i2c0 {
+-- 
+2.24.1
+
+
diff --git a/target/linux/mvebu/patches-5.4/9908-PCI-of-Zero-max-link-speed-value-is-invalid.patch b/target/linux/mvebu/patches-5.4/9908-PCI-of-Zero-max-link-speed-value-is-invalid.patch
new file mode 100644
index 0000000..c0e1d31
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/9908-PCI-of-Zero-max-link-speed-value-is-invalid.patch
@@ -0,0 +1,32 @@
+From 57f57d71dd25cf06e6255fdae946682c07d90469 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 24 Apr 2020 12:20:30 +0200
+Subject: [PATCH] PCI: of: Zero max-link-speed value is invalid
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Interpret zero value of max-link-speed property as invalid,
+as the device tree bindings documentation specifies.
+
+Signed-off-by: Pali Roh√°r <pali@kernel.org>
+---
+ drivers/pci/of.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/pci/of.c b/drivers/pci/of.c
+index 36891e7deee3..4080ad884612 100644
+--- a/drivers/pci/of.c
++++ b/drivers/pci/of.c
+@@ -547,7 +547,7 @@ int of_pci_get_max_link_speed(struct device_node *node)
+ 	u32 max_link_speed;
+ 
+ 	if (of_property_read_u32(node, "max-link-speed", &max_link_speed) ||
+-	    max_link_speed > 4)
++	    max_link_speed == 0 || max_link_speed > 4)
+ 		return -EINVAL;
+ 
+ 	return max_link_speed;
+-- 
+2.24.1
+
diff --git a/target/linux/mvebu/patches-5.4/9912-net-dsa-mv88e6xxx-implement-phylink-AN-restart-on-Se.patch b/target/linux/mvebu/patches-5.4/9912-net-dsa-mv88e6xxx-implement-phylink-AN-restart-on-Se.patch
new file mode 100644
index 0000000..47a9739
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/9912-net-dsa-mv88e6xxx-implement-phylink-AN-restart-on-Se.patch
@@ -0,0 +1,137 @@
+From ebf692d8fb2608fed2a2a4cb721a92a33d5a9667 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Tue, 5 May 2020 14:22:17 +0200
+Subject: [PATCH] net: dsa: mv88e6xxx: implement phylink AN restart on Serdes
+ PHY for Topaz
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Implement .phylink_mac_an_restart method for Topaz switches for the
+SERDES capable port. For some reason without this when the Topaz is
+connected on Turris MOX in distributed configuration with Peridot,
+Topaz's Serdes doesn't get enabled in phylink_start, although Peridot
+does.
+
+This is implemented in upstream by a superior commit
+a5a6858b793f ("net: dsa: mv88e6xxx: extend phylink to Serdes PHYs")
+
+Signed-off-by: Marek Beh√∫n <marek.behun@nic.cz>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c   | 22 ++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/chip.h   |  3 +++
+ drivers/net/dsa/mv88e6xxx/serdes.c | 17 +++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/serdes.h |  1 +
+ 4 files changed, 43 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 6787d560e9e3..33b391376352 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -629,6 +629,25 @@ static void mv88e6xxx_mac_config(struct dsa_switch *ds, int port,
+ 		dev_err(ds->dev, "p%d: failed to configure MAC\n", port);
+ }
+ 
++static void mv88e6xxx_mac_an_restart(struct dsa_switch *ds, int port)
++{
++	struct mv88e6xxx_chip *chip = ds->priv;
++	u8 lane;
++	int err = 0;
++
++	if (!chip->info->ops->serdes_an_restart)
++		return;
++
++	mv88e6xxx_reg_lock(chip);
++	lane = mv88e6xxx_serdes_get_lane(chip, port);
++	if (lane)
++		err = chip->info->ops->serdes_an_restart(chip, port, lane);
++	mv88e6xxx_reg_unlock(chip);
++
++	if (err)
++		dev_err(chip->dev, "p%d: failed restarting SERDES AN\n", port);
++}
++
+ static void mv88e6xxx_mac_link_force(struct dsa_switch *ds, int port, int link)
+ {
+ 	struct mv88e6xxx_chip *chip = ds->priv;
+@@ -3203,6 +3222,7 @@ static const struct mv88e6xxx_ops mv88e6141_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.serdes_an_restart = mv88e6390_serdes_an_restart,
+ 	.serdes_power = mv88e6390_serdes_power,
+ 	.serdes_get_lane = mv88e6341_serdes_get_lane,
+ 	.serdes_irq_mapping = mv88e6390_serdes_irq_mapping,
+@@ -3917,6 +3937,7 @@ static const struct mv88e6xxx_ops mv88e6341_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.serdes_an_restart = mv88e6390_serdes_an_restart,
+ 	.serdes_power = mv88e6390_serdes_power,
+ 	.serdes_get_lane = mv88e6341_serdes_get_lane,
+ 	.serdes_irq_mapping = mv88e6390_serdes_irq_mapping,
+@@ -4934,6 +4955,7 @@ static const struct dsa_switch_ops mv88e6xxx_switch_ops = {
+ 	.get_tag_protocol	= mv88e6xxx_get_tag_protocol,
+ 	.setup			= mv88e6xxx_setup,
+ 	.phylink_validate	= mv88e6xxx_validate,
++	.phylink_mac_an_restart = mv88e6xxx_mac_an_restart,
+ 	.phylink_mac_link_state	= mv88e6xxx_link_state,
+ 	.phylink_mac_config	= mv88e6xxx_mac_config,
+ 	.phylink_mac_link_down	= mv88e6xxx_mac_link_down,
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index e9b1a1ac9a8e..3adbbf3fd52a 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -482,6 +482,9 @@ struct mv88e6xxx_ops {
+ 	/* SERDES lane mapping */
+ 	u8 (*serdes_get_lane)(struct mv88e6xxx_chip *chip, int port);
+ 
++	int (*serdes_an_restart)(struct mv88e6xxx_chip *chip, int port,
++				 u8 lane);
++
+ 	/* SERDES interrupt handling */
+ 	unsigned int (*serdes_irq_mapping)(struct mv88e6xxx_chip *chip,
+ 					   int port);
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index 902feb398746..e28d24076800 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -423,6 +423,23 @@ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, u8 lane,
+ 	return 0;
+ }
+ 
++int mv88e6390_serdes_an_restart(struct mv88e6xxx_chip *chip, int port, u8 lane)
++{
++	u16 val;
++	int err;
++
++	err = mv88e6390_serdes_read(chip, lane, MDIO_MMD_PHYXS,
++				    MV88E6390_SGMII_CONTROL, &val);
++	if (err)
++		return err;
++
++	val |= BMCR_ANRESTART;
++	err = mv88e6390_serdes_write(chip, lane, MDIO_MMD_PHYXS,
++				     MV88E6390_SGMII_CONTROL, val);
++
++	return err;
++}
++
+ static void mv88e6390_serdes_irq_link_sgmii(struct mv88e6xxx_chip *chip,
+ 					    int port, u8 lane)
+ {
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.h b/drivers/net/dsa/mv88e6xxx/serdes.h
+index bd8df36ab537..5994652a9baa 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.h
++++ b/drivers/net/dsa/mv88e6xxx/serdes.h
+@@ -78,6 +78,7 @@ u8 mv88e6341_serdes_get_lane(struct mv88e6xxx_chip *chip, int port);
+ u8 mv88e6352_serdes_get_lane(struct mv88e6xxx_chip *chip, int port);
+ u8 mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port);
+ u8 mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port);
++int mv88e6390_serdes_an_restart(struct mv88e6xxx_chip *chip, int port, u8 lane);
+ unsigned int mv88e6352_serdes_irq_mapping(struct mv88e6xxx_chip *chip,
+ 					  int port);
+ unsigned int mv88e6390_serdes_irq_mapping(struct mv88e6xxx_chip *chip,
+-- 
+2.24.1
+
diff --git a/target/linux/mvebu/patches-5.4/9999-arm64-restart-Armada-3700-restart-code.patch b/target/linux/mvebu/patches-5.4/9999-arm64-restart-Armada-3700-restart-code.patch
new file mode 100644
index 0000000..21c4c3c
--- /dev/null
+++ b/target/linux/mvebu/patches-5.4/9999-arm64-restart-Armada-3700-restart-code.patch
@@ -0,0 +1,44 @@
+From 2540a6ba05712695b7528cafc6e5f744835fd980 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Mon, 14 Jan 2019 17:00:04 +0100
+Subject: [PATCH] arm64: restart: Armada 3700 restart code
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This is a bugfix for Turris Mox, do not send to mainline.
+
+Signed-off-by: Marek Beh√∫n <marek.behun@nic.cz>
+---
+ arch/arm64/kernel/process.c | 15 +++++++++++----
+ 1 file changed, 11 insertions(+), 4 deletions(-)
+
+diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
+index fab013c5ee8c..5749b8ebda2b 100644
+--- a/arch/arm64/kernel/process.c
++++ b/arch/arm64/kernel/process.c
+@@ -197,10 +197,17 @@ void machine_restart(char *cmd)
+ 		efi_reboot(reboot_mode, NULL);
+ 
+ 	/* Now call the architecture specific reboot code. */
+-	if (arm_pm_restart)
+-		arm_pm_restart(reboot_mode, cmd);
+-	else
+-		do_kernel_restart(cmd);
++	if (0) {
++		if (arm_pm_restart)
++			arm_pm_restart(reboot_mode, cmd);
++		else
++			do_kernel_restart(cmd);
++	} else {
++		void __iomem *r = ioremap(0xd0013000, 0x1000);
++		writel(0x1d1e, r + 0x840);
++		iounmap(r);
++		mdelay(1000);
++	}
+ 
+ 	/*
+ 	 * Whoops - the architecture was unable to reboot.
+-- 
+2.24.1
+
-- 
2.28.0


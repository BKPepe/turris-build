From 0d0a5a7562688ef450eb1b5a5d8aa622e0196c56 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
Date: Thu, 24 Sep 2020 00:28:51 +0200
Subject: [PATCH] mvebu: add support for Turris SFP module

---
 target/linux/mvebu/config-5.10                 |   1 +
 ...e-linkmode_test_bit-take-const-point.patch |  34 +++
 ...y-add-supported_interfaces-to-phylib.patch |  58 ++++
 ...supported_interfaces-to-marvell-PHYs.patch |  33 ++
 ...ported_interfaces-to-marvell10g-PHYs.patch |  29 ++
 .../8567-net-sfp-add-interface-bitmap.patch   | 248 +++++++++++++++
 ...ylink-use-phy-interface-mode-bitmaps.patch | 199 ++++++++++++
 ...ta-fill-in-phy-interface-mode-bitmap.patch |  43 +++
 ...-support-I2C-MDIO-protocol-for-RollB.patch | 285 ++++++++++++++++++
 ...support-for-multigig-RollBall-module.patch | 171 +++++++++++
 ...t-fail-attaching-phy-on-1000base-x-2.patch |  37 +++
 ...PHYs-know-what-interfaces-are-suppor.patch | 111 +++++++
 ...0g-change-MACTYPE-according-to-host-.patch | 216 +++++++++++++
 ...vell10g-fix-null-pointer-dereference.patch |  88 ++++++
 47 files changed, 4601 insertions(+)
 create mode 100644 target/linux/mvebu/patches-5.10/8558-net-linkmode-make-linkmode_test_bit-take-const-point.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8564-net-phy-add-supported_interfaces-to-phylib.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8565-net-phy-add-supported_interfaces-to-marvell-PHYs.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8566-net-phy-add-supported_interfaces-to-marvell10g-PHYs.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8567-net-sfp-add-interface-bitmap.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8569-net-phylink-use-phy-interface-mode-bitmaps.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8570-net-mvneta-fill-in-phy-interface-mode-bitmap.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8571-net-phy-mdio-i2c-support-I2C-MDIO-protocol-for-RollB.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8572-net-phy-sfp-add-support-for-multigig-RollBall-module.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8573-net-phylink-don-t-fail-attaching-phy-on-1000base-x-2.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8574-net-phylink-let-PHYs-know-what-interfaces-are-suppor.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8586-net-phy-marvell10g-change-MACTYPE-according-to-host-.patch

diff --git a/target/linux/mvebu/config-5.10 b/target/linux/mvebu/config-5.10
index a13cb8d..eca5632 100644
--- a/target/linux/mvebu/config-5.10
+++ b/target/linux/mvebu/config-5.10
@@ -310,6 +310,7 @@ CONFIG_MACH_MVEBU_V7=y
 CONFIG_MAGIC_SYSRQ=y
 CONFIG_MANGLE_BOOTARGS=y
 CONFIG_MARVELL_PHY=y
+CONFIG_MARVELL_10G_PHY=y
 CONFIG_MDIO_BUS=y
 CONFIG_MDIO_DEVICE=y
 CONFIG_MDIO_I2C=y
diff --git a/target/linux/mvebu/patches-5.10/8564-net-phy-add-supported_interfaces-to-phylib.patch b/target/linux/mvebu/patches-5.10/8564-net-phy-add-supported_interfaces-to-phylib.patch
new file mode 100644
index 0000000..05b9c41
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8564-net-phy-add-supported_interfaces-to-phylib.patch
@@ -0,0 +1,58 @@
+From aa0897dc1d3088f53f705f1d94454aa3abbf1d70 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Mon, 23 Dec 2019 23:24:17 +0000
+Subject: [PATCH 8564/8586] net: phy: add supported_interfaces to phylib
+
+Add a supported_interfaces member to phylib so we know which
+interfaces a PHY supports. Currently, set any unconverted driver
+to indicate all interfaces are supported.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ include/linux/phy.h | 23 +++++++++++++++++++++++
+ 1 file changed, 23 insertions(+)
+
+diff --git a/include/linux/phy.h b/include/linux/phy.h
+index 24d21f68ea9b..2bf28a737521 100644
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -107,6 +107,26 @@ typedef enum {
+ 	PHY_INTERFACE_MODE_MAX,
+ } phy_interface_t;
+ 
++/* PHY interface mode bitmap handling */
++#define DECLARE_PHY_INTERFACE_MASK(name) \
++	DECLARE_BITMAP(name, PHY_INTERFACE_MODE_MAX)
++
++static inline void phy_interface_zero(unsigned long *intf)
++{
++	bitmap_zero(intf, PHY_INTERFACE_MODE_MAX);
++}
++
++static inline bool phy_interface_empty(const unsigned long *intf)
++{
++	return bitmap_empty(intf, PHY_INTERFACE_MODE_MAX);
++}
++
++static inline void phy_interface_and(unsigned long *dst, const unsigned long *a,
++				     const unsigned long *b)
++{
++	bitmap_and(dst, a, b, PHY_INTERFACE_MODE_MAX);
++}
++
+ /**
+  * phy_supported_speeds - return all speeds currently supported by a phy device
+  * @phy: The phy device to return supported speeds of.
+@@ -412,6 +432,9 @@ struct phy_device {
+ 	/* used with phy_speed_down */
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(adv_old);
+ 
++	/* bitmap of supported interfaces */
++	DECLARE_PHY_INTERFACE_MASK(supported_interfaces);
++
+ 	/* Energy efficient ethernet modes which should be prohibited */
+ 	u32 eee_broken_modes;
+ 
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8565-net-phy-add-supported_interfaces-to-marvell-PHYs.patch b/target/linux/mvebu/patches-5.10/8565-net-phy-add-supported_interfaces-to-marvell-PHYs.patch
new file mode 100644
index 0000000..9e2827b
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8565-net-phy-add-supported_interfaces-to-marvell-PHYs.patch
@@ -0,0 +1,33 @@
+From 9149ffed98466afd5ad9b46f7862eedd2a8556b7 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Mon, 23 Dec 2019 23:25:49 +0000
+Subject: [PATCH 8565/8586] net: phy: add supported_interfaces to marvell PHYs
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/phy/marvell.c | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c
+index 91cf1d167263..eba3169e6d1c 100644
+--- a/drivers/net/phy/marvell.c
++++ b/drivers/net/phy/marvell.c
+@@ -2091,6 +2091,15 @@ static int marvell_probe(struct phy_device *phydev)
+ 
+ 	phydev->priv = priv;
+ 
++	__set_bit(PHY_INTERFACE_MODE_GMII, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_SGMII, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_TBI, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII_ID, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII_RXID, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII_TXID, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RTBI, phydev->supported_interfaces);
++
+ 	return 0;
+ }
+ 
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8566-net-phy-add-supported_interfaces-to-marvell10g-PHYs.patch b/target/linux/mvebu/patches-5.10/8566-net-phy-add-supported_interfaces-to-marvell10g-PHYs.patch
new file mode 100644
index 0000000..c22e6d7
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8566-net-phy-add-supported_interfaces-to-marvell10g-PHYs.patch
@@ -0,0 +1,29 @@
+From 434cbd7c8237a3db507a0f186c7c2879e48ad4c6 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Mon, 23 Dec 2019 23:26:04 +0000
+Subject: [PATCH 8566/8586] net: phy: add supported_interfaces to marvell10g
+ PHYs
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/phy/marvell10g.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/drivers/net/phy/marvell10g.c b/drivers/net/phy/marvell10g.c
+index ac8520dc0913..1c805b2bcb69 100644
+--- a/drivers/net/phy/marvell10g.c
++++ b/drivers/net/phy/marvell10g.c
+@@ -216,6 +216,10 @@ static int mv3310_probe(struct phy_device *phydev)
+ 	    (phydev->c45_ids.devices_in_package & mmd_mask) != mmd_mask)
+ 		return -ENODEV;
+ 
++	__set_bit(PHY_INTERFACE_MODE_SGMII, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_2500BASEX, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_10GBASER, phydev->supported_interfaces);
++
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MV_PMA_BOOT);
+ 	if (ret < 0)
+ 		return ret;
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8567-net-sfp-add-interface-bitmap.patch b/target/linux/mvebu/patches-5.10/8567-net-sfp-add-interface-bitmap.patch
new file mode 100644
index 0000000..4b282af
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8567-net-sfp-add-interface-bitmap.patch
@@ -0,0 +1,248 @@
+From 25e566b35a2aa3d795137e883bdf985b7959dee6 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 3 Mar 2020 11:57:39 +0000
+Subject: [PATCH 8567/8586] net: sfp: add interface bitmap
+
+Add parsing the SFP EEPROM to supported phy interface modes.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/phy/marvell10g.c |  3 +-
+ drivers/net/phy/phylink.c    |  3 +-
+ drivers/net/phy/sfp-bus.c    | 69 +++++++++++++++++++++++++++++----------
+ include/linux/sfp.h          |  5 +--
+ 4 files changed, 59 insertions(+), 21 deletions(-)
+
+diff --git a/drivers/net/phy/marvell10g.c b/drivers/net/phy/marvell10g.c
+index df9f674f1b3af..fe97b16095867 100644
+--- a/drivers/net/phy/marvell10g.c
++++ b/drivers/net/phy/marvell10g.c
+@@ -354,9 +354,10 @@ static int mv3310_sfp_insert(void *upstream, const struct sfp_eeprom_id *id)
+ {
+ 	struct phy_device *phydev = upstream;
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(support) = { 0, };
++	DECLARE_PHY_INTERFACE_MASK(interfaces);
+ 	phy_interface_t iface;
+ 
+-	sfp_parse_support(phydev->sfp_bus, id, support);
++	sfp_parse_support(phydev->sfp_bus, id, support, interfaces);
+ 	iface = sfp_select_interface(phydev->sfp_bus, support);
+ 
+ 	if (iface != PHY_INTERFACE_MODE_10GBASER) {
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 7d06230743ee..0fe5865691f9 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -1844,11 +1844,12 @@ static int phylink_sfp_module_insert(void *upstream,
+ {
+ 	struct phylink *pl = upstream;
+ 	unsigned long *support = pl->sfp_support;
++	DECLARE_PHY_INTERFACE_MASK(sfp_interfaces);
+ 
+ 	ASSERT_RTNL();
+ 
+ 	linkmode_zero(support);
+-	sfp_parse_support(pl->sfp_bus, id, support);
++	sfp_parse_support(pl->sfp_bus, id, support, sfp_interfaces);
+ 	pl->sfp_port = sfp_parse_port(pl->sfp_bus, id, support);
+ 
+ 	/* If this module may have a PHY connecting later, defer until later */
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index e1400ee9b2b1..07dc29ecaf1c 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -13,7 +13,8 @@
+ struct sfp_quirk {
+ 	const char *vendor;
+ 	const char *part;
+-	void (*modes)(const struct sfp_eeprom_id *id, unsigned long *modes);
++	void (*modes)(const struct sfp_eeprom_id *id, unsigned long *modes,
++		      unsigned long *interfaces);
+ };
+ 
+ /**
+@@ -39,9 +40,10 @@ struct sfp_bus {
+ };
+ 
+ static void sfp_quirk_2500basex(const struct sfp_eeprom_id *id,
+-				unsigned long *modes)
++				unsigned long *modes, unsigned long *interfaces)
+ {
+ 	phylink_set(modes, 2500baseX_Full);
++	__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
+ }
+ 
+ static const struct sfp_quirk sfp_quirks[] = {
+@@ -211,12 +213,14 @@ EXPORT_SYMBOL_GPL(sfp_may_have_phy);
+  * @bus: a pointer to the &struct sfp_bus structure for the sfp module
+  * @id: a pointer to the module's &struct sfp_eeprom_id
+  * @support: pointer to an array of unsigned long for the ethtool support mask
++ * @interfaces: pointer to an array of unsigned long for phy interface modes
++ *		mask
+  *
+  * Parse the EEPROM identification information and derive the supported
+  * ethtool link modes for the module.
+  */
+ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+-		       unsigned long *support)
++		       unsigned long *support, unsigned long *interfaces)
+ {
+ 	unsigned int br_min, br_nom, br_max;
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(modes) = { 0, };
+@@ -243,48 +247,71 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	}
+ 
+ 	/* Set ethtool support from the compliance fields. */
+-	if (id->base.e10g_base_sr)
++	if (id->base.e10g_base_sr) {
+ 		phylink_set(modes, 10000baseSR_Full);
+-	if (id->base.e10g_base_lr)
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++	}
++	if (id->base.e10g_base_lr) {
+ 		phylink_set(modes, 10000baseLR_Full);
+-	if (id->base.e10g_base_lrm)
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++	}
++	if (id->base.e10g_base_lrm) {
+ 		phylink_set(modes, 10000baseLRM_Full);
+-	if (id->base.e10g_base_er)
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++	}
++	if (id->base.e10g_base_er) {
+ 		phylink_set(modes, 10000baseER_Full);
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++	}
+ 	if (id->base.e1000_base_sx ||
+ 	    id->base.e1000_base_lx ||
+-	    id->base.e1000_base_cx)
++	    id->base.e1000_base_cx) {
+ 		phylink_set(modes, 1000baseX_Full);
++		__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++	}
+ 	if (id->base.e1000_base_t) {
+ 		phylink_set(modes, 1000baseT_Half);
+ 		phylink_set(modes, 1000baseT_Full);
++		__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++		__set_bit(PHY_INTERFACE_MODE_SGMII, interfaces);
+ 	}
+ 
+ 	/* 1000Base-PX or 1000Base-BX10 */
+ 	if ((id->base.e_base_px || id->base.e_base_bx10) &&
+-	    br_min <= 1300 && br_max >= 1200)
++	    br_min <= 1300 && br_max >= 1200) {
+ 		phylink_set(modes, 1000baseX_Full);
++		__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++	}
+ 
+ 	/* For active or passive cables, select the link modes
+ 	 * based on the bit rates and the cable compliance bytes.
+ 	 */
+ 	if ((id->base.sfp_ct_passive || id->base.sfp_ct_active) && br_nom) {
+ 		/* This may look odd, but some manufacturers use 12000MBd */
+-		if (br_min <= 12000 && br_max >= 10300)
++		if (br_min <= 12000 && br_max >= 10300) {
+ 			phylink_set(modes, 10000baseCR_Full);
+-		if (br_min <= 3200 && br_max >= 3100)
++			__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++		}
++		if (br_min <= 3200 && br_max >= 3100) {
+ 			phylink_set(modes, 2500baseX_Full);
+-		if (br_min <= 1300 && br_max >= 1200)
++			__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
++		}
++		if (br_min <= 1300 && br_max >= 1200) {
+ 			phylink_set(modes, 1000baseX_Full);
++			__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++		}
+ 	}
+ 	if (id->base.sfp_ct_passive) {
+-		if (id->base.passive.sff8431_app_e)
++		if (id->base.passive.sff8431_app_e) {
+ 			phylink_set(modes, 10000baseCR_Full);
++			__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++		}
+ 	}
+ 	if (id->base.sfp_ct_active) {
+ 		if (id->base.active.sff8431_app_e ||
+ 		    id->base.active.sff8431_lim) {
+ 			phylink_set(modes, 10000baseCR_Full);
++			__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
+ 		}
+ 	}
+ 
+@@ -309,12 +336,14 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	case SFF8024_ECC_10GBASE_T_SFI:
+ 	case SFF8024_ECC_10GBASE_T_SR:
+ 		phylink_set(modes, 10000baseT_Full);
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
+ 		break;
+ 	case SFF8024_ECC_5GBASE_T:
+ 		phylink_set(modes, 5000baseT_Full);
+ 		break;
+ 	case SFF8024_ECC_2_5GBASE_T:
+ 		phylink_set(modes, 2500baseT_Full);
++		__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
+ 		break;
+ 	default:
+ 		dev_warn(bus->sfp_dev,
+@@ -327,10 +356,14 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	if (id->base.fc_speed_100 ||
+ 	    id->base.fc_speed_200 ||
+ 	    id->base.fc_speed_400) {
+-		if (id->base.br_nominal >= 31)
++		if (id->base.br_nominal >= 31) {
+ 			phylink_set(modes, 2500baseX_Full);
+-		if (id->base.br_nominal >= 12)
++			__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
++		}
++		if (id->base.br_nominal >= 12) {
+ 			phylink_set(modes, 1000baseX_Full);
++			__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++		}
+ 	}
+ 
+ 	/* If we haven't discovered any modes that this module supports, try
+@@ -341,12 +374,14 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	if (bitmap_empty(modes, __ETHTOOL_LINK_MODE_MASK_NBITS)) {
+ 		/* If the encoding and bit rate allows 1000baseX */
+ 		if (id->base.encoding == SFF8024_ENCODING_8B10B && br_nom &&
+-		    br_min <= 1300 && br_max >= 1200)
++		    br_min <= 1300 && br_max >= 1200) {
+ 			phylink_set(modes, 1000baseX_Full);
++			__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++		}
+ 	}
+ 
+ 	if (bus->sfp_quirk)
+-		bus->sfp_quirk->modes(id, modes);
++		bus->sfp_quirk->modes(id, modes, interfaces);
+ 
+ 	bitmap_or(support, support, modes, __ETHTOOL_LINK_MODE_MASK_NBITS);
+ 
+diff --git a/include/linux/sfp.h b/include/linux/sfp.h
+index 38893e4dd0f0..2da1a5181779 100644
+--- a/include/linux/sfp.h
++++ b/include/linux/sfp.h
+@@ -535,7 +535,7 @@ int sfp_parse_port(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		   unsigned long *support);
+ bool sfp_may_have_phy(struct sfp_bus *bus, const struct sfp_eeprom_id *id);
+ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+-		       unsigned long *support);
++		       unsigned long *support, unsigned long *interfaces);
+ phy_interface_t sfp_select_interface(struct sfp_bus *bus,
+ 				     unsigned long *link_modes);
+ 
+@@ -565,7 +565,8 @@ static inline bool sfp_may_have_phy(struct sfp_bus *bus,
+ 
+ static inline void sfp_parse_support(struct sfp_bus *bus,
+ 				     const struct sfp_eeprom_id *id,
+-				     unsigned long *support)
++				     unsigned long *support,
++				     unsigned long *interfaces)
+ {
+ }
+ 
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8569-net-phylink-use-phy-interface-mode-bitmaps.patch b/target/linux/mvebu/patches-5.10/8569-net-phylink-use-phy-interface-mode-bitmaps.patch
new file mode 100644
index 0000000..db052d3
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8569-net-phylink-use-phy-interface-mode-bitmaps.patch
@@ -0,0 +1,199 @@
+From 8bbed6c9486473abb6671246bf8337c2d6ef27fa Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 3 Mar 2020 12:12:43 +0000
+Subject: [PATCH 8569/8586] net: phylink: use phy interface mode bitmaps
+
+Use the phy interface mode bitmaps for SFP modules and PHYs to select
+the operating interface for SFPs and PHYs with SFPs.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/phy/phylink.c | 116 +++++++++++++++++++++++++++++++-------
+ include/linux/phylink.h   |   1 +
+ 2 files changed, 98 insertions(+), 19 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index ea32f38db10e..99d46bf7e4e0 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -73,6 +73,7 @@ struct phylink {
+ 
+ 	struct sfp_bus *sfp_bus;
+ 	bool sfp_may_have_phy;
++	DECLARE_PHY_INTERFACE_MASK(sfp_interfaces);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(sfp_support);
+ 	u8 sfp_port;
+ };
+@@ -1789,6 +1790,41 @@ static void phylink_sfp_detach(void *upstream, struct sfp_bus *bus)
+ 	pl->netdev->sfp_bus = NULL;
+ }
+ 
++static const phy_interface_t phylink_sfp_interface_preference[] = {
++	PHY_INTERFACE_MODE_USXGMII,
++	PHY_INTERFACE_MODE_10GBASER,
++	PHY_INTERFACE_MODE_10GKR,
++	PHY_INTERFACE_MODE_2500BASEX,
++	PHY_INTERFACE_MODE_SGMII,
++	PHY_INTERFACE_MODE_1000BASEX,
++};
++
++static phy_interface_t phylink_select_interface(struct phylink *pl,
++						const unsigned long *intf,
++						const char *intf_name)
++{
++	DECLARE_PHY_INTERFACE_MASK(u);
++	phy_interface_t interface;
++	size_t i;
++
++	phy_interface_and(u, intf, pl->config->supported_interfaces);
++
++	interface = PHY_INTERFACE_MODE_NA;
++	for (i = 0; i < ARRAY_SIZE(phylink_sfp_interface_preference); i++)
++		if (test_bit(phylink_sfp_interface_preference[i], u)) {
++			interface = phylink_sfp_interface_preference[i];
++			break;
++		}
++
++	phylink_info(pl, "interfaces=[mac=%*pbl %s=%*pbl] selected %d (%s)\n",
++		     (int)PHY_INTERFACE_MODE_MAX,
++		     pl->config->supported_interfaces,
++		     intf_name, (int)PHY_INTERFACE_MODE_MAX, intf,
++		     interface, phy_modes(interface));
++
++	return interface;
++}
++
+ static int phylink_sfp_config(struct phylink *pl, u8 mode,
+ 			      const unsigned long *supported,
+ 			      const unsigned long *advertising)
+@@ -1871,25 +1907,33 @@ static int phylink_sfp_config(struct phylink *pl, u8 mode,
+ 	return ret;
+ }
+ 
++static int phylink_sfp_config_nophy(struct phylink *pl)
++{
++	if (!phy_interface_empty(pl->config->supported_interfaces))
++		phylink_select_interface(pl, pl->sfp_interfaces, "sfp");
++
++	return phylink_sfp_config(pl, MLO_AN_INBAND,
++				  pl->sfp_support, pl->sfp_support);
++}
++
+ static int phylink_sfp_module_insert(void *upstream,
+ 				     const struct sfp_eeprom_id *id)
+ {
+ 	struct phylink *pl = upstream;
+-	unsigned long *support = pl->sfp_support;
+-	DECLARE_PHY_INTERFACE_MASK(sfp_interfaces);
+ 
+ 	ASSERT_RTNL();
+ 
+-	linkmode_zero(support);
+-	sfp_parse_support(pl->sfp_bus, id, support, sfp_interfaces);
+-	pl->sfp_port = sfp_parse_port(pl->sfp_bus, id, support);
++	linkmode_zero(pl->sfp_support);
++	phy_interface_zero(pl->sfp_interfaces);
++	sfp_parse_support(pl->sfp_bus, id, pl->sfp_support, pl->sfp_interfaces);
++	pl->sfp_port = sfp_parse_port(pl->sfp_bus, id, pl->sfp_support);
+ 
+ 	/* If this module may have a PHY connecting later, defer until later */
+ 	pl->sfp_may_have_phy = sfp_may_have_phy(pl->sfp_bus, id);
+ 	if (pl->sfp_may_have_phy)
+ 		return 0;
+ 
+-	return phylink_sfp_config(pl, MLO_AN_INBAND, support, support);
++	return phylink_sfp_config_nophy(pl);
+ }
+ 
+ static int phylink_sfp_module_start(void *upstream)
+@@ -1908,8 +1952,7 @@ static int phylink_sfp_module_start(void *upstream)
+ 	if (!pl->sfp_may_have_phy)
+ 		return 0;
+ 
+-	return phylink_sfp_config(pl, MLO_AN_INBAND,
+-				  pl->sfp_support, pl->sfp_support);
++	return phylink_sfp_config_nophy(pl);
+ }
+ 
+ static void phylink_sfp_module_stop(void *upstream)
+@@ -1970,19 +2013,54 @@ static int phylink_sfp_connect_phy(void *upstream, struct phy_device *phy)
+ 	else
+ 		mode = MLO_AN_INBAND;
+ 
+-	/* Do the initial configuration */
+-	ret = phylink_sfp_config(pl, mode, phy->supported, phy->advertising);
+-	if (ret < 0)
+-		return ret;
++	if (!phy_interface_empty(phy->supported_interfaces) &&
++	    !phy_interface_empty(pl->config->supported_interfaces)) {
++		interface = phylink_select_interface(pl,
++						     phy->supported_interfaces,
++						     "phy");
++		if (interface == PHY_INTERFACE_MODE_NA) {
++			phylink_err(pl,
++				    "selection of interface for PHY failed\n");
++			return -EINVAL;
++		}
+ 
+-	interface = pl->link_config.interface;
+-	ret = phylink_attach_phy(pl, phy, interface);
+-	if (ret < 0)
+-		return ret;
++		if (pl->cur_link_an_mode != mode ||
++		    pl->link_config.interface != interface) {
++			pl->link_config.interface = interface;
++			pl->cur_link_an_mode = mode;
+ 
+-	ret = phylink_bringup_phy(pl, phy, interface);
+-	if (ret)
+-		phy_detach(phy);
++			phylink_info(pl, "switched to %s/%s link mode\n",
++				     phylink_an_mode_str(mode),
++				     phy_modes(interface));
++		}
++
++		ret = phylink_attach_phy(pl, phy, interface);
++		if (ret < 0)
++			return ret;
++
++		ret = phylink_bringup_phy(pl, phy, interface);
++		if (ret)
++			phy_detach(phy);
++
++		if (!test_bit(PHYLINK_DISABLE_STOPPED,
++			      &pl->phylink_disable_state))
++			phylink_mac_initial_config(pl);
++	} else {
++		/* Do the initial configuration */
++		ret = phylink_sfp_config(pl, mode, phy->supported,
++					phy->advertising);
++		if (ret < 0)
++			return ret;
++
++		interface = pl->link_config.interface;
++		ret = phylink_attach_phy(pl, phy, interface);
++		if (ret < 0)
++			return ret;
++
++		ret = phylink_bringup_phy(pl, phy, interface);
++		if (ret)
++			phy_detach(phy);
++	}
+ 
+ 	return ret;
+ }
+diff --git a/include/linux/phylink.h b/include/linux/phylink.h
+index 641720ef712f..31e61ea4e3e2 100644
+--- a/include/linux/phylink.h
++++ b/include/linux/phylink.h
+@@ -67,6 +67,7 @@ enum phylink_op_type {
+ struct phylink_config {
+ 	struct device *dev;
+ 	enum phylink_op_type type;
++	DECLARE_PHY_INTERFACE_MASK(supported_interfaces);
+ };
+ 
+ /**
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8570-net-mvneta-fill-in-phy-interface-mode-bitmap.patch b/target/linux/mvebu/patches-5.10/8570-net-mvneta-fill-in-phy-interface-mode-bitmap.patch
new file mode 100644
index 0000000..6f9d85b
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8570-net-mvneta-fill-in-phy-interface-mode-bitmap.patch
@@ -0,0 +1,43 @@
+From 429204abeca76e1f10f837454519fe12a95856a7 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 3 Mar 2020 12:15:38 +0000
+Subject: [PATCH 8570/8586] net: mvneta: fill in phy interface mode bitmap
+
+Fill in the phy interface mode bitmap for the Marvell mvneta driver, so
+phylink can know which interfaces are supported by the MAC.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 16 ++++++++++++++++
+ 1 file changed, 16 insertions(+)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index ccb2abd18d6c..c857ff3d5aef 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -4556,6 +4556,22 @@ static int mvneta_probe(struct platform_device *pdev)
+ 
+ 	pp->phylink_config.dev = &dev->dev;
+ 	pp->phylink_config.type = PHYLINK_NETDEV;
++	__set_bit(PHY_INTERFACE_MODE_SGMII,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII_ID,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII_RXID,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII_TXID,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_QSGMII,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_1000BASEX,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_2500BASEX,
++		  pp->phylink_config.supported_interfaces);
+ 
+ 	phylink = phylink_create(&pp->phylink_config, pdev->dev.fwnode,
+ 				 phy_mode, &mvneta_phylink_ops);
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8571-net-phy-mdio-i2c-support-I2C-MDIO-protocol-for-RollB.patch b/target/linux/mvebu/patches-5.10/8571-net-phy-mdio-i2c-support-I2C-MDIO-protocol-for-RollB.patch
new file mode 100644
index 0000000..4e5424e
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8571-net-phy-mdio-i2c-support-I2C-MDIO-protocol-for-RollB.patch
@@ -0,0 +1,285 @@
+From cfd8925a008d441d5dd502a4f5259d898bf14892 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 12 Aug 2020 16:12:02 +0200
+Subject: [PATCH 8571/8586] net: phy: mdio-i2c: support I2C MDIO protocol for
+ RollBall SFP modules
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Some multigig SFPs from RollBall and Hilink do not expose functional
+MDIO access to the internal PHY of the SFP via I2C address 0x56
+(although there seems to be read-only clause 22 access on this address).
+
+Instead these SFPs PHY can be accessed via I2C via the SFP Enhanced
+Digital Diagnostic Interface - I2C address 0x51.
+
+This extends the mdio-i2c driver so that when SFP PHY address 17 is used
+(which in mdio-i2c terms corresponds to I2C address 0x51), then this
+different protocol is used for MDIO access.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/net/phy/mdio-i2c.c | 197 +++++++++++++++++++++++++++++++++++--
+ 1 file changed, 187 insertions(+), 10 deletions(-)
+
+diff --git a/drivers/net/phy/mdio-i2c.c b/drivers/net/phy/mdio-i2c.c
+index 0dce67672548..a529b69c123f 100644
+--- a/drivers/net/phy/mdio-i2c.c
++++ b/drivers/net/phy/mdio-i2c.c
+@@ -3,12 +3,14 @@
+  * MDIO I2C bridge
+  *
+  * Copyright (C) 2015-2016 Russell King
++ * Copyright (C) 2020 Marek Behun
+  *
+  * Network PHYs can appear on I2C buses when they are part of SFP module.
+  * This driver exposes these PHYs to the networking PHY code, allowing
+  * our PHY drivers access to these PHYs, and so allowing configuration
+  * of their settings.
+  */
++#include <linux/delay.h>
+ #include <linux/i2c.h>
+ #include <linux/phy.h>
+ 
+@@ -17,11 +19,17 @@
+ /*
+  * I2C bus addresses 0x50 and 0x51 are normally an EEPROM, which is
+  * specified to be present in SFP modules.  These correspond with PHY
+- * addresses 16 and 17.  Disallow access to these "phy" addresses.
++ * addresses 16 and 17.  Disallow access to 0x50 "phy" address.
++ * Use RollBall protocol when accessing via the 0x51 address.
+  */
+ static bool i2c_mii_valid_phy_id(int phy_id)
+ {
+-	return phy_id != 0x10 && phy_id != 0x11;
++	return phy_id != 0x10;
++}
++
++static bool i2c_mii_rollball_phy_id(int phy_id)
++{
++	return phy_id == 0x11;
+ }
+ 
+ static unsigned int i2c_mii_phy_addr(int phy_id)
+@@ -29,16 +37,13 @@ static unsigned int i2c_mii_phy_addr(int
+ 	return phy_id + 0x40;
+ }
+ 
+-static int i2c_mii_read(struct mii_bus *bus, int phy_id, int reg)
++static int i2c_mii_read_default(struct mii_bus *bus, int phy_id, int reg)
+ {
+ 	struct i2c_adapter *i2c = bus->priv;
+ 	struct i2c_msg msgs[2];
+ 	u8 addr[3], data[2], *p;
+ 	int bus_addr, ret;
+ 
+-	if (!i2c_mii_valid_phy_id(phy_id))
+-		return 0xffff;
+-
+ 	p = addr;
+ 	if (reg & MII_ADDR_C45) {
+ 		*p++ = 0x20 | ((reg >> 16) & 31);
+@@ -63,16 +68,13 @@ static int i2c_mii_read(struct mii_bus *
+ 	return data[0] << 8 | data[1];
+ }
+ 
+-static int i2c_mii_write(struct mii_bus *bus, int phy_id, int reg, u16 val)
++static int i2c_mii_write_default(struct mii_bus *bus, int phy_id, int reg, u16 val)
+ {
+ 	struct i2c_adapter *i2c = bus->priv;
+ 	struct i2c_msg msg;
+ 	int ret;
+ 	u8 data[5], *p;
+ 
+-	if (!i2c_mii_valid_phy_id(phy_id))
+-		return 0;
+-
+ 	p = data;
+ 	if (reg & MII_ADDR_C45) {
+ 		*p++ = (reg >> 16) & 31;
+@@ -92,6 +94,181 @@ static int i2c_mii_write(struct mii_bus
+ 	return ret < 0 ? ret : 0;
+ }
+ 
++/* RollBall SFPs do not access internal PHY via I2C address 0x56, but
++ * instead via address 0x51, when SFP page is set to 0x03 and password to
++ * 0xffffffff:
++ *
++ * address  size  contents  description
++ * -------  ----  --------  -----------
++ * 0x80     1     CMD       0x01/0x02/0x04 for write/read/done
++ * 0x81     1     DEV       Clause 45 device
++ * 0x82     2     REG       Clause 45 register
++ * 0x84     2     VAL       Register value
++ */
++#define ROLLBALL_CMD_ADDR		0x80
++#define ROLLBALL_DATA_ADDR		0x81
++
++#define ROLLBALL_CMD_WRITE		0x01
++#define ROLLBALL_CMD_READ		0x02
++#define ROLLBALL_CMD_DONE		0x04
++
++static int i2c_rollball_mii_poll(struct mii_bus *bus, int bus_addr, u8 *buf, size_t len)
++{
++	struct i2c_adapter *i2c = bus->priv;
++	struct i2c_msg msgs[2];
++	u8 buf0[2], *res;
++	int i, ret;
++
++	buf0[0] = ROLLBALL_CMD_ADDR;
++
++	msgs[0].addr = bus_addr;
++	msgs[0].flags = 0;
++	msgs[0].len = 1;
++	msgs[0].buf = &buf0[0];
++
++	res = buf ? buf : &buf0[1];
++
++	msgs[1].addr = bus_addr;
++	msgs[1].flags = I2C_M_RD;
++	msgs[1].len = buf ? len : 1;
++	msgs[1].buf = res;
++
++	/* By experiment it takes up to 70 ms to access a register for these SFPs. Sleep 20ms
++	  * between iteratios and try 10 times.
++	  */
++	i = 10;
++	do {
++		msleep(20);
++
++		ret = i2c_transfer(i2c, msgs, ARRAY_SIZE(msgs));
++		if (ret < 0)
++			return ret;
++		else if (ret != ARRAY_SIZE(msgs))
++			return -EIO;
++
++		if (*res == ROLLBALL_CMD_DONE)
++			return 0;
++	} while (i-- > 0);
++
++	dev_dbg(&bus->dev, "poll timed out\n");
++
++	return -ETIMEDOUT;
++}
++
++static int i2c_rollball_mii_cmd(struct mii_bus *bus, int bus_addr, u8 cmd, u8 *data, size_t len)
++{
++	struct i2c_adapter *i2c = bus->priv;
++	struct i2c_msg msgs[2];
++	u8 cmdbuf[2];
++	int ret;
++
++	msgs[0].addr = bus_addr;
++	msgs[0].flags = 0;
++	msgs[0].len = len;
++	msgs[0].buf = data;
++
++	cmdbuf[0] = ROLLBALL_CMD_ADDR;
++	cmdbuf[1] = cmd;
++
++	msgs[1].addr = bus_addr;
++	msgs[1].flags = 0;
++	msgs[1].len = sizeof(cmdbuf);
++	msgs[1].buf = cmdbuf;
++
++	ret = i2c_transfer(i2c, msgs, 2);
++	if (ret < 0)
++		return ret;
++
++	return ret == ARRAY_SIZE(msgs) ? 0 : -EIO;
++}
++
++static int i2c_mii_read_rollball(struct mii_bus *bus, int phy_id, int reg)
++{
++	u8 buf[4], res[6];
++	int bus_addr, ret;
++	u16 val;
++
++	if (!(reg & MII_ADDR_C45))
++		return -EOPNOTSUPP;
++
++	buf[0] = ROLLBALL_DATA_ADDR;
++	buf[1] = (reg >> 16) & 0x1f;
++	buf[2] = (reg >> 8) & 0xff;
++	buf[3] = reg & 0xff;
++
++	bus_addr = i2c_mii_phy_addr(phy_id);
++
++	ret = i2c_rollball_mii_cmd(bus, bus_addr, ROLLBALL_CMD_READ, buf, sizeof(buf));
++	if (ret < 0)
++		return ret;
++
++	ret = i2c_rollball_mii_poll(bus, bus_addr, res, sizeof(res));
++	if (ret == -ETIMEDOUT)
++		return 0xffff;
++	else if (ret < 0)
++		return ret;
++
++	val = res[4];
++	val <<= 8;
++	val |= res[5];
++
++	dev_dbg(&bus->dev, "read reg %02x:%04x = %04x\n", (reg >> 16) & 0x1f, reg & 0xffff, val);
++
++	return val;
++}
++
++static int i2c_mii_write_rollball(struct mii_bus *bus, int phy_id, int reg, u16 val)
++{
++	int bus_addr, ret;
++	u8 buf[6];
++
++	if (!(reg & MII_ADDR_C45))
++		return -EOPNOTSUPP;
++
++	buf[0] = ROLLBALL_DATA_ADDR;
++	buf[1] = (reg >> 16) & 0x1f;
++	buf[2] = (reg >> 8) & 0xff;
++	buf[3] = reg & 0xff;
++	buf[4] = val >> 8;
++	buf[5] = val & 0xff;
++
++	bus_addr = i2c_mii_phy_addr(phy_id);
++
++	ret = i2c_rollball_mii_cmd(bus, bus_addr, ROLLBALL_CMD_WRITE, buf, sizeof(buf));
++	if (ret < 0)
++		return ret;
++
++	ret = i2c_rollball_mii_poll(bus, bus_addr, NULL, 0);
++	if (ret < 0)
++		return ret;
++
++	dev_dbg(&bus->dev, "write reg %02x:%04x = %04x\n", (reg >> 16) & 0x1f, reg & 0xffff, val);
++
++	return 0;
++}
++
++static int i2c_mii_read(struct mii_bus *bus, int phy_id, int reg)
++{
++	if (!i2c_mii_valid_phy_id(phy_id))
++		return 0xffff;
++
++	if (i2c_mii_rollball_phy_id(phy_id))
++		return i2c_mii_read_rollball(bus, phy_id, reg);
++	else
++		return i2c_mii_read_default(bus, phy_id, reg);
++}
++
++static int i2c_mii_write(struct mii_bus *bus, int phy_id, int reg, u16 val)
++{
++	if (!i2c_mii_valid_phy_id(phy_id))
++		return 0;
++
++	if (i2c_mii_rollball_phy_id(phy_id))
++		return i2c_mii_write_rollball(bus, phy_id, reg, val);
++	else
++		return i2c_mii_write_default(bus, phy_id, reg, val);
++}
++
+ struct mii_bus *mdio_i2c_alloc(struct device *parent, struct i2c_adapter *i2c)
+ {
+ 	struct mii_bus *mii;
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8572-net-phy-sfp-add-support-for-multigig-RollBall-module.patch b/target/linux/mvebu/patches-5.10/8572-net-phy-sfp-add-support-for-multigig-RollBall-module.patch
new file mode 100644
index 0000000..fa69547
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8572-net-phy-sfp-add-support-for-multigig-RollBall-module.patch
@@ -0,0 +1,171 @@
+From edae63276a1d5e736f88b80aff0e4cbc3a787473 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 12 Aug 2020 16:14:54 +0200
+Subject: [PATCH 8572/8586] net: phy: sfp: add support for multigig RollBall
+ modules
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds support for multigig copper SFP modules from RollBall/Hilink.
+These modules have a specific way to access clause 45 registers of the
+internal PHY.
+
+We also need to wait at least 25 seconds after deasserting TX disable
+before accessing the PHY. The code waits for 30 seconds just to be sure.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/net/phy/sfp.c | 67 +++++++++++++++++++++++++++++++++++++++----
+ 1 file changed, 62 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/net/phy/sfp.c b/drivers/net/phy/sfp.c
+index 73c2969f11a4..a7404b16628f 100644
+--- a/drivers/net/phy/sfp.c
++++ b/drivers/net/phy/sfp.c
+@@ -165,6 +165,7 @@ static const enum gpiod_flags gpio_flags[] = {
+  * on board (for a copper SFP) time to initialise.
+  */
+ #define T_WAIT			msecs_to_jiffies(50)
++#define T_WAIT_LONG_PHY		msecs_to_jiffies(30000)
+ #define T_START_UP		msecs_to_jiffies(300)
+ #define T_START_UP_BAD_GPON	msecs_to_jiffies(60000)
+ 
+@@ -204,8 +205,11 @@ static const enum gpiod_flags gpio_flags[] = {
+ 
+ /* SFP modules appear to always have their PHY configured for bus address
+  * 0x56 (which with mdio-i2c, translates to a PHY address of 22).
++ * RollBall SFPs access phy via SFP Enhanced Digital Diagnostic Interface
++ * via address 0x51 (mdio-i2c will use RollBall protocol on this address).
+  */
+-#define SFP_PHY_ADDR	22
++#define SFP_PHY_ADDR		22
++#define SFP_PHY_ADDR_ROLLBALL	17
+ 
+ struct sff_data {
+ 	unsigned int gpios;
+@@ -220,6 +224,7 @@ struct sfp {
+ 	struct phy_device *mod_phy;
+ 	const struct sff_data *type;
+ 	u32 max_power_mW;
++	int phy_addr;
+ 
+ 	unsigned int (*get_state)(struct sfp *);
+ 	void (*set_state)(struct sfp *, unsigned int);
+@@ -248,6 +253,7 @@ struct sfp {
+ 	struct sfp_eeprom_id id;
+ 	unsigned int module_power_mW;
+ 	unsigned int module_t_start_up;
++	unsigned int module_t_wait;
+ 
+ #if IS_ENABLED(CONFIG_HWMON)
+ 	struct sfp_diag diag;
+@@ -1431,7 +1437,7 @@ static int sfp_sm_probe_phy(struct sfp *sfp, bool is_c45)
+ 	struct phy_device *phy;
+ 	int err;
+ 
+-	phy = get_phy_device(sfp->i2c_mii, SFP_PHY_ADDR, is_c45);
++	phy = get_phy_device(sfp->i2c_mii, sfp->phy_addr, is_c45);
+ 	if (phy == ERR_PTR(-ENODEV))
+ 		return PTR_ERR(phy);
+ 	if (IS_ERR(phy)) {
+@@ -1632,11 +1638,39 @@ static int sfp_sm_mod_hpower(struct sfp *sfp, bool enable)
+ 	return 0;
+ }
+ 
++static int sfp_rollball_init_mdio(struct sfp *sfp)
++{
++	u8 page, password[4];
++	int err;
++
++	page = 3;
++
++	err = sfp_write(sfp, true, SFP_PAGE, &page, 1);
++	if (err != 1) {
++		dev_err(sfp->dev, "Failed to set SFP page for RollBall MDIO access: %d\n", err);
++		return err;
++	}
++
++	password[0] = 0xff;
++	password[1] = 0xff;
++	password[2] = 0xff;
++	password[3] = 0xff;
++
++	err = sfp_write(sfp, true, 0x7b, password, 4);
++	if (err != 4) {
++		dev_err(sfp->dev, "Failed to write password for RollBall MDIO access; %d\n", err);
++		return err;
++	}
++
++	return 0;
++}
++
+ static int sfp_sm_mod_probe(struct sfp *sfp, bool report)
+ {
+ 	/* SFP module inserted - read I2C data */
+ 	struct sfp_eeprom_id id;
+ 	bool cotsworks;
++	bool rollball;
+ 	u8 check;
+ 	int ret;
+ 
+@@ -1691,6 +1725,24 @@ static int sfp_sm_mod_probe(struct sfp *sfp, bool report)
+ 		}
+ 	}
+ 
++	sfp->phy_addr = SFP_PHY_ADDR;
++
++	rollball = ((!memcmp(id.base.vendor_name, "OEM             ", 16) ||
++		     !memcmp(id.base.vendor_name, "Turris          ", 16)) &&
++		    (!memcmp(id.base.vendor_pn, "SFP-10G-T       ", 16) ||
++		     !memcmp(id.base.vendor_pn, "RTSFP-10        ", 16) ||
++		     !memcmp(id.base.vendor_pn, "RTSFP-2.5G      ", 16)));
++	if (rollball) {
++		sfp->phy_addr = SFP_PHY_ADDR_ROLLBALL;
++		ret = sfp_rollball_init_mdio(sfp);
++		if (ret < 0)
++			return ret;
++
++		/* RollBall SFPs may have wrong (zero) extended compliacne code burned in EEPROM.
++		 * To try to probe for PHY we need the correct one */
++		id.base.extended_cc = SFF8024_ECC_10GBASE_T_SFI;
++	}
++
+ 	sfp->id = id;
+ 
+ 	dev_info(sfp->dev, "module %.*s %.*s rev %.*s sn %.*s dc %.*s\n",
+@@ -1724,6 +1776,11 @@ static int sfp_sm_mod_probe(struct sfp *sfp, bool report)
+ 	else
+ 		sfp->module_t_start_up = T_START_UP;
+ 
++	if (rollball)
++		sfp->module_t_wait = T_WAIT_LONG_PHY;
++	else
++		sfp->module_t_wait = T_WAIT;
++
+ 	return 0;
+ }
+ 
+@@ -1919,7 +1976,7 @@ static void sfp_sm_main(struct sfp *sfp, unsigned int event)
+ 		 * while TX_DISABLE is asserted. The earliest we want to do
+ 		 * anything (such as probe for a PHY) is 50ms.
+ 		 */
+-		sfp_sm_next(sfp, SFP_S_WAIT, T_WAIT);
++		sfp_sm_next(sfp, SFP_S_WAIT, sfp->module_t_wait);
+ 		break;
+ 
+ 	case SFP_S_WAIT:
+@@ -1933,8 +1990,8 @@ static void sfp_sm_main(struct sfp *sfp, unsigned int event)
+ 			 * deasserting.
+ 			 */
+ 			timeout = sfp->module_t_start_up;
+-			if (timeout > T_WAIT)
+-				timeout -= T_WAIT;
++			if (timeout > sfp->module_t_wait)
++				timeout -= sfp->module_t_wait;
+ 			else
+ 				timeout = 1;
+ 
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8573-net-phylink-don-t-fail-attaching-phy-on-1000base-x-2.patch b/target/linux/mvebu/patches-5.10/8573-net-phylink-don-t-fail-attaching-phy-on-1000base-x-2.patch
new file mode 100644
index 0000000..4901b52
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8573-net-phylink-don-t-fail-attaching-phy-on-1000base-x-2.patch
@@ -0,0 +1,37 @@
+From 5b9a8d4b7c87569e9073fdd1027f1457ccf6a972 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 12 Aug 2020 19:04:39 +0200
+Subject: [PATCH 8573/8586] net: phylink: don't fail attaching phy on
+ 1000base-x/2500base-x mode
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Some SFPs may contain an internal PHY which may in some cases want to
+connect with the host interface in 1000base-x/2500base-x mode.
+Do not fail if such PHY is being attached in one of these PHY interface
+modes.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/net/phy/phylink.c | 4 +---
+ 1 file changed, 1 insertion(+), 3 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 99d46bf7e4e0..001149c189cc 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -851,9 +851,7 @@ static int phylink_bringup_phy(struct phylink *pl, struct phy_device *phy,
+ static int phylink_attach_phy(struct phylink *pl, struct phy_device *phy,
+ 			      phy_interface_t interface)
+ {
+-	if (WARN_ON(pl->cfg_link_an_mode == MLO_AN_FIXED ||
+-		    (pl->cfg_link_an_mode == MLO_AN_INBAND &&
+-		     phy_interface_mode_is_8023z(interface))))
++	if (WARN_ON(pl->cfg_link_an_mode == MLO_AN_FIXED))
+ 		return -EINVAL;
+ 
+ 	if (pl->phydev)
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8574-net-phylink-let-PHYs-know-what-interfaces-are-suppor.patch b/target/linux/mvebu/patches-5.10/8574-net-phylink-let-PHYs-know-what-interfaces-are-suppor.patch
new file mode 100644
index 0000000..e25efaa
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8574-net-phylink-let-PHYs-know-what-interfaces-are-suppor.patch
@@ -0,0 +1,111 @@
+From 11d0c8a1e39f1780b4a9e14b9a6a1c3260baeae2 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Tue, 18 Aug 2020 19:45:48 +0200
+Subject: [PATCH 8574/8586] net: phylink: let PHYs know what interfaces are
+ supported by host
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Some PHYs may want to configure how they talk to the host. For this they
+need to know which PHY interface modes the host MAC supports.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/net/phy/phylink.c | 24 ++++++++++++++++++++++++
+ include/linux/phy.h       |  8 +++++++-
+ 2 files changed, 31 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 001149c189cc..7f1fff35c5a7 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -885,6 +885,9 @@ int phylink_connect_phy(struct phylink *pl, struct phy_device *phy)
+ 		pl->link_config.interface = pl->link_interface;
+ 	}
+ 
++	/* Set the PHY's host supported interfaces */
++	phy_interface_copy(phy->host_interfaces, pl->config->supported_interfaces);
++
+ 	ret = phylink_attach_phy(pl, phy, pl->link_interface);
+ 	if (ret < 0)
+ 		return ret;
+@@ -940,6 +943,9 @@ int phylink_of_phy_connect(struct phylink *pl, struct device_node *dn,
+ 	if (!phy_dev)
+ 		return -ENODEV;
+ 
++	/* Set the PHY's host supported interfaces */
++	phy_interface_copy(phy_dev->host_interfaces, pl->config->supported_interfaces);
++
+ 	ret = phy_attach_direct(pl->netdev, phy_dev, flags,
+ 				pl->link_interface);
+ 	if (ret)
+@@ -1788,6 +1794,8 @@ static void phylink_sfp_detach(void *upstream, struct sfp_bus *bus)
+ 	pl->netdev->sfp_bus = NULL;
+ }
+ 
++static DECLARE_PHY_INTERFACE_MASK(phylink_sfp_interfaces);
++
+ static const phy_interface_t phylink_sfp_interface_preference[] = {
+ 	PHY_INTERFACE_MODE_USXGMII,
+ 	PHY_INTERFACE_MODE_10GBASER,
+@@ -1797,6 +1805,18 @@ static const phy_interface_t phylink_sfp_interface_preference[] = {
+ 	PHY_INTERFACE_MODE_1000BASEX,
+ };
+ 
++static int __init phylink_init(void)
++{
++	int i;
++
++	for (i = 0; i < ARRAY_SIZE(phylink_sfp_interface_preference); i++)
++		set_bit(phylink_sfp_interface_preference[i],
++			phylink_sfp_interfaces);
++
++	return 0;
++}
++module_init(phylink_init);
++
+ static phy_interface_t phylink_select_interface(struct phylink *pl,
+ 						const unsigned long *intf,
+ 						const char *intf_name)
+@@ -2011,6 +2031,10 @@ static int phylink_sfp_connect_phy(void *upstream, struct phy_device *phy)
+ 	else
+ 		mode = MLO_AN_INBAND;
+ 
++	/* Set the PHY's host supported interfaces */
++	phy_interface_and(phy->host_interfaces, phylink_sfp_interfaces,
++			  pl->config->supported_interfaces);
++
+ 	if (!phy_interface_empty(phy->supported_interfaces) &&
+ 	    !phy_interface_empty(pl->config->supported_interfaces)) {
+ 		interface = phylink_select_interface(pl,
+diff --git a/include/linux/phy.h b/include/linux/phy.h
+index 2bf28a737521..d878e23dca16 100644
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -127,6 +127,11 @@ static inline void phy_interface_and(unsigned long *dst, const unsigned long *a,
+ 	bitmap_and(dst, a, b, PHY_INTERFACE_MODE_MAX);
+ }
+ 
++static inline void phy_interface_copy(unsigned long *dst, const unsigned long *src)
++{
++	bitmap_copy(dst, src, PHY_INTERFACE_MODE_MAX);
++}
++
+ /**
+  * phy_supported_speeds - return all speeds currently supported by a phy device
+  * @phy: The phy device to return supported speeds of.
+@@ -432,8 +437,9 @@ struct phy_device {
+ 	/* used with phy_speed_down */
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(adv_old);
+ 
+-	/* bitmap of supported interfaces */
++	/* bitmap of supported interfaces and host supported interfaces */
+ 	DECLARE_PHY_INTERFACE_MASK(supported_interfaces);
++	DECLARE_PHY_INTERFACE_MASK(host_interfaces);
+ 
+ 	/* Energy efficient ethernet modes which should be prohibited */
+ 	u32 eee_broken_modes;
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8586-net-phy-marvell10g-change-MACTYPE-according-to-host-.patch b/target/linux/mvebu/patches-5.10/8586-net-phy-marvell10g-change-MACTYPE-according-to-host-.patch
new file mode 100644
index 0000000..49cf29f
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8586-net-phy-marvell10g-change-MACTYPE-according-to-host-.patch
@@ -0,0 +1,216 @@
+From 6360d5e3f3ea7ce23064aed391ce9b055b380b66 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 19 Aug 2020 15:46:36 +0200
+Subject: [PATCH 8586/8586] net: phy: marvell10g: change MACTYPE according to
+ host supported interface modes
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Use phydev->host_interfaces to determine and set MACTYPE accordingly.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/net/phy/marvell10g.c | 132 ++++++++++++++++++++++++++++++-----
+ 1 file changed, 113 insertions(+), 19 deletions(-)
+
+diff --git a/drivers/net/phy/marvell10g.c b/drivers/net/phy/marvell10g.c
+index 78807bae2117..7f6ac6b1630e 100644
+--- a/drivers/net/phy/marvell10g.c
++++ b/drivers/net/phy/marvell10g.c
+@@ -79,6 +79,7 @@ enum {
+ 	MV_V2_PORT_CTRL		= 0xf001,
+ 	MV_V2_PORT_CTRL_SWRST	= BIT(15),
+ 	MV_V2_PORT_CTRL_PWRDOWN = BIT(11),
++	MV_V2_PORT_MAC_TYPE_MASK = 0x7,
+ 	/* Temperature control/read registers (88X3310 only) */
+ 	MV_V2_TEMP_CTRL		= 0xf08a,
+ 	MV_V2_TEMP_CTRL_MASK	= 0xc000,
+@@ -90,6 +91,7 @@ enum {
+ 
+ struct mv3310_priv {
+ 	u32 firmware_ver;
++	int mac_type;
+ 
+ 	struct device *hwmon_dev;
+ 	char *hwmon_name;
+@@ -357,8 +359,14 @@ static int mv3310_probe(struct phy_device *phydev)
+ 		return -ENODEV;
+ 
+ 	__set_bit(PHY_INTERFACE_MODE_SGMII, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_1000BASEX, phydev->supported_interfaces);
+ 	__set_bit(PHY_INTERFACE_MODE_2500BASEX, phydev->supported_interfaces);
+-	__set_bit(PHY_INTERFACE_MODE_10GBASER, phydev->supported_interfaces);
++
++	if (phydev->drv->phy_id == MARVELL_PHY_ID_88X3310) {
++		__set_bit(PHY_INTERFACE_MODE_XAUI, phydev->supported_interfaces);
++		__set_bit(PHY_INTERFACE_MODE_RXAUI, phydev->supported_interfaces);
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, phydev->supported_interfaces);
++	}
+ 
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MV_PMA_BOOT);
+ 	if (ret < 0)
+@@ -437,17 +445,81 @@ static bool mv3310_has_pma_ngbaset_quirk(struct phy_device *phydev)
+ 		MV_PHY_ALASKA_NBT_QUIRK_MASK) == MV_PHY_ALASKA_NBT_QUIRK_REV;
+ }
+ 
++static int mv3310_select_mactype(struct phy_device *phydev,
++				 unsigned long *host_interfaces)
++{
++	bool h_sgmii, h_1000, h_10g, h_xaui, h_rxaui;
++
++	h_sgmii = test_bit(PHY_INTERFACE_MODE_SGMII, host_interfaces);
++	h_1000 = test_bit(PHY_INTERFACE_MODE_1000BASEX, host_interfaces);
++	h_10g = test_bit(PHY_INTERFACE_MODE_10GBASER, host_interfaces);
++	h_xaui = test_bit(PHY_INTERFACE_MODE_XAUI, host_interfaces);
++	h_rxaui = test_bit(PHY_INTERFACE_MODE_RXAUI, host_interfaces);
++
++	/* 88E2110 only supports 5gbase-r/2500base-x/SGMII/1000base-x */
++	if (phydev->drv->phy_id == MARVELL_PHY_ID_88E2110)
++		h_10g = h_xaui = h_rxaui = false;
++
++	if (h_sgmii && h_10g)
++		return 4;
++	else if (h_sgmii && h_rxaui)
++		return 0;
++	else if (h_sgmii && h_xaui)
++		return 3;
++	else if (h_10g)
++		return 6;
++	else if (h_rxaui)
++		return 2;
++	else if (h_xaui)
++		return 1;
++	else if (h_sgmii)
++		return 4;
++	else if (h_1000)
++		return 5;
++	else
++		return -1;
++}
++
++static int mv3310_set_mactype(struct phy_device *phydev, int mac_type)
++{
++	struct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);
++	int ret;
++
++	if (mac_type == -1 || phydev->drv->phy_id != MARVELL_PHY_ID_88X3310) {
++		ret = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_V2_PORT_CTRL);
++		if (ret < 0)
++			return ret;
++
++		priv->mac_type = ret & MV_V2_PORT_MAC_TYPE_MASK;
++	} else {
++		ret = phy_modify_mmd_changed(phydev, MDIO_MMD_VEND2, MV_V2_PORT_CTRL,
++					     MV_V2_PORT_CTRL_SWRST | MV_V2_PORT_MAC_TYPE_MASK,
++					     MV_V2_PORT_CTRL_SWRST | mac_type);
++		if (ret < 0)
++			return ret;
++
++		priv->mac_type = mac_type;
++	}
++
++	return 0;
++}
++
+ static int mv3310_config_init(struct phy_device *phydev)
+ {
+-	int err;
++	int err, mac_type = -1;
+ 
+ 	/* Check that the PHY interface type is compatible */
+-	if (phydev->interface != PHY_INTERFACE_MODE_SGMII &&
+-	    phydev->interface != PHY_INTERFACE_MODE_2500BASEX &&
+-	    phydev->interface != PHY_INTERFACE_MODE_XAUI &&
+-	    phydev->interface != PHY_INTERFACE_MODE_RXAUI &&
+-	    phydev->interface != PHY_INTERFACE_MODE_10GBASER)
++	if (!phy_interface_empty(phydev->host_interfaces)) {
++		mac_type = mv3310_select_mactype(phydev, phydev->host_interfaces);
++		phydev_info(phydev, "selected MAC type: %d\n", mac_type);
++	} else if (phydev->interface != PHY_INTERFACE_MODE_SGMII &&
++		   phydev->interface != PHY_INTERFACE_MODE_1000BASEX &&
++		   phydev->interface != PHY_INTERFACE_MODE_2500BASEX &&
++		   phydev->interface != PHY_INTERFACE_MODE_XAUI &&
++		   phydev->interface != PHY_INTERFACE_MODE_RXAUI &&
++		   phydev->interface != PHY_INTERFACE_MODE_10GBASER) {
+ 		return -ENODEV;
++	}
+ 
+ 	phydev->mdix_ctrl = ETH_TP_MDI_AUTO;
+ 
+@@ -456,6 +528,10 @@ static int mv3310_config_init(struct phy_device *phydev)
+ 	if (err)
+ 		return err;
+ 
++	err = mv3310_set_mactype(phydev, mac_type);
++	if (err)
++		return err;
++
+ 	/* Enable EDPD mode - saving 600mW */
+ 	return mv3310_set_edpd(phydev, ETHTOOL_PHY_EDPD_DFLT_TX_MSECS);
+ }
+@@ -562,31 +638,49 @@ static int mv3310_aneg_done(struct phy_device *phydev)
+ 
+ static void mv3310_update_interface(struct phy_device *phydev)
+ {
+-	if ((phydev->interface == PHY_INTERFACE_MODE_SGMII ||
+-	     phydev->interface == PHY_INTERFACE_MODE_2500BASEX ||
+-	     phydev->interface == PHY_INTERFACE_MODE_10GBASER) &&
+-	    phydev->link) {
+-		/* The PHY automatically switches its serdes interface (and
+-		 * active PHYXS instance) between Cisco SGMII, 10GBase-R and
+-		 * 2500BaseX modes according to the speed.  Florian suggests
+-		 * setting phydev->interface to communicate this to the MAC.
+-		 * Only do this if we are already in one of the above modes.
+-		 */
++	struct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);
++
++	switch (priv->mac_type) {
++	case 1:
++		phydev->interface = PHY_INTERFACE_MODE_XAUI;
++		break;
++	case 2:
++		phydev->interface = PHY_INTERFACE_MODE_RXAUI;
++		break;
++	case 6:
++		phydev->interface = PHY_INTERFACE_MODE_10GBASER;
++		break;
++	case 0:
++	case 3:
++	case 4:
++	case 5:
+ 		switch (phydev->speed) {
+ 		case SPEED_10000:
+-			phydev->interface = PHY_INTERFACE_MODE_10GBASER;
++			if (priv->mac_type == 0)
++				phydev->interface = PHY_INTERFACE_MODE_RXAUI;
++			else if (priv->mac_type == 3)
++				phydev->interface = PHY_INTERFACE_MODE_XAUI;
++			else
++				phydev->interface = PHY_INTERFACE_MODE_10GBASER;
+ 			break;
+ 		case SPEED_2500:
+ 			phydev->interface = PHY_INTERFACE_MODE_2500BASEX;
+ 			break;
+ 		case SPEED_1000:
++			if (priv->mac_type == 5)
++				phydev->interface = PHY_INTERFACE_MODE_1000BASEX;
++			else
++				phydev->interface = PHY_INTERFACE_MODE_SGMII;
++			break;
+ 		case SPEED_100:
+ 		case SPEED_10:
+ 			phydev->interface = PHY_INTERFACE_MODE_SGMII;
+-			break;
+ 		default:
+ 			break;
+ 		}
++		break;
++	default:
++		break;
+ 	}
+ }
+ 
+-- 
+2.26.2
+
-- 
2.26.2


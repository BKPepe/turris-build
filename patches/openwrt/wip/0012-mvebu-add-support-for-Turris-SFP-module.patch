From 0d0a5a7562688ef450eb1b5a5d8aa622e0196c56 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
Date: Thu, 24 Sep 2020 00:28:51 +0200
Subject: [PATCH] mvebu: add support for Turris SFP module

---
 target/linux/mvebu/config-5.10                 |   1 +
 ...rror-on-failure-to-read-sfp-soft-sta.patch |  46 +++
 ...-phy-add-PHY_INTERFACE_MODE_10GBASER.patch |  82 +++++
 ...s-to-resolve-negotiated-flow-control.patch | 160 ++++++++++
 ...e-linkmode_test_bit-take-const-point.patch |  34 +++
 ...s-for-parsing-SGMII-auto-negotiation.patch | 113 +++++++
 ...mii_lpa_to_ethtool_lpa_x-to-linkmode.patch |  75 +++++
 ...y-add-supported_interfaces-to-phylib.patch |  58 ++++
 ...supported_interfaces-to-marvell-PHYs.patch |  33 ++
 ...ported_interfaces-to-marvell10g-PHYs.patch |  29 ++
 .../8567-net-sfp-add-interface-bitmap.patch   | 248 +++++++++++++++
 ...ylink-use-phy-interface-mode-bitmaps.patch | 199 ++++++++++++
 ...ta-fill-in-phy-interface-mode-bitmap.patch |  43 +++
 ...-support-I2C-MDIO-protocol-for-RollB.patch | 285 ++++++++++++++++++
 ...support-for-multigig-RollBall-module.patch | 171 +++++++++++
 ...t-fail-attaching-phy-on-1000base-x-2.patch |  37 +++
 ...PHYs-know-what-interfaces-are-suppor.patch | 111 +++++++
 ...0g-change-MACTYPE-according-to-host-.patch | 216 +++++++++++++
 ...vell10g-fix-null-pointer-dereference.patch |  88 ++++++
 47 files changed, 4601 insertions(+)
 create mode 100644 target/linux/mvebu/patches-5.10/8546-net-sfp-report-error-on-failure-to-read-sfp-soft-sta.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8548-net-phy-add-PHY_INTERFACE_MODE_10GBASER.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8554-net-add-helpers-to-resolve-negotiated-flow-control.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8558-net-linkmode-make-linkmode_test_bit-take-const-point.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8559-mii-Add-helpers-for-parsing-SGMII-auto-negotiation.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8560-net-mii-convert-mii_lpa_to_ethtool_lpa_x-to-linkmode.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8564-net-phy-add-supported_interfaces-to-phylib.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8565-net-phy-add-supported_interfaces-to-marvell-PHYs.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8566-net-phy-add-supported_interfaces-to-marvell10g-PHYs.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8567-net-sfp-add-interface-bitmap.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8569-net-phylink-use-phy-interface-mode-bitmaps.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8570-net-mvneta-fill-in-phy-interface-mode-bitmap.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8571-net-phy-mdio-i2c-support-I2C-MDIO-protocol-for-RollB.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8572-net-phy-sfp-add-support-for-multigig-RollBall-module.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8573-net-phylink-don-t-fail-attaching-phy-on-1000base-x-2.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8574-net-phylink-let-PHYs-know-what-interfaces-are-suppor.patch
 create mode 100644 target/linux/mvebu/patches-5.10/8586-net-phy-marvell10g-change-MACTYPE-according-to-host-.patch

diff --git a/target/linux/mvebu/config-5.10 b/target/linux/mvebu/config-5.10
index a13cb8d..eca5632 100644
--- a/target/linux/mvebu/config-5.10
+++ b/target/linux/mvebu/config-5.10
@@ -310,6 +310,7 @@ CONFIG_MACH_MVEBU_V7=y
 CONFIG_MAGIC_SYSRQ=y
 CONFIG_MANGLE_BOOTARGS=y
 CONFIG_MARVELL_PHY=y
+CONFIG_MARVELL_10G_PHY=y
 CONFIG_MDIO_BUS=y
 CONFIG_MDIO_DEVICE=y
 CONFIG_MDIO_I2C=y
diff --git a/target/linux/mvebu/patches-5.10/8546-net-sfp-report-error-on-failure-to-read-sfp-soft-sta.patch b/target/linux/mvebu/patches-5.10/8546-net-sfp-report-error-on-failure-to-read-sfp-soft-sta.patch
new file mode 100644
index 0000000..2fd37bd
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8546-net-sfp-report-error-on-failure-to-read-sfp-soft-sta.patch
@@ -0,0 +1,46 @@
+From 0be0dc493d87e96d0b34441777173f69bfd48432 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 17 Dec 2019 13:50:29 +0000
+Subject: [PATCH 8546/8586] net: sfp: report error on failure to read sfp soft
+ status
+
+Report a rate-limited error if we fail to read the SFP soft status,
+and preserve the current status in that case. This avoids I2C bus
+errors from triggering a link flap.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/sfp.c | 11 +++++++++--
+ 1 file changed, 9 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/net/phy/sfp.c b/drivers/net/phy/sfp.c
+index e54aef921038..73c2969f11a4 100644
+--- a/drivers/net/phy/sfp.c
++++ b/drivers/net/phy/sfp.c
+@@ -442,13 +442,20 @@ static unsigned int sfp_soft_get_state(struct sfp *sfp)
+ {
+ 	unsigned int state = 0;
+ 	u8 status;
++	int ret;
+ 
+-	if (sfp_read(sfp, true, SFP_STATUS, &status, sizeof(status)) ==
+-		     sizeof(status)) {
++	ret = sfp_read(sfp, true, SFP_STATUS, &status, sizeof(status));
++	if (ret == sizeof(status)) {
+ 		if (status & SFP_STATUS_RX_LOS)
+ 			state |= SFP_F_LOS;
+ 		if (status & SFP_STATUS_TX_FAULT)
+ 			state |= SFP_F_TX_FAULT;
++	} else {
++		dev_err_ratelimited(sfp->dev,
++				    "failed to read SFP soft status: %d\n",
++				    ret);
++		/* Preserve the current state */
++		state = sfp->state;
+ 	}
+ 
+ 	return state & sfp->state_soft_mask;
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8548-net-phy-add-PHY_INTERFACE_MODE_10GBASER.patch b/target/linux/mvebu/patches-5.10/8548-net-phy-add-PHY_INTERFACE_MODE_10GBASER.patch
new file mode 100644
index 0000000..08079f1
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8548-net-phy-add-PHY_INTERFACE_MODE_10GBASER.patch
@@ -0,0 +1,82 @@
+From a1d3dba2b5e1f568d5de316cc6998dd6ea9f6bff Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 3 Jan 2020 20:43:17 +0000
+Subject: [PATCH 8548/8586] net: phy: add PHY_INTERFACE_MODE_10GBASER
+
+Recent discussion has revealed that the use of PHY_INTERFACE_MODE_10GKR
+is incorrect. Add a 10GBASE-R definition, document both the -R and -KR
+versions, and the fact that 10GKR was used incorrectly.
+
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ Documentation/networking/phy.rst | 18 ++++++++++++++++++
+ include/linux/phy.h              | 12 ++++++++----
+ 2 files changed, 26 insertions(+), 4 deletions(-)
+
+diff --git a/Documentation/networking/phy.rst b/Documentation/networking/phy.rst
+index a689966bc4be..8adeca741ff9 100644
+--- a/Documentation/networking/phy.rst
++++ b/Documentation/networking/phy.rst
+@@ -267,6 +267,24 @@ Some of the interface modes are described below:
+     duplex, pause or other settings.  This is dependent on the MAC and/or
+     PHY behaviour.
+ 
++``PHY_INTERFACE_MODE_10GBASER``
++    This is the IEEE 802.3 Clause 49 defined 10GBASE-R protocol used with
++    various different mediums. Please refer to the IEEE standard for a
++    definition of this.
++
++    Note: 10GBASE-R is just one protocol that can be used with XFI and SFI.
++    XFI and SFI permit multiple protocols over a single SERDES lane, and
++    also defines the electrical characteristics of the signals with a host
++    compliance board plugged into the host XFP/SFP connector. Therefore,
++    XFI and SFI are not PHY interface types in their own right.
++
++``PHY_INTERFACE_MODE_10GKR``
++    This is the IEEE 802.3 Clause 49 defined 10GBASE-R with Clause 73
++    autonegotiation. Please refer to the IEEE standard for further
++    information.
++
++    Note: due to legacy usage, some 10GBASE-R usage incorrectly makes
++    use of this definition.
+ 
+ Pause frames / flow control
+ ===========================
+diff --git a/include/linux/phy.h b/include/linux/phy.h
+index 80750783b5b0..14fbadac1777 100644
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -99,9 +99,11 @@ typedef enum {
+ 	PHY_INTERFACE_MODE_2500BASEX,
+ 	PHY_INTERFACE_MODE_RXAUI,
+ 	PHY_INTERFACE_MODE_XAUI,
+-	/* 10GBASE-KR, XFI, SFI - single lane 10G Serdes */
+-	PHY_INTERFACE_MODE_10GKR,
++	/* 10GBASE-R, XFI, SFI - single lane 10G Serdes */
++	PHY_INTERFACE_MODE_10GBASER,
+ 	PHY_INTERFACE_MODE_USXGMII,
++	/* 10GBASE-KR - with Clause 73 AN */
++	PHY_INTERFACE_MODE_10GKR,
+ 	PHY_INTERFACE_MODE_MAX,
+ } phy_interface_t;
+ 
+@@ -175,10 +177,12 @@ static inline const char *phy_modes(phy_interface_t interface)
+ 		return "rxaui";
+ 	case PHY_INTERFACE_MODE_XAUI:
+ 		return "xaui";
+-	case PHY_INTERFACE_MODE_10GKR:
+-		return "10gbase-kr";
++	case PHY_INTERFACE_MODE_10GBASER:
++		return "10gbase-r";
+ 	case PHY_INTERFACE_MODE_USXGMII:
+ 		return "usxgmii";
++	case PHY_INTERFACE_MODE_10GKR:
++		return "10gbase-kr";
+ 	default:
+ 		return "unknown";
+ 	}
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8554-net-add-helpers-to-resolve-negotiated-flow-control.patch b/target/linux/mvebu/patches-5.10/8554-net-add-helpers-to-resolve-negotiated-flow-control.patch
new file mode 100644
index 0000000..d8007b2
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8554-net-add-helpers-to-resolve-negotiated-flow-control.patch
@@ -0,0 +1,160 @@
+From 34da89c94569ed4a4c7ae8cab7cf51118c37a902 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Sat, 15 Feb 2020 15:49:27 +0000
+Subject: [PATCH 8554/8586] net: add helpers to resolve negotiated flow control
+
+Add a couple of helpers to resolve negotiated flow control. Two helpers
+are provided:
+
+- linkmode_resolve_pause() which takes the link partner and local
+  advertisements, and decodes whether we should enable TX or RX pause
+  at the MAC. This is useful outside of phylib, e.g. in phylink.
+- phy_get_pause(), which returns the TX/RX enablement status for the
+  current negotiation results of the PHY.
+
+This allows us to centralise the flow control resolution, rather than
+spreading it around.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/Makefile     |  3 ++-
+ drivers/net/phy/linkmode.c   | 44 ++++++++++++++++++++++++++++++++++++
+ drivers/net/phy/phy_device.c | 26 +++++++++++++++++++++
+ include/linux/linkmode.h     |  4 ++++
+ include/linux/phy.h          |  3 +++
+ 5 files changed, 79 insertions(+), 1 deletion(-)
+ create mode 100644 drivers/net/phy/linkmode.c
+
+diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
+index a03437e091f3..693beac6bef4 100644
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -1,7 +1,8 @@
+ # SPDX-License-Identifier: GPL-2.0
+ # Makefile for Linux PHY drivers and MDIO bus drivers
+ 
+-libphy-y			:= phy.o phy-c45.o phy-core.o phy_device.o
++libphy-y			:= phy.o phy-c45.o phy-core.o phy_device.o \
++				   linkmode.o
+ mdio-bus-y			+= mdio_bus.o mdio_device.o
+ 
+ ifdef CONFIG_MDIO_DEVICE
+diff --git a/drivers/net/phy/linkmode.c b/drivers/net/phy/linkmode.c
+new file mode 100644
+index 000000000000..969918795228
+--- /dev/null
++++ b/drivers/net/phy/linkmode.c
+@@ -0,0 +1,44 @@
++// SPDX-License-Identifier: GPL-2.0+
++#include <linux/linkmode.h>
++
++/**
++ * linkmode_resolve_pause - resolve the allowable pause modes
++ * @local_adv: local advertisement in ethtool format
++ * @partner_adv: partner advertisement in ethtool format
++ * @tx_pause: pointer to bool to indicate whether transmit pause should be
++ * enabled.
++ * @rx_pause: pointer to bool to indicate whether receive pause should be
++ * enabled.
++ *
++ * Flow control is resolved according to our and the link partners
++ * advertisements using the following drawn from the 802.3 specs:
++ *  Local device  Link partner
++ *  Pause AsymDir Pause AsymDir Result
++ *    0     X       0     X     Disabled
++ *    0     1       1     0     Disabled
++ *    0     1       1     1     TX
++ *    1     0       0     X     Disabled
++ *    1     X       1     X     TX+RX
++ *    1     1       0     1     RX
++ */
++void linkmode_resolve_pause(const unsigned long *local_adv,
++			    const unsigned long *partner_adv,
++			    bool *tx_pause, bool *rx_pause)
++{
++	__ETHTOOL_DECLARE_LINK_MODE_MASK(m);
++
++	linkmode_and(m, local_adv, partner_adv);
++	if (linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT, m)) {
++		*tx_pause = true;
++		*rx_pause = true;
++	} else if (linkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, m)) {
++		*tx_pause = linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,
++					      partner_adv);
++		*rx_pause = linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,
++					      local_adv);
++	} else {
++		*tx_pause = false;
++		*rx_pause = false;
++	}
++}
++EXPORT_SYMBOL_GPL(linkmode_resolve_pause);
+diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
+index a292d8db3a1d..ac99a2f89f72 100644
+--- a/drivers/net/phy/phy_device.c
++++ b/drivers/net/phy/phy_device.c
+@@ -2178,6 +2178,32 @@ bool phy_validate_pause(struct phy_device *phydev,
+ }
+ EXPORT_SYMBOL(phy_validate_pause);
+ 
++/**
++ * phy_get_pause - resolve negotiated pause modes
++ * @phydev: phy_device struct
++ * @tx_pause: pointer to bool to indicate whether transmit pause should be
++ * enabled.
++ * @rx_pause: pointer to bool to indicate whether receive pause should be
++ * enabled.
++ *
++ * Resolve and return the flow control modes according to the negotiation
++ * result. This includes checking that we are operating in full duplex mode.
++ * See linkmode_resolve_pause() for further details.
++ */
++void phy_get_pause(struct phy_device *phydev, bool *tx_pause, bool *rx_pause)
++{
++	if (phydev->duplex != DUPLEX_FULL) {
++		*tx_pause = false;
++		*rx_pause = false;
++		return;
++	}
++
++	return linkmode_resolve_pause(phydev->advertising,
++				      phydev->lp_advertising,
++				      tx_pause, rx_pause);
++}
++EXPORT_SYMBOL(phy_get_pause);
++
+ static bool phy_drv_supports_irq(struct phy_driver *phydrv)
+ {
+ 	return phydrv->config_intr && phydrv->ack_interrupt;
+diff --git a/include/linux/linkmode.h b/include/linux/linkmode.h
+index fe740031339d..f10fb34f2173 100644
+--- a/include/linux/linkmode.h
++++ b/include/linux/linkmode.h
+@@ -88,4 +88,8 @@ static inline int linkmode_subset(const unsigned long *src1,
+ 	return bitmap_subset(src1, src2, __ETHTOOL_LINK_MODE_MASK_NBITS);
+ }
+ 
++void linkmode_resolve_pause(const unsigned long *local_adv,
++			    const unsigned long *partner_adv,
++			    bool *tx_pause, bool *rx_pause);
++
+ #endif /* __LINKMODE_H */
+diff --git a/include/linux/phy.h b/include/linux/phy.h
+index 5b873139607e..24d21f68ea9b 100644
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -1173,6 +1173,9 @@ void phy_set_sym_pause(struct phy_device *phydev, bool rx, bool tx,
+ void phy_set_asym_pause(struct phy_device *phydev, bool rx, bool tx);
+ bool phy_validate_pause(struct phy_device *phydev,
+ 			struct ethtool_pauseparam *pp);
++void phy_get_pause(struct phy_device *phydev, bool *tx_pause, bool *rx_pause);
++void phy_resolve_pause(unsigned long *local_adv, unsigned long *partner_adv,
++		       bool *tx_pause, bool *rx_pause);
+ 
+ int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,
+ 		       int (*run)(struct phy_device *));
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8558-net-linkmode-make-linkmode_test_bit-take-const-point.patch b/target/linux/mvebu/patches-5.10/8558-net-linkmode-make-linkmode_test_bit-take-const-point.patch
new file mode 100644
index 0000000..88fbc69
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8558-net-linkmode-make-linkmode_test_bit-take-const-point.patch
@@ -0,0 +1,34 @@
+From 15f55bfce3f959303dc485e27867cb3cb7714feb Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Sat, 15 Feb 2020 23:57:36 +0000
+Subject: [PATCH 8558/8586] net: linkmode: make linkmode_test_bit() take const
+ pointer
+
+linkmode_test_bit() does not modify the address; test_bit() is also
+declared const volatile for the same reason. There's no need for
+linkmode_test_bit() to be any different, and allows implementation of
+helpers that take a const linkmode pointer.
+
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/linux/linkmode.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/include/linux/linkmode.h b/include/linux/linkmode.h
+index f10fb34f2173..9ec210f31d06 100644
+--- a/include/linux/linkmode.h
++++ b/include/linux/linkmode.h
+@@ -71,7 +71,7 @@ static inline void linkmode_change_bit(int nr, volatile unsigned long *addr)
+ 	__change_bit(nr, addr);
+ }
+ 
+-static inline int linkmode_test_bit(int nr, volatile unsigned long *addr)
++static inline int linkmode_test_bit(int nr, const volatile unsigned long *addr)
+ {
+ 	return test_bit(nr, addr);
+ }
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8559-mii-Add-helpers-for-parsing-SGMII-auto-negotiation.patch b/target/linux/mvebu/patches-5.10/8559-mii-Add-helpers-for-parsing-SGMII-auto-negotiation.patch
new file mode 100644
index 0000000..6ec0023
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8559-mii-Add-helpers-for-parsing-SGMII-auto-negotiation.patch
@@ -0,0 +1,113 @@
+From ef1f2d257dab46eb563127e75a8c7046756ab0bb Mon Sep 17 00:00:00 2001
+From: Vladimir Oltean <vladimir.oltean@nxp.com>
+Date: Mon, 6 Jan 2020 03:34:09 +0200
+Subject: [PATCH 8559/8586] mii: Add helpers for parsing SGMII auto-negotiation
+
+Typically a MAC PCS auto-configures itself after it receives the
+negotiated copper-side link settings from the PHY, but some MAC devices
+are more special and need manual interpretation of the SGMII AN result.
+
+In other cases, the PCS exposes the entire tx_config_reg base page as it
+is transmitted on the wire during auto-negotiation, so it makes sense to
+be able to decode the equivalent lp_advertised bit mask from the raw u16
+(of course, "lp" considering the PCS to be the local PHY).
+
+Therefore, add the bit definitions for the SGMII registers 4 and 5
+(local device ability, link partner ability), as well as a link_mode
+conversion helper that can be used to feed the AN results into
+phy_resolve_aneg_linkmode.
+
+Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/linux/mii.h      | 50 ++++++++++++++++++++++++++++++++++++++++
+ include/uapi/linux/mii.h | 12 ++++++++++
+ 2 files changed, 62 insertions(+)
+
+diff --git a/include/linux/mii.h b/include/linux/mii.h
+index 4ce8901a1af6..18c6208f56fc 100644
+--- a/include/linux/mii.h
++++ b/include/linux/mii.h
+@@ -372,6 +372,56 @@ static inline u32 mii_lpa_to_ethtool_lpa_x(u32 lpa)
+ 	return result | mii_adv_to_ethtool_adv_x(lpa);
+ }
+ 
++/**
++ * mii_lpa_mod_linkmode_adv_sgmii
++ * @lp_advertising: pointer to destination link mode.
++ * @lpa: value of the MII_LPA register
++ *
++ * A small helper function that translates MII_LPA bits to
++ * linkmode advertisement settings for SGMII.
++ * Leaves other bits unchanged.
++ */
++static inline void
++mii_lpa_mod_linkmode_lpa_sgmii(unsigned long *lp_advertising, u32 lpa)
++{
++	u32 speed_duplex = lpa & LPA_SGMII_DPX_SPD_MASK;
++
++	linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT, lp_advertising,
++			 speed_duplex == LPA_SGMII_1000HALF);
++
++	linkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, lp_advertising,
++			 speed_duplex == LPA_SGMII_1000FULL);
++
++	linkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, lp_advertising,
++			 speed_duplex == LPA_SGMII_100HALF);
++
++	linkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, lp_advertising,
++			 speed_duplex == LPA_SGMII_100FULL);
++
++	linkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, lp_advertising,
++			 speed_duplex == LPA_SGMII_10HALF);
++
++	linkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, lp_advertising,
++			 speed_duplex == LPA_SGMII_10FULL);
++}
++
++/**
++ * mii_lpa_to_linkmode_adv_sgmii
++ * @advertising: pointer to destination link mode.
++ * @lpa: value of the MII_LPA register
++ *
++ * A small helper function that translates MII_ADVERTISE bits
++ * to linkmode advertisement settings when in SGMII mode.
++ * Clears the old value of advertising.
++ */
++static inline void mii_lpa_to_linkmode_lpa_sgmii(unsigned long *lp_advertising,
++						 u32 lpa)
++{
++	linkmode_zero(lp_advertising);
++
++	mii_lpa_mod_linkmode_lpa_sgmii(lp_advertising, lpa);
++}
++
+ /**
+  * mii_adv_mod_linkmode_adv_t
+  * @advertising:pointer to destination link mode.
+diff --git a/include/uapi/linux/mii.h b/include/uapi/linux/mii.h
+index 51b48e4be1f2..0b9c3beda345 100644
+--- a/include/uapi/linux/mii.h
++++ b/include/uapi/linux/mii.h
+@@ -131,6 +131,18 @@
+ #define NWAYTEST_LOOPBACK	0x0100	/* Enable loopback for N-way   */
+ #define NWAYTEST_RESV2		0xfe00	/* Unused...                   */
+ 
++/* MAC and PHY tx_config_Reg[15:0] for SGMII in-band auto-negotiation.*/
++#define ADVERTISE_SGMII		0x0001	/* MAC can do SGMII            */
++#define LPA_SGMII		0x0001	/* PHY can do SGMII            */
++#define LPA_SGMII_DPX_SPD_MASK	0x1C00	/* SGMII duplex and speed bits */
++#define LPA_SGMII_10HALF	0x0000	/* Can do 10mbps half-duplex   */
++#define LPA_SGMII_10FULL	0x1000	/* Can do 10mbps full-duplex   */
++#define LPA_SGMII_100HALF	0x0400	/* Can do 100mbps half-duplex  */
++#define LPA_SGMII_100FULL	0x1400	/* Can do 100mbps full-duplex  */
++#define LPA_SGMII_1000HALF	0x0800	/* Can do 1000mbps half-duplex */
++#define LPA_SGMII_1000FULL	0x1800	/* Can do 1000mbps full-duplex */
++#define LPA_SGMII_LINK		0x8000	/* PHY link with copper-side partner */
++
+ /* 1000BASE-T Control register */
+ #define ADVERTISE_1000FULL	0x0200  /* Advertise 1000BASE-T full duplex */
+ #define ADVERTISE_1000HALF	0x0100  /* Advertise 1000BASE-T half duplex */
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8560-net-mii-convert-mii_lpa_to_ethtool_lpa_x-to-linkmode.patch b/target/linux/mvebu/patches-5.10/8560-net-mii-convert-mii_lpa_to_ethtool_lpa_x-to-linkmode.patch
new file mode 100644
index 0000000..7fe0e74
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8560-net-mii-convert-mii_lpa_to_ethtool_lpa_x-to-linkmode.patch
@@ -0,0 +1,75 @@
+From 09cfc6ce3f91cdd9c83975fa013f9ffeb0544708 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Sat, 14 Mar 2020 10:09:53 +0000
+Subject: [PATCH 8560/8586] net: mii: convert mii_lpa_to_ethtool_lpa_x() to
+ linkmode variant
+
+Add a LPA to linkmode decoder for 1000BASE-X protocols; this decoder
+only provides the modify semantics similar to other such decoders.
+This replaces the unused mii_lpa_to_ethtool_lpa_x() helper.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/linux/mii.h | 37 +++++++++++++++++++------------------
+ 1 file changed, 19 insertions(+), 18 deletions(-)
+
+diff --git a/include/linux/mii.h b/include/linux/mii.h
+index 18c6208f56fc..309de4a3e6e7 100644
+--- a/include/linux/mii.h
++++ b/include/linux/mii.h
+@@ -354,24 +354,6 @@ static inline u32 mii_adv_to_ethtool_adv_x(u32 adv)
+ 	return result;
+ }
+ 
+-/**
+- * mii_lpa_to_ethtool_lpa_x
+- * @adv: value of the MII_LPA register
+- *
+- * A small helper function that translates MII_LPA
+- * bits, when in 1000Base-X mode, to ethtool
+- * LP advertisement settings.
+- */
+-static inline u32 mii_lpa_to_ethtool_lpa_x(u32 lpa)
+-{
+-	u32 result = 0;
+-
+-	if (lpa & LPA_LPACK)
+-		result |= ADVERTISED_Autoneg;
+-
+-	return result | mii_adv_to_ethtool_adv_x(lpa);
+-}
+-
+ /**
+  * mii_lpa_mod_linkmode_adv_sgmii
+  * @lp_advertising: pointer to destination link mode.
+@@ -535,6 +517,25 @@ static inline u32 linkmode_adv_to_lcl_adv_t(unsigned long *advertising)
+ 	return lcl_adv;
+ }
+ 
++/**
++ * mii_lpa_mod_linkmode_x - decode the link partner's config_reg to linkmodes
++ * @linkmodes: link modes array
++ * @lpa: config_reg word from link partner
++ * @fd_bit: link mode for 1000XFULL bit
++ */
++static inline void mii_lpa_mod_linkmode_x(unsigned long *linkmodes, u16 lpa,
++					 int fd_bit)
++{
++	linkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, linkmodes,
++			 lpa & LPA_LPACK);
++	linkmode_mod_bit(ETHTOOL_LINK_MODE_Pause_BIT, linkmodes,
++			 lpa & LPA_1000XPAUSE);
++	linkmode_mod_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, linkmodes,
++			 lpa & LPA_1000XPAUSE_ASYM);
++	linkmode_mod_bit(fd_bit, linkmodes,
++			 lpa & LPA_1000XFULL);
++}
++
+ /**
+  * mii_advertise_flowctrl - get flow control advertisement flags
+  * @cap: Flow control capabilities (FLOW_CTRL_RX, FLOW_CTRL_TX or both)
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8564-net-phy-add-supported_interfaces-to-phylib.patch b/target/linux/mvebu/patches-5.10/8564-net-phy-add-supported_interfaces-to-phylib.patch
new file mode 100644
index 0000000..05b9c41
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8564-net-phy-add-supported_interfaces-to-phylib.patch
@@ -0,0 +1,58 @@
+From aa0897dc1d3088f53f705f1d94454aa3abbf1d70 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Mon, 23 Dec 2019 23:24:17 +0000
+Subject: [PATCH 8564/8586] net: phy: add supported_interfaces to phylib
+
+Add a supported_interfaces member to phylib so we know which
+interfaces a PHY supports. Currently, set any unconverted driver
+to indicate all interfaces are supported.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ include/linux/phy.h | 23 +++++++++++++++++++++++
+ 1 file changed, 23 insertions(+)
+
+diff --git a/include/linux/phy.h b/include/linux/phy.h
+index 24d21f68ea9b..2bf28a737521 100644
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -107,6 +107,26 @@ typedef enum {
+ 	PHY_INTERFACE_MODE_MAX,
+ } phy_interface_t;
+ 
++/* PHY interface mode bitmap handling */
++#define DECLARE_PHY_INTERFACE_MASK(name) \
++	DECLARE_BITMAP(name, PHY_INTERFACE_MODE_MAX)
++
++static inline void phy_interface_zero(unsigned long *intf)
++{
++	bitmap_zero(intf, PHY_INTERFACE_MODE_MAX);
++}
++
++static inline bool phy_interface_empty(const unsigned long *intf)
++{
++	return bitmap_empty(intf, PHY_INTERFACE_MODE_MAX);
++}
++
++static inline void phy_interface_and(unsigned long *dst, const unsigned long *a,
++				     const unsigned long *b)
++{
++	bitmap_and(dst, a, b, PHY_INTERFACE_MODE_MAX);
++}
++
+ /**
+  * phy_supported_speeds - return all speeds currently supported by a phy device
+  * @phy: The phy device to return supported speeds of.
+@@ -412,6 +432,9 @@ struct phy_device {
+ 	/* used with phy_speed_down */
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(adv_old);
+ 
++	/* bitmap of supported interfaces */
++	DECLARE_PHY_INTERFACE_MASK(supported_interfaces);
++
+ 	/* Energy efficient ethernet modes which should be prohibited */
+ 	u32 eee_broken_modes;
+ 
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8565-net-phy-add-supported_interfaces-to-marvell-PHYs.patch b/target/linux/mvebu/patches-5.10/8565-net-phy-add-supported_interfaces-to-marvell-PHYs.patch
new file mode 100644
index 0000000..9e2827b
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8565-net-phy-add-supported_interfaces-to-marvell-PHYs.patch
@@ -0,0 +1,33 @@
+From 9149ffed98466afd5ad9b46f7862eedd2a8556b7 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Mon, 23 Dec 2019 23:25:49 +0000
+Subject: [PATCH 8565/8586] net: phy: add supported_interfaces to marvell PHYs
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/phy/marvell.c | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c
+index 91cf1d167263..eba3169e6d1c 100644
+--- a/drivers/net/phy/marvell.c
++++ b/drivers/net/phy/marvell.c
+@@ -2091,6 +2091,15 @@ static int marvell_probe(struct phy_device *phydev)
+ 
+ 	phydev->priv = priv;
+ 
++	__set_bit(PHY_INTERFACE_MODE_GMII, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_SGMII, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_TBI, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII_ID, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII_RXID, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII_TXID, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RTBI, phydev->supported_interfaces);
++
+ 	return 0;
+ }
+ 
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8566-net-phy-add-supported_interfaces-to-marvell10g-PHYs.patch b/target/linux/mvebu/patches-5.10/8566-net-phy-add-supported_interfaces-to-marvell10g-PHYs.patch
new file mode 100644
index 0000000..c22e6d7
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8566-net-phy-add-supported_interfaces-to-marvell10g-PHYs.patch
@@ -0,0 +1,29 @@
+From 434cbd7c8237a3db507a0f186c7c2879e48ad4c6 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Mon, 23 Dec 2019 23:26:04 +0000
+Subject: [PATCH 8566/8586] net: phy: add supported_interfaces to marvell10g
+ PHYs
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/phy/marvell10g.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/drivers/net/phy/marvell10g.c b/drivers/net/phy/marvell10g.c
+index ac8520dc0913..1c805b2bcb69 100644
+--- a/drivers/net/phy/marvell10g.c
++++ b/drivers/net/phy/marvell10g.c
+@@ -216,6 +216,10 @@ static int mv3310_probe(struct phy_device *phydev)
+ 	    (phydev->c45_ids.devices_in_package & mmd_mask) != mmd_mask)
+ 		return -ENODEV;
+ 
++	__set_bit(PHY_INTERFACE_MODE_SGMII, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_2500BASEX, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_10GBASER, phydev->supported_interfaces);
++
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MV_PMA_BOOT);
+ 	if (ret < 0)
+ 		return ret;
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8567-net-sfp-add-interface-bitmap.patch b/target/linux/mvebu/patches-5.10/8567-net-sfp-add-interface-bitmap.patch
new file mode 100644
index 0000000..4b282af
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8567-net-sfp-add-interface-bitmap.patch
@@ -0,0 +1,248 @@
+From 25e566b35a2aa3d795137e883bdf985b7959dee6 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 3 Mar 2020 11:57:39 +0000
+Subject: [PATCH 8567/8586] net: sfp: add interface bitmap
+
+Add parsing the SFP EEPROM to supported phy interface modes.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/phy/marvell10g.c |  3 +-
+ drivers/net/phy/phylink.c    |  3 +-
+ drivers/net/phy/sfp-bus.c    | 69 +++++++++++++++++++++++++++++----------
+ include/linux/sfp.h          |  5 +--
+ 4 files changed, 59 insertions(+), 21 deletions(-)
+
+diff --git a/drivers/net/phy/marvell10g.c b/drivers/net/phy/marvell10g.c
+index df9f674f1b3af..fe97b16095867 100644
+--- a/drivers/net/phy/marvell10g.c
++++ b/drivers/net/phy/marvell10g.c
+@@ -354,9 +354,10 @@ static int mv3310_sfp_insert(void *upstream, const struct sfp_eeprom_id *id)
+ {
+ 	struct phy_device *phydev = upstream;
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(support) = { 0, };
++	DECLARE_PHY_INTERFACE_MASK(interfaces);
+ 	phy_interface_t iface;
+ 
+-	sfp_parse_support(phydev->sfp_bus, id, support);
++	sfp_parse_support(phydev->sfp_bus, id, support, interfaces);
+ 	iface = sfp_select_interface(phydev->sfp_bus, support);
+ 
+ 	if (iface != PHY_INTERFACE_MODE_10GBASER) {
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 7d06230743ee..0fe5865691f9 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -1844,11 +1844,12 @@ static int phylink_sfp_module_insert(void *upstream,
+ {
+ 	struct phylink *pl = upstream;
+ 	unsigned long *support = pl->sfp_support;
++	DECLARE_PHY_INTERFACE_MASK(sfp_interfaces);
+ 
+ 	ASSERT_RTNL();
+ 
+ 	linkmode_zero(support);
+-	sfp_parse_support(pl->sfp_bus, id, support);
++	sfp_parse_support(pl->sfp_bus, id, support, sfp_interfaces);
+ 	pl->sfp_port = sfp_parse_port(pl->sfp_bus, id, support);
+ 
+ 	/* If this module may have a PHY connecting later, defer until later */
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index e1400ee9b2b1..07dc29ecaf1c 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -13,7 +13,8 @@
+ struct sfp_quirk {
+ 	const char *vendor;
+ 	const char *part;
+-	void (*modes)(const struct sfp_eeprom_id *id, unsigned long *modes);
++	void (*modes)(const struct sfp_eeprom_id *id, unsigned long *modes,
++		      unsigned long *interfaces);
+ };
+ 
+ /**
+@@ -39,9 +40,10 @@ struct sfp_bus {
+ };
+ 
+ static void sfp_quirk_2500basex(const struct sfp_eeprom_id *id,
+-				unsigned long *modes)
++				unsigned long *modes, unsigned long *interfaces)
+ {
+ 	phylink_set(modes, 2500baseX_Full);
++	__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
+ }
+ 
+ static const struct sfp_quirk sfp_quirks[] = {
+@@ -211,12 +213,14 @@ EXPORT_SYMBOL_GPL(sfp_may_have_phy);
+  * @bus: a pointer to the &struct sfp_bus structure for the sfp module
+  * @id: a pointer to the module's &struct sfp_eeprom_id
+  * @support: pointer to an array of unsigned long for the ethtool support mask
++ * @interfaces: pointer to an array of unsigned long for phy interface modes
++ *		mask
+  *
+  * Parse the EEPROM identification information and derive the supported
+  * ethtool link modes for the module.
+  */
+ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+-		       unsigned long *support)
++		       unsigned long *support, unsigned long *interfaces)
+ {
+ 	unsigned int br_min, br_nom, br_max;
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(modes) = { 0, };
+@@ -243,48 +247,71 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	}
+ 
+ 	/* Set ethtool support from the compliance fields. */
+-	if (id->base.e10g_base_sr)
++	if (id->base.e10g_base_sr) {
+ 		phylink_set(modes, 10000baseSR_Full);
+-	if (id->base.e10g_base_lr)
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++	}
++	if (id->base.e10g_base_lr) {
+ 		phylink_set(modes, 10000baseLR_Full);
+-	if (id->base.e10g_base_lrm)
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++	}
++	if (id->base.e10g_base_lrm) {
+ 		phylink_set(modes, 10000baseLRM_Full);
+-	if (id->base.e10g_base_er)
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++	}
++	if (id->base.e10g_base_er) {
+ 		phylink_set(modes, 10000baseER_Full);
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++	}
+ 	if (id->base.e1000_base_sx ||
+ 	    id->base.e1000_base_lx ||
+-	    id->base.e1000_base_cx)
++	    id->base.e1000_base_cx) {
+ 		phylink_set(modes, 1000baseX_Full);
++		__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++	}
+ 	if (id->base.e1000_base_t) {
+ 		phylink_set(modes, 1000baseT_Half);
+ 		phylink_set(modes, 1000baseT_Full);
++		__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++		__set_bit(PHY_INTERFACE_MODE_SGMII, interfaces);
+ 	}
+ 
+ 	/* 1000Base-PX or 1000Base-BX10 */
+ 	if ((id->base.e_base_px || id->base.e_base_bx10) &&
+-	    br_min <= 1300 && br_max >= 1200)
++	    br_min <= 1300 && br_max >= 1200) {
+ 		phylink_set(modes, 1000baseX_Full);
++		__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++	}
+ 
+ 	/* For active or passive cables, select the link modes
+ 	 * based on the bit rates and the cable compliance bytes.
+ 	 */
+ 	if ((id->base.sfp_ct_passive || id->base.sfp_ct_active) && br_nom) {
+ 		/* This may look odd, but some manufacturers use 12000MBd */
+-		if (br_min <= 12000 && br_max >= 10300)
++		if (br_min <= 12000 && br_max >= 10300) {
+ 			phylink_set(modes, 10000baseCR_Full);
+-		if (br_min <= 3200 && br_max >= 3100)
++			__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++		}
++		if (br_min <= 3200 && br_max >= 3100) {
+ 			phylink_set(modes, 2500baseX_Full);
+-		if (br_min <= 1300 && br_max >= 1200)
++			__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
++		}
++		if (br_min <= 1300 && br_max >= 1200) {
+ 			phylink_set(modes, 1000baseX_Full);
++			__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++		}
+ 	}
+ 	if (id->base.sfp_ct_passive) {
+-		if (id->base.passive.sff8431_app_e)
++		if (id->base.passive.sff8431_app_e) {
+ 			phylink_set(modes, 10000baseCR_Full);
++			__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++		}
+ 	}
+ 	if (id->base.sfp_ct_active) {
+ 		if (id->base.active.sff8431_app_e ||
+ 		    id->base.active.sff8431_lim) {
+ 			phylink_set(modes, 10000baseCR_Full);
++			__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
+ 		}
+ 	}
+ 
+@@ -309,12 +336,14 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	case SFF8024_ECC_10GBASE_T_SFI:
+ 	case SFF8024_ECC_10GBASE_T_SR:
+ 		phylink_set(modes, 10000baseT_Full);
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
+ 		break;
+ 	case SFF8024_ECC_5GBASE_T:
+ 		phylink_set(modes, 5000baseT_Full);
+ 		break;
+ 	case SFF8024_ECC_2_5GBASE_T:
+ 		phylink_set(modes, 2500baseT_Full);
++		__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
+ 		break;
+ 	default:
+ 		dev_warn(bus->sfp_dev,
+@@ -327,10 +356,14 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	if (id->base.fc_speed_100 ||
+ 	    id->base.fc_speed_200 ||
+ 	    id->base.fc_speed_400) {
+-		if (id->base.br_nominal >= 31)
++		if (id->base.br_nominal >= 31) {
+ 			phylink_set(modes, 2500baseX_Full);
+-		if (id->base.br_nominal >= 12)
++			__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
++		}
++		if (id->base.br_nominal >= 12) {
+ 			phylink_set(modes, 1000baseX_Full);
++			__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++		}
+ 	}
+ 
+ 	/* If we haven't discovered any modes that this module supports, try
+@@ -341,12 +374,14 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	if (bitmap_empty(modes, __ETHTOOL_LINK_MODE_MASK_NBITS)) {
+ 		/* If the encoding and bit rate allows 1000baseX */
+ 		if (id->base.encoding == SFF8024_ENCODING_8B10B && br_nom &&
+-		    br_min <= 1300 && br_max >= 1200)
++		    br_min <= 1300 && br_max >= 1200) {
+ 			phylink_set(modes, 1000baseX_Full);
++			__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++		}
+ 	}
+ 
+ 	if (bus->sfp_quirk)
+-		bus->sfp_quirk->modes(id, modes);
++		bus->sfp_quirk->modes(id, modes, interfaces);
+ 
+ 	bitmap_or(support, support, modes, __ETHTOOL_LINK_MODE_MASK_NBITS);
+ 
+diff --git a/include/linux/sfp.h b/include/linux/sfp.h
+index 38893e4dd0f0..2da1a5181779 100644
+--- a/include/linux/sfp.h
++++ b/include/linux/sfp.h
+@@ -535,7 +535,7 @@ int sfp_parse_port(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		   unsigned long *support);
+ bool sfp_may_have_phy(struct sfp_bus *bus, const struct sfp_eeprom_id *id);
+ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+-		       unsigned long *support);
++		       unsigned long *support, unsigned long *interfaces);
+ phy_interface_t sfp_select_interface(struct sfp_bus *bus,
+ 				     unsigned long *link_modes);
+ 
+@@ -565,7 +565,8 @@ static inline bool sfp_may_have_phy(struct sfp_bus *bus,
+ 
+ static inline void sfp_parse_support(struct sfp_bus *bus,
+ 				     const struct sfp_eeprom_id *id,
+-				     unsigned long *support)
++				     unsigned long *support,
++				     unsigned long *interfaces)
+ {
+ }
+ 
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8569-net-phylink-use-phy-interface-mode-bitmaps.patch b/target/linux/mvebu/patches-5.10/8569-net-phylink-use-phy-interface-mode-bitmaps.patch
new file mode 100644
index 0000000..db052d3
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8569-net-phylink-use-phy-interface-mode-bitmaps.patch
@@ -0,0 +1,199 @@
+From 8bbed6c9486473abb6671246bf8337c2d6ef27fa Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 3 Mar 2020 12:12:43 +0000
+Subject: [PATCH 8569/8586] net: phylink: use phy interface mode bitmaps
+
+Use the phy interface mode bitmaps for SFP modules and PHYs to select
+the operating interface for SFPs and PHYs with SFPs.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/phy/phylink.c | 116 +++++++++++++++++++++++++++++++-------
+ include/linux/phylink.h   |   1 +
+ 2 files changed, 98 insertions(+), 19 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index ea32f38db10e..99d46bf7e4e0 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -73,6 +73,7 @@ struct phylink {
+ 
+ 	struct sfp_bus *sfp_bus;
+ 	bool sfp_may_have_phy;
++	DECLARE_PHY_INTERFACE_MASK(sfp_interfaces);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(sfp_support);
+ 	u8 sfp_port;
+ };
+@@ -1789,6 +1790,41 @@ static void phylink_sfp_detach(void *upstream, struct sfp_bus *bus)
+ 	pl->netdev->sfp_bus = NULL;
+ }
+ 
++static const phy_interface_t phylink_sfp_interface_preference[] = {
++	PHY_INTERFACE_MODE_USXGMII,
++	PHY_INTERFACE_MODE_10GBASER,
++	PHY_INTERFACE_MODE_10GKR,
++	PHY_INTERFACE_MODE_2500BASEX,
++	PHY_INTERFACE_MODE_SGMII,
++	PHY_INTERFACE_MODE_1000BASEX,
++};
++
++static phy_interface_t phylink_select_interface(struct phylink *pl,
++						const unsigned long *intf,
++						const char *intf_name)
++{
++	DECLARE_PHY_INTERFACE_MASK(u);
++	phy_interface_t interface;
++	size_t i;
++
++	phy_interface_and(u, intf, pl->config->supported_interfaces);
++
++	interface = PHY_INTERFACE_MODE_NA;
++	for (i = 0; i < ARRAY_SIZE(phylink_sfp_interface_preference); i++)
++		if (test_bit(phylink_sfp_interface_preference[i], u)) {
++			interface = phylink_sfp_interface_preference[i];
++			break;
++		}
++
++	phylink_info(pl, "interfaces=[mac=%*pbl %s=%*pbl] selected %d (%s)\n",
++		     (int)PHY_INTERFACE_MODE_MAX,
++		     pl->config->supported_interfaces,
++		     intf_name, (int)PHY_INTERFACE_MODE_MAX, intf,
++		     interface, phy_modes(interface));
++
++	return interface;
++}
++
+ static int phylink_sfp_config(struct phylink *pl, u8 mode,
+ 			      const unsigned long *supported,
+ 			      const unsigned long *advertising)
+@@ -1871,25 +1907,33 @@ static int phylink_sfp_config(struct phylink *pl, u8 mode,
+ 	return ret;
+ }
+ 
++static int phylink_sfp_config_nophy(struct phylink *pl)
++{
++	if (!phy_interface_empty(pl->config->supported_interfaces))
++		phylink_select_interface(pl, pl->sfp_interfaces, "sfp");
++
++	return phylink_sfp_config(pl, MLO_AN_INBAND,
++				  pl->sfp_support, pl->sfp_support);
++}
++
+ static int phylink_sfp_module_insert(void *upstream,
+ 				     const struct sfp_eeprom_id *id)
+ {
+ 	struct phylink *pl = upstream;
+-	unsigned long *support = pl->sfp_support;
+-	DECLARE_PHY_INTERFACE_MASK(sfp_interfaces);
+ 
+ 	ASSERT_RTNL();
+ 
+-	linkmode_zero(support);
+-	sfp_parse_support(pl->sfp_bus, id, support, sfp_interfaces);
+-	pl->sfp_port = sfp_parse_port(pl->sfp_bus, id, support);
++	linkmode_zero(pl->sfp_support);
++	phy_interface_zero(pl->sfp_interfaces);
++	sfp_parse_support(pl->sfp_bus, id, pl->sfp_support, pl->sfp_interfaces);
++	pl->sfp_port = sfp_parse_port(pl->sfp_bus, id, pl->sfp_support);
+ 
+ 	/* If this module may have a PHY connecting later, defer until later */
+ 	pl->sfp_may_have_phy = sfp_may_have_phy(pl->sfp_bus, id);
+ 	if (pl->sfp_may_have_phy)
+ 		return 0;
+ 
+-	return phylink_sfp_config(pl, MLO_AN_INBAND, support, support);
++	return phylink_sfp_config_nophy(pl);
+ }
+ 
+ static int phylink_sfp_module_start(void *upstream)
+@@ -1908,8 +1952,7 @@ static int phylink_sfp_module_start(void *upstream)
+ 	if (!pl->sfp_may_have_phy)
+ 		return 0;
+ 
+-	return phylink_sfp_config(pl, MLO_AN_INBAND,
+-				  pl->sfp_support, pl->sfp_support);
++	return phylink_sfp_config_nophy(pl);
+ }
+ 
+ static void phylink_sfp_module_stop(void *upstream)
+@@ -1970,19 +2013,54 @@ static int phylink_sfp_connect_phy(void *upstream, struct phy_device *phy)
+ 	else
+ 		mode = MLO_AN_INBAND;
+ 
+-	/* Do the initial configuration */
+-	ret = phylink_sfp_config(pl, mode, phy->supported, phy->advertising);
+-	if (ret < 0)
+-		return ret;
++	if (!phy_interface_empty(phy->supported_interfaces) &&
++	    !phy_interface_empty(pl->config->supported_interfaces)) {
++		interface = phylink_select_interface(pl,
++						     phy->supported_interfaces,
++						     "phy");
++		if (interface == PHY_INTERFACE_MODE_NA) {
++			phylink_err(pl,
++				    "selection of interface for PHY failed\n");
++			return -EINVAL;
++		}
+ 
+-	interface = pl->link_config.interface;
+-	ret = phylink_attach_phy(pl, phy, interface);
+-	if (ret < 0)
+-		return ret;
++		if (pl->cur_link_an_mode != mode ||
++		    pl->link_config.interface != interface) {
++			pl->link_config.interface = interface;
++			pl->cur_link_an_mode = mode;
+ 
+-	ret = phylink_bringup_phy(pl, phy, interface);
+-	if (ret)
+-		phy_detach(phy);
++			phylink_info(pl, "switched to %s/%s link mode\n",
++				     phylink_an_mode_str(mode),
++				     phy_modes(interface));
++		}
++
++		ret = phylink_attach_phy(pl, phy, interface);
++		if (ret < 0)
++			return ret;
++
++		ret = phylink_bringup_phy(pl, phy, interface);
++		if (ret)
++			phy_detach(phy);
++
++		if (!test_bit(PHYLINK_DISABLE_STOPPED,
++			      &pl->phylink_disable_state))
++			phylink_mac_initial_config(pl);
++	} else {
++		/* Do the initial configuration */
++		ret = phylink_sfp_config(pl, mode, phy->supported,
++					phy->advertising);
++		if (ret < 0)
++			return ret;
++
++		interface = pl->link_config.interface;
++		ret = phylink_attach_phy(pl, phy, interface);
++		if (ret < 0)
++			return ret;
++
++		ret = phylink_bringup_phy(pl, phy, interface);
++		if (ret)
++			phy_detach(phy);
++	}
+ 
+ 	return ret;
+ }
+diff --git a/include/linux/phylink.h b/include/linux/phylink.h
+index 641720ef712f..31e61ea4e3e2 100644
+--- a/include/linux/phylink.h
++++ b/include/linux/phylink.h
+@@ -67,6 +67,7 @@ enum phylink_op_type {
+ struct phylink_config {
+ 	struct device *dev;
+ 	enum phylink_op_type type;
++	DECLARE_PHY_INTERFACE_MASK(supported_interfaces);
+ };
+ 
+ /**
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8570-net-mvneta-fill-in-phy-interface-mode-bitmap.patch b/target/linux/mvebu/patches-5.10/8570-net-mvneta-fill-in-phy-interface-mode-bitmap.patch
new file mode 100644
index 0000000..6f9d85b
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8570-net-mvneta-fill-in-phy-interface-mode-bitmap.patch
@@ -0,0 +1,43 @@
+From 429204abeca76e1f10f837454519fe12a95856a7 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 3 Mar 2020 12:15:38 +0000
+Subject: [PATCH 8570/8586] net: mvneta: fill in phy interface mode bitmap
+
+Fill in the phy interface mode bitmap for the Marvell mvneta driver, so
+phylink can know which interfaces are supported by the MAC.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 16 ++++++++++++++++
+ 1 file changed, 16 insertions(+)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index ccb2abd18d6c..c857ff3d5aef 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -4556,6 +4556,22 @@ static int mvneta_probe(struct platform_device *pdev)
+ 
+ 	pp->phylink_config.dev = &dev->dev;
+ 	pp->phylink_config.type = PHYLINK_NETDEV;
++	__set_bit(PHY_INTERFACE_MODE_SGMII,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII_ID,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII_RXID,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_RGMII_TXID,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_QSGMII,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_1000BASEX,
++		  pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_2500BASEX,
++		  pp->phylink_config.supported_interfaces);
+ 
+ 	phylink = phylink_create(&pp->phylink_config, pdev->dev.fwnode,
+ 				 phy_mode, &mvneta_phylink_ops);
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8571-net-phy-mdio-i2c-support-I2C-MDIO-protocol-for-RollB.patch b/target/linux/mvebu/patches-5.10/8571-net-phy-mdio-i2c-support-I2C-MDIO-protocol-for-RollB.patch
new file mode 100644
index 0000000..4e5424e
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8571-net-phy-mdio-i2c-support-I2C-MDIO-protocol-for-RollB.patch
@@ -0,0 +1,285 @@
+From cfd8925a008d441d5dd502a4f5259d898bf14892 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 12 Aug 2020 16:12:02 +0200
+Subject: [PATCH 8571/8586] net: phy: mdio-i2c: support I2C MDIO protocol for
+ RollBall SFP modules
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Some multigig SFPs from RollBall and Hilink do not expose functional
+MDIO access to the internal PHY of the SFP via I2C address 0x56
+(although there seems to be read-only clause 22 access on this address).
+
+Instead these SFPs PHY can be accessed via I2C via the SFP Enhanced
+Digital Diagnostic Interface - I2C address 0x51.
+
+This extends the mdio-i2c driver so that when SFP PHY address 17 is used
+(which in mdio-i2c terms corresponds to I2C address 0x51), then this
+different protocol is used for MDIO access.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/net/phy/mdio-i2c.c | 197 +++++++++++++++++++++++++++++++++++--
+ 1 file changed, 187 insertions(+), 10 deletions(-)
+
+diff --git a/drivers/net/phy/mdio-i2c.c b/drivers/net/phy/mdio-i2c.c
+index 0dce67672548..a529b69c123f 100644
+--- a/drivers/net/phy/mdio-i2c.c
++++ b/drivers/net/phy/mdio-i2c.c
+@@ -3,12 +3,14 @@
+  * MDIO I2C bridge
+  *
+  * Copyright (C) 2015-2016 Russell King
++ * Copyright (C) 2020 Marek Behun
+  *
+  * Network PHYs can appear on I2C buses when they are part of SFP module.
+  * This driver exposes these PHYs to the networking PHY code, allowing
+  * our PHY drivers access to these PHYs, and so allowing configuration
+  * of their settings.
+  */
++#include <linux/delay.h>
+ #include <linux/i2c.h>
+ #include <linux/phy.h>
+ 
+@@ -17,11 +19,17 @@
+ /*
+  * I2C bus addresses 0x50 and 0x51 are normally an EEPROM, which is
+  * specified to be present in SFP modules.  These correspond with PHY
+- * addresses 16 and 17.  Disallow access to these "phy" addresses.
++ * addresses 16 and 17.  Disallow access to 0x50 "phy" address.
++ * Use RollBall protocol when accessing via the 0x51 address.
+  */
+ static bool i2c_mii_valid_phy_id(int phy_id)
+ {
+-	return phy_id != 0x10 && phy_id != 0x11;
++	return phy_id != 0x10;
++}
++
++static bool i2c_mii_rollball_phy_id(int phy_id)
++{
++	return phy_id == 0x11;
+ }
+ 
+ static unsigned int i2c_mii_phy_addr(int phy_id)
+@@ -29,16 +37,13 @@ static unsigned int i2c_mii_phy_addr(int
+ 	return phy_id + 0x40;
+ }
+ 
+-static int i2c_mii_read(struct mii_bus *bus, int phy_id, int reg)
++static int i2c_mii_read_default(struct mii_bus *bus, int phy_id, int reg)
+ {
+ 	struct i2c_adapter *i2c = bus->priv;
+ 	struct i2c_msg msgs[2];
+ 	u8 addr[3], data[2], *p;
+ 	int bus_addr, ret;
+ 
+-	if (!i2c_mii_valid_phy_id(phy_id))
+-		return 0xffff;
+-
+ 	p = addr;
+ 	if (reg & MII_ADDR_C45) {
+ 		*p++ = 0x20 | ((reg >> 16) & 31);
+@@ -63,16 +68,13 @@ static int i2c_mii_read(struct mii_bus *
+ 	return data[0] << 8 | data[1];
+ }
+ 
+-static int i2c_mii_write(struct mii_bus *bus, int phy_id, int reg, u16 val)
++static int i2c_mii_write_default(struct mii_bus *bus, int phy_id, int reg, u16 val)
+ {
+ 	struct i2c_adapter *i2c = bus->priv;
+ 	struct i2c_msg msg;
+ 	int ret;
+ 	u8 data[5], *p;
+ 
+-	if (!i2c_mii_valid_phy_id(phy_id))
+-		return 0;
+-
+ 	p = data;
+ 	if (reg & MII_ADDR_C45) {
+ 		*p++ = (reg >> 16) & 31;
+@@ -92,6 +94,181 @@ static int i2c_mii_write(struct mii_bus
+ 	return ret < 0 ? ret : 0;
+ }
+ 
++/* RollBall SFPs do not access internal PHY via I2C address 0x56, but
++ * instead via address 0x51, when SFP page is set to 0x03 and password to
++ * 0xffffffff:
++ *
++ * address  size  contents  description
++ * -------  ----  --------  -----------
++ * 0x80     1     CMD       0x01/0x02/0x04 for write/read/done
++ * 0x81     1     DEV       Clause 45 device
++ * 0x82     2     REG       Clause 45 register
++ * 0x84     2     VAL       Register value
++ */
++#define ROLLBALL_CMD_ADDR		0x80
++#define ROLLBALL_DATA_ADDR		0x81
++
++#define ROLLBALL_CMD_WRITE		0x01
++#define ROLLBALL_CMD_READ		0x02
++#define ROLLBALL_CMD_DONE		0x04
++
++static int i2c_rollball_mii_poll(struct mii_bus *bus, int bus_addr, u8 *buf, size_t len)
++{
++	struct i2c_adapter *i2c = bus->priv;
++	struct i2c_msg msgs[2];
++	u8 buf0[2], *res;
++	int i, ret;
++
++	buf0[0] = ROLLBALL_CMD_ADDR;
++
++	msgs[0].addr = bus_addr;
++	msgs[0].flags = 0;
++	msgs[0].len = 1;
++	msgs[0].buf = &buf0[0];
++
++	res = buf ? buf : &buf0[1];
++
++	msgs[1].addr = bus_addr;
++	msgs[1].flags = I2C_M_RD;
++	msgs[1].len = buf ? len : 1;
++	msgs[1].buf = res;
++
++	/* By experiment it takes up to 70 ms to access a register for these SFPs. Sleep 20ms
++	  * between iteratios and try 10 times.
++	  */
++	i = 10;
++	do {
++		msleep(20);
++
++		ret = i2c_transfer(i2c, msgs, ARRAY_SIZE(msgs));
++		if (ret < 0)
++			return ret;
++		else if (ret != ARRAY_SIZE(msgs))
++			return -EIO;
++
++		if (*res == ROLLBALL_CMD_DONE)
++			return 0;
++	} while (i-- > 0);
++
++	dev_dbg(&bus->dev, "poll timed out\n");
++
++	return -ETIMEDOUT;
++}
++
++static int i2c_rollball_mii_cmd(struct mii_bus *bus, int bus_addr, u8 cmd, u8 *data, size_t len)
++{
++	struct i2c_adapter *i2c = bus->priv;
++	struct i2c_msg msgs[2];
++	u8 cmdbuf[2];
++	int ret;
++
++	msgs[0].addr = bus_addr;
++	msgs[0].flags = 0;
++	msgs[0].len = len;
++	msgs[0].buf = data;
++
++	cmdbuf[0] = ROLLBALL_CMD_ADDR;
++	cmdbuf[1] = cmd;
++
++	msgs[1].addr = bus_addr;
++	msgs[1].flags = 0;
++	msgs[1].len = sizeof(cmdbuf);
++	msgs[1].buf = cmdbuf;
++
++	ret = i2c_transfer(i2c, msgs, 2);
++	if (ret < 0)
++		return ret;
++
++	return ret == ARRAY_SIZE(msgs) ? 0 : -EIO;
++}
++
++static int i2c_mii_read_rollball(struct mii_bus *bus, int phy_id, int reg)
++{
++	u8 buf[4], res[6];
++	int bus_addr, ret;
++	u16 val;
++
++	if (!(reg & MII_ADDR_C45))
++		return -EOPNOTSUPP;
++
++	buf[0] = ROLLBALL_DATA_ADDR;
++	buf[1] = (reg >> 16) & 0x1f;
++	buf[2] = (reg >> 8) & 0xff;
++	buf[3] = reg & 0xff;
++
++	bus_addr = i2c_mii_phy_addr(phy_id);
++
++	ret = i2c_rollball_mii_cmd(bus, bus_addr, ROLLBALL_CMD_READ, buf, sizeof(buf));
++	if (ret < 0)
++		return ret;
++
++	ret = i2c_rollball_mii_poll(bus, bus_addr, res, sizeof(res));
++	if (ret == -ETIMEDOUT)
++		return 0xffff;
++	else if (ret < 0)
++		return ret;
++
++	val = res[4];
++	val <<= 8;
++	val |= res[5];
++
++	dev_dbg(&bus->dev, "read reg %02x:%04x = %04x\n", (reg >> 16) & 0x1f, reg & 0xffff, val);
++
++	return val;
++}
++
++static int i2c_mii_write_rollball(struct mii_bus *bus, int phy_id, int reg, u16 val)
++{
++	int bus_addr, ret;
++	u8 buf[6];
++
++	if (!(reg & MII_ADDR_C45))
++		return -EOPNOTSUPP;
++
++	buf[0] = ROLLBALL_DATA_ADDR;
++	buf[1] = (reg >> 16) & 0x1f;
++	buf[2] = (reg >> 8) & 0xff;
++	buf[3] = reg & 0xff;
++	buf[4] = val >> 8;
++	buf[5] = val & 0xff;
++
++	bus_addr = i2c_mii_phy_addr(phy_id);
++
++	ret = i2c_rollball_mii_cmd(bus, bus_addr, ROLLBALL_CMD_WRITE, buf, sizeof(buf));
++	if (ret < 0)
++		return ret;
++
++	ret = i2c_rollball_mii_poll(bus, bus_addr, NULL, 0);
++	if (ret < 0)
++		return ret;
++
++	dev_dbg(&bus->dev, "write reg %02x:%04x = %04x\n", (reg >> 16) & 0x1f, reg & 0xffff, val);
++
++	return 0;
++}
++
++static int i2c_mii_read(struct mii_bus *bus, int phy_id, int reg)
++{
++	if (!i2c_mii_valid_phy_id(phy_id))
++		return 0xffff;
++
++	if (i2c_mii_rollball_phy_id(phy_id))
++		return i2c_mii_read_rollball(bus, phy_id, reg);
++	else
++		return i2c_mii_read_default(bus, phy_id, reg);
++}
++
++static int i2c_mii_write(struct mii_bus *bus, int phy_id, int reg, u16 val)
++{
++	if (!i2c_mii_valid_phy_id(phy_id))
++		return 0;
++
++	if (i2c_mii_rollball_phy_id(phy_id))
++		return i2c_mii_write_rollball(bus, phy_id, reg, val);
++	else
++		return i2c_mii_write_default(bus, phy_id, reg, val);
++}
++
+ struct mii_bus *mdio_i2c_alloc(struct device *parent, struct i2c_adapter *i2c)
+ {
+ 	struct mii_bus *mii;
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8572-net-phy-sfp-add-support-for-multigig-RollBall-module.patch b/target/linux/mvebu/patches-5.10/8572-net-phy-sfp-add-support-for-multigig-RollBall-module.patch
new file mode 100644
index 0000000..fa69547
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8572-net-phy-sfp-add-support-for-multigig-RollBall-module.patch
@@ -0,0 +1,171 @@
+From edae63276a1d5e736f88b80aff0e4cbc3a787473 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 12 Aug 2020 16:14:54 +0200
+Subject: [PATCH 8572/8586] net: phy: sfp: add support for multigig RollBall
+ modules
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds support for multigig copper SFP modules from RollBall/Hilink.
+These modules have a specific way to access clause 45 registers of the
+internal PHY.
+
+We also need to wait at least 25 seconds after deasserting TX disable
+before accessing the PHY. The code waits for 30 seconds just to be sure.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/net/phy/sfp.c | 67 +++++++++++++++++++++++++++++++++++++++----
+ 1 file changed, 62 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/net/phy/sfp.c b/drivers/net/phy/sfp.c
+index 73c2969f11a4..a7404b16628f 100644
+--- a/drivers/net/phy/sfp.c
++++ b/drivers/net/phy/sfp.c
+@@ -165,6 +165,7 @@ static const enum gpiod_flags gpio_flags[] = {
+  * on board (for a copper SFP) time to initialise.
+  */
+ #define T_WAIT			msecs_to_jiffies(50)
++#define T_WAIT_LONG_PHY		msecs_to_jiffies(30000)
+ #define T_START_UP		msecs_to_jiffies(300)
+ #define T_START_UP_BAD_GPON	msecs_to_jiffies(60000)
+ 
+@@ -204,8 +205,11 @@ static const enum gpiod_flags gpio_flags[] = {
+ 
+ /* SFP modules appear to always have their PHY configured for bus address
+  * 0x56 (which with mdio-i2c, translates to a PHY address of 22).
++ * RollBall SFPs access phy via SFP Enhanced Digital Diagnostic Interface
++ * via address 0x51 (mdio-i2c will use RollBall protocol on this address).
+  */
+-#define SFP_PHY_ADDR	22
++#define SFP_PHY_ADDR		22
++#define SFP_PHY_ADDR_ROLLBALL	17
+ 
+ struct sff_data {
+ 	unsigned int gpios;
+@@ -220,6 +224,7 @@ struct sfp {
+ 	struct phy_device *mod_phy;
+ 	const struct sff_data *type;
+ 	u32 max_power_mW;
++	int phy_addr;
+ 
+ 	unsigned int (*get_state)(struct sfp *);
+ 	void (*set_state)(struct sfp *, unsigned int);
+@@ -248,6 +253,7 @@ struct sfp {
+ 	struct sfp_eeprom_id id;
+ 	unsigned int module_power_mW;
+ 	unsigned int module_t_start_up;
++	unsigned int module_t_wait;
+ 
+ #if IS_ENABLED(CONFIG_HWMON)
+ 	struct sfp_diag diag;
+@@ -1431,7 +1437,7 @@ static int sfp_sm_probe_phy(struct sfp *sfp, bool is_c45)
+ 	struct phy_device *phy;
+ 	int err;
+ 
+-	phy = get_phy_device(sfp->i2c_mii, SFP_PHY_ADDR, is_c45);
++	phy = get_phy_device(sfp->i2c_mii, sfp->phy_addr, is_c45);
+ 	if (phy == ERR_PTR(-ENODEV))
+ 		return PTR_ERR(phy);
+ 	if (IS_ERR(phy)) {
+@@ -1632,11 +1638,39 @@ static int sfp_sm_mod_hpower(struct sfp *sfp, bool enable)
+ 	return 0;
+ }
+ 
++static int sfp_rollball_init_mdio(struct sfp *sfp)
++{
++	u8 page, password[4];
++	int err;
++
++	page = 3;
++
++	err = sfp_write(sfp, true, SFP_PAGE, &page, 1);
++	if (err != 1) {
++		dev_err(sfp->dev, "Failed to set SFP page for RollBall MDIO access: %d\n", err);
++		return err;
++	}
++
++	password[0] = 0xff;
++	password[1] = 0xff;
++	password[2] = 0xff;
++	password[3] = 0xff;
++
++	err = sfp_write(sfp, true, 0x7b, password, 4);
++	if (err != 4) {
++		dev_err(sfp->dev, "Failed to write password for RollBall MDIO access; %d\n", err);
++		return err;
++	}
++
++	return 0;
++}
++
+ static int sfp_sm_mod_probe(struct sfp *sfp, bool report)
+ {
+ 	/* SFP module inserted - read I2C data */
+ 	struct sfp_eeprom_id id;
+ 	bool cotsworks;
++	bool rollball;
+ 	u8 check;
+ 	int ret;
+ 
+@@ -1691,6 +1725,24 @@ static int sfp_sm_mod_probe(struct sfp *sfp, bool report)
+ 		}
+ 	}
+ 
++	sfp->phy_addr = SFP_PHY_ADDR;
++
++	rollball = ((!memcmp(id.base.vendor_name, "OEM             ", 16) ||
++		     !memcmp(id.base.vendor_name, "Turris          ", 16)) &&
++		    (!memcmp(id.base.vendor_pn, "SFP-10G-T       ", 16) ||
++		     !memcmp(id.base.vendor_pn, "RTSFP-10        ", 16) ||
++		     !memcmp(id.base.vendor_pn, "RTSFP-2.5G      ", 16)));
++	if (rollball) {
++		sfp->phy_addr = SFP_PHY_ADDR_ROLLBALL;
++		ret = sfp_rollball_init_mdio(sfp);
++		if (ret < 0)
++			return ret;
++
++		/* RollBall SFPs may have wrong (zero) extended compliacne code burned in EEPROM.
++		 * To try to probe for PHY we need the correct one */
++		id.base.extended_cc = SFF8024_ECC_10GBASE_T_SFI;
++	}
++
+ 	sfp->id = id;
+ 
+ 	dev_info(sfp->dev, "module %.*s %.*s rev %.*s sn %.*s dc %.*s\n",
+@@ -1724,6 +1776,11 @@ static int sfp_sm_mod_probe(struct sfp *sfp, bool report)
+ 	else
+ 		sfp->module_t_start_up = T_START_UP;
+ 
++	if (rollball)
++		sfp->module_t_wait = T_WAIT_LONG_PHY;
++	else
++		sfp->module_t_wait = T_WAIT;
++
+ 	return 0;
+ }
+ 
+@@ -1919,7 +1976,7 @@ static void sfp_sm_main(struct sfp *sfp, unsigned int event)
+ 		 * while TX_DISABLE is asserted. The earliest we want to do
+ 		 * anything (such as probe for a PHY) is 50ms.
+ 		 */
+-		sfp_sm_next(sfp, SFP_S_WAIT, T_WAIT);
++		sfp_sm_next(sfp, SFP_S_WAIT, sfp->module_t_wait);
+ 		break;
+ 
+ 	case SFP_S_WAIT:
+@@ -1933,8 +1990,8 @@ static void sfp_sm_main(struct sfp *sfp, unsigned int event)
+ 			 * deasserting.
+ 			 */
+ 			timeout = sfp->module_t_start_up;
+-			if (timeout > T_WAIT)
+-				timeout -= T_WAIT;
++			if (timeout > sfp->module_t_wait)
++				timeout -= sfp->module_t_wait;
+ 			else
+ 				timeout = 1;
+ 
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8573-net-phylink-don-t-fail-attaching-phy-on-1000base-x-2.patch b/target/linux/mvebu/patches-5.10/8573-net-phylink-don-t-fail-attaching-phy-on-1000base-x-2.patch
new file mode 100644
index 0000000..4901b52
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8573-net-phylink-don-t-fail-attaching-phy-on-1000base-x-2.patch
@@ -0,0 +1,37 @@
+From 5b9a8d4b7c87569e9073fdd1027f1457ccf6a972 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 12 Aug 2020 19:04:39 +0200
+Subject: [PATCH 8573/8586] net: phylink: don't fail attaching phy on
+ 1000base-x/2500base-x mode
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Some SFPs may contain an internal PHY which may in some cases want to
+connect with the host interface in 1000base-x/2500base-x mode.
+Do not fail if such PHY is being attached in one of these PHY interface
+modes.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/net/phy/phylink.c | 4 +---
+ 1 file changed, 1 insertion(+), 3 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 99d46bf7e4e0..001149c189cc 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -851,9 +851,7 @@ static int phylink_bringup_phy(struct phylink *pl, struct phy_device *phy,
+ static int phylink_attach_phy(struct phylink *pl, struct phy_device *phy,
+ 			      phy_interface_t interface)
+ {
+-	if (WARN_ON(pl->cfg_link_an_mode == MLO_AN_FIXED ||
+-		    (pl->cfg_link_an_mode == MLO_AN_INBAND &&
+-		     phy_interface_mode_is_8023z(interface))))
++	if (WARN_ON(pl->cfg_link_an_mode == MLO_AN_FIXED))
+ 		return -EINVAL;
+ 
+ 	if (pl->phydev)
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8574-net-phylink-let-PHYs-know-what-interfaces-are-suppor.patch b/target/linux/mvebu/patches-5.10/8574-net-phylink-let-PHYs-know-what-interfaces-are-suppor.patch
new file mode 100644
index 0000000..e25efaa
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8574-net-phylink-let-PHYs-know-what-interfaces-are-suppor.patch
@@ -0,0 +1,111 @@
+From 11d0c8a1e39f1780b4a9e14b9a6a1c3260baeae2 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Tue, 18 Aug 2020 19:45:48 +0200
+Subject: [PATCH 8574/8586] net: phylink: let PHYs know what interfaces are
+ supported by host
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Some PHYs may want to configure how they talk to the host. For this they
+need to know which PHY interface modes the host MAC supports.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/net/phy/phylink.c | 24 ++++++++++++++++++++++++
+ include/linux/phy.h       |  8 +++++++-
+ 2 files changed, 31 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 001149c189cc..7f1fff35c5a7 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -885,6 +885,9 @@ int phylink_connect_phy(struct phylink *pl, struct phy_device *phy)
+ 		pl->link_config.interface = pl->link_interface;
+ 	}
+ 
++	/* Set the PHY's host supported interfaces */
++	phy_interface_copy(phy->host_interfaces, pl->config->supported_interfaces);
++
+ 	ret = phylink_attach_phy(pl, phy, pl->link_interface);
+ 	if (ret < 0)
+ 		return ret;
+@@ -940,6 +943,9 @@ int phylink_of_phy_connect(struct phylink *pl, struct device_node *dn,
+ 	if (!phy_dev)
+ 		return -ENODEV;
+ 
++	/* Set the PHY's host supported interfaces */
++	phy_interface_copy(phy_dev->host_interfaces, pl->config->supported_interfaces);
++
+ 	ret = phy_attach_direct(pl->netdev, phy_dev, flags,
+ 				pl->link_interface);
+ 	if (ret)
+@@ -1788,6 +1794,8 @@ static void phylink_sfp_detach(void *upstream, struct sfp_bus *bus)
+ 	pl->netdev->sfp_bus = NULL;
+ }
+ 
++static DECLARE_PHY_INTERFACE_MASK(phylink_sfp_interfaces);
++
+ static const phy_interface_t phylink_sfp_interface_preference[] = {
+ 	PHY_INTERFACE_MODE_USXGMII,
+ 	PHY_INTERFACE_MODE_10GBASER,
+@@ -1797,6 +1805,18 @@ static const phy_interface_t phylink_sfp_interface_preference[] = {
+ 	PHY_INTERFACE_MODE_1000BASEX,
+ };
+ 
++static int __init phylink_init(void)
++{
++	int i;
++
++	for (i = 0; i < ARRAY_SIZE(phylink_sfp_interface_preference); i++)
++		set_bit(phylink_sfp_interface_preference[i],
++			phylink_sfp_interfaces);
++
++	return 0;
++}
++module_init(phylink_init);
++
+ static phy_interface_t phylink_select_interface(struct phylink *pl,
+ 						const unsigned long *intf,
+ 						const char *intf_name)
+@@ -2011,6 +2031,10 @@ static int phylink_sfp_connect_phy(void *upstream, struct phy_device *phy)
+ 	else
+ 		mode = MLO_AN_INBAND;
+ 
++	/* Set the PHY's host supported interfaces */
++	phy_interface_and(phy->host_interfaces, phylink_sfp_interfaces,
++			  pl->config->supported_interfaces);
++
+ 	if (!phy_interface_empty(phy->supported_interfaces) &&
+ 	    !phy_interface_empty(pl->config->supported_interfaces)) {
+ 		interface = phylink_select_interface(pl,
+diff --git a/include/linux/phy.h b/include/linux/phy.h
+index 2bf28a737521..d878e23dca16 100644
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -127,6 +127,11 @@ static inline void phy_interface_and(unsigned long *dst, const unsigned long *a,
+ 	bitmap_and(dst, a, b, PHY_INTERFACE_MODE_MAX);
+ }
+ 
++static inline void phy_interface_copy(unsigned long *dst, const unsigned long *src)
++{
++	bitmap_copy(dst, src, PHY_INTERFACE_MODE_MAX);
++}
++
+ /**
+  * phy_supported_speeds - return all speeds currently supported by a phy device
+  * @phy: The phy device to return supported speeds of.
+@@ -432,8 +437,9 @@ struct phy_device {
+ 	/* used with phy_speed_down */
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(adv_old);
+ 
+-	/* bitmap of supported interfaces */
++	/* bitmap of supported interfaces and host supported interfaces */
+ 	DECLARE_PHY_INTERFACE_MASK(supported_interfaces);
++	DECLARE_PHY_INTERFACE_MASK(host_interfaces);
+ 
+ 	/* Energy efficient ethernet modes which should be prohibited */
+ 	u32 eee_broken_modes;
+-- 
+2.26.2
+
diff --git a/target/linux/mvebu/patches-5.10/8586-net-phy-marvell10g-change-MACTYPE-according-to-host-.patch b/target/linux/mvebu/patches-5.10/8586-net-phy-marvell10g-change-MACTYPE-according-to-host-.patch
new file mode 100644
index 0000000..49cf29f
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/8586-net-phy-marvell10g-change-MACTYPE-according-to-host-.patch
@@ -0,0 +1,216 @@
+From 6360d5e3f3ea7ce23064aed391ce9b055b380b66 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 19 Aug 2020 15:46:36 +0200
+Subject: [PATCH 8586/8586] net: phy: marvell10g: change MACTYPE according to
+ host supported interface modes
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Use phydev->host_interfaces to determine and set MACTYPE accordingly.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/net/phy/marvell10g.c | 132 ++++++++++++++++++++++++++++++-----
+ 1 file changed, 113 insertions(+), 19 deletions(-)
+
+diff --git a/drivers/net/phy/marvell10g.c b/drivers/net/phy/marvell10g.c
+index 78807bae2117..7f6ac6b1630e 100644
+--- a/drivers/net/phy/marvell10g.c
++++ b/drivers/net/phy/marvell10g.c
+@@ -79,6 +79,7 @@ enum {
+ 	MV_V2_PORT_CTRL		= 0xf001,
+ 	MV_V2_PORT_CTRL_SWRST	= BIT(15),
+ 	MV_V2_PORT_CTRL_PWRDOWN = BIT(11),
++	MV_V2_PORT_MAC_TYPE_MASK = 0x7,
+ 	/* Temperature control/read registers (88X3310 only) */
+ 	MV_V2_TEMP_CTRL		= 0xf08a,
+ 	MV_V2_TEMP_CTRL_MASK	= 0xc000,
+@@ -90,6 +91,7 @@ enum {
+ 
+ struct mv3310_priv {
+ 	u32 firmware_ver;
++	int mac_type;
+ 
+ 	struct device *hwmon_dev;
+ 	char *hwmon_name;
+@@ -357,8 +359,14 @@ static int mv3310_probe(struct phy_device *phydev)
+ 		return -ENODEV;
+ 
+ 	__set_bit(PHY_INTERFACE_MODE_SGMII, phydev->supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_1000BASEX, phydev->supported_interfaces);
+ 	__set_bit(PHY_INTERFACE_MODE_2500BASEX, phydev->supported_interfaces);
+-	__set_bit(PHY_INTERFACE_MODE_10GBASER, phydev->supported_interfaces);
++
++	if (phydev->drv->phy_id == MARVELL_PHY_ID_88X3310) {
++		__set_bit(PHY_INTERFACE_MODE_XAUI, phydev->supported_interfaces);
++		__set_bit(PHY_INTERFACE_MODE_RXAUI, phydev->supported_interfaces);
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, phydev->supported_interfaces);
++	}
+ 
+ 	ret = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MV_PMA_BOOT);
+ 	if (ret < 0)
+@@ -437,17 +445,81 @@ static bool mv3310_has_pma_ngbaset_quirk(struct phy_device *phydev)
+ 		MV_PHY_ALASKA_NBT_QUIRK_MASK) == MV_PHY_ALASKA_NBT_QUIRK_REV;
+ }
+ 
++static int mv3310_select_mactype(struct phy_device *phydev,
++				 unsigned long *host_interfaces)
++{
++	bool h_sgmii, h_1000, h_10g, h_xaui, h_rxaui;
++
++	h_sgmii = test_bit(PHY_INTERFACE_MODE_SGMII, host_interfaces);
++	h_1000 = test_bit(PHY_INTERFACE_MODE_1000BASEX, host_interfaces);
++	h_10g = test_bit(PHY_INTERFACE_MODE_10GBASER, host_interfaces);
++	h_xaui = test_bit(PHY_INTERFACE_MODE_XAUI, host_interfaces);
++	h_rxaui = test_bit(PHY_INTERFACE_MODE_RXAUI, host_interfaces);
++
++	/* 88E2110 only supports 5gbase-r/2500base-x/SGMII/1000base-x */
++	if (phydev->drv->phy_id == MARVELL_PHY_ID_88E2110)
++		h_10g = h_xaui = h_rxaui = false;
++
++	if (h_sgmii && h_10g)
++		return 4;
++	else if (h_sgmii && h_rxaui)
++		return 0;
++	else if (h_sgmii && h_xaui)
++		return 3;
++	else if (h_10g)
++		return 6;
++	else if (h_rxaui)
++		return 2;
++	else if (h_xaui)
++		return 1;
++	else if (h_sgmii)
++		return 4;
++	else if (h_1000)
++		return 5;
++	else
++		return -1;
++}
++
++static int mv3310_set_mactype(struct phy_device *phydev, int mac_type)
++{
++	struct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);
++	int ret;
++
++	if (mac_type == -1 || phydev->drv->phy_id != MARVELL_PHY_ID_88X3310) {
++		ret = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_V2_PORT_CTRL);
++		if (ret < 0)
++			return ret;
++
++		priv->mac_type = ret & MV_V2_PORT_MAC_TYPE_MASK;
++	} else {
++		ret = phy_modify_mmd_changed(phydev, MDIO_MMD_VEND2, MV_V2_PORT_CTRL,
++					     MV_V2_PORT_CTRL_SWRST | MV_V2_PORT_MAC_TYPE_MASK,
++					     MV_V2_PORT_CTRL_SWRST | mac_type);
++		if (ret < 0)
++			return ret;
++
++		priv->mac_type = mac_type;
++	}
++
++	return 0;
++}
++
+ static int mv3310_config_init(struct phy_device *phydev)
+ {
+-	int err;
++	int err, mac_type = -1;
+ 
+ 	/* Check that the PHY interface type is compatible */
+-	if (phydev->interface != PHY_INTERFACE_MODE_SGMII &&
+-	    phydev->interface != PHY_INTERFACE_MODE_2500BASEX &&
+-	    phydev->interface != PHY_INTERFACE_MODE_XAUI &&
+-	    phydev->interface != PHY_INTERFACE_MODE_RXAUI &&
+-	    phydev->interface != PHY_INTERFACE_MODE_10GBASER)
++	if (!phy_interface_empty(phydev->host_interfaces)) {
++		mac_type = mv3310_select_mactype(phydev, phydev->host_interfaces);
++		phydev_info(phydev, "selected MAC type: %d\n", mac_type);
++	} else if (phydev->interface != PHY_INTERFACE_MODE_SGMII &&
++		   phydev->interface != PHY_INTERFACE_MODE_1000BASEX &&
++		   phydev->interface != PHY_INTERFACE_MODE_2500BASEX &&
++		   phydev->interface != PHY_INTERFACE_MODE_XAUI &&
++		   phydev->interface != PHY_INTERFACE_MODE_RXAUI &&
++		   phydev->interface != PHY_INTERFACE_MODE_10GBASER) {
+ 		return -ENODEV;
++	}
+ 
+ 	phydev->mdix_ctrl = ETH_TP_MDI_AUTO;
+ 
+@@ -456,6 +528,10 @@ static int mv3310_config_init(struct phy_device *phydev)
+ 	if (err)
+ 		return err;
+ 
++	err = mv3310_set_mactype(phydev, mac_type);
++	if (err)
++		return err;
++
+ 	/* Enable EDPD mode - saving 600mW */
+ 	return mv3310_set_edpd(phydev, ETHTOOL_PHY_EDPD_DFLT_TX_MSECS);
+ }
+@@ -562,31 +638,49 @@ static int mv3310_aneg_done(struct phy_device *phydev)
+ 
+ static void mv3310_update_interface(struct phy_device *phydev)
+ {
+-	if ((phydev->interface == PHY_INTERFACE_MODE_SGMII ||
+-	     phydev->interface == PHY_INTERFACE_MODE_2500BASEX ||
+-	     phydev->interface == PHY_INTERFACE_MODE_10GBASER) &&
+-	    phydev->link) {
+-		/* The PHY automatically switches its serdes interface (and
+-		 * active PHYXS instance) between Cisco SGMII, 10GBase-R and
+-		 * 2500BaseX modes according to the speed.  Florian suggests
+-		 * setting phydev->interface to communicate this to the MAC.
+-		 * Only do this if we are already in one of the above modes.
+-		 */
++	struct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);
++
++	switch (priv->mac_type) {
++	case 1:
++		phydev->interface = PHY_INTERFACE_MODE_XAUI;
++		break;
++	case 2:
++		phydev->interface = PHY_INTERFACE_MODE_RXAUI;
++		break;
++	case 6:
++		phydev->interface = PHY_INTERFACE_MODE_10GBASER;
++		break;
++	case 0:
++	case 3:
++	case 4:
++	case 5:
+ 		switch (phydev->speed) {
+ 		case SPEED_10000:
+-			phydev->interface = PHY_INTERFACE_MODE_10GBASER;
++			if (priv->mac_type == 0)
++				phydev->interface = PHY_INTERFACE_MODE_RXAUI;
++			else if (priv->mac_type == 3)
++				phydev->interface = PHY_INTERFACE_MODE_XAUI;
++			else
++				phydev->interface = PHY_INTERFACE_MODE_10GBASER;
+ 			break;
+ 		case SPEED_2500:
+ 			phydev->interface = PHY_INTERFACE_MODE_2500BASEX;
+ 			break;
+ 		case SPEED_1000:
++			if (priv->mac_type == 5)
++				phydev->interface = PHY_INTERFACE_MODE_1000BASEX;
++			else
++				phydev->interface = PHY_INTERFACE_MODE_SGMII;
++			break;
+ 		case SPEED_100:
+ 		case SPEED_10:
+ 			phydev->interface = PHY_INTERFACE_MODE_SGMII;
+-			break;
+ 		default:
+ 			break;
+ 		}
++		break;
++	default:
++		break;
+ 	}
+ }
+ 
+-- 
+2.26.2
+
-- 
2.26.2


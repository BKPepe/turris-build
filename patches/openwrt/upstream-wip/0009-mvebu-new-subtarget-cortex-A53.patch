From 95ebf81578cefce06ab1a80f0e151bfe96c7a031 Mon Sep 17 00:00:00 2001
From: Tomasz Maciej Nowak <tomek_n@o2.pl>
Date: Fri, 16 Feb 2018 21:50:07 +0100
Subject: [PATCH] mvebu: new subtarget cortex A53
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This commit introduces new subtarget for Marvell EBU Armada Cortex A53
processor based devices.

The first device is Globalscale ESPRESSObin. Some hardware specs:

SoC: Marvell Armada 3700LP (88F3720) dual core ARM Cortex A53
     processor up to 1.2GHz
RAM: 1 GB DDR3 or 2GB DDR3
Storage: SATA interface
         µSD card slot with footprint for an optional 4GB EMMC
         4MB SPI NOR flash for bootloader
Ethernet: Topaz Networking Switch (88E6341) with 3x GbE ports
Connectors: USB 3.0
            USB 2.0
            µUSB port connected to PL2303SA (USB to serial bridge
            controller) for UART access
Expansion: 2x 46-pin GPIO headers for accessories and shields with
           I2C, GPIOs, PWM, UART, SPI, MMC, etc
           MiniPCIe slot
Misc: Reset button, JTAG interface

Currently booting only from µSD card is supported.
To run OpenWrt on this board, it's necessary to modify default U-Boot
environment:

 1. Interrupt boot process to run U-Boot command line,
 2. Run following commands:
     setenv bootcmd "load mmc 0:1 0x4d00000 boot.scr; source 0x4d00000"
     saveenv
 3. Poweroff, insert SD card with OpenWrt image, boot and enjoy.

Signed-off-by: Tomasz Maciej Nowak <tomek_n@o2.pl>
---
 target/linux/mvebu/Makefile                        |   2 +-
 .../linux/mvebu/base-files/etc/board.d/02_network  |   3 +
 target/linux/mvebu/base-files/lib/mvebu.sh         |   3 +
 .../linux/mvebu/base-files/lib/upgrade/platform.sh |   4 +-
 target/linux/mvebu/config-4.14                     |   1 +
 target/linux/mvebu/cortexa53/config-default        | 131 +++++++++
 target/linux/mvebu/cortexa53/target.mk             |  15 +
 target/linux/mvebu/image/Makefile                  |   7 +-
 target/linux/mvebu/image/cortex-a53.mk             |  16 ++
 .../mvebu/image/globalscale-espressobin.bootscript |  10 +
 ...mvebu-armada-37xx-periph-cosmetic-changes.patch |  78 +++++
 ...rmada-37xx-periph-prepare-cpu-clk-to-be-u.patch | 178 ++++++++++++
 ...rmada-37xx-periph-add-DVFS-support-for-cp.patch | 315 +++++++++++++++++++++
 ...-cpufreq-Add-DVFS-support-for-Armada-37xx.patch | 297 +++++++++++++++++++
 ...hange-SPI-mode-before-asserting-chip-sele.patch |  70 +++++
 ...dts-marvell-Fix-A37xx-UART0-register-size.patch |  39 +++
 ...64-dts-marvell-armada-37xx-add-UART-clock.patch |  27 ++
 ...-marvell-armada-37xx-add-second-UART-port.patch |  56 ++++
 ...arvell-armada-3720-espressobin-fill-UART-.patch |  47 +++
 ...arvell-armada-37xx-add-nodes-allowing-cpu.patch |  48 ++++
 ...dts-marvell-armada-37xx-add-a-crypto-node.patch |  37 +++
 ...m64-dts-marvell-armada37xx-Add-eth0-alias.patch |  20 ++
 ...521-esporessobin-dt-enable-spi-nor-on-i2c.patch |  29 ++
 23 files changed, 1428 insertions(+), 5 deletions(-)
 create mode 100644 target/linux/mvebu/cortexa53/config-default
 create mode 100644 target/linux/mvebu/cortexa53/target.mk
 create mode 100644 target/linux/mvebu/image/cortex-a53.mk
 create mode 100644 target/linux/mvebu/image/globalscale-espressobin.bootscript
 create mode 100644 target/linux/mvebu/patches-4.14/500-clk-mvebu-armada-37xx-periph-cosmetic-changes.patch
 create mode 100644 target/linux/mvebu/patches-4.14/501-clk-mvebu-armada-37xx-periph-prepare-cpu-clk-to-be-u.patch
 create mode 100644 target/linux/mvebu/patches-4.14/502-clk-mvebu-armada-37xx-periph-add-DVFS-support-for-cp.patch
 create mode 100644 target/linux/mvebu/patches-4.14/503-cpufreq-Add-DVFS-support-for-Armada-37xx.patch
 create mode 100644 target/linux/mvebu/patches-4.14/504-spi-a3700-Change-SPI-mode-before-asserting-chip-sele.patch
 create mode 100644 target/linux/mvebu/patches-4.14/505-arm64-dts-marvell-Fix-A37xx-UART0-register-size.patch
 create mode 100644 target/linux/mvebu/patches-4.14/506-arm64-dts-marvell-armada-37xx-add-UART-clock.patch
 create mode 100644 target/linux/mvebu/patches-4.14/507-arm64-dts-marvell-armada-37xx-add-second-UART-port.patch
 create mode 100644 target/linux/mvebu/patches-4.14/508-arm64-dts-marvell-armada-3720-espressobin-fill-UART-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/509-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch
 create mode 100644 target/linux/mvebu/patches-4.14/510-arm64-dts-marvell-armada-37xx-add-a-crypto-node.patch
 create mode 100644 target/linux/mvebu/patches-4.14/520-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
 create mode 100644 target/linux/mvebu/patches-4.14/521-esporessobin-dt-enable-spi-nor-on-i2c.patch

diff --git a/target/linux/mvebu/Makefile b/target/linux/mvebu/Makefile
index 331c7c8..8a61e6c 100644
--- a/target/linux/mvebu/Makefile
+++ b/target/linux/mvebu/Makefile
@@ -9,7 +9,7 @@ include $(TOPDIR)/rules.mk
 BOARD:=mvebu
 BOARDNAME:=Marvell EBU Armada
 FEATURES:=fpu usb pci pcie gpio
-SUBTARGETS:=cortexa9
+SUBTARGETS:=cortexa9 cortexa53
 MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 
 KERNEL_PATCHVER:=4.14
diff --git a/target/linux/mvebu/base-files/etc/board.d/02_network b/target/linux/mvebu/base-files/etc/board.d/02_network
index 4fc9540..32ca3e2 100755
--- a/target/linux/mvebu/base-files/etc/board.d/02_network
+++ b/target/linux/mvebu/base-files/etc/board.d/02_network
@@ -38,6 +38,9 @@ armada-388-clearfog-*)
 armada-xp-gp)
 	ucidef_set_interface_lan "eth0 eth1 eth2 eth3"
 	;;
+globalscale,espressobin)
+	ucidef_set_interfaces_lan_wan "lan0 lan1" "wan"
+	;;
 *)
 	ucidef_set_interface_lan "eth0"
 	;;
diff --git a/target/linux/mvebu/base-files/lib/mvebu.sh b/target/linux/mvebu/base-files/lib/mvebu.sh
index fb3ddee..5c4f68a 100755
--- a/target/linux/mvebu/base-files/lib/mvebu.sh
+++ b/target/linux/mvebu/base-files/lib/mvebu.sh
@@ -17,6 +17,9 @@ mvebu_board_detect() {
 	*"Marvell Armada 370 Evaluation Board")
 		name="armada-370-db"
 		;;
+	*"Globalscale Marvell ESPRESSOBin Board")
+		name="globalscale,espressobin"
+		;;
 	*"Globalscale Mirabox")
 		name="mirabox"
 		;;
diff --git a/target/linux/mvebu/base-files/lib/upgrade/platform.sh b/target/linux/mvebu/base-files/lib/upgrade/platform.sh
index b59c765..413069c 100755
--- a/target/linux/mvebu/base-files/lib/upgrade/platform.sh
+++ b/target/linux/mvebu/base-files/lib/upgrade/platform.sh
@@ -16,7 +16,7 @@ platform_do_upgrade() {
 	armada-385-linksys-caiman|armada-385-linksys-cobra|armada-385-linksys-rango|armada-385-linksys-shelby|armada-xp-linksys-mamba)
 		platform_do_upgrade_linksys "$ARGV"
 		;;
-	armada-388-clearfog-base|armada-388-clearfog-pro)
+	armada-388-clearfog-base|armada-388-clearfog-pro|globalscale,espressobin)
 		platform_do_upgrade_sdcard "$ARGV"
 		;;
 	*)
@@ -29,7 +29,7 @@ platform_copy_config() {
 	armada-385-linksys-caiman|armada-385-linksys-cobra|armada-385-linksys-rango|armada-385-linksys-shelby|armada-xp-linksys-mamba)
 		platform_copy_config_linksys
 		;;
-	armada-388-clearfog-base|armada-388-clearfog-pro)
+	armada-388-clearfog-base|armada-388-clearfog-pro|globalscale,espressobin)
 		platform_copy_config_sdcard "$ARGV"
 		;;
 	esac
diff --git a/target/linux/mvebu/config-4.14 b/target/linux/mvebu/config-4.14
index 71123f5..c0dd113 100644
--- a/target/linux/mvebu/config-4.14
+++ b/target/linux/mvebu/config-4.14
@@ -39,6 +39,7 @@ CONFIG_ARMADA_38X_CLK=y
 CONFIG_ARMADA_THERMAL=y
 CONFIG_ARMADA_XP_CLK=y
 CONFIG_ARM_APPENDED_DTB=y
+# CONFIG_ARM_ARMADA_37XX_CPUFREQ is not set
 CONFIG_ARM_ATAG_DTB_COMPAT=y
 # CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEND is not set
 CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_FROM_BOOTLOADER=y
diff --git a/target/linux/mvebu/cortexa53/config-default b/target/linux/mvebu/cortexa53/config-default
new file mode 100644
index 0000000..e9f1edd
--- /dev/null
+++ b/target/linux/mvebu/cortexa53/config-default
@@ -0,0 +1,131 @@
+CONFIG_64BIT=y
+# CONFIG_ACPI is not set
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_ARCH_HAS_FORTIFY_SOURCE=y
+CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_ARCH_MMAP_RND_BITS=18
+CONFIG_ARCH_MMAP_RND_BITS_MAX=24
+CONFIG_ARCH_MMAP_RND_BITS_MIN=18
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=11
+# CONFIG_ARCH_OPTIONAL_KERNEL_RWX is not set
+# CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT is not set
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_ARM64=y
+# CONFIG_ARM64_16K_PAGES is not set
+CONFIG_ARM64_4K_PAGES=y
+# CONFIG_ARM64_64K_PAGES is not set
+CONFIG_ARM64_CONT_SHIFT=4
+# CONFIG_ARM64_CRYPTO is not set
+# CONFIG_ARM64_HW_AFDBM is not set
+# CONFIG_ARM64_LSE_ATOMICS is not set
+CONFIG_ARM64_PAGE_SHIFT=12
+# CONFIG_ARM64_PAN is not set
+# CONFIG_ARM64_PMEM is not set
+# CONFIG_ARM64_PTDUMP_CORE is not set
+# CONFIG_ARM64_PTDUMP_DEBUGFS is not set
+# CONFIG_ARM64_RANDOMIZE_TEXT_OFFSET is not set
+# CONFIG_ARM64_SW_TTBR0_PAN is not set
+# CONFIG_ARM64_UAO is not set
+CONFIG_ARM64_VA_BITS=39
+CONFIG_ARM64_VA_BITS_39=y
+# CONFIG_ARM64_VA_BITS_48 is not set
+# CONFIG_ARM64_VHE is not set
+CONFIG_ARMADA_37XX_CLK=y
+CONFIG_ARMADA_AP806_SYSCON=y
+CONFIG_ARMADA_CP110_SYSCON=y
+CONFIG_ARM_AMBA=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+CONFIG_ARM_ARMADA_37XX_CPUFREQ=y
+CONFIG_ARM_GIC_V2M=y
+CONFIG_ARM_GIC_V3=y
+CONFIG_ARM_GIC_V3_ITS=y
+# CONFIG_ARM_PL172_MPMC is not set
+# CONFIG_ARM_PSCI_CHECKER is not set
+CONFIG_ARM_PSCI_FW=y
+# CONFIG_ARM_SP805_WATCHDOG is not set
+CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
+# CONFIG_COMMON_CLK_VERSATILE is not set
+CONFIG_COMMON_CLK_XGENE=n
+# CONFIG_COMPAT is not set
+# CONFIG_CRYPTO_DEV_CAVIUM_ZIP is not set
+# CONFIG_CRYPTO_DEV_SAFEXCEL is not set
+# CONFIG_DEBUG_ALIGN_RODATA is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
+CONFIG_GENERIC_PINCONF=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GPIOLIB_IRQCHIP=y
+CONFIG_HAVE_ALIGNED_STRUCT_PAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_HAVE_ARCH_KASAN=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_VMAP_STACK=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_DEBUG_BUGVERBOSE=y
+CONFIG_HAVE_GENERIC_GUP=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_HAVE_PATA_PLATFORM=y
+CONFIG_HAVE_RCU_TABLE_FREE=y
+# CONFIG_HUGETLBFS is not set
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+# CONFIG_KASAN is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MMC_CAVIUM_THUNDERX is not set
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_MVEBU_GICP=y
+CONFIG_MVEBU_ICU=y
+CONFIG_MVEBU_ODMI=y
+CONFIG_MVEBU_PIC=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_NET_DSA=y
+CONFIG_NET_DSA_MV88E6XXX=y
+CONFIG_NET_DSA_MV88E6XXX_GLOBAL2=y
+# CONFIG_NET_DSA_SMSC_LAN9303_I2C is not set
+CONFIG_NET_DSA_TAG_DSA=y
+CONFIG_NET_DSA_TAG_EDSA=y
+CONFIG_NET_SWITCHDEV=y
+# CONFIG_NUMA is not set
+CONFIG_PARTITION_PERCPU=y
+# CONFIG_PCIE_KIRIN is not set
+CONFIG_PCI_AARDVARK=y
+CONFIG_PCI_BUS_ADDR_T_64BIT=y
+# CONFIG_PCI_HISI is not set
+# CONFIG_PCI_XGENE is not set
+CONFIG_PGTABLE_LEVELS=3
+CONFIG_PHYS_ADDR_T_64BIT=y
+# CONFIG_PHY_XGENE is not set
+CONFIG_PINCTRL_ARMADA_37XX=y
+CONFIG_PINCTRL_ARMADA_AP806=y
+CONFIG_PINCTRL_ARMADA_CP110=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_SUPPLY=y
+# CONFIG_RANDOMIZE_BASE is not set
+CONFIG_REGULATOR_GPIO=y
+# CONFIG_SERIAL_AMBA_PL011 is not set
+CONFIG_SPARSEMEM=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPI_ARMADA_3700=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_SYS_SUPPORTS_HUGETLBFS=y
+CONFIG_THREAD_INFO_IN_TASK=y
+CONFIG_VMAP_STACK=y
diff --git a/target/linux/mvebu/cortexa53/target.mk b/target/linux/mvebu/cortexa53/target.mk
new file mode 100644
index 0000000..c8c6849
--- /dev/null
+++ b/target/linux/mvebu/cortexa53/target.mk
@@ -0,0 +1,15 @@
+#
+# Copyright (C) 2017 Hauke Mehrtens
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+
+ARCH:=aarch64
+BOARDNAME:=Marvell Armada 3700LP (ARM64)
+CPU_TYPE:=cortex-a53
+FEATURES+=targz
+
+KERNELNAME:=Image
diff --git a/target/linux/mvebu/image/Makefile b/target/linux/mvebu/image/Makefile
index 1ed9c39..1646f8c 100644
--- a/target/linux/mvebu/image/Makefile
+++ b/target/linux/mvebu/image/Makefile
@@ -27,14 +27,16 @@ endef
 
 define Build/boot-scr
 	rm -f $@-boot.scr
-	mkimage -A arm -O linux -T script -C none -a 0 -e 0 -d $(DEVICE_NAME).bootscript $@-boot.scr
+	sed -e 's#@ROOT@#$(SIGNATURE)#g' \
+		$(DEVICE_NAME).bootscript > $@-new.bootscript
+	mkimage -A arm -O linux -T script -C none -a 0 -e 0 -d $@-new.bootscript $@-boot.scr
 endef
 
 define Build/boot-img
 	rm -f $@.boot
 	mkfs.fat -C $@.boot 16384
 	$(foreach dts,$(DEVICE_DTS), mcopy -i $@.boot $(DTS_DIR)/$(dts).dtb ::$(dts).dtb;)
-	mcopy -i $@.boot $(IMAGE_KERNEL) ::zImage
+	mcopy -i $@.boot $(IMAGE_KERNEL) ::$(KERNEL_NAME)
 	-mcopy -i $@.boot $@-boot.scr ::boot.scr
 endef
 
@@ -90,5 +92,6 @@ define Device/NAND-512K
 endef
 
 include cortex-a9.mk
+include cortex-a53.mk
 
 $(eval $(call BuildImage))
diff --git a/target/linux/mvebu/image/cortex-a53.mk b/target/linux/mvebu/image/cortex-a53.mk
new file mode 100644
index 0000000..a30c75c
--- /dev/null
+++ b/target/linux/mvebu/image/cortex-a53.mk
@@ -0,0 +1,16 @@
+ifeq ($(SUBTARGET),cortexa53)
+
+define Device/globalscale-espressobin
+  KERNEL_NAME := Image
+  KERNEL := kernel-bin
+  DEVICE_TITLE := ESPRESSObin (Marvell Armada 3700 Community Board)
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2 kmod-usb3 kmod-usb-storage
+  IMAGES := sdcard.img.gz
+  IMAGE/sdcard.img.gz := boot-scr | boot-img | sdcard-img | gzip | append-metadata
+  DEVICE_DTS := armada-3720-espressobin
+  DTS_DIR := $(DTS_DIR)/marvell
+  SUPPORTED_DEVICES := globalscale,espressobin
+endef
+TARGET_DEVICES += globalscale-espressobin
+
+endif
diff --git a/target/linux/mvebu/image/globalscale-espressobin.bootscript b/target/linux/mvebu/image/globalscale-espressobin.bootscript
new file mode 100644
index 0000000..0d03ac8
--- /dev/null
+++ b/target/linux/mvebu/image/globalscale-espressobin.bootscript
@@ -0,0 +1,10 @@
+setenv bootargs "root=PARTUUID=@ROOT@-02 rw rootwait"
+
+if test -n "${console}"; then
+	setenv bootargs "${bootargs} ${console}"
+fi
+
+load mmc 0:1 ${fdt_addr} armada-3720-espressobin.dtb
+load mmc 0:1 ${kernel_addr} Image
+
+booti ${kernel_addr} - ${fdt_addr}
diff --git a/target/linux/mvebu/patches-4.14/500-clk-mvebu-armada-37xx-periph-cosmetic-changes.patch b/target/linux/mvebu/patches-4.14/500-clk-mvebu-armada-37xx-periph-cosmetic-changes.patch
new file mode 100644
index 0000000..7343e01
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/500-clk-mvebu-armada-37xx-periph-cosmetic-changes.patch
@@ -0,0 +1,78 @@
+From adf4e289dd7f801c3fe12e0e6b491e11e548cd3d Mon Sep 17 00:00:00 2001
+From: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Date: Thu, 30 Nov 2017 14:40:27 +0100
+Subject: clk: mvebu: armada-37xx-periph: cosmetic changes
+
+This patches fixes few cosmetic issues such as alignment, blank lines
+and required space.
+
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
+---
+ drivers/clk/mvebu/armada-37xx-periph.c | 17 +++++++++--------
+ 1 file changed, 9 insertions(+), 8 deletions(-)
+
+--- a/drivers/clk/mvebu/armada-37xx-periph.c
++++ b/drivers/clk/mvebu/armada-37xx-periph.c
+@@ -79,6 +79,7 @@ static const struct clk_div_table clk_ta
+ 	{ .val = 1, .div = 4, },
+ 	{ .val = 0, .div = 0, }, /* last entry */
+ };
++
+ static const struct clk_ops clk_double_div_ops;
+ 
+ #define PERIPH_GATE(_name, _bit)		\
+@@ -217,7 +218,7 @@ PERIPH_CLK_FULL(counter, 23, 20, DIV_SEL
+ PERIPH_CLK_FULL_DD(eip97, 24, 24, DIV_SEL2, DIV_SEL2, 22, 19);
+ PERIPH_CLK_MUX_DIV(cpu, 22, DIV_SEL0, 28, clk_table6);
+ 
+-static struct clk_periph_data data_nb[] ={
++static struct clk_periph_data data_nb[] = {
+ 	REF_CLK_FULL_DD(mmc),
+ 	REF_CLK_FULL_DD(sata_host),
+ 	REF_CLK_FULL_DD(sec_at),
+@@ -281,7 +282,7 @@ static unsigned int get_div(void __iomem
+ }
+ 
+ static unsigned long clk_double_div_recalc_rate(struct clk_hw *hw,
+-		unsigned long parent_rate)
++						unsigned long parent_rate)
+ {
+ 	struct clk_double_div *double_div = to_clk_double_div(hw);
+ 	unsigned int div;
+@@ -303,6 +304,7 @@ static const struct of_device_id armada_
+ 	.data = data_sb, },
+ 	{ }
+ };
++
+ static int armada_3700_add_composite_clk(const struct clk_periph_data *data,
+ 					 void __iomem *reg, spinlock_t *lock,
+ 					 struct device *dev, struct clk_hw **hw)
+@@ -355,9 +357,9 @@ static int armada_3700_add_composite_clk
+ 	}
+ 
+ 	*hw = clk_hw_register_composite(dev, data->name, data->parent_names,
+-				       data->num_parents, mux_hw,
+-				       mux_ops, rate_hw, rate_ops,
+-				       gate_hw, gate_ops, CLK_IGNORE_UNUSED);
++					data->num_parents, mux_hw,
++					mux_ops, rate_hw, rate_ops,
++					gate_hw, gate_ops, CLK_IGNORE_UNUSED);
+ 
+ 	if (IS_ERR(*hw))
+ 		return PTR_ERR(*hw);
+@@ -406,12 +408,11 @@ static int armada_3700_periph_clock_prob
+ 		if (armada_3700_add_composite_clk(&data[i], reg,
+ 						  &driver_data->lock, dev, hw))
+ 			dev_err(dev, "Can't register periph clock %s\n",
+-			       data[i].name);
+-
++				data[i].name);
+ 	}
+ 
+ 	ret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get,
+-				  driver_data->hw_data);
++				     driver_data->hw_data);
+ 	if (ret) {
+ 		for (i = 0; i < num_periph; i++)
+ 			clk_hw_unregister(driver_data->hw_data->hws[i]);
diff --git a/target/linux/mvebu/patches-4.14/501-clk-mvebu-armada-37xx-periph-prepare-cpu-clk-to-be-u.patch b/target/linux/mvebu/patches-4.14/501-clk-mvebu-armada-37xx-periph-prepare-cpu-clk-to-be-u.patch
new file mode 100644
index 0000000..f9dec9f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/501-clk-mvebu-armada-37xx-periph-prepare-cpu-clk-to-be-u.patch
@@ -0,0 +1,178 @@
+From 9818a7a4fd10f72537cdf2a5ec3402f2c245ea24 Mon Sep 17 00:00:00 2001
+From: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Date: Thu, 30 Nov 2017 14:40:28 +0100
+Subject: clk: mvebu: armada-37xx-periph: prepare cpu clk to be
+ used with DVFS
+
+When DVFS will be enabled then the cpu clk will use a different set of
+register at run time. That means that we won't be able to use the common
+callback and need to use our own ones.
+
+This patch prepares this change by switching on our own set of callbacks
+without modifying the behavior of the clocks.
+
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
+---
+ drivers/clk/mvebu/armada-37xx-periph.c | 82 ++++++++++++++++++++++++++++++----
+ 1 file changed, 73 insertions(+), 9 deletions(-)
+
+--- a/drivers/clk/mvebu/armada-37xx-periph.c
++++ b/drivers/clk/mvebu/armada-37xx-periph.c
+@@ -46,7 +46,17 @@ struct clk_double_div {
+ 	u8 shift2;
+ };
+ 
++struct clk_pm_cpu {
++	struct clk_hw hw;
++	void __iomem *reg_mux;
++	u8 shift_mux;
++	u32 mask_mux;
++	void __iomem *reg_div;
++	u8 shift_div;
++};
++
+ #define to_clk_double_div(_hw) container_of(_hw, struct clk_double_div, hw)
++#define to_clk_pm_cpu(_hw) container_of(_hw, struct clk_pm_cpu, hw)
+ 
+ struct clk_periph_data {
+ 	const char *name;
+@@ -55,6 +65,7 @@ struct clk_periph_data {
+ 	struct clk_hw *mux_hw;
+ 	struct clk_hw *rate_hw;
+ 	struct clk_hw *gate_hw;
++	struct clk_hw *muxrate_hw;
+ 	bool is_double_div;
+ };
+ 
+@@ -81,6 +92,7 @@ static const struct clk_div_table clk_ta
+ };
+ 
+ static const struct clk_ops clk_double_div_ops;
++static const struct clk_ops clk_pm_cpu_ops;
+ 
+ #define PERIPH_GATE(_name, _bit)		\
+ struct clk_gate gate_##_name = {		\
+@@ -122,6 +134,18 @@ struct clk_divider rate_##_name = {		\
+ 	}					\
+ };
+ 
++#define PERIPH_PM_CPU(_name, _shift1, _reg, _shift2)	\
++struct clk_pm_cpu muxrate_##_name = {		\
++	.reg_mux = (void *)TBG_SEL,		\
++	.mask_mux = 3,				\
++	.shift_mux = _shift1,			\
++	.reg_div = (void *)_reg,		\
++	.shift_div = _shift2,			\
++	.hw.init = &(struct clk_init_data){	\
++		.ops =  &clk_pm_cpu_ops,	\
++	}					\
++};
++
+ #define PERIPH_CLK_FULL_DD(_name, _bit, _shift, _reg1, _reg2, _shift1, _shift2)\
+ static PERIPH_GATE(_name, _bit);			    \
+ static PERIPH_MUX(_name, _shift);			    \
+@@ -136,10 +160,6 @@ static PERIPH_DIV(_name, _reg, _shift1,
+ static PERIPH_GATE(_name, _bit);			\
+ static PERIPH_DIV(_name, _reg, _shift, _table);
+ 
+-#define PERIPH_CLK_MUX_DIV(_name, _shift,  _reg, _shift_div, _table)	\
+-static PERIPH_MUX(_name, _shift);			    \
+-static PERIPH_DIV(_name, _reg, _shift_div, _table);
+-
+ #define PERIPH_CLK_MUX_DD(_name, _shift, _reg1, _reg2, _shift1, _shift2)\
+ static PERIPH_MUX(_name, _shift);			    \
+ static PERIPH_DOUBLEDIV(_name, _reg1, _reg2, _shift1, _shift2);
+@@ -180,13 +200,12 @@ static PERIPH_DOUBLEDIV(_name, _reg1, _r
+ 	  .rate_hw = &rate_##_name.hw,				\
+ 	}
+ 
+-#define REF_CLK_MUX_DIV(_name)				\
++#define REF_CLK_PM_CPU(_name)				\
+ 	{ .name = #_name,				\
+ 	  .parent_names = (const char *[]){ "TBG-A-P",	\
+ 	      "TBG-B-P", "TBG-A-S", "TBG-B-S"},		\
+ 	  .num_parents = 4,				\
+-	  .mux_hw = &mux_##_name.hw,			\
+-	  .rate_hw = &rate_##_name.hw,			\
++	  .muxrate_hw = &muxrate_##_name.hw,		\
+ 	}
+ 
+ #define REF_CLK_MUX_DD(_name)				\
+@@ -216,7 +235,7 @@ PERIPH_CLK_FULL_DD(ddr_fclk, 21, 16, DIV
+ PERIPH_CLK_FULL(trace, 22, 18, DIV_SEL0, 20, clk_table6);
+ PERIPH_CLK_FULL(counter, 23, 20, DIV_SEL0, 23, clk_table6);
+ PERIPH_CLK_FULL_DD(eip97, 24, 24, DIV_SEL2, DIV_SEL2, 22, 19);
+-PERIPH_CLK_MUX_DIV(cpu, 22, DIV_SEL0, 28, clk_table6);
++static PERIPH_PM_CPU(cpu, 22, DIV_SEL0, 28);
+ 
+ static struct clk_periph_data data_nb[] = {
+ 	REF_CLK_FULL_DD(mmc),
+@@ -235,7 +254,7 @@ static struct clk_periph_data data_nb[]
+ 	REF_CLK_FULL(trace),
+ 	REF_CLK_FULL(counter),
+ 	REF_CLK_FULL_DD(eip97),
+-	REF_CLK_MUX_DIV(cpu),
++	REF_CLK_PM_CPU(cpu),
+ 	{ },
+ };
+ 
+@@ -297,6 +316,37 @@ static const struct clk_ops clk_double_d
+ 	.recalc_rate = clk_double_div_recalc_rate,
+ };
+ 
++static u8 clk_pm_cpu_get_parent(struct clk_hw *hw)
++{
++	struct clk_pm_cpu *pm_cpu = to_clk_pm_cpu(hw);
++	int num_parents = clk_hw_get_num_parents(hw);
++	u32 val;
++
++	val = readl(pm_cpu->reg_mux) >> pm_cpu->shift_mux;
++	val &= pm_cpu->mask_mux;
++
++	if (val >= num_parents)
++		return -EINVAL;
++
++	return val;
++}
++
++static unsigned long clk_pm_cpu_recalc_rate(struct clk_hw *hw,
++					    unsigned long parent_rate)
++{
++	struct clk_pm_cpu *pm_cpu = to_clk_pm_cpu(hw);
++	unsigned int div;
++
++	div = get_div(pm_cpu->reg_div, pm_cpu->shift_div);
++
++	return DIV_ROUND_UP_ULL((u64)parent_rate, div);
++}
++
++static const struct clk_ops clk_pm_cpu_ops = {
++	.get_parent = clk_pm_cpu_get_parent,
++	.recalc_rate = clk_pm_cpu_recalc_rate,
++};
++
+ static const struct of_device_id armada_3700_periph_clock_of_match[] = {
+ 	{ .compatible = "marvell,armada-3700-periph-clock-nb",
+ 	  .data = data_nb, },
+@@ -356,6 +406,20 @@ static int armada_3700_add_composite_clk
+ 		}
+ 	}
+ 
++	if (data->muxrate_hw) {
++		struct clk_pm_cpu *pmcpu_clk;
++		struct clk_hw *muxrate_hw = data->muxrate_hw;
++
++		pmcpu_clk =  to_clk_pm_cpu(muxrate_hw);
++		pmcpu_clk->reg_mux = reg + (u64)pmcpu_clk->reg_mux;
++		pmcpu_clk->reg_div = reg + (u64)pmcpu_clk->reg_div;
++
++		mux_hw = muxrate_hw;
++		rate_hw = muxrate_hw;
++		mux_ops = muxrate_hw->init->ops;
++		rate_ops = muxrate_hw->init->ops;
++	}
++
+ 	*hw = clk_hw_register_composite(dev, data->name, data->parent_names,
+ 					data->num_parents, mux_hw,
+ 					mux_ops, rate_hw, rate_ops,
diff --git a/target/linux/mvebu/patches-4.14/502-clk-mvebu-armada-37xx-periph-add-DVFS-support-for-cp.patch b/target/linux/mvebu/patches-4.14/502-clk-mvebu-armada-37xx-periph-add-DVFS-support-for-cp.patch
new file mode 100644
index 0000000..2065e78
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/502-clk-mvebu-armada-37xx-periph-add-DVFS-support-for-cp.patch
@@ -0,0 +1,315 @@
+From 2089dc33ea0e3917465929d4020fbff3d6dbf7f4 Mon Sep 17 00:00:00 2001
+From: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Date: Thu, 30 Nov 2017 14:40:29 +0100
+Subject: clk: mvebu: armada-37xx-periph: add DVFS support for cpu clocks
+
+When DVFS is enabled the CPU clock setting is done using an other set of
+registers.
+
+These Power Management registers are exposed through a syscon as they
+will also be used by other drivers such as the cpufreq.
+
+This patch add the possibility to modify the CPU frequency using the
+associate load level matching the target frequency. Then all the
+frequency switch is handle by the hardware.
+
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+[sboyd@codeaurora.org: Grow a local variable for regmap pointer
+to keep lines shorter]
+Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
+---
+ drivers/clk/mvebu/armada-37xx-periph.c | 221 ++++++++++++++++++++++++++++++++-
+ 1 file changed, 217 insertions(+), 4 deletions(-)
+
+--- a/drivers/clk/mvebu/armada-37xx-periph.c
++++ b/drivers/clk/mvebu/armada-37xx-periph.c
+@@ -21,9 +21,11 @@
+  */
+ 
+ #include <linux/clk-provider.h>
++#include <linux/mfd/syscon.h>
+ #include <linux/of.h>
+ #include <linux/of_device.h>
+ #include <linux/platform_device.h>
++#include <linux/regmap.h>
+ #include <linux/slab.h>
+ 
+ #define TBG_SEL		0x0
+@@ -33,6 +35,26 @@
+ #define CLK_SEL		0x10
+ #define CLK_DIS		0x14
+ 
++#define LOAD_LEVEL_NR	4
++
++#define ARMADA_37XX_NB_L0L1	0x18
++#define ARMADA_37XX_NB_L2L3	0x1C
++#define		ARMADA_37XX_NB_TBG_DIV_OFF	13
++#define		ARMADA_37XX_NB_TBG_DIV_MASK	0x7
++#define		ARMADA_37XX_NB_CLK_SEL_OFF	11
++#define		ARMADA_37XX_NB_CLK_SEL_MASK	0x1
++#define		ARMADA_37XX_NB_TBG_SEL_OFF	9
++#define		ARMADA_37XX_NB_TBG_SEL_MASK	0x3
++#define		ARMADA_37XX_NB_CONFIG_SHIFT	16
++#define ARMADA_37XX_NB_DYN_MOD	0x24
++#define		ARMADA_37XX_NB_DFS_EN	31
++#define ARMADA_37XX_NB_CPU_LOAD	0x30
++#define		ARMADA_37XX_NB_CPU_LOAD_MASK	0x3
++#define		ARMADA_37XX_DVFS_LOAD_0		0
++#define		ARMADA_37XX_DVFS_LOAD_1		1
++#define		ARMADA_37XX_DVFS_LOAD_2		2
++#define		ARMADA_37XX_DVFS_LOAD_3		3
++
+ struct clk_periph_driver_data {
+ 	struct clk_hw_onecell_data *hw_data;
+ 	spinlock_t lock;
+@@ -53,6 +75,7 @@ struct clk_pm_cpu {
+ 	u32 mask_mux;
+ 	void __iomem *reg_div;
+ 	u8 shift_div;
++	struct regmap *nb_pm_base;
+ };
+ 
+ #define to_clk_double_div(_hw) container_of(_hw, struct clk_double_div, hw)
+@@ -316,14 +339,94 @@ static const struct clk_ops clk_double_d
+ 	.recalc_rate = clk_double_div_recalc_rate,
+ };
+ 
++static void armada_3700_pm_dvfs_update_regs(unsigned int load_level,
++					    unsigned int *reg,
++					    unsigned int *offset)
++{
++	if (load_level <= ARMADA_37XX_DVFS_LOAD_1)
++		*reg = ARMADA_37XX_NB_L0L1;
++	else
++		*reg = ARMADA_37XX_NB_L2L3;
++
++	if (load_level == ARMADA_37XX_DVFS_LOAD_0 ||
++	    load_level ==  ARMADA_37XX_DVFS_LOAD_2)
++		*offset += ARMADA_37XX_NB_CONFIG_SHIFT;
++}
++
++static bool armada_3700_pm_dvfs_is_enabled(struct regmap *base)
++{
++	unsigned int val, reg = ARMADA_37XX_NB_DYN_MOD;
++
++	if (IS_ERR(base))
++		return false;
++
++	regmap_read(base, reg, &val);
++
++	return !!(val & BIT(ARMADA_37XX_NB_DFS_EN));
++}
++
++static unsigned int armada_3700_pm_dvfs_get_cpu_div(struct regmap *base)
++{
++	unsigned int reg = ARMADA_37XX_NB_CPU_LOAD;
++	unsigned int offset = ARMADA_37XX_NB_TBG_DIV_OFF;
++	unsigned int load_level, div;
++
++	/*
++	 * This function is always called after the function
++	 * armada_3700_pm_dvfs_is_enabled, so no need to check again
++	 * if the base is valid.
++	 */
++	regmap_read(base, reg, &load_level);
++
++	/*
++	 * The register and the offset inside this register accessed to
++	 * read the current divider depend on the load level
++	 */
++	load_level &= ARMADA_37XX_NB_CPU_LOAD_MASK;
++	armada_3700_pm_dvfs_update_regs(load_level, &reg, &offset);
++
++	regmap_read(base, reg, &div);
++
++	return (div >> offset) & ARMADA_37XX_NB_TBG_DIV_MASK;
++}
++
++static unsigned int armada_3700_pm_dvfs_get_cpu_parent(struct regmap *base)
++{
++	unsigned int reg = ARMADA_37XX_NB_CPU_LOAD;
++	unsigned int offset = ARMADA_37XX_NB_TBG_SEL_OFF;
++	unsigned int load_level, sel;
++
++	/*
++	 * This function is always called after the function
++	 * armada_3700_pm_dvfs_is_enabled, so no need to check again
++	 * if the base is valid
++	 */
++	regmap_read(base, reg, &load_level);
++
++	/*
++	 * The register and the offset inside this register accessed to
++	 * read the current divider depend on the load level
++	 */
++	load_level &= ARMADA_37XX_NB_CPU_LOAD_MASK;
++	armada_3700_pm_dvfs_update_regs(load_level, &reg, &offset);
++
++	regmap_read(base, reg, &sel);
++
++	return (sel >> offset) & ARMADA_37XX_NB_TBG_SEL_MASK;
++}
++
+ static u8 clk_pm_cpu_get_parent(struct clk_hw *hw)
+ {
+ 	struct clk_pm_cpu *pm_cpu = to_clk_pm_cpu(hw);
+ 	int num_parents = clk_hw_get_num_parents(hw);
+ 	u32 val;
+ 
+-	val = readl(pm_cpu->reg_mux) >> pm_cpu->shift_mux;
+-	val &= pm_cpu->mask_mux;
++	if (armada_3700_pm_dvfs_is_enabled(pm_cpu->nb_pm_base)) {
++		val = armada_3700_pm_dvfs_get_cpu_parent(pm_cpu->nb_pm_base);
++	} else {
++		val = readl(pm_cpu->reg_mux) >> pm_cpu->shift_mux;
++		val &= pm_cpu->mask_mux;
++	}
+ 
+ 	if (val >= num_parents)
+ 		return -EINVAL;
+@@ -331,19 +434,124 @@ static u8 clk_pm_cpu_get_parent(struct c
+ 	return val;
+ }
+ 
++static int clk_pm_cpu_set_parent(struct clk_hw *hw, u8 index)
++{
++	struct clk_pm_cpu *pm_cpu = to_clk_pm_cpu(hw);
++	struct regmap *base = pm_cpu->nb_pm_base;
++	int load_level;
++
++	/*
++	 * We set the clock parent only if the DVFS is available but
++	 * not enabled.
++	 */
++	if (IS_ERR(base) || armada_3700_pm_dvfs_is_enabled(base))
++		return -EINVAL;
++
++	/* Set the parent clock for all the load level */
++	for (load_level = 0; load_level < LOAD_LEVEL_NR; load_level++) {
++		unsigned int reg, mask,  val,
++			offset = ARMADA_37XX_NB_TBG_SEL_OFF;
++
++		armada_3700_pm_dvfs_update_regs(load_level, &reg, &offset);
++
++		val = index << offset;
++		mask = ARMADA_37XX_NB_TBG_SEL_MASK << offset;
++		regmap_update_bits(base, reg, mask, val);
++	}
++	return 0;
++}
++
+ static unsigned long clk_pm_cpu_recalc_rate(struct clk_hw *hw,
+ 					    unsigned long parent_rate)
+ {
+ 	struct clk_pm_cpu *pm_cpu = to_clk_pm_cpu(hw);
+ 	unsigned int div;
+ 
+-	div = get_div(pm_cpu->reg_div, pm_cpu->shift_div);
+-
++	if (armada_3700_pm_dvfs_is_enabled(pm_cpu->nb_pm_base))
++		div = armada_3700_pm_dvfs_get_cpu_div(pm_cpu->nb_pm_base);
++	else
++		div = get_div(pm_cpu->reg_div, pm_cpu->shift_div);
+ 	return DIV_ROUND_UP_ULL((u64)parent_rate, div);
+ }
+ 
++static long clk_pm_cpu_round_rate(struct clk_hw *hw, unsigned long rate,
++				  unsigned long *parent_rate)
++{
++	struct clk_pm_cpu *pm_cpu = to_clk_pm_cpu(hw);
++	struct regmap *base = pm_cpu->nb_pm_base;
++	unsigned int div = *parent_rate / rate;
++	unsigned int load_level;
++	/* only available when DVFS is enabled */
++	if (!armada_3700_pm_dvfs_is_enabled(base))
++		return -EINVAL;
++
++	for (load_level = 0; load_level < LOAD_LEVEL_NR; load_level++) {
++		unsigned int reg, val, offset = ARMADA_37XX_NB_TBG_DIV_OFF;
++
++		armada_3700_pm_dvfs_update_regs(load_level, &reg, &offset);
++
++		regmap_read(base, reg, &val);
++
++		val >>= offset;
++		val &= ARMADA_37XX_NB_TBG_DIV_MASK;
++		if (val == div)
++			/*
++			 * We found a load level matching the target
++			 * divider, switch to this load level and
++			 * return.
++			 */
++			return *parent_rate / div;
++	}
++
++	/* We didn't find any valid divider */
++	return -EINVAL;
++}
++
++static int clk_pm_cpu_set_rate(struct clk_hw *hw, unsigned long rate,
++			       unsigned long parent_rate)
++{
++	struct clk_pm_cpu *pm_cpu = to_clk_pm_cpu(hw);
++	struct regmap *base = pm_cpu->nb_pm_base;
++	unsigned int div = parent_rate / rate;
++	unsigned int load_level;
++
++	/* only available when DVFS is enabled */
++	if (!armada_3700_pm_dvfs_is_enabled(base))
++		return -EINVAL;
++
++	for (load_level = 0; load_level < LOAD_LEVEL_NR; load_level++) {
++		unsigned int reg, mask, val,
++			offset = ARMADA_37XX_NB_TBG_DIV_OFF;
++
++		armada_3700_pm_dvfs_update_regs(load_level, &reg, &offset);
++
++		regmap_read(base, reg, &val);
++		val >>= offset;
++		val &= ARMADA_37XX_NB_TBG_DIV_MASK;
++
++		if (val == div) {
++			/*
++			 * We found a load level matching the target
++			 * divider, switch to this load level and
++			 * return.
++			 */
++			reg = ARMADA_37XX_NB_CPU_LOAD;
++			mask = ARMADA_37XX_NB_CPU_LOAD_MASK;
++			regmap_update_bits(base, reg, mask, load_level);
++
++			return rate;
++		}
++	}
++
++	/* We didn't find any valid divider */
++	return -EINVAL;
++}
++
+ static const struct clk_ops clk_pm_cpu_ops = {
+ 	.get_parent = clk_pm_cpu_get_parent,
++	.set_parent = clk_pm_cpu_set_parent,
++	.round_rate = clk_pm_cpu_round_rate,
++	.set_rate = clk_pm_cpu_set_rate,
+ 	.recalc_rate = clk_pm_cpu_recalc_rate,
+ };
+ 
+@@ -409,6 +617,7 @@ static int armada_3700_add_composite_clk
+ 	if (data->muxrate_hw) {
+ 		struct clk_pm_cpu *pmcpu_clk;
+ 		struct clk_hw *muxrate_hw = data->muxrate_hw;
++		struct regmap *map;
+ 
+ 		pmcpu_clk =  to_clk_pm_cpu(muxrate_hw);
+ 		pmcpu_clk->reg_mux = reg + (u64)pmcpu_clk->reg_mux;
+@@ -418,6 +627,10 @@ static int armada_3700_add_composite_clk
+ 		rate_hw = muxrate_hw;
+ 		mux_ops = muxrate_hw->init->ops;
+ 		rate_ops = muxrate_hw->init->ops;
++
++		map = syscon_regmap_lookup_by_compatible(
++				"marvell,armada-3700-nb-pm");
++		pmcpu_clk->nb_pm_base = map;
+ 	}
+ 
+ 	*hw = clk_hw_register_composite(dev, data->name, data->parent_names,
diff --git a/target/linux/mvebu/patches-4.14/503-cpufreq-Add-DVFS-support-for-Armada-37xx.patch b/target/linux/mvebu/patches-4.14/503-cpufreq-Add-DVFS-support-for-Armada-37xx.patch
new file mode 100644
index 0000000..11562c5
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/503-cpufreq-Add-DVFS-support-for-Armada-37xx.patch
@@ -0,0 +1,297 @@
+From 92ce45fb875d7c3e021cc454482fe0687ff54f29 Mon Sep 17 00:00:00 2001
+From: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Date: Thu, 14 Dec 2017 16:00:05 +0100
+Subject: cpufreq: Add DVFS support for Armada 37xx
+
+This patch adds DVFS support for the Armada 37xx SoCs
+
+There are up to four CPU frequency loads for Armada 37xx controlled by
+the hardware.
+
+This driver associates the CPU load level to a frequency, then the
+hardware will switch while selecting a load level.
+
+The hardware also can associate a voltage for each level (AVS support)
+but it is not yet supported
+
+Tested-by: Andre Heider <a.heider@gmail.com>
+Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
+---
+ drivers/cpufreq/Kconfig.arm           |   7 +
+ drivers/cpufreq/Makefile              |   1 +
+ drivers/cpufreq/armada-37xx-cpufreq.c | 241 ++++++++++++++++++++++++++++++++++
+ 3 files changed, 249 insertions(+)
+ create mode 100644 drivers/cpufreq/armada-37xx-cpufreq.c
+
+--- a/drivers/cpufreq/Kconfig.arm
++++ b/drivers/cpufreq/Kconfig.arm
+@@ -2,6 +2,13 @@
+ # ARM CPU Frequency scaling drivers
+ #
+ 
++config ARM_ARMADA_37XX_CPUFREQ
++	tristate "Armada 37xx CPUFreq support"
++	depends on ARCH_MVEBU
++	help
++	  This adds the CPUFreq driver support for Marvell Armada 37xx SoCs.
++	  The Armada 37xx PMU supports 4 frequency and VDD levels.
++
+ # big LITTLE core layer and glue drivers
+ config ARM_BIG_LITTLE_CPUFREQ
+ 	tristate "Generic ARM big LITTLE CPUfreq driver"
+--- a/drivers/cpufreq/Makefile
++++ b/drivers/cpufreq/Makefile
+@@ -52,6 +52,7 @@ obj-$(CONFIG_ARM_BIG_LITTLE_CPUFREQ)	+=
+ # LITTLE drivers, so that it is probed last.
+ obj-$(CONFIG_ARM_DT_BL_CPUFREQ)		+= arm_big_little_dt.o
+ 
++obj-$(CONFIG_ARM_ARMADA_37XX_CPUFREQ)	+= armada-37xx-cpufreq.o
+ obj-$(CONFIG_ARM_BRCMSTB_AVS_CPUFREQ)	+= brcmstb-avs-cpufreq.o
+ obj-$(CONFIG_ARCH_DAVINCI)		+= davinci-cpufreq.o
+ obj-$(CONFIG_ARM_EXYNOS5440_CPUFREQ)	+= exynos5440-cpufreq.o
+--- /dev/null
++++ b/drivers/cpufreq/armada-37xx-cpufreq.c
+@@ -0,0 +1,241 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * CPU frequency scaling support for Armada 37xx platform.
++ *
++ * Copyright (C) 2017 Marvell
++ *
++ * Gregory CLEMENT <gregory.clement@free-electrons.com>
++ */
++
++#include <linux/clk.h>
++#include <linux/cpu.h>
++#include <linux/cpufreq.h>
++#include <linux/err.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/mfd/syscon.h>
++#include <linux/module.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/of_irq.h>
++#include <linux/platform_device.h>
++#include <linux/pm_opp.h>
++#include <linux/regmap.h>
++#include <linux/slab.h>
++
++/* Power management in North Bridge register set */
++#define ARMADA_37XX_NB_L0L1	0x18
++#define ARMADA_37XX_NB_L2L3	0x1C
++#define  ARMADA_37XX_NB_TBG_DIV_OFF	13
++#define  ARMADA_37XX_NB_TBG_DIV_MASK	0x7
++#define  ARMADA_37XX_NB_CLK_SEL_OFF	11
++#define  ARMADA_37XX_NB_CLK_SEL_MASK	0x1
++#define  ARMADA_37XX_NB_CLK_SEL_TBG	0x1
++#define  ARMADA_37XX_NB_TBG_SEL_OFF	9
++#define  ARMADA_37XX_NB_TBG_SEL_MASK	0x3
++#define  ARMADA_37XX_NB_VDD_SEL_OFF	6
++#define  ARMADA_37XX_NB_VDD_SEL_MASK	0x3
++#define  ARMADA_37XX_NB_CONFIG_SHIFT	16
++#define ARMADA_37XX_NB_DYN_MOD	0x24
++#define  ARMADA_37XX_NB_CLK_SEL_EN	BIT(26)
++#define  ARMADA_37XX_NB_TBG_EN		BIT(28)
++#define  ARMADA_37XX_NB_DIV_EN		BIT(29)
++#define  ARMADA_37XX_NB_VDD_EN		BIT(30)
++#define  ARMADA_37XX_NB_DFS_EN		BIT(31)
++#define ARMADA_37XX_NB_CPU_LOAD 0x30
++#define  ARMADA_37XX_NB_CPU_LOAD_MASK	0x3
++#define  ARMADA_37XX_DVFS_LOAD_0	0
++#define  ARMADA_37XX_DVFS_LOAD_1	1
++#define  ARMADA_37XX_DVFS_LOAD_2	2
++#define  ARMADA_37XX_DVFS_LOAD_3	3
++
++/*
++ * On Armada 37xx the Power management manages 4 level of CPU load,
++ * each level can be associated with a CPU clock source, a CPU
++ * divider, a VDD level, etc...
++ */
++#define LOAD_LEVEL_NR	4
++
++struct armada_37xx_dvfs {
++	u32 cpu_freq_max;
++	u8 divider[LOAD_LEVEL_NR];
++};
++
++static struct armada_37xx_dvfs armada_37xx_dvfs[] = {
++	{.cpu_freq_max = 1200*1000*1000, .divider = {1, 2, 4, 6} },
++	{.cpu_freq_max = 1000*1000*1000, .divider = {1, 2, 4, 5} },
++	{.cpu_freq_max = 800*1000*1000,  .divider = {1, 2, 3, 4} },
++	{.cpu_freq_max = 600*1000*1000,  .divider = {2, 4, 5, 6} },
++};
++
++static struct armada_37xx_dvfs *armada_37xx_cpu_freq_info_get(u32 freq)
++{
++	int i;
++
++	for (i = 0; i < ARRAY_SIZE(armada_37xx_dvfs); i++) {
++		if (freq == armada_37xx_dvfs[i].cpu_freq_max)
++			return &armada_37xx_dvfs[i];
++	}
++
++	pr_err("Unsupported CPU frequency %d MHz\n", freq/1000000);
++	return NULL;
++}
++
++/*
++ * Setup the four level managed by the hardware. Once the four level
++ * will be configured then the DVFS will be enabled.
++ */
++static void __init armada37xx_cpufreq_dvfs_setup(struct regmap *base,
++						 struct clk *clk, u8 *divider)
++{
++	int load_lvl;
++	struct clk *parent;
++
++	for (load_lvl = 0; load_lvl < LOAD_LEVEL_NR; load_lvl++) {
++		unsigned int reg, mask, val, offset = 0;
++
++		if (load_lvl <= ARMADA_37XX_DVFS_LOAD_1)
++			reg = ARMADA_37XX_NB_L0L1;
++		else
++			reg = ARMADA_37XX_NB_L2L3;
++
++		if (load_lvl == ARMADA_37XX_DVFS_LOAD_0 ||
++		    load_lvl == ARMADA_37XX_DVFS_LOAD_2)
++			offset += ARMADA_37XX_NB_CONFIG_SHIFT;
++
++		/* Set cpu clock source, for all the level we use TBG */
++		val = ARMADA_37XX_NB_CLK_SEL_TBG << ARMADA_37XX_NB_CLK_SEL_OFF;
++		mask = (ARMADA_37XX_NB_CLK_SEL_MASK
++			<< ARMADA_37XX_NB_CLK_SEL_OFF);
++
++		/*
++		 * Set cpu divider based on the pre-computed array in
++		 * order to have balanced step.
++		 */
++		val |= divider[load_lvl] << ARMADA_37XX_NB_TBG_DIV_OFF;
++		mask |= (ARMADA_37XX_NB_TBG_DIV_MASK
++			<< ARMADA_37XX_NB_TBG_DIV_OFF);
++
++		/* Set VDD divider which is actually the load level. */
++		val |= load_lvl << ARMADA_37XX_NB_VDD_SEL_OFF;
++		mask |= (ARMADA_37XX_NB_VDD_SEL_MASK
++			<< ARMADA_37XX_NB_VDD_SEL_OFF);
++
++		val <<= offset;
++		mask <<= offset;
++
++		regmap_update_bits(base, reg, mask, val);
++	}
++
++	/*
++	 * Set cpu clock source, for all the level we keep the same
++	 * clock source that the one already configured. For this one
++	 * we need to use the clock framework
++	 */
++	parent = clk_get_parent(clk);
++	clk_set_parent(clk, parent);
++}
++
++static void __init armada37xx_cpufreq_disable_dvfs(struct regmap *base)
++{
++	unsigned int reg = ARMADA_37XX_NB_DYN_MOD,
++		mask = ARMADA_37XX_NB_DFS_EN;
++
++	regmap_update_bits(base, reg, mask, 0);
++}
++
++static void __init armada37xx_cpufreq_enable_dvfs(struct regmap *base)
++{
++	unsigned int val, reg = ARMADA_37XX_NB_CPU_LOAD,
++		mask = ARMADA_37XX_NB_CPU_LOAD_MASK;
++
++	/* Start with the highest load (0) */
++	val = ARMADA_37XX_DVFS_LOAD_0;
++	regmap_update_bits(base, reg, mask, val);
++
++	/* Now enable DVFS for the CPUs */
++	reg = ARMADA_37XX_NB_DYN_MOD;
++	mask =	ARMADA_37XX_NB_CLK_SEL_EN | ARMADA_37XX_NB_TBG_EN |
++		ARMADA_37XX_NB_DIV_EN | ARMADA_37XX_NB_VDD_EN |
++		ARMADA_37XX_NB_DFS_EN;
++
++	regmap_update_bits(base, reg, mask, mask);
++}
++
++static int __init armada37xx_cpufreq_driver_init(void)
++{
++	struct armada_37xx_dvfs *dvfs;
++	struct platform_device *pdev;
++	unsigned int cur_frequency;
++	struct regmap *nb_pm_base;
++	struct device *cpu_dev;
++	int load_lvl, ret;
++	struct clk *clk;
++
++	nb_pm_base =
++		syscon_regmap_lookup_by_compatible("marvell,armada-3700-nb-pm");
++
++	if (IS_ERR(nb_pm_base))
++		return -ENODEV;
++
++	/* Before doing any configuration on the DVFS first, disable it */
++	armada37xx_cpufreq_disable_dvfs(nb_pm_base);
++
++	/*
++	 * On CPU 0 register the operating points supported (which are
++	 * the nominal CPU frequency and full integer divisions of
++	 * it).
++	 */
++	cpu_dev = get_cpu_device(0);
++	if (!cpu_dev) {
++		dev_err(cpu_dev, "Cannot get CPU\n");
++		return -ENODEV;
++	}
++
++	clk = clk_get(cpu_dev, 0);
++	if (IS_ERR(clk)) {
++		dev_err(cpu_dev, "Cannot get clock for CPU0\n");
++		return PTR_ERR(clk);
++	}
++
++	/* Get nominal (current) CPU frequency */
++	cur_frequency = clk_get_rate(clk);
++	if (!cur_frequency) {
++		dev_err(cpu_dev, "Failed to get clock rate for CPU\n");
++		return -EINVAL;
++	}
++
++	dvfs = armada_37xx_cpu_freq_info_get(cur_frequency);
++	if (!dvfs)
++		return -EINVAL;
++
++	armada37xx_cpufreq_dvfs_setup(nb_pm_base, clk, dvfs->divider);
++
++	for (load_lvl = ARMADA_37XX_DVFS_LOAD_0; load_lvl < LOAD_LEVEL_NR;
++	     load_lvl++) {
++		unsigned long freq = cur_frequency / dvfs->divider[load_lvl];
++
++		ret = dev_pm_opp_add(cpu_dev, freq, 0);
++		if (ret) {
++			/* clean-up the already added opp before leaving */
++			while (load_lvl-- > ARMADA_37XX_DVFS_LOAD_0) {
++				freq = cur_frequency / dvfs->divider[load_lvl];
++				dev_pm_opp_remove(cpu_dev, freq);
++			}
++			return ret;
++		}
++	}
++
++	/* Now that everything is setup, enable the DVFS at hardware level */
++	armada37xx_cpufreq_enable_dvfs(nb_pm_base);
++
++	pdev = platform_device_register_simple("cpufreq-dt", -1, NULL, 0);
++
++	return PTR_ERR_OR_ZERO(pdev);
++}
++/* late_initcall, to guarantee the driver is loaded after A37xx clock driver */
++late_initcall(armada37xx_cpufreq_driver_init);
++
++MODULE_AUTHOR("Gregory CLEMENT <gregory.clement@free-electrons.com>");
++MODULE_DESCRIPTION("Armada 37xx cpufreq driver");
++MODULE_LICENSE("GPL");
diff --git a/target/linux/mvebu/patches-4.14/504-spi-a3700-Change-SPI-mode-before-asserting-chip-sele.patch b/target/linux/mvebu/patches-4.14/504-spi-a3700-Change-SPI-mode-before-asserting-chip-sele.patch
new file mode 100644
index 0000000..3ac7091
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/504-spi-a3700-Change-SPI-mode-before-asserting-chip-sele.patch
@@ -0,0 +1,70 @@
+From dd7aa8d4b53b3484ba31ba56f3ff1be7deb38530 Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Tue, 10 Oct 2017 10:43:18 +0200
+Subject: spi: a3700: Change SPI mode before asserting chip-select
+
+The spi device mode should be configured in the controller before the
+chip-select is asserted, so that a clock polarity configuration change
+is not interpreted as a clock tick by the device.
+
+This patch moves the mode setting to the 'prepare_message' function
+instead of the 'transfer_one' function.
+
+By doing so, this patch also removes redundant code in
+a3700_spi_clock_set.
+
+This was tested on EspressoBin board, with spidev.
+
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 17 ++++-------------
+ 1 file changed, 4 insertions(+), 13 deletions(-)
+
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -214,7 +214,7 @@ static void a3700_spi_mode_set(struct a3
+ }
+ 
+ static void a3700_spi_clock_set(struct a3700_spi *a3700_spi,
+-				unsigned int speed_hz, u16 mode)
++				unsigned int speed_hz)
+ {
+ 	u32 val;
+ 	u32 prescale;
+@@ -239,17 +239,6 @@ static void a3700_spi_clock_set(struct a
+ 		val |= A3700_SPI_CLK_CAPT_EDGE;
+ 		spireg_write(a3700_spi, A3700_SPI_IF_TIME_REG, val);
+ 	}
+-
+-	val = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);
+-	val &= ~(A3700_SPI_CLK_POL | A3700_SPI_CLK_PHA);
+-
+-	if (mode & SPI_CPOL)
+-		val |= A3700_SPI_CLK_POL;
+-
+-	if (mode & SPI_CPHA)
+-		val |= A3700_SPI_CLK_PHA;
+-
+-	spireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);
+ }
+ 
+ static void a3700_spi_bytelen_set(struct a3700_spi *a3700_spi, unsigned int len)
+@@ -431,7 +420,7 @@ static void a3700_spi_transfer_setup(str
+ 
+ 	a3700_spi = spi_master_get_devdata(spi->master);
+ 
+-	a3700_spi_clock_set(a3700_spi, xfer->speed_hz, spi->mode);
++	a3700_spi_clock_set(a3700_spi, xfer->speed_hz);
+ 
+ 	byte_len = xfer->bits_per_word >> 3;
+ 
+@@ -592,6 +581,8 @@ static int a3700_spi_prepare_message(str
+ 
+ 	a3700_spi_bytelen_set(a3700_spi, 4);
+ 
++	a3700_spi_mode_set(a3700_spi, spi->mode);
++
+ 	return 0;
+ }
+ 
diff --git a/target/linux/mvebu/patches-4.14/505-arm64-dts-marvell-Fix-A37xx-UART0-register-size.patch b/target/linux/mvebu/patches-4.14/505-arm64-dts-marvell-Fix-A37xx-UART0-register-size.patch
new file mode 100644
index 0000000..9e2b1c1
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/505-arm64-dts-marvell-Fix-A37xx-UART0-register-size.patch
@@ -0,0 +1,39 @@
+From c737abc193d16e62e23e2fb585b8b7398ab380d8 Mon Sep 17 00:00:00 2001
+From: allen yan <yanwei@marvell.com>
+Date: Thu, 7 Sep 2017 15:04:53 +0200
+Subject: arm64: dts: marvell: Fix A37xx UART0 register size
+
+Armada-37xx UART0 registers are 0x200 bytes wide. Right next to them are
+the UART1 registers that should not be declared in this node.
+
+Update the example in DT bindings document accordingly.
+
+Signed-off-by: allen yan <yanwei@marvell.com>
+Signed-off-by: Miquel Raynal <miquel.raynal@free-electrons.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+---
+ Documentation/devicetree/bindings/serial/mvebu-uart.txt | 2 +-
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi            | 2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+
+--- a/Documentation/devicetree/bindings/serial/mvebu-uart.txt
++++ b/Documentation/devicetree/bindings/serial/mvebu-uart.txt
+@@ -8,6 +8,6 @@ Required properties:
+ Example:
+ 	serial@12000 {
+ 		compatible = "marvell,armada-3700-uart";
+-		reg = <0x12000 0x400>;
++		reg = <0x12000 0x200>;
+ 		interrupts = <43>;
+ 	};
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -134,7 +134,7 @@
+ 
+ 			uart0: serial@12000 {
+ 				compatible = "marvell,armada-3700-uart";
+-				reg = <0x12000 0x400>;
++				reg = <0x12000 0x200>;
+ 				interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
+ 				status = "disabled";
+ 			};
diff --git a/target/linux/mvebu/patches-4.14/506-arm64-dts-marvell-armada-37xx-add-UART-clock.patch b/target/linux/mvebu/patches-4.14/506-arm64-dts-marvell-armada-37xx-add-UART-clock.patch
new file mode 100644
index 0000000..47e0751
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/506-arm64-dts-marvell-armada-37xx-add-UART-clock.patch
@@ -0,0 +1,27 @@
+From 2ff0d0b5bb397c3dc5c9b97bd0f20948f0b77740 Mon Sep 17 00:00:00 2001
+From: Miquel Raynal <miquel.raynal@free-electrons.com>
+Date: Fri, 13 Oct 2017 11:01:57 +0200
+Subject: arm64: dts: marvell: armada-37xx: add UART clock
+
+Add the missing clock property to armada-3700 UART node.
+
+This clock will be used to derive the prescaler value to comply with
+the requested baudrate.
+
+Signed-off-by: Miquel Raynal <miquel.raynal@free-electrons.com>
+Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -135,6 +135,7 @@
+ 			uart0: serial@12000 {
+ 				compatible = "marvell,armada-3700-uart";
+ 				reg = <0x12000 0x200>;
++				clocks = <&xtalclk>;
+ 				interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
+ 				status = "disabled";
+ 			};
diff --git a/target/linux/mvebu/patches-4.14/507-arm64-dts-marvell-armada-37xx-add-second-UART-port.patch b/target/linux/mvebu/patches-4.14/507-arm64-dts-marvell-armada-37xx-add-second-UART-port.patch
new file mode 100644
index 0000000..347119d
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/507-arm64-dts-marvell-armada-37xx-add-second-UART-port.patch
@@ -0,0 +1,56 @@
+From 7c48dc201bf9aa8636716bccaa78f37a165e725b Mon Sep 17 00:00:00 2001
+From: Miquel Raynal <miquel.raynal@free-electrons.com>
+Date: Fri, 13 Oct 2017 11:01:58 +0200
+Subject: arm64: dts: marvell: armada-37xx: add second UART port
+
+Add a node in Armada 37xx DTSI file for the second UART, with a
+different compatible due to its extended IP which has some
+differences with the first UART already in place.
+
+Make use of this commit to also fully describe the first port and
+use the same clear and named interrupt bindings for both ports.
+
+The standard UART (UART0) uses level-interrupts while the extended
+UART (UART1) uses edge-triggered interrupts.
+
+Signed-off-by: Miquel Raynal <miquel.raynal@free-electrons.com>
+Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 18 +++++++++++++++++-
+ 1 file changed, 17 insertions(+), 1 deletion(-)
+
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -55,6 +55,7 @@
+ 
+ 	aliases {
+ 		serial0 = &uart0;
++		serial1 = &uart1;
+ 	};
+ 
+ 	cpus {
+@@ -136,7 +137,22 @@
+ 				compatible = "marvell,armada-3700-uart";
+ 				reg = <0x12000 0x200>;
+ 				clocks = <&xtalclk>;
+-				interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
++				interrupts =
++				<GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>,
++				<GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>,
++				<GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "uart-sum", "uart-tx", "uart-rx";
++				status = "disabled";
++			};
++
++			uart1: serial@12200 {
++				compatible = "marvell,armada-3700-uart-ext";
++				reg = <0x12200 0x30>;
++				clocks = <&xtalclk>;
++				interrupts =
++				<GIC_SPI 30 IRQ_TYPE_EDGE_RISING>,
++				<GIC_SPI 31 IRQ_TYPE_EDGE_RISING>;
++				interrupt-names = "uart-tx", "uart-rx";
+ 				status = "disabled";
+ 			};
+ 
diff --git a/target/linux/mvebu/patches-4.14/508-arm64-dts-marvell-armada-3720-espressobin-fill-UART-.patch b/target/linux/mvebu/patches-4.14/508-arm64-dts-marvell-armada-3720-espressobin-fill-UART-.patch
new file mode 100644
index 0000000..fc85385
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/508-arm64-dts-marvell-armada-3720-espressobin-fill-UART-.patch
@@ -0,0 +1,47 @@
+From c3c08c5d32d819a73f75a76b315e229a2081680a Mon Sep 17 00:00:00 2001
+From: Miquel Raynal <miquel.raynal@free-electrons.com>
+Date: Fri, 13 Oct 2017 11:02:00 +0200
+Subject: arm64: dts: marvell: armada-3720-espressobin: fill UART nodes
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Fill ESPRESSObin uart0 node with pinctrl information like in the
+Armada-3720-DB device tree (which uses the same node).
+
+Also explain how to enable the second UART port available on the
+headers. This second port is not enabled by default because both
+headers are dedicated to expose general purpose pins and remapping
+some of them to use the second UART would break existing users.
+
+Suggested-by: László ÁSHIN <laszlo@ashin.hu>
+Signed-off-by: Miquel Raynal <miquel.raynal@free-electrons.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+---
+ arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+--- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
+@@ -98,9 +98,21 @@
+ 
+ /* Exported on the micro USB connector J5 through an FTDI */
+ &uart0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&uart1_pins>;
+ 	status = "okay";
+ };
+ 
++/*
++ * Connector J17 and J18 expose a number of different features. Some pins are
++ * multiplexed. This is the case for instance for the following features:
++ * - UART1 (pin 24 = RX, pin 26 = TX). See armada-3720-db.dts for an example of
++ *   how to enable it. Beware that the signals are 1.8V TTL.
++ * - I2C
++ * - SPI
++ * - MMC
++ */
++
+ /* J7 */
+ &usb3 {
+ 	status = "okay";
diff --git a/target/linux/mvebu/patches-4.14/509-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch b/target/linux/mvebu/patches-4.14/509-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch
new file mode 100644
index 0000000..937ecc5
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/509-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch
@@ -0,0 +1,48 @@
+From e8d66e7927b2a15310df0eb44a67d120ea147a59 Mon Sep 17 00:00:00 2001
+From: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Date: Thu, 14 Dec 2017 16:00:06 +0100
+Subject: arm64: dts: marvell: armada-37xx: add nodes allowing cpufreq
+ support
+
+In order to be able to use cpu freq, we need to associate a clock to each
+CPU and to expose the power management registers.
+
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+---
+ arch/arm64/boot/dts/marvell/armada-372x.dtsi | 1 +
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 7 +++++++
+ 2 files changed, 8 insertions(+)
+
+--- a/arch/arm64/boot/dts/marvell/armada-372x.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-372x.dtsi
+@@ -56,6 +56,7 @@
+ 			device_type = "cpu";
+ 			compatible = "arm,cortex-a53","arm,armv8";
+ 			reg = <0x1>;
++			clocks = <&nb_periph_clk 16>;
+ 			enable-method = "psci";
+ 		};
+ 	};
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -65,6 +65,7 @@
+ 			device_type = "cpu";
+ 			compatible = "arm,cortex-a53", "arm,armv8";
+ 			reg = <0>;
++			clocks = <&nb_periph_clk 16>;
+ 			enable-method = "psci";
+ 		};
+ 	};
+@@ -235,6 +236,12 @@
+ 				};
+ 			};
+ 
++			nb_pm: syscon@14000 {
++				compatible = "marvell,armada-3700-nb-pm",
++					     "syscon";
++				reg = <0x14000 0x60>;
++			};
++
+ 			pinctrl_sb: pinctrl@18800 {
+ 				compatible = "marvell,armada3710-sb-pinctrl",
+ 					     "syscon", "simple-mfd";
diff --git a/target/linux/mvebu/patches-4.14/510-arm64-dts-marvell-armada-37xx-add-a-crypto-node.patch b/target/linux/mvebu/patches-4.14/510-arm64-dts-marvell-armada-37xx-add-a-crypto-node.patch
new file mode 100644
index 0000000..11a86de
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/510-arm64-dts-marvell-armada-37xx-add-a-crypto-node.patch
@@ -0,0 +1,37 @@
+From e2707a288ce7f325d0762a406622c204df6c7a44 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@free-electrons.com>
+Date: Tue, 26 Dec 2017 17:16:53 +0100
+Subject: arm64: dts: marvell: armada-37xx: add a crypto node
+
+This patch adds a crypto node describing the EIP97 engine found in
+Armada 37xx SoCs. The cryptographic engine is enabled by default.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 14 ++++++++++++++
+ 1 file changed, 14 insertions(+)
+
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -317,6 +317,20 @@
+ 				};
+ 			};
+ 
++			crypto: crypto@90000 {
++				compatible = "inside-secure,safexcel-eip97";
++				reg = <0x90000 0x20000>;
++				interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "mem", "ring0", "ring1",
++						  "ring2", "ring3", "eip";
++				clocks = <&nb_periph_clk 15>;
++			};
++
+ 			sdhci1: sdhci@d0000 {
+ 				compatible = "marvell,armada-3700-sdhci",
+ 					     "marvell,sdhci-xenon";
diff --git a/target/linux/mvebu/patches-4.14/520-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch b/target/linux/mvebu/patches-4.14/520-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
new file mode 100644
index 0000000..ba26ee7
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/520-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
@@ -0,0 +1,20 @@
+From be893f672e340b56ca60f2f6c32fdd713a5852f5 Mon Sep 17 00:00:00 2001
+From: Kevin Mihelich <kevin@archlinuxarm.org>
+Date: Tue, 4 Jul 2017 19:25:28 -0600
+Subject: arm64: dts: marvell: armada37xx: Add eth0 alias
+
+Signed-off-by: Kevin Mihelich <kevin@archlinuxarm.org>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -54,6 +54,7 @@
+ 	#size-cells = <2>;
+ 
+ 	aliases {
++		ethernet0 = &eth0;
+ 		serial0 = &uart0;
+ 		serial1 = &uart1;
+ 	};
diff --git a/target/linux/mvebu/patches-4.14/521-esporessobin-dt-enable-spi-nor-on-i2c.patch b/target/linux/mvebu/patches-4.14/521-esporessobin-dt-enable-spi-nor-on-i2c.patch
new file mode 100644
index 0000000..57f83a2
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/521-esporessobin-dt-enable-spi-nor-on-i2c.patch
@@ -0,0 +1,29 @@
+--- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
+@@ -123,6 +123,26 @@
+ 	status = "okay";
+ };
+ 
++&spi0 {
++	status = "okay";
++
++	w25q32dw@0 {
++		#address-cells = <1>;
++		#size-cells = <1>;
++		compatible = "jedec,spi-nor";
++		reg = <0>;
++		spi-max-frequency = <104000000>;
++		m25,fast-read;
++
++		pinctrl-names = "default";
++		pinctrl-0 = <&spi_quad_pins>;
++	};
++};
++
++&i2c0 {
++	status = "okay";
++};
++
+ &mdio {
+ 	switch0: switch0@1 {
+ 		compatible = "marvell,mv88e6085";
-- 
2.16.2


From 6cef91a3ac8a1e3eb3b4da472dd6ec00fac869ca Mon Sep 17 00:00:00 2001
From: Josef Schlehofer <pepe.schlehofer@gmail.com>
Date: Mon, 24 Oct 2022 15:13:48 +0200
Subject: [PATCH] mac80211: update to version 5.15.74-1

---
 package/kernel/mac80211/Makefile              |   36 +-
 package/kernel/mac80211/ath.mk                |    4 +-
 package/kernel/mac80211/broadcom.mk           |    4 +-
 .../mac80211/files/lib/netifd/mac80211.sh     |   36 -
 .../files/lib/netifd/wireless/mac80211.sh     |    7 +-
 .../mac80211/files/lib/wifi/mac80211.sh       |    5 +-
 .../patches/ath/120-owl-loader-compat.patch   |   53 -
 .../patches/ath/402-ath_regd_optional.patch   |    8 +-
 .../patches/ath/404-regd_no_assoc_hints.patch |    4 +-
 .../ath/406-ath_relax_default_regd.patch      |    2 +-
 .../ath/550-ath9k-disable-bands-via-dt.patch  |   15 -
 ...h10k-increase-rx-buffer-size-to-2048.patch |   37 -
 .../080-ath10k_thermal_config.patch           |    2 +-
 ...us-and-device-specific-API-1-BDF-sel.patch |   65 +
 ...calibration-data-via-nvmem-subsystem.patch |  162 ++
 ...21-ath10k_init_devices_synchronously.patch |    2 +-
 .../930-ath10k_add_tpt_led_trigger.patch      |    4 +-
 ...rolling-support-for-various-chipsets.patch |   24 +-
 ...75-ath10k-use-tpt-trigger-by-default.patch |    8 +-
 ...-power-reduction-for-US-regulatory-d.patch |    8 +-
 ...h10k-Try-to-get-mac-address-from-dts.patch |   37 +
 .../990-ath10k-small-buffers.patch            |    2 +-
 .../201-ath5k-WAR-for-AR71xx-PCI-bug.patch    |    0
 .../411-ath5k_allow_adhoc_and_ap.patch        |    6 +-
 .../420-ath5k_disable_fast_cc.patch           |    0
 .../430-add_ath5k_platform.patch              |    0
 .../{ath => ath5k}/432-ath5k_add_pciids.patch |    0
 .../440-ath5k_channel_bw_debugfs.patch        |    2 +-
 ...-ieee80211-freq-limit-property-to-li.patch |   28 +
 ...w-reset-AHB-WMAC-interface-on-AR91xx.patch |    2 +-
 ..._hw-issue-external-reset-for-QCA955x.patch |    4 +-
 ...h9k-force-rx_clear-when-disabling-rx.patch |    0
 ...erpret-requested-txpower-in-EIRP-dom.patch |    4 +-
 ...power-reduction-for-US-regulatory-do.patch |    2 +-
 .../401-ath9k_blink_default.patch             |    2 +-
 .../410-ath9k_allow_adhoc_and_ap.patch        |    4 +-
 ...abled-MFP-capability-unconditionally.patch |    4 +-
 .../500-ath9k_eeprom_debugfs.patch            |    0
 .../{ath => ath9k}/501-ath9k_ahb_init.patch   |    2 +-
 .../510-ath9k_intr_mitigation_tweak.patch     |    2 +-
 .../511-ath9k_reduce_rxbuf.patch              |    0
 .../512-ath9k_channelbw_debugfs.patch         |    0
 .../513-ath9k_add_pci_ids.patch               |    2 +-
 .../{ath => ath9k}/530-ath9k_extra_leds.patch |    8 +-
 .../531-ath9k_extra_platform_leds.patch       |    0
 .../540-ath9k_reduce_ani_interval.patch       |    0
 .../542-ath9k_debugfs_diag.patch              |    4 +-
 .../543-ath9k_entropy_from_adc.patch          |   14 +-
 ...544-ath9k-ar933x-usb-hang-workaround.patch |   10 +-
 .../545-ath9k_ani_ws_detect.patch             |    2 +-
 .../547-ath9k_led_defstate_fix.patch          |    0
 .../548-ath9k_enable_gpio_chip.patch          |    4 +-
 .../549-ath9k_enable_gpio_buttons.patch       |    2 +-
 .../551-ath9k_ubnt_uap_plus_hsr.patch         |    2 +-
 .../552-ath9k-ahb_of.patch}                   |   18 +-
 .../553-ath9k_of_gpio_mask.patch              |    4 +-
 ...calibration-data-via-nvmem-subsystem.patch |  154 ++
 ...-fetch-pci-init-values-through-nvmem.patch |  181 +++
 .../brcm/812-b43-add-antenna-control.patch    |    8 +-
 ...-register-wiphy-s-during-module_init.patch |   18 +-
 ...62-brcmfmac-Disable-power-management.patch |    2 +-
 ...-in-driver-tables-with-country-codes.patch |   12 +-
 .../mac80211/patches/brcm/998-survey.patch    |   12 +-
 .../build/003-remove_bogus_modparams.patch    |    2 +-
 .../build/004-kconfig_backport_fix.patch      |   28 -
 .../patches/build/010-disable_rfkill.patch    |   15 -
 .../patches/build/060-no_local_ssb_bcma.patch |   18 +-
 ...700-mwl8k-missing-pci-id-for-WNR854T.patch |    2 +-
 ...940-mwl8k_init_devices_synchronously.patch |    4 +-
 ...define-RF5592-in-init_eeprom-routine.patch |   52 +
 ...02-rt2x00-add-throughput-LED-trigger.patch |   76 +
 ...define-RF5592-in-init_eeprom-routine.patch |   51 -
 ...d-support-for-external-PA-on-MT7620.patch} |   72 +-
 ...ove-up-and-reuse-busy-wait-functions.patch |  178 +++
 ...RF-self-TXDC-calibration-for-MT7620.patch} |   61 +-
 ...rt2x00-add-r-calibration-for-MT7620.patch} |   93 +-
 ...0-add-RXDCOC-calibration-for-MT7620.patch} |   62 +-
 ...x00-add-RXIQ-calibration-for-MT7620.patch} |  285 ++--
 ...-run-Rt5592-IQ-calibration-on-MT7620.patch |   52 +
 ...-add-TX-LOFT-calibration-for-MT7620.patch} |  277 ++--
 ...x00-move-helper-functions-up-in-file.patch |   94 ++
 ...HT20-HT40-bandwidth-switch-on-MT7620.patch |   56 +
 ...t-TX_SW_CFG1-MAC-register-for-MT7620.patch |   52 +
 ...t-VGC-gain-for-both-chains-of-MT7620.patch |   50 +
 ...5-rt2x00-set-SoC-wmac-clock-register.patch |   70 +
 ...ectly-set-BBP-register-86-for-MT7620.patch |   79 +
 .../602-rt2x00-introduce-rt2x00eeprom.patch   |   16 +-
 .../603-rt2x00-of_load_eeprom_filename.patch  |    6 +-
 ...isabling_bands_through_platform_data.patch |    4 +-
 ...07-rt2x00-add_platform_data_mac_addr.patch |   11 +-
 ...00-allow_disabling_bands_through_dts.patch |    2 +-
 ...0-rt2x00-change-led-polarity-from-OF.patch |    2 +-
 .../611-rt2x00-add-AP+STA-support.patch       |    2 +-
 .../612-rt2x00-led-tpt-trigger-support.patch  |   44 -
 ...ave-survey-for-every-channel-visited.patch |  183 ---
 ...t-support-for-external-LNA-on-MT7620.patch |  161 ++
 ...uce-accessors-for-CHIP_VER-register.patch} |    0
 ...differentiate-based-on-SoC-CHIP_VER.patch} |   28 +-
 ...ent-set_tim-by-update-beacon-content.patch |  118 --
 .../patches/subsys/010-sync-nl80211_h.patch   |  297 ----
 .../100-remove-cryptoapi-dependencies.patch   |  699 ---------
 .../110-mac80211_keep_keys_on_stop_ap.patch   |    2 +-
 .../120-cfg80211_allow_perm_addr_change.patch |    2 +-
 .../patches/subsys/130-disable-fils.patch     |   32 -
 ...aes-cmac-switch-to-shash-CMAC-driver.patch |  230 ---
 .../132-mac80211-remove-cmac-dependency.patch |   10 -
 .../subsys/150-disable_addr_notifier.patch    |   12 +-
 .../mac80211/patches/subsys/210-ap_scan.patch |    2 +-
 ...ort-immediate-reconnect-request-hint.patch |  279 ----
 ...omize-BA-session-dialog-token-alloc.patch} |    0
 ...-driver-based-disconnect-with-reconn.patch |  271 ----
 ...port-to-configure-SAE-PWE-value-to-d.patch |   74 -
 ...the-fwd_skb-dev-for-mesh-forwarding.patch} |    2 +-
 ...se-boottime-for-airtime-fairness-co.patch} |   10 +-
 ...211_hwsim-make-6-GHz-channels-usable.patch |   74 +
 ...d-support-for-.ndo_fill_forward_path.patch |  178 +++
 ...minstrel_ht-fix-MINSTREL_FRAC-macro.patch} |    0
 ..._ht-reduce-fluctuations-in-rate-pro.patch} |    2 +-
 ...-free-packets-from-a-flow-on-overmem.patch |   95 --
 ..._ht-rework-rate-downgrade-code-and-.patch} |   16 +-
 ...-get_default_func-move-default-flow-.patch |  144 --
 ...211-split-beacon-retrieval-functions.patch |  262 ++++
 ...ot-maintain-a-backlog-sorted-list-of.patch |  317 ----
 ...11-MBSSID-and-EMA-support-in-AP-mode.patch |  493 ++++++
 ...nt-APIs-for-dedicated-radar-detectio.patch |  378 +++++
 ...ffchan_cac_event-to-a-dedicated-work.patch |  183 +++
 ...add-rx-decapsulation-offload-support.patch |  570 -------
 ...sible-NULL-pointer-dereference-in-cf.patch |   99 ++
 ...le-QoS-support-for-nl80211-ctrl-port.patch |  116 --
 ...e-offchan_cac_abort_wk-in-cfg80211_r.patch |  136 ++
 ...ontinuous-radar-monitoring-on-offcha.patch |  220 +++
 ...introduce-set_radar_offchan-callback.patch |   67 +
 ...offchannel_chain-structs-to-backgrou.patch |  532 +++++++
 ...MBSSID-support-in-interface-handling.patch |  144 ++
 ...11-MBSSID-beacon-handling-in-AP-mode.patch |  326 ++++
 .../325-mac80211-MBSSID-channel-switch.patch  |   52 +
 ...bssid_indicator-in-ieee80211_assign_.patch |   25 +
 ...wake-queues-on-a-vif-that-is-being-s.patch |   38 +
 ...airtime-fairness-back-to-deficit-rou.patch | 1249 ++++++++++++++++
 ...a-airtime-deficit-field-s32-instead-.patch |   52 +
 ...r-aql_tx_pending-when-checking-airti.patch |   48 +
 ...cently-active-tx-queues-in-schedulin.patch |  118 ++
 ...er-PHY-AQL-limit-to-improve-fairness.patch |  131 ++
 ...ugfs-file-to-display-per-phy-AQL-pen.patch |   58 +
 ...cumulate-airtime-deficit-for-active-.patch |   36 +
 ...crease-quantum-for-airtime-scheduler.patch |   53 +
 ...c80211-minstrel_ht-clean-up-CCK-code.patch |  166 ---
 ...l_ht-add-support-for-OFDM-rates-on-n.patch |  762 ----------
 ...-multicast-packets-from-AQL-pending-.patch |   30 +
 ...-remove-legacy-minstrel-rate-control.patch | 1328 -----------------
 ...l_ht-remove-old-ewma-based-rate-aver.patch |   96 --
 ...-not-abuse-fq.lock-in-ieee80211_do_s.patch |   46 +
 ...dlock-Don-t-start-TX-while-holding-f.patch |   40 +
 ...l_ht-improve-ampdu-length-estimation.patch |   67 -
 ...vif-queues-are-operational-after-sta.patch |   47 +
 ...rel_ht-improve-sample-rate-selection.patch |   31 -
 ...l_ht-fix-max-probability-rate-select.patch |  124 --
 ...el_ht-increase-stats-update-interval.patch |   20 -
 ...l_ht-fix-rounding-error-in-throughpu.patch |   34 -
 ...l_ht-use-bitfields-to-encode-rate-in.patch |  412 -----
 ...l_ht-update-total-packets-counter-in.patch |   54 -
 ...l_ht-reduce-the-need-to-sample-slowe.patch |  102 --
 ...l_ht-significantly-redesign-the-rate.patch |  767 ----------
 ...el_ht-show-sampling-rates-in-debugfs.patch |   58 -
 ...l_ht-remove-sample-rate-switching-co.patch |  279 ----
 ...l_ht-fix-regression-in-the-max_prob_.patch |   23 -
 ...pply-flow-control-on-management-fram.patch |   60 -
 ...set-sk_pacing_shift-for-802.3-txpath.patch |   21 -
 ...-Rx-timestamp-calculation-for-all-pr.patch |  134 --
 ...MPDU-session-check-from-minstrel_ht-.patch |  126 --
 ...eee80211_tx_h_rate_ctrl-when-dequeue.patch |  114 --
 ...te-control-support-for-encap-offload.patch |  126 --
 ...11-minstrel_ht-fix-sample-time-check.patch |   23 -
 ...rting-aggregation-sessions-on-mesh-i.patch |  112 --
 ...introduce-aql_enable-node-in-debugfs.patch |  111 --
 ...ange-struct-txq_info-for-fewer-holes.patch |   39 -
 ...to-a-virtual-time-based-airtime-sche.patch | 1277 ----------------
 ...on-API-to-configure-SAR-power-limita.patch |  398 -----
 ...mac80211-add-ieee80211_set_sar_specs.patch |   51 -
 ...eck-per-vif-offload_flags-in-Tx-path.patch |   26 -
 ...nl80211-add-support-for-BSS-coloring.patch |  485 ------
 ...211-add-support-for-BSS-color-change.patch |  524 -------
 ...eee80211-add-TWT-element-definitions.patch |  112 --
 ...ce-individual-TWT-support-in-AP-mode.patch |  576 -------
 ...n-some-HE-capabilities-with-the-spec.patch |  196 ---
 ...pelling-of-A-MSDU-in-HE-capabilities.patch |  113 --
 ...E-capabilities-A-MPDU-Length-Exponen.patch |  148 --
 ...ate-control-for-retransmitted-frames.patch |   35 -
 .../patches/subsys/397-disable-mbssid.patch   |   44 -
 .../patches/subsys/400-allow-ibss-mixed.patch |    2 +-
 .../500-mac80211_configure_antenna_gain.patch |   66 +-
 ...the-dst-buffer-to-of_get_mac_address.patch |   29 +
 package/kernel/mac80211/realtek.mk            |   18 +
 193 files changed, 7460 insertions(+), 13476 deletions(-)
 delete mode 100644 package/kernel/mac80211/files/lib/netifd/mac80211.sh
 delete mode 100644 package/kernel/mac80211/patches/ath/120-owl-loader-compat.patch
 delete mode 100644 package/kernel/mac80211/patches/ath/550-ath9k-disable-bands-via-dt.patch
 delete mode 100644 package/kernel/mac80211/patches/ath/922-ath10k-increase-rx-buffer-size-to-2048.patch
 rename package/kernel/mac80211/patches/{ath => ath10k}/080-ath10k_thermal_config.patch (97%)
 create mode 100644 package/kernel/mac80211/patches/ath10k/100-ath10k-support-bus-and-device-specific-API-1-BDF-sel.patch
 create mode 100644 package/kernel/mac80211/patches/ath10k/120-ath10k-fetch-calibration-data-via-nvmem-subsystem.patch
 rename package/kernel/mac80211/patches/{ath => ath10k}/921-ath10k_init_devices_synchronously.patch (94%)
 rename package/kernel/mac80211/patches/{ath => ath10k}/930-ath10k_add_tpt_led_trigger.patch (89%)
 rename package/kernel/mac80211/patches/{ath => ath10k}/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch (96%)
 rename package/kernel/mac80211/patches/{ath => ath10k}/975-ath10k-use-tpt-trigger-by-default.patch (92%)
 rename package/kernel/mac80211/patches/{ath => ath10k}/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch (93%)
 create mode 100644 package/kernel/mac80211/patches/ath10k/984-ath10k-Try-to-get-mac-address-from-dts.patch
 rename package/kernel/mac80211/patches/{ath => ath10k}/990-ath10k-small-buffers.patch (97%)
 rename package/kernel/mac80211/patches/{ath => ath5k}/201-ath5k-WAR-for-AR71xx-PCI-bug.patch (100%)
 rename package/kernel/mac80211/patches/{ath => ath5k}/411-ath5k_allow_adhoc_and_ap.patch (89%)
 rename package/kernel/mac80211/patches/{ath => ath5k}/420-ath5k_disable_fast_cc.patch (100%)
 rename package/kernel/mac80211/patches/{ath => ath5k}/430-add_ath5k_platform.patch (100%)
 rename package/kernel/mac80211/patches/{ath => ath5k}/432-ath5k_add_pciids.patch (100%)
 rename package/kernel/mac80211/patches/{ath => ath5k}/440-ath5k_channel_bw_debugfs.patch (98%)
 create mode 100644 package/kernel/mac80211/patches/ath9k/040-ath9k-support-DT-ieee80211-freq-limit-property-to-li.patch
 rename package/kernel/mac80211/patches/{ath => ath9k}/350-ath9k_hw-reset-AHB-WMAC-interface-on-AR91xx.patch (89%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/351-ath9k_hw-issue-external-reset-for-QCA955x.patch (95%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/354-ath9k-force-rx_clear-when-disabling-rx.patch (100%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch (89%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch (91%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/401-ath9k_blink_default.patch (88%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/410-ath9k_allow_adhoc_and_ap.patch (73%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/450-ath9k-enabled-MFP-capability-unconditionally.patch (90%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/500-ath9k_eeprom_debugfs.patch (100%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/501-ath9k_ahb_init.patch (91%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/510-ath9k_intr_mitigation_tweak.patch (87%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/511-ath9k_reduce_rxbuf.patch (100%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/512-ath9k_channelbw_debugfs.patch (100%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/513-ath9k_add_pci_ids.patch (93%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/530-ath9k_extra_leds.patch (96%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/531-ath9k_extra_platform_leds.patch (100%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/540-ath9k_reduce_ani_interval.patch (100%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/542-ath9k_debugfs_diag.patch (96%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/543-ath9k_entropy_from_adc.patch (94%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/544-ath9k-ar933x-usb-hang-workaround.patch (84%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/545-ath9k_ani_ws_detect.patch (98%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/547-ath9k_led_defstate_fix.patch (100%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/548-ath9k_enable_gpio_chip.patch (98%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/549-ath9k_enable_gpio_buttons.patch (98%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/551-ath9k_ubnt_uap_plus_hsr.patch (99%)
 rename package/kernel/mac80211/patches/{ath/552-ahb_of.patch => ath9k/552-ath9k-ahb_of.patch} (93%)
 rename package/kernel/mac80211/patches/{ath => ath9k}/553-ath9k_of_gpio_mask.patch (80%)
 create mode 100644 package/kernel/mac80211/patches/ath9k/600-v5.16-ath9k-fetch-calibration-data-via-nvmem-subsystem.patch
 create mode 100644 package/kernel/mac80211/patches/ath9k/601-v5.16-ath9k-owl-loader-fetch-pci-init-values-through-nvmem.patch
 delete mode 100644 package/kernel/mac80211/patches/build/004-kconfig_backport_fix.patch
 delete mode 100644 package/kernel/mac80211/patches/build/010-disable_rfkill.patch
 create mode 100644 package/kernel/mac80211/patches/rt2x00/001-rt2x00-define-RF5592-in-init_eeprom-routine.patch
 create mode 100644 package/kernel/mac80211/patches/rt2x00/002-rt2x00-add-throughput-LED-trigger.patch
 delete mode 100644 package/kernel/mac80211/patches/rt2x00/002-rt2x00-define-RF5592-in-init_eeprom-routine.patch
 rename package/kernel/mac80211/patches/rt2x00/{650-rt2x00-add-support-for-external-PA-on-MT7620.patch => 003-rt2x00-add-support-for-external-PA-on-MT7620.patch} (58%)
 create mode 100644 package/kernel/mac80211/patches/rt2x00/004-rt2x00-move-up-and-reuse-busy-wait-functions.patch
 rename package/kernel/mac80211/patches/rt2x00/{982-rt2x00-add-rf-self-txdc-calibration.patch => 005-rt2x00-add-RF-self-TXDC-calibration-for-MT7620.patch} (51%)
 rename package/kernel/mac80211/patches/rt2x00/{983-rt2x00-add-r-calibration.patch => 006-rt2x00-add-r-calibration-for-MT7620.patch} (66%)
 rename package/kernel/mac80211/patches/rt2x00/{984-rt2x00-add-rxdcoc-calibration.patch => 007-rt2x00-add-RXDCOC-calibration-for-MT7620.patch} (50%)
 rename package/kernel/mac80211/patches/rt2x00/{985-rt2x00-add-rxiq-calibration.patch => 008-rt2x00-add-RXIQ-calibration-for-MT7620.patch} (63%)
 create mode 100644 package/kernel/mac80211/patches/rt2x00/009-rt2x00-don-t-run-Rt5592-IQ-calibration-on-MT7620.patch
 rename package/kernel/mac80211/patches/rt2x00/{986-rt2x00-add-TX-LOFT-calibration.patch => 010-rt2x00-add-TX-LOFT-calibration-for-MT7620.patch} (84%)
 create mode 100644 package/kernel/mac80211/patches/rt2x00/011-rt2x00-move-helper-functions-up-in-file.patch
 create mode 100644 package/kernel/mac80211/patches/rt2x00/012-rt2x00-fix-HT20-HT40-bandwidth-switch-on-MT7620.patch
 create mode 100644 package/kernel/mac80211/patches/rt2x00/013-rt2x00-set-correct-TX_SW_CFG1-MAC-register-for-MT7620.patch
 create mode 100644 package/kernel/mac80211/patches/rt2x00/014-rt2x00-set-VGC-gain-for-both-chains-of-MT7620.patch
 create mode 100644 package/kernel/mac80211/patches/rt2x00/015-rt2x00-set-SoC-wmac-clock-register.patch
 create mode 100644 package/kernel/mac80211/patches/rt2x00/016-rt2x00-correctly-set-BBP-register-86-for-MT7620.patch
 delete mode 100644 package/kernel/mac80211/patches/rt2x00/612-rt2x00-led-tpt-trigger-support.patch
 delete mode 100644 package/kernel/mac80211/patches/rt2x00/992-rt2x00-save-survey-for-every-channel-visited.patch
 create mode 100644 package/kernel/mac80211/patches/rt2x00/994-rt2x00-import-support-for-external-LNA-on-MT7620.patch
 rename package/kernel/mac80211/patches/rt2x00/{990-rt2x00-mt7620-introduce-accessors-for-CHIP_VER-register.patch => 995-rt2x00-mt7620-introduce-accessors-for-CHIP_VER-register.patch} (100%)
 rename package/kernel/mac80211/patches/rt2x00/{991-rt2x00-mt7620-differentiate-based-on-SoC-CHIP_VER.patch => 996-rt2x00-mt7620-differentiate-based-on-SoC-CHIP_VER.patch} (95%)
 delete mode 100644 package/kernel/mac80211/patches/rtl/002-v5.13-rtlwifi-implement-set_tim-by-update-beacon-content.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/010-sync-nl80211_h.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/100-remove-cryptoapi-dependencies.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/130-disable-fils.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/131-Revert-mac80211-aes-cmac-switch-to-shash-CMAC-driver.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/132-mac80211-remove-cmac-dependency.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/300-cfg80211-support-immediate-reconnect-request-hint.patch
 rename package/kernel/mac80211/patches/subsys/{304-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch => 301-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch} (100%)
 delete mode 100644 package/kernel/mac80211/patches/subsys/301-mac80211-support-driver-based-disconnect-with-reconn.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/302-cfg80211-Add-support-to-configure-SAE-PWE-value-to-d.patch
 rename package/kernel/mac80211/patches/subsys/{306-mac80211-set-up-the-fwd_skb-dev-for-mesh-forwarding.patch => 303-mac80211-set-up-the-fwd_skb-dev-for-mesh-forwarding.patch} (97%)
 rename package/kernel/mac80211/patches/subsys/{395-mac80211-use-coarse-boottime-for-airtime-fairness-co.patch => 306-mac80211-use-coarse-boottime-for-airtime-fairness-co.patch} (84%)
 create mode 100644 package/kernel/mac80211/patches/subsys/307-mac80211_hwsim-make-6-GHz-channels-usable.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/308-mac80211-add-support-for-.ndo_fill_forward_path.patch
 rename package/kernel/mac80211/patches/subsys/{353-mac80211-minstrel_ht-fix-MINSTREL_FRAC-macro.patch => 309-mac80211-minstrel_ht-fix-MINSTREL_FRAC-macro.patch} (100%)
 rename package/kernel/mac80211/patches/subsys/{354-mac80211-minstrel_ht-reduce-fluctuations-in-rate-pro.patch => 310-mac80211-minstrel_ht-reduce-fluctuations-in-rate-pro.patch} (94%)
 delete mode 100644 package/kernel/mac80211/patches/subsys/310-net-fq_impl-bulk-free-packets-from-a-flow-on-overmem.patch
 rename package/kernel/mac80211/patches/subsys/{355-mac80211-minstrel_ht-rework-rate-downgrade-code-and-.patch => 311-mac80211-minstrel_ht-rework-rate-downgrade-code-and-.patch} (90%)
 delete mode 100644 package/kernel/mac80211/patches/subsys/311-net-fq_impl-drop-get_default_func-move-default-flow-.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/312-mac80211-split-beacon-retrieval-functions.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/312-net-fq_impl-do-not-maintain-a-backlog-sorted-list-of.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/313-nl80211-MBSSID-and-EMA-support-in-AP-mode.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/314-cfg80211-implement-APIs-for-dedicated-radar-detectio.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/315-cfg80211-move-offchan_cac_event-to-a-dedicated-work.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/315-mac80211-add-rx-decapsulation-offload-support.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/316-cfg80211-fix-possible-NULL-pointer-dereference-in-cf.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/316-mac80211-enable-QoS-support-for-nl80211-ctrl-port.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/317-cfg80211-schedule-offchan_cac_abort_wk-in-cfg80211_r.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/318-cfg80211-allow-continuous-radar-monitoring-on-offcha.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/319-mac80211-introduce-set_radar_offchan-callback.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/320-cfg80211-rename-offchannel_chain-structs-to-backgrou.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/323-mac80211-MBSSID-support-in-interface-handling.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/324-mac80211-MBSSID-beacon-handling-in-AP-mode.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/325-mac80211-MBSSID-channel-switch.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/326-mac80211-update-bssid_indicator-in-ieee80211_assign_.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/328-mac80211-do-not-wake-queues-on-a-vif-that-is-being-s.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/330-mac80211-switch-airtime-fairness-back-to-deficit-rou.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/331-mac80211-make-sta-airtime-deficit-field-s32-instead-.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/332-mac80211-consider-aql_tx_pending-when-checking-airti.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/333-mac80211-keep-recently-active-tx-queues-in-schedulin.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/334-mac80211-add-a-per-PHY-AQL-limit-to-improve-fairness.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/335-mac80211-add-debugfs-file-to-display-per-phy-AQL-pen.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/336-mac80211-only-accumulate-airtime-deficit-for-active-.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/337-mac80211-increase-quantum-for-airtime-scheduler.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/337-mac80211-minstrel_ht-clean-up-CCK-code.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/338-mac80211-minstrel_ht-add-support-for-OFDM-rates-on-n.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/339-mac80211-exclude-multicast-packets-from-AQL-pending-.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/339-mac80211-remove-legacy-minstrel-rate-control.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/340-mac80211-minstrel_ht-remove-old-ewma-based-rate-aver.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/340-wifi-mac80211-do-not-abuse-fq.lock-in-ieee80211_do_s.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/341-mac80211-Fix-deadlock-Don-t-start-TX-while-holding-f.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/341-mac80211-minstrel_ht-improve-ampdu-length-estimation.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/342-mac80211-Ensure-vif-queues-are-operational-after-sta.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/342-mac80211-minstrel_ht-improve-sample-rate-selection.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/343-mac80211-minstrel_ht-fix-max-probability-rate-select.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/344-mac80211-minstrel_ht-increase-stats-update-interval.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/345-mac80211-minstrel_ht-fix-rounding-error-in-throughpu.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/346-mac80211-minstrel_ht-use-bitfields-to-encode-rate-in.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/347-mac80211-minstrel_ht-update-total-packets-counter-in.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/348-mac80211-minstrel_ht-reduce-the-need-to-sample-slowe.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/349-mac80211-minstrel_ht-significantly-redesign-the-rate.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/350-mac80211-minstrel_ht-show-sampling-rates-in-debugfs.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/351-mac80211-minstrel_ht-remove-sample-rate-switching-co.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/352-mac80211-minstrel_ht-fix-regression-in-the-max_prob_.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/371-mac80211-don-t-apply-flow-control-on-management-fram.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/372-mac80211-set-sk_pacing_shift-for-802.3-txpath.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/373-mac80211-support-Rx-timestamp-calculation-for-all-pr.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/374-mac80211-move-A-MPDU-session-check-from-minstrel_ht-.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/375-mac80211-call-ieee80211_tx_h_rate_ctrl-when-dequeue.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/376-mac80211-add-rate-control-support-for-encap-offload.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/377-mac80211-minstrel_ht-fix-sample-time-check.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/379-mac80211-fix-starting-aggregation-sessions-on-mesh-i.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/380-mac80211-introduce-aql_enable-node-in-debugfs.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/381-mac80211-rearrange-struct-txq_info-for-fewer-holes.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/382-mac80211-Switch-to-a-virtual-time-based-airtime-sche.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/384-nl80211-add-common-API-to-configure-SAR-power-limita.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/385-mac80211-add-ieee80211_set_sar_specs.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/386-mac80211-check-per-vif-offload_flags-in-Tx-path.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/387-nl80211-add-support-for-BSS-coloring.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/388-mac80211-add-support-for-BSS-color-change.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/389-ieee80211-add-TWT-element-definitions.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/390-mac80211-introduce-individual-TWT-support-in-AP-mode.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/391-wireless-align-some-HE-capabilities-with-the-spec.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/392-wireless-fix-spelling-of-A-MSDU-in-HE-capabilities.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/393-wireless-align-HE-capabilities-A-MPDU-Length-Exponen.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/394-mac80211-fix-rate-control-for-retransmitted-frames.patch
 delete mode 100644 package/kernel/mac80211/patches/subsys/397-disable-mbssid.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/782-net-next-1-of-net-pass-the-dst-buffer-to-of_get_mac_address.patch

diff --git a/package/kernel/mac80211/Makefile b/package/kernel/mac80211/Makefile
index 014512c67b..5d70874bad 100644
--- a/package/kernel/mac80211/Makefile
+++ b/package/kernel/mac80211/Makefile
@@ -10,10 +10,10 @@ include $(INCLUDE_DIR)/kernel.mk
 
 PKG_NAME:=mac80211
 
-PKG_VERSION:=5.10.149-1
+PKG_VERSION:=5.15.74-1
 PKG_RELEASE:=1
-PKG_SOURCE_URL:=@KERNEL/linux/kernel/projects/backports/stable/v5.10.149/
-PKG_HASH:=80a68a78c9b18513bad0bbd0cb70907eadbfd9bba44c075a94f0795fd7f7be2a
+PKG_SOURCE_URL:=@KERNEL/linux/kernel/projects/backports/stable/v5.15.74/
+PKG_HASH:=98098d0cab24cc76a04db738dc746a0c8d38d180398805481224f141cca06423
 
 PKG_SOURCE:=backports-$(PKG_VERSION).tar.xz
 PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/backports-$(PKG_VERSION)
@@ -23,7 +23,6 @@ PKG_MAINTAINER:=Felix Fietkau <nbd@nbd.name>
 
 PKG_DRIVERS = \
 	adm8211 \
-	airo \
 	hermes hermes-pci hermes-pcmcia hermes-plx\
 	lib80211 \
 	mac80211-hwsim \
@@ -98,7 +97,7 @@ PKG_CONFIG_DEPENDS += \
 define KernelPackage/cfg80211
   $(call KernelPackage/mac80211/Default)
   TITLE:=cfg80211 - wireless configuration API
-  DEPENDS+= +iw +wireless-regdb
+  DEPENDS+= +iw +iwinfo +wireless-regdb +USE_RFKILL:kmod-rfkill
   ABI_VERSION:=$(PKG_VERSION)-$(PKG_RELEASE)
   FILES:= \
 	$(PKG_BUILD_DIR)/compat/compat.ko \
@@ -127,7 +126,7 @@ define KernelPackage/mac80211
   $(call KernelPackage/mac80211/Default)
   TITLE:=Linux 802.11 Wireless Networking Stack
   # +kmod-crypto-cmac is a runtime only dependency of net/mac80211/aes_cmac.c
-  DEPENDS+= +kmod-cfg80211 +hostapd-common
+  DEPENDS+= +kmod-cfg80211 +kmod-crypto-cmac +kmod-crypto-ccm +kmod-crypto-gcm +hostapd-common
   KCONFIG:=\
 	CONFIG_AVERAGE=y
   FILES:= $(PKG_BUILD_DIR)/net/mac80211/mac80211.ko
@@ -174,18 +173,6 @@ define KernelPackage/adm8211
   AUTOLOAD:=$(call AutoProbe,adm8211)
 endef
 
-define KernelPackage/airo
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Cisco Aironet driver
-  DEPENDS+=@PCI_SUPPORT +@DRIVER_WEXT_SUPPORT +kmod-cfg80211 @TARGET_x86 @BROKEN
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/cisco/airo.ko
-  AUTOLOAD:=$(call AutoProbe,airo)
-endef
-
-define KernelPackage/airo/description
- Kernel support for Cisco Aironet cards
-endef
-
 define KernelPackage/hermes
   $(call KernelPackage/mac80211/Default)
   TITLE:=Hermes 802.11b chipset support
@@ -406,8 +393,6 @@ endif
 
 config-$(call config_package,lib80211) += LIB80211 LIB80211_CRYPT_WEP LIB80211_CRYPT_CCMP LIB80211_CRYPT_TKIP
 
-config-$(call config_package,airo) += AIRO
-
 config-$(call config_package,mac80211-hwsim) += MAC80211_HWSIM
 config-$(call config_package,mt7601u) += MT7601U
 config-y += WL_MEDIATEK
@@ -507,9 +492,14 @@ define Build/Patch
 	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/build,build/)
 	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/subsys,subsys/)
 	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath,ath/)
+	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath5k,ath5k/)
+	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath9k,ath9k/)
+	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath10k,ath10k/)
+	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath11k,ath11k/)
 	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/rt2x00,rt2x00/)
 	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/mwl,mwl/)
 	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/brcm,brcm/)
+	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/rtl,rtl/)
 	$(if $(QUILT),touch $(PKG_BUILD_DIR)/.quilt_used)
 endef
 
@@ -517,9 +507,14 @@ define Quilt/Refresh/Package
 	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/build,build/)
 	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/subsys,subsys/)
 	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath,ath/)
+	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath5k,ath5k/)
+	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath9k,ath9k/)
+	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath10k,ath10k/)
+	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath11k,ath11k/)
 	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/rt2x00,rt2x00/)
 	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/mwl,mwl/)
 	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/brcm,brcm/)
+	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/rtl,rtl/)
 endef
 
 define Build/Compile
@@ -545,7 +540,6 @@ endef
 define KernelPackage/cfg80211/install
 	$(INSTALL_DIR) $(1)/lib/wifi $(1)/lib/netifd/wireless
 	$(INSTALL_DATA) ./files/lib/wifi/mac80211.sh $(1)/lib/wifi
-	$(INSTALL_DATA) ./files/lib/netifd/mac80211.sh $(1)/lib/netifd
 	$(INSTALL_BIN) ./files/lib/netifd/wireless/mac80211.sh $(1)/lib/netifd/wireless
 	$(INSTALL_DIR) $(1)/etc/hotplug.d/ieee80211
 	$(INSTALL_DATA) ./files/mac80211.hotplug $(1)/etc/hotplug.d/ieee80211/10-wifi-detect
diff --git a/package/kernel/mac80211/ath.mk b/package/kernel/mac80211/ath.mk
index e815f37e1c..50b1eed9c8 100644
--- a/package/kernel/mac80211/ath.mk
+++ b/package/kernel/mac80211/ath.mk
@@ -34,7 +34,7 @@ ifdef CONFIG_PACKAGE_MAC80211_TRACING
 	WIL6210_TRACING
 endif
 
-config-$(call config_package,ath) += ATH_CARDS ATH_COMMON ATH_REG_DYNAMIC_USER_REG_HINTS
+config-$(call config_package,ath) += ATH_CARDS ATH_COMMON
 config-$(CONFIG_PACKAGE_ATH_DEBUG) += ATH_DEBUG ATH10K_DEBUG ATH9K_STATION_STATISTICS
 config-$(CONFIG_PACKAGE_ATH_DFS) += ATH9K_DFS_CERTIFIED ATH10K_DFS_CERTIFIED
 config-$(CONFIG_PACKAGE_ATH_SPECTRAL) += ATH9K_COMMON_SPECTRAL ATH10K_SPECTRAL
@@ -45,7 +45,7 @@ config-$(call config_package,owl-loader) += ATH9K_PCI_NO_EEPROM
 config-$(CONFIG_TARGET_ath79) += ATH9K_AHB
 config-$(CONFIG_TARGET_ipq40xx) += ATH10K_AHB
 config-$(CONFIG_PCI) += ATH9K_PCI
-config-$(CONFIG_ATH_USER_REGD) += ATH_USER_REGD
+config-$(CONFIG_ATH_USER_REGD) += ATH_USER_REGD ATH_REG_DYNAMIC_USER_REG_HINTS
 config-$(CONFIG_ATH9K_HWRNG) += ATH9K_HWRNG
 config-$(CONFIG_ATH9K_SUPPORT_PCOEM) += ATH9K_PCOEM
 config-$(CONFIG_ATH9K_TX99) += ATH9K_TX99
diff --git a/package/kernel/mac80211/broadcom.mk b/package/kernel/mac80211/broadcom.mk
index fb576c5809..473bbf597c 100644
--- a/package/kernel/mac80211/broadcom.mk
+++ b/package/kernel/mac80211/broadcom.mk
@@ -209,7 +209,7 @@ config PACKAGE_B43_USE_BCMA
 		default "16,28,29,30" if TARGET_bcm47xx_mips74k
 		default "5,6,7,8,9,10,11,13,15,16,28,29,30"
 		help
-		  This is a comma seperated list of core revision numbers.
+		  This is a comma separated list of core revision numbers.
 
 		  Example (keep files for rev5 only):
 		    5
@@ -224,7 +224,7 @@ config PACKAGE_B43_USE_BCMA
 		default "N,HT" if TARGET_bcm47xx_mips74k
 		default "G,N,LP,HT"
 		help
-		  This is a comma seperated list of PHY types:
+		  This is a comma separated list of PHY types:
 		    A  => A-PHY
 		    AG => Dual A-PHY G-PHY
 		    G  => G-PHY
diff --git a/package/kernel/mac80211/files/lib/netifd/mac80211.sh b/package/kernel/mac80211/files/lib/netifd/mac80211.sh
deleted file mode 100644
index 92e5c0e395..0000000000
--- a/package/kernel/mac80211/files/lib/netifd/mac80211.sh
+++ /dev/null
@@ -1,36 +0,0 @@
-mac80211_phy_to_path() {
-	local phy="$1"
-
-	[ -x /usr/bin/readlink -a -h /sys/class/ieee80211/${phy} ] || return
-
-	local path="$(readlink -f /sys/class/ieee80211/${phy}/device)"
-	[ -n "$path" ] || return
-
-	path="${path##/sys/devices/}"
-	case "$path" in
-		platform*/pci*) path="${path##platform/}";;
-	esac
-
-	local p
-	local seq=""
-	for p in $(ls /sys/class/ieee80211/$phy/device/ieee80211); do
-		[ "$p" = "$phy" ] && {
-			echo "$path${seq:++$seq}"
-			break
-		}
-
-		seq=$((${seq:-0} + 1))
-	done
-}
-
-mac80211_path_to_phy() {
-	local path="$1"
-
-	local p
-	for p in $(ls /sys/class/ieee80211); do
-		local cur="$(mac80211_phy_to_path "$p")"
-		case "$cur" in
-			*$path) echo "$p"; return;;
-		esac
-	done
-}
diff --git a/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh b/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
index d69667bf8c..daa54949a0 100644
--- a/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
+++ b/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
@@ -1,7 +1,6 @@
 #!/bin/sh
 . /lib/netifd/netifd-wireless.sh
 . /lib/netifd/hostapd.sh
-. /lib/netifd/mac80211.sh
 
 init_wireless_driver "$@"
 
@@ -414,9 +413,9 @@ mac80211_hostapd_setup_base() {
 			he_spr_non_srg_obss_pd_max_offset:1 \
 			he_bss_color
 
-		he_phy_cap=$(iw phy "$phy" info | awk -F "[()]" '/HE PHY Capabilities/ { print $2 }' | head -1)
+		he_phy_cap=$(iw phy "$phy" info | sed -n '/HE Iftypes: AP/,$p' | awk -F "[()]" '/HE PHY Capabilities/ { print $2 }' | head -1)
 		he_phy_cap=${he_phy_cap:2}
-		he_mac_cap=$(iw phy "$phy" info | awk -F "[()]" '/HE MAC Capabilities/ { print $2 }' | head -1)
+		he_mac_cap=$(iw phy "$phy" info | sed -n '/HE Iftypes: AP/,$p' | awk -F "[()]" '/HE MAC Capabilities/ { print $2 }' | head -1)
 		he_mac_cap=${he_mac_cap:2}
 
 		append base_cfg "ieee80211ax=1" "$N"
@@ -563,7 +562,7 @@ mac80211_generate_mac() {
 find_phy() {
 	[ -n "$phy" -a -d /sys/class/ieee80211/$phy ] && return 0
 	[ -n "$path" ] && {
-		phy="$(mac80211_path_to_phy "$path")"
+		phy="$(iwinfo nl80211 phyname "path=$path")"
 		[ -n "$phy" ] && return 0
 	}
 	[ -n "$macaddr" ] && {
diff --git a/package/kernel/mac80211/files/lib/wifi/mac80211.sh b/package/kernel/mac80211/files/lib/wifi/mac80211.sh
index 5eb7cc4c61..6aa46b0c74 100644
--- a/package/kernel/mac80211/files/lib/wifi/mac80211.sh
+++ b/package/kernel/mac80211/files/lib/wifi/mac80211.sh
@@ -1,5 +1,4 @@
 #!/bin/sh
-. /lib/netifd/mac80211.sh
 
 append DRIVERS "mac80211"
 
@@ -11,7 +10,7 @@ lookup_phy() {
 	local devpath
 	config_get devpath "$device" path
 	[ -n "$devpath" ] && {
-		phy="$(mac80211_path_to_phy "$devpath")"
+		phy="$(iwinfo nl80211 phyname "path=$devpath")"
 		[ -n "$phy" ] && return
 	}
 
@@ -161,7 +160,7 @@ detect_mac80211() {
 
 		get_band_defaults "$dev"
 
-		path="$(mac80211_phy_to_path "$dev")"
+		path="$(iwinfo nl80211 path "$dev")"
 		if [ -n "$path" ]; then
 			dev_id="set wireless.radio${devidx}.path='$path'"
 		else
diff --git a/package/kernel/mac80211/patches/ath/120-owl-loader-compat.patch b/package/kernel/mac80211/patches/ath/120-owl-loader-compat.patch
deleted file mode 100644
index d1d6c9e2e3..0000000000
--- a/package/kernel/mac80211/patches/ath/120-owl-loader-compat.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From: Christian Lamparter <chunkeey@gmail.com>
-Date: Sat, 16 Nov 2019 19:25:24 +0100
-Subject: [PATCH] owl_loader: compatibility patch
-
-This patch includes OpenWrt specific changes that are
-not included in the upstream owl-loader.
-
-This includes a platform data handling changes for ar71xx.
-
-Signed-off-by: Christian Lamparter <chunkeey@gmail.com>
-
---- a/drivers/net/wireless/ath/ath9k/ath9k_pci_owl_loader.c
-+++ b/drivers/net/wireless/ath/ath9k/ath9k_pci_owl_loader.c
-@@ -103,6 +103,7 @@ static void owl_fw_cb(const struct firmw
- {
- 	struct pci_dev *pdev = (struct pci_dev *)context;
- 	struct owl_ctx *ctx = (struct owl_ctx *)pci_get_drvdata(pdev);
-+	struct ath9k_platform_data *pdata = dev_get_platdata(&pdev->dev);
- 	struct pci_bus *bus;
- 
- 	complete(&ctx->eeprom_load);
-@@ -118,6 +119,16 @@ static void owl_fw_cb(const struct firmw
- 		goto release;
- 	}
- 
-+	if (pdata) {
-+		memcpy(pdata->eeprom_data, fw->data, fw->size);
-+
-+		/*
-+		 * eeprom has been successfully loaded - pass the data to ath9k
-+		 * but remove the eeprom_name, so it doesn't try to load it too.
-+		 */
-+		pdata->eeprom_name = NULL;
-+	}
-+
- 	if (ath9k_pci_fixup(pdev, (const u16 *)fw->data, fw->size))
- 		goto release;
- 
-@@ -137,8 +148,14 @@ release:
- static const char *owl_get_eeprom_name(struct pci_dev *pdev)
- {
- 	struct device *dev = &pdev->dev;
-+	struct ath9k_platform_data *pdata;
- 	char *eeprom_name;
- 
-+	/* try the existing platform data first */
-+	pdata = dev_get_platdata(dev);
-+	if (pdata && pdata->eeprom_name)
-+		return pdata->eeprom_name;
-+
- 	dev_dbg(dev, "using auto-generated eeprom filename\n");
- 
- 	eeprom_name = devm_kzalloc(dev, EEPROM_FILENAME_LEN, GFP_KERNEL);
diff --git a/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch b/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch
index bf87d3551a..4ea33365d1 100644
--- a/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch
+++ b/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch
@@ -37,7 +37,7 @@
  	for (band = 0; band < NUM_NL80211_BANDS; band++) {
  		if (!wiphy->bands[band])
  			continue;
-@@ -378,6 +387,9 @@ ath_reg_apply_ir_flags(struct wiphy *wip
+@@ -379,6 +388,9 @@ ath_reg_apply_ir_flags(struct wiphy *wip
  {
  	struct ieee80211_supported_band *sband;
  
@@ -47,7 +47,7 @@
  	sband = wiphy->bands[NL80211_BAND_2GHZ];
  	if (!sband)
  		return;
-@@ -407,6 +419,9 @@ static void ath_reg_apply_radar_flags(st
+@@ -408,6 +420,9 @@ static void ath_reg_apply_radar_flags(st
  	struct ieee80211_channel *ch;
  	unsigned int i;
  
@@ -57,7 +57,7 @@
  	if (!wiphy->bands[NL80211_BAND_5GHZ])
  		return;
  
-@@ -639,6 +654,10 @@ ath_regd_init_wiphy(struct ath_regulator
+@@ -640,6 +655,10 @@ ath_regd_init_wiphy(struct ath_regulator
  	const struct ieee80211_regdomain *regd;
  
  	wiphy->reg_notifier = reg_notifier;
@@ -82,7 +82,7 @@
  	help
 --- a/local-symbols
 +++ b/local-symbols
-@@ -85,6 +85,7 @@ ADM8211=
+@@ -106,6 +106,7 @@ ADM8211=
  ATH_COMMON=
  WLAN_VENDOR_ATH=
  ATH_DEBUG=
diff --git a/package/kernel/mac80211/patches/ath/404-regd_no_assoc_hints.patch b/package/kernel/mac80211/patches/ath/404-regd_no_assoc_hints.patch
index dfe324caf8..02281adf4a 100644
--- a/package/kernel/mac80211/patches/ath/404-regd_no_assoc_hints.patch
+++ b/package/kernel/mac80211/patches/ath/404-regd_no_assoc_hints.patch
@@ -1,6 +1,6 @@
 --- a/net/wireless/reg.c
 +++ b/net/wireless/reg.c
-@@ -3257,6 +3257,8 @@ void regulatory_hint_country_ie(struct w
+@@ -3309,6 +3309,8 @@ void regulatory_hint_country_ie(struct w
  	enum environment_cap env = ENVIRON_ANY;
  	struct regulatory_request *request = NULL, *lr;
  
@@ -9,7 +9,7 @@
  	/* IE len must be evenly divisible by 2 */
  	if (country_ie_len & 0x01)
  		return;
-@@ -3508,6 +3510,7 @@ static bool is_wiphy_all_set_reg_flag(en
+@@ -3560,6 +3562,7 @@ static bool is_wiphy_all_set_reg_flag(en
  
  void regulatory_hint_disconnect(void)
  {
diff --git a/package/kernel/mac80211/patches/ath/406-ath_relax_default_regd.patch b/package/kernel/mac80211/patches/ath/406-ath_relax_default_regd.patch
index 35b0f2b76e..ee4e461342 100644
--- a/package/kernel/mac80211/patches/ath/406-ath_relax_default_regd.patch
+++ b/package/kernel/mac80211/patches/ath/406-ath_relax_default_regd.patch
@@ -39,7 +39,7 @@
  bool ath_is_world_regd(struct ath_regulatory *reg)
  {
  	return is_wwr_sku(ath_regd_get_eepromRD(reg));
-@@ -658,6 +666,9 @@ ath_regd_init_wiphy(struct ath_regulator
+@@ -659,6 +667,9 @@ ath_regd_init_wiphy(struct ath_regulator
  	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
  		return 0;
  
diff --git a/package/kernel/mac80211/patches/ath/550-ath9k-disable-bands-via-dt.patch b/package/kernel/mac80211/patches/ath/550-ath9k-disable-bands-via-dt.patch
deleted file mode 100644
index 7d3a334c42..0000000000
--- a/package/kernel/mac80211/patches/ath/550-ath9k-disable-bands-via-dt.patch
+++ /dev/null
@@ -1,15 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -627,6 +627,12 @@ static int ath9k_of_init(struct ath_soft
- 
- 	ath_dbg(common, CONFIG, "parsing configuration from OF node\n");
- 
-+	if (of_property_read_bool(np, "qca,disable-2ghz"))
-+		ah->disable_2ghz = true;
-+
-+	if (of_property_read_bool(np, "qca,disable-5ghz"))
-+		ah->disable_5ghz = true;
-+
- 	if (of_property_read_bool(np, "qca,no-eeprom")) {
- 		/* ath9k-eeprom-<bus>-<id>.bin */
- 		scnprintf(eeprom_name, sizeof(eeprom_name),
diff --git a/package/kernel/mac80211/patches/ath/922-ath10k-increase-rx-buffer-size-to-2048.patch b/package/kernel/mac80211/patches/ath/922-ath10k-increase-rx-buffer-size-to-2048.patch
deleted file mode 100644
index 8f7a60eec8..0000000000
--- a/package/kernel/mac80211/patches/ath/922-ath10k-increase-rx-buffer-size-to-2048.patch
+++ /dev/null
@@ -1,37 +0,0 @@
-From: Linus Lüssing <ll@simonwunderlich.de>
-Date: Wed, 5 Feb 2020 20:10:43 +0100
-Subject: ath10k: increase rx buffer size to 2048
-
-Before, only frames with a maximum size of 1528 bytes could be
-transmitted between two 802.11s nodes.
-
-For batman-adv for instance, which adds its own header to each frame,
-we typically need an MTU of at least 1532 bytes to be able to transmit
-without fragmentation.
-
-This patch now increases the maxmimum frame size from 1528 to 1656
-bytes.
-
-Tested with two ath10k devices in 802.11s mode, as well as with
-batman-adv on top of 802.11s with forwarding disabled.
-
-Fix originally found and developed by Ben Greear.
-
-Link: https://github.com/greearb/ath10k-ct/issues/89
-Link: https://github.com/greearb/ath10k-ct/commit/9e5ab25027e0971fa24ccf93373324c08c4e992d
-Cc: Ben Greear <greearb@candelatech.com>
-Signed-off-by: Linus Lüssing <ll@simonwunderlich.de>
-
-Forwarded: https://patchwork.kernel.org/patch/11367055/
-
---- a/drivers/net/wireless/ath/ath10k/htt.h
-+++ b/drivers/net/wireless/ath/ath10k/htt.h
-@@ -2243,7 +2243,7 @@ struct htt_rx_chan_info {
-  * Should be: sizeof(struct htt_host_rx_desc) + max rx MSDU size,
-  * rounded up to a cache line size.
-  */
--#define HTT_RX_BUF_SIZE 1920
-+#define HTT_RX_BUF_SIZE 2048
- #define HTT_RX_MSDU_SIZE (HTT_RX_BUF_SIZE - (int)sizeof(struct htt_rx_desc))
- 
- /* Refill a bunch of RX buffers for each refill round so that FW/HW can handle
diff --git a/package/kernel/mac80211/patches/ath/080-ath10k_thermal_config.patch b/package/kernel/mac80211/patches/ath10k/080-ath10k_thermal_config.patch
similarity index 97%
rename from package/kernel/mac80211/patches/ath/080-ath10k_thermal_config.patch
rename to package/kernel/mac80211/patches/ath10k/080-ath10k_thermal_config.patch
index de6f9d9bb0..d9a3cd534c 100644
--- a/package/kernel/mac80211/patches/ath/080-ath10k_thermal_config.patch
+++ b/package/kernel/mac80211/patches/ath10k/080-ath10k_thermal_config.patch
@@ -37,7 +37,7 @@
  void ath10k_thermal_event_temperature(struct ath10k *ar, int temperature);
 --- a/local-symbols
 +++ b/local-symbols
-@@ -142,6 +142,7 @@ ATH10K_SNOC=
+@@ -165,6 +165,7 @@ ATH10K_SNOC=
  ATH10K_DEBUG=
  ATH10K_DEBUGFS=
  ATH10K_SPECTRAL=
diff --git a/package/kernel/mac80211/patches/ath10k/100-ath10k-support-bus-and-device-specific-API-1-BDF-sel.patch b/package/kernel/mac80211/patches/ath10k/100-ath10k-support-bus-and-device-specific-API-1-BDF-sel.patch
new file mode 100644
index 0000000000..74d5b374fb
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath10k/100-ath10k-support-bus-and-device-specific-API-1-BDF-sel.patch
@@ -0,0 +1,65 @@
+From f2a7064a78b22f2b68b9fcbc8a6f4c5e61c5ba64 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Sun, 10 Oct 2021 00:17:11 +0200
+Subject: [PATCH] ath10k: support bus and device specific API 1 BDF selection
+
+Some ath10k IPQ40xx devices like the MikroTik hAP ac2 and ac3 require the
+BDF-s to be extracted from the device storage instead of shipping packaged
+API 2 BDF-s.
+
+This is required as MikroTik has started shipping boards that require BDF-s
+to be updated, as otherwise their WLAN performance really suffers.
+This is however impossible as the devices that require this are release
+under the same revision and its not possible to differentiate them from
+devices using the older BDF-s.
+
+In OpenWrt we are extracting the calibration data during runtime and we are
+able to extract the BDF-s in the same manner, however we cannot package the
+BDF-s to API 2 format on the fly and can only use API 1 to provide BDF-s on
+the fly.
+This is an issue as the ath10k driver explicitly looks only for the
+board.bin file and not for something like board-bus-device.bin like it does
+for pre-cal data.
+Due to this we have no way of providing correct BDF-s on the fly, so lets
+extend the ath10k driver to first look for BDF-s in the
+board-bus-device.bin format, for example: board-ahb-a800000.wifi.bin
+If that fails, look for the default board file name as defined previously.
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
+Link: https://lore.kernel.org/r/20211009221711.2315352-1-robimarko@gmail.com
+---
+ drivers/net/wireless/ath/ath10k/core.c | 13 ++++++++++++-
+ 1 file changed, 12 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/ath/ath10k/core.c
++++ b/drivers/net/wireless/ath/ath10k/core.c
+@@ -1199,6 +1199,7 @@ success:
+ static int ath10k_core_fetch_board_data_api_1(struct ath10k *ar, int bd_ie_type)
+ {
+ 	const struct firmware *fw;
++	char boardname[100];
+ 
+ 	if (bd_ie_type == ATH10K_BD_IE_BOARD) {
+ 		if (!ar->hw_params.fw.board) {
+@@ -1206,9 +1207,19 @@ static int ath10k_core_fetch_board_data_
+ 			return -EINVAL;
+ 		}
+ 
++		scnprintf(boardname, sizeof(boardname), "board-%s-%s.bin",
++			  ath10k_bus_str(ar->hif.bus), dev_name(ar->dev));
++
+ 		ar->normal_mode_fw.board = ath10k_fetch_fw_file(ar,
+ 								ar->hw_params.fw.dir,
+-								ar->hw_params.fw.board);
++								boardname);
++		if (IS_ERR(ar->normal_mode_fw.board)) {
++			fw = ath10k_fetch_fw_file(ar,
++						  ar->hw_params.fw.dir,
++						  ar->hw_params.fw.board);
++			ar->normal_mode_fw.board = fw;
++		}
++
+ 		if (IS_ERR(ar->normal_mode_fw.board))
+ 			return PTR_ERR(ar->normal_mode_fw.board);
+ 
diff --git a/package/kernel/mac80211/patches/ath10k/120-ath10k-fetch-calibration-data-via-nvmem-subsystem.patch b/package/kernel/mac80211/patches/ath10k/120-ath10k-fetch-calibration-data-via-nvmem-subsystem.patch
new file mode 100644
index 0000000000..ab42c6e1e0
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath10k/120-ath10k-fetch-calibration-data-via-nvmem-subsystem.patch
@@ -0,0 +1,162 @@
+From e2333703373e8b81294da5d1c73c30154f75b082 Mon Sep 17 00:00:00 2001
+From: Christian Lamparter <chunkeey@gmail.com>
+Date: Fri, 15 Oct 2021 18:56:33 +0200
+Subject: [PATCH] ath10k: fetch (pre-)calibration data via nvmem subsystem
+
+On most embedded ath10k devices (like range extenders,
+routers, accesspoints, ...) the calibration data is
+stored in a easily accessible MTD partitions named
+"ART", "caldata", "calibration", etc...
+
+Since commit 4b361cfa8624 ("mtd: core: add OTP nvmem provider support"):
+MTD partitions and portions of them can be specified
+as potential nvmem-cells which are accessible through
+the nvmem subsystem.
+
+This feature - together with an nvmem cell definition either
+in the platform data or via device-tree allows drivers to get
+the (pre-)calibration data which is required for initializing
+the WIFI.
+
+Tested with Netgear EX6150v2 (IPQ4018)
+
+Cc: Robert Marko <robimarko@gmail.com>
+Cc: Thibaut Varene <hacks@slashdirt.org>
+Signed-off-by: Christian Lamparter <chunkeey@gmail.com>
+---
+--- a/drivers/net/wireless/ath/ath10k/core.c
++++ b/drivers/net/wireless/ath/ath10k/core.c
+@@ -12,6 +12,7 @@
+ #include <linux/dmi.h>
+ #include <linux/ctype.h>
+ #include <linux/pm_qos.h>
++#include <linux/nvmem-consumer.h>
+ #include <asm/byteorder.h>
+ 
+ #include "core.h"
+@@ -952,7 +953,8 @@ static int ath10k_core_get_board_id_from
+ 	}
+ 
+ 	if (ar->cal_mode == ATH10K_PRE_CAL_MODE_DT ||
+-	    ar->cal_mode == ATH10K_PRE_CAL_MODE_FILE)
++	    ar->cal_mode == ATH10K_PRE_CAL_MODE_FILE ||
++	    ar->cal_mode == ATH10K_PRE_CAL_MODE_NVMEM)
+ 		bmi_board_id_param = BMI_PARAM_GET_FLASH_BOARD_ID;
+ 	else
+ 		bmi_board_id_param = BMI_PARAM_GET_EEPROM_BOARD_ID;
+@@ -1754,7 +1756,8 @@ static int ath10k_download_and_run_otp(s
+ 
+ 	/* As of now pre-cal is valid for 10_4 variants */
+ 	if (ar->cal_mode == ATH10K_PRE_CAL_MODE_DT ||
+-	    ar->cal_mode == ATH10K_PRE_CAL_MODE_FILE)
++	    ar->cal_mode == ATH10K_PRE_CAL_MODE_FILE ||
++	    ar->cal_mode == ATH10K_PRE_CAL_MODE_NVMEM)
+ 		bmi_otp_exe_param = BMI_PARAM_FLASH_SECTION_ALL;
+ 
+ 	ret = ath10k_bmi_execute(ar, address, bmi_otp_exe_param, &result);
+@@ -1881,6 +1884,39 @@ out_free:
+ 	return ret;
+ }
+ 
++static int ath10k_download_cal_nvmem(struct ath10k *ar, const char *cell_name)
++{
++	struct nvmem_cell *cell;
++	void *buf;
++	size_t len;
++	int ret;
++
++	cell = devm_nvmem_cell_get(ar->dev, cell_name);
++	if (IS_ERR(cell)) {
++		ret = PTR_ERR(cell);
++		return ret;
++	}
++
++	buf = nvmem_cell_read(cell, &len);
++	if (IS_ERR(buf))
++		return PTR_ERR(buf);
++
++	if (ar->hw_params.cal_data_len != len) {
++		kfree(buf);
++		ath10k_warn(ar, "invalid calibration data length in nvmem-cell '%s': %zu != %u\n",
++			    cell_name, len, ar->hw_params.cal_data_len);
++		return -EMSGSIZE;
++	}
++
++	ret = ath10k_download_board_data(ar, buf, len);
++	kfree(buf);
++	if (ret)
++		ath10k_warn(ar, "failed to download calibration data from nvmem-cell '%s': %d\n",
++			    cell_name, ret);
++
++	return ret;
++}
++
+ int ath10k_core_fetch_firmware_api_n(struct ath10k *ar, const char *name,
+ 				     struct ath10k_fw_file *fw_file)
+ {
+@@ -2115,6 +2151,18 @@ static int ath10k_core_pre_cal_download(
+ {
+ 	int ret;
+ 
++	ret = ath10k_download_cal_nvmem(ar, "pre-calibration");
++	if (ret == 0) {
++		ar->cal_mode = ATH10K_PRE_CAL_MODE_NVMEM;
++		goto success;
++	} else if (ret == -EPROBE_DEFER) {
++		return ret;
++	}
++
++	ath10k_dbg(ar, ATH10K_DBG_BOOT,
++		   "boot did not find a pre-calibration nvmem-cell, try file next: %d\n",
++		   ret);
++
+ 	ret = ath10k_download_cal_file(ar, ar->pre_cal_file);
+ 	if (ret == 0) {
+ 		ar->cal_mode = ATH10K_PRE_CAL_MODE_FILE;
+@@ -2181,6 +2229,18 @@ static int ath10k_download_cal_data(stru
+ 		   "pre cal download procedure failed, try cal file: %d\n",
+ 		   ret);
+ 
++	ret = ath10k_download_cal_nvmem(ar, "calibration");
++	if (ret == 0) {
++		ar->cal_mode = ATH10K_CAL_MODE_NVMEM;
++		goto done;
++	} else if (ret == -EPROBE_DEFER) {
++		return ret;
++	}
++
++	ath10k_dbg(ar, ATH10K_DBG_BOOT,
++		   "boot did not find a calibration nvmem-cell, try file next: %d\n",
++		   ret);
++
+ 	ret = ath10k_download_cal_file(ar, ar->cal_file);
+ 	if (ret == 0) {
+ 		ar->cal_mode = ATH10K_CAL_MODE_FILE;
+--- a/drivers/net/wireless/ath/ath10k/core.h
++++ b/drivers/net/wireless/ath/ath10k/core.h
+@@ -877,8 +877,10 @@ enum ath10k_cal_mode {
+ 	ATH10K_CAL_MODE_FILE,
+ 	ATH10K_CAL_MODE_OTP,
+ 	ATH10K_CAL_MODE_DT,
++	ATH10K_CAL_MODE_NVMEM,
+ 	ATH10K_PRE_CAL_MODE_FILE,
+ 	ATH10K_PRE_CAL_MODE_DT,
++	ATH10K_PRE_CAL_MODE_NVMEM,
+ 	ATH10K_CAL_MODE_EEPROM,
+ };
+ 
+@@ -898,10 +900,14 @@ static inline const char *ath10k_cal_mod
+ 		return "otp";
+ 	case ATH10K_CAL_MODE_DT:
+ 		return "dt";
++	case ATH10K_CAL_MODE_NVMEM:
++		return "nvmem";
+ 	case ATH10K_PRE_CAL_MODE_FILE:
+ 		return "pre-cal-file";
+ 	case ATH10K_PRE_CAL_MODE_DT:
+ 		return "pre-cal-dt";
++	case ATH10K_PRE_CAL_MODE_NVMEM:
++		return "pre-cal-nvmem";
+ 	case ATH10K_CAL_MODE_EEPROM:
+ 		return "eeprom";
+ 	}
diff --git a/package/kernel/mac80211/patches/ath/921-ath10k_init_devices_synchronously.patch b/package/kernel/mac80211/patches/ath10k/921-ath10k_init_devices_synchronously.patch
similarity index 94%
rename from package/kernel/mac80211/patches/ath/921-ath10k_init_devices_synchronously.patch
rename to package/kernel/mac80211/patches/ath10k/921-ath10k_init_devices_synchronously.patch
index 2b8fe7816f..5362c2436d 100644
--- a/package/kernel/mac80211/patches/ath/921-ath10k_init_devices_synchronously.patch
+++ b/package/kernel/mac80211/patches/ath10k/921-ath10k_init_devices_synchronously.patch
@@ -14,7 +14,7 @@ Signed-off-by: Sven Eckelmann <sven@open-mesh.com>
 
 --- a/drivers/net/wireless/ath/ath10k/core.c
 +++ b/drivers/net/wireless/ath/ath10k/core.c
-@@ -3206,6 +3206,16 @@ int ath10k_core_register(struct ath10k *
+@@ -3440,6 +3440,16 @@ int ath10k_core_register(struct ath10k *
  
  	queue_work(ar->workqueue, &ar->register_work);
  
diff --git a/package/kernel/mac80211/patches/ath/930-ath10k_add_tpt_led_trigger.patch b/package/kernel/mac80211/patches/ath10k/930-ath10k_add_tpt_led_trigger.patch
similarity index 89%
rename from package/kernel/mac80211/patches/ath/930-ath10k_add_tpt_led_trigger.patch
rename to package/kernel/mac80211/patches/ath10k/930-ath10k_add_tpt_led_trigger.patch
index 8da72a4fe1..200b310305 100644
--- a/package/kernel/mac80211/patches/ath/930-ath10k_add_tpt_led_trigger.patch
+++ b/package/kernel/mac80211/patches/ath10k/930-ath10k_add_tpt_led_trigger.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -9748,6 +9748,21 @@ static int ath10k_mac_init_rd(struct ath
+@@ -9859,6 +9859,21 @@ static int ath10k_mac_init_rd(struct ath
  	return 0;
  }
  
@@ -22,7 +22,7 @@
  int ath10k_mac_register(struct ath10k *ar)
  {
  	static const u32 cipher_suites[] = {
-@@ -10097,6 +10112,12 @@ int ath10k_mac_register(struct ath10k *a
+@@ -10211,6 +10226,12 @@ int ath10k_mac_register(struct ath10k *a
  
  	ar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;
  
diff --git a/package/kernel/mac80211/patches/ath/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch b/package/kernel/mac80211/patches/ath10k/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch
similarity index 96%
rename from package/kernel/mac80211/patches/ath/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch
rename to package/kernel/mac80211/patches/ath10k/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch
index d8c8a8abc0..35927e7850 100644
--- a/package/kernel/mac80211/patches/ath/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch
+++ b/package/kernel/mac80211/patches/ath10k/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch
@@ -85,7 +85,7 @@ v13:
  create mode 100644 drivers/net/wireless/ath/ath10k/leds.h
 --- a/drivers/net/wireless/ath/ath10k/Kconfig
 +++ b/drivers/net/wireless/ath/ath10k/Kconfig
-@@ -70,6 +70,16 @@ config ATH10K_DEBUGFS
+@@ -71,6 +71,16 @@ config ATH10K_DEBUGFS
  
  	  If unsure, say Y to make it easier to debug problems.
  
@@ -114,7 +114,7 @@ v13:
  ath10k_core-$(CONFIG_DEV_COREDUMP) += coredump.o
 --- a/local-symbols
 +++ b/local-symbols
-@@ -145,6 +145,7 @@ ATH10K_DEBUG=
+@@ -166,6 +166,7 @@ ATH10K_DEBUG=
  ATH10K_DEBUGFS=
  ATH10K_SPECTRAL=
  ATH10K_THERMAL=
@@ -124,7 +124,7 @@ v13:
  WCN36XX=
 --- a/drivers/net/wireless/ath/ath10k/core.c
 +++ b/drivers/net/wireless/ath/ath10k/core.c
-@@ -25,6 +25,7 @@
+@@ -26,6 +26,7 @@
  #include "testmode.h"
  #include "wmi-ops.h"
  #include "coredump.h"
@@ -132,7 +132,7 @@ v13:
  
  unsigned int ath10k_debug_mask;
  EXPORT_SYMBOL(ath10k_debug_mask);
-@@ -61,6 +62,7 @@ static const struct ath10k_hw_params ath
+@@ -62,6 +63,7 @@ static const struct ath10k_hw_params ath
  		.dev_id = QCA988X_2_0_DEVICE_ID,
  		.bus = ATH10K_BUS_PCI,
  		.name = "qca988x hw2.0",
@@ -140,7 +140,7 @@ v13:
  		.patch_load_addr = QCA988X_HW_2_0_PATCH_LOAD_ADDR,
  		.uart_pin = 7,
  		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
-@@ -132,6 +134,7 @@ static const struct ath10k_hw_params ath
+@@ -135,6 +137,7 @@ static const struct ath10k_hw_params ath
  		.dev_id = QCA9887_1_0_DEVICE_ID,
  		.bus = ATH10K_BUS_PCI,
  		.name = "qca9887 hw1.0",
@@ -148,7 +148,7 @@ v13:
  		.patch_load_addr = QCA9887_HW_1_0_PATCH_LOAD_ADDR,
  		.uart_pin = 7,
  		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
-@@ -343,6 +346,7 @@ static const struct ath10k_hw_params ath
+@@ -352,6 +355,7 @@ static const struct ath10k_hw_params ath
  		.dev_id = QCA99X0_2_0_DEVICE_ID,
  		.bus = ATH10K_BUS_PCI,
  		.name = "qca99x0 hw2.0",
@@ -156,7 +156,7 @@ v13:
  		.patch_load_addr = QCA99X0_HW_2_0_PATCH_LOAD_ADDR,
  		.uart_pin = 7,
  		.otp_exe_param = 0x00000700,
-@@ -384,6 +388,7 @@ static const struct ath10k_hw_params ath
+@@ -394,6 +398,7 @@ static const struct ath10k_hw_params ath
  		.dev_id = QCA9984_1_0_DEVICE_ID,
  		.bus = ATH10K_BUS_PCI,
  		.name = "qca9984/qca9994 hw1.0",
@@ -164,7 +164,7 @@ v13:
  		.patch_load_addr = QCA9984_HW_1_0_PATCH_LOAD_ADDR,
  		.uart_pin = 7,
  		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
-@@ -432,6 +437,7 @@ static const struct ath10k_hw_params ath
+@@ -443,6 +448,7 @@ static const struct ath10k_hw_params ath
  		.dev_id = QCA9888_2_0_DEVICE_ID,
  		.bus = ATH10K_BUS_PCI,
  		.name = "qca9888 hw2.0",
@@ -172,7 +172,7 @@ v13:
  		.patch_load_addr = QCA9888_HW_2_0_PATCH_LOAD_ADDR,
  		.uart_pin = 7,
  		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
-@@ -2921,6 +2927,10 @@ int ath10k_core_start(struct ath10k *ar,
+@@ -3155,6 +3161,10 @@ int ath10k_core_start(struct ath10k *ar,
  		goto err_hif_stop;
  	}
  
@@ -183,7 +183,7 @@ v13:
  	return 0;
  
  err_hif_stop:
-@@ -3179,9 +3189,18 @@ static void ath10k_core_register_work(st
+@@ -3413,9 +3423,18 @@ static void ath10k_core_register_work(st
  		goto err_spectral_destroy;
  	}
  
@@ -202,7 +202,7 @@ v13:
  err_spectral_destroy:
  	ath10k_spectral_destroy(ar);
  err_debug_destroy:
-@@ -3227,6 +3246,8 @@ void ath10k_core_unregister(struct ath10
+@@ -3461,6 +3480,8 @@ void ath10k_core_unregister(struct ath10
  	if (!test_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags))
  		return;
  
@@ -221,7 +221,7 @@ v13:
  
  #include "htt.h"
  #include "htc.h"
-@@ -1237,6 +1238,13 @@ struct ath10k {
+@@ -1256,6 +1257,13 @@ struct ath10k {
  	} testmode;
  
  	struct {
diff --git a/package/kernel/mac80211/patches/ath/975-ath10k-use-tpt-trigger-by-default.patch b/package/kernel/mac80211/patches/ath10k/975-ath10k-use-tpt-trigger-by-default.patch
similarity index 92%
rename from package/kernel/mac80211/patches/ath/975-ath10k-use-tpt-trigger-by-default.patch
rename to package/kernel/mac80211/patches/ath10k/975-ath10k-use-tpt-trigger-by-default.patch
index 005feda798..d4b46d943e 100644
--- a/package/kernel/mac80211/patches/ath/975-ath10k-use-tpt-trigger-by-default.patch
+++ b/package/kernel/mac80211/patches/ath10k/975-ath10k-use-tpt-trigger-by-default.patch
@@ -16,9 +16,9 @@ Signed-off-by: Mathias Kresin <dev@kresin.me>
 
 --- a/drivers/net/wireless/ath/ath10k/core.h
 +++ b/drivers/net/wireless/ath/ath10k/core.h
-@@ -1290,6 +1290,10 @@ struct ath10k {
- 	bool coex_support;
- 	int coex_gpio_pin;
+@@ -1312,6 +1312,10 @@ struct ath10k {
+ 	s32 tx_power_2g_limit;
+ 	s32 tx_power_5g_limit;
  
 +#ifdef CPTCFG_MAC80211_LEDS
 +	const char *led_default_trigger;
@@ -42,7 +42,7 @@ Signed-off-by: Mathias Kresin <dev@kresin.me>
  	if (ret)
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -10114,7 +10114,7 @@ int ath10k_mac_register(struct ath10k *a
+@@ -10228,7 +10228,7 @@ int ath10k_mac_register(struct ath10k *a
  	ar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;
  
  #ifdef CPTCFG_MAC80211_LEDS
diff --git a/package/kernel/mac80211/patches/ath/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch b/package/kernel/mac80211/patches/ath10k/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch
similarity index 93%
rename from package/kernel/mac80211/patches/ath/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch
rename to package/kernel/mac80211/patches/ath10k/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch
index 1f19765891..a45addf119 100644
--- a/package/kernel/mac80211/patches/ath/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch
+++ b/package/kernel/mac80211/patches/ath10k/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch
@@ -28,7 +28,7 @@ Forwarded: no
 
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -1010,6 +1010,40 @@ static inline int ath10k_vdev_setup_sync
+@@ -1021,6 +1021,40 @@ static inline int ath10k_vdev_setup_sync
  	return ar->last_wmi_vdev_start_status;
  }
  
@@ -69,7 +69,7 @@ Forwarded: no
  static int ath10k_monitor_vdev_start(struct ath10k *ar, int vdev_id)
  {
  	struct cfg80211_chan_def *chandef = NULL;
-@@ -1042,7 +1076,8 @@ static int ath10k_monitor_vdev_start(str
+@@ -1053,7 +1087,8 @@ static int ath10k_monitor_vdev_start(str
  	arg.channel.min_power = 0;
  	arg.channel.max_power = channel->max_power * 2;
  	arg.channel.max_reg_power = channel->max_reg_power * 2;
@@ -79,7 +79,7 @@ Forwarded: no
  
  	reinit_completion(&ar->vdev_setup_done);
  	reinit_completion(&ar->vdev_delete_done);
-@@ -1488,7 +1523,8 @@ static int ath10k_vdev_start_restart(str
+@@ -1499,7 +1534,8 @@ static int ath10k_vdev_start_restart(str
  	arg.channel.min_power = 0;
  	arg.channel.max_power = chandef->chan->max_power * 2;
  	arg.channel.max_reg_power = chandef->chan->max_reg_power * 2;
@@ -89,7 +89,7 @@ Forwarded: no
  
  	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
  		arg.ssid = arvif->u.ap.ssid;
-@@ -3259,7 +3295,8 @@ static int ath10k_update_channel_list(st
+@@ -3427,7 +3463,8 @@ static int ath10k_update_channel_list(st
  			ch->min_power = 0;
  			ch->max_power = channel->max_power * 2;
  			ch->max_reg_power = channel->max_reg_power * 2;
diff --git a/package/kernel/mac80211/patches/ath10k/984-ath10k-Try-to-get-mac-address-from-dts.patch b/package/kernel/mac80211/patches/ath10k/984-ath10k-Try-to-get-mac-address-from-dts.patch
new file mode 100644
index 0000000000..d94a8a8596
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath10k/984-ath10k-Try-to-get-mac-address-from-dts.patch
@@ -0,0 +1,37 @@
+From 22fb5991a44c78ff18ec0082dc90c809356eb893 Mon Sep 17 00:00:00 2001
+From: Ansuel Smith <ansuelsmth@gmail.com>
+Date: Sun, 27 Sep 2020 19:23:35 +0200
+Subject: [PATCH 1/2] ath10k: Try to get mac-address from dts
+
+Most of embedded device that have the ath10k wifi integrated store the
+mac-address in nvmem partitions. Try to fetch the mac-address using the
+standard 'of_get_mac_address' than in all the check also try to fetch the
+address using the nvmem api searching for a defined 'mac-address' cell.
+Mac-address defined in the dts have priority than any other address found.
+
+Tested-on: QCA9984 hw1.0 PCI 10.4
+
+Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
+---
+ drivers/net/wireless/ath/ath10k/core.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/net/wireless/ath/ath10k/core.c
++++ b/drivers/net/wireless/ath/ath10k/core.c
+@@ -8,6 +8,7 @@
+ #include <linux/module.h>
+ #include <linux/firmware.h>
+ #include <linux/of.h>
++#include <linux/of_net.h>
+ #include <linux/property.h>
+ #include <linux/dmi.h>
+ #include <linux/ctype.h>
+@@ -3331,6 +3332,8 @@ static int ath10k_core_probe_fw(struct a
+ 
+ 	device_get_mac_address(ar->dev, ar->mac_addr, sizeof(ar->mac_addr));
+ 
++	of_get_mac_address(ar->dev->of_node, ar->mac_addr);
++
+ 	ret = ath10k_core_init_firmware_features(ar);
+ 	if (ret) {
+ 		ath10k_err(ar, "fatal problem with firmware features: %d\n",
diff --git a/package/kernel/mac80211/patches/ath/990-ath10k-small-buffers.patch b/package/kernel/mac80211/patches/ath10k/990-ath10k-small-buffers.patch
similarity index 97%
rename from package/kernel/mac80211/patches/ath/990-ath10k-small-buffers.patch
rename to package/kernel/mac80211/patches/ath10k/990-ath10k-small-buffers.patch
index d065a8b8ca..2f560c70a0 100644
--- a/package/kernel/mac80211/patches/ath/990-ath10k-small-buffers.patch
+++ b/package/kernel/mac80211/patches/ath10k/990-ath10k-small-buffers.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath10k/htt.h
 +++ b/drivers/net/wireless/ath/ath10k/htt.h
-@@ -236,7 +236,11 @@ enum htt_rx_ring_flags {
+@@ -235,7 +235,11 @@ enum htt_rx_ring_flags {
  };
  
  #define HTT_RX_RING_SIZE_MIN 128
diff --git a/package/kernel/mac80211/patches/ath/201-ath5k-WAR-for-AR71xx-PCI-bug.patch b/package/kernel/mac80211/patches/ath5k/201-ath5k-WAR-for-AR71xx-PCI-bug.patch
similarity index 100%
rename from package/kernel/mac80211/patches/ath/201-ath5k-WAR-for-AR71xx-PCI-bug.patch
rename to package/kernel/mac80211/patches/ath5k/201-ath5k-WAR-for-AR71xx-PCI-bug.patch
diff --git a/package/kernel/mac80211/patches/ath/411-ath5k_allow_adhoc_and_ap.patch b/package/kernel/mac80211/patches/ath5k/411-ath5k_allow_adhoc_and_ap.patch
similarity index 89%
rename from package/kernel/mac80211/patches/ath/411-ath5k_allow_adhoc_and_ap.patch
rename to package/kernel/mac80211/patches/ath5k/411-ath5k_allow_adhoc_and_ap.patch
index 9dbe047c9a..35ed6ea555 100644
--- a/package/kernel/mac80211/patches/ath/411-ath5k_allow_adhoc_and_ap.patch
+++ b/package/kernel/mac80211/patches/ath5k/411-ath5k_allow_adhoc_and_ap.patch
@@ -18,7 +18,7 @@
  		goto end;
 --- a/drivers/net/wireless/ath/ath5k/base.c
 +++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -1964,7 +1964,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
+@@ -1963,7 +1963,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
  	}
  
  	if ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs +
@@ -27,7 +27,7 @@
  			ah->opmode == NL80211_IFTYPE_MESH_POINT) {
  		u64 tsf = ath5k_hw_get_tsf64(ah);
  		u32 tsftu = TSF_TO_TU(tsf);
-@@ -2050,7 +2050,7 @@ ath5k_beacon_update_timers(struct ath5k_
+@@ -2049,7 +2049,7 @@ ath5k_beacon_update_timers(struct ath5k_
  
  	intval = ah->bintval & AR5K_BEACON_PERIOD;
  	if (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs
@@ -36,7 +36,7 @@
  		intval /= ATH_BCBUF;	/* staggered multi-bss beacons */
  		if (intval < 15)
  			ATH5K_WARN(ah, "intval %u is too low, min 15\n",
-@@ -2516,6 +2516,7 @@ static const struct ieee80211_iface_limi
+@@ -2515,6 +2515,7 @@ static const struct ieee80211_iface_limi
  				 BIT(NL80211_IFTYPE_MESH_POINT) |
  #endif
  				 BIT(NL80211_IFTYPE_AP) },
diff --git a/package/kernel/mac80211/patches/ath/420-ath5k_disable_fast_cc.patch b/package/kernel/mac80211/patches/ath5k/420-ath5k_disable_fast_cc.patch
similarity index 100%
rename from package/kernel/mac80211/patches/ath/420-ath5k_disable_fast_cc.patch
rename to package/kernel/mac80211/patches/ath5k/420-ath5k_disable_fast_cc.patch
diff --git a/package/kernel/mac80211/patches/ath/430-add_ath5k_platform.patch b/package/kernel/mac80211/patches/ath5k/430-add_ath5k_platform.patch
similarity index 100%
rename from package/kernel/mac80211/patches/ath/430-add_ath5k_platform.patch
rename to package/kernel/mac80211/patches/ath5k/430-add_ath5k_platform.patch
diff --git a/package/kernel/mac80211/patches/ath/432-ath5k_add_pciids.patch b/package/kernel/mac80211/patches/ath5k/432-ath5k_add_pciids.patch
similarity index 100%
rename from package/kernel/mac80211/patches/ath/432-ath5k_add_pciids.patch
rename to package/kernel/mac80211/patches/ath5k/432-ath5k_add_pciids.patch
diff --git a/package/kernel/mac80211/patches/ath/440-ath5k_channel_bw_debugfs.patch b/package/kernel/mac80211/patches/ath5k/440-ath5k_channel_bw_debugfs.patch
similarity index 98%
rename from package/kernel/mac80211/patches/ath/440-ath5k_channel_bw_debugfs.patch
rename to package/kernel/mac80211/patches/ath5k/440-ath5k_channel_bw_debugfs.patch
index 92fb90c165..a63f0c881b 100644
--- a/package/kernel/mac80211/patches/ath/440-ath5k_channel_bw_debugfs.patch
+++ b/package/kernel/mac80211/patches/ath5k/440-ath5k_channel_bw_debugfs.patch
@@ -130,7 +130,7 @@ drivers/net/wireless/ath/ath5k/debug.c |   86 ++++++++++++++++++++++++++++++++
  	/* Antenna Control */
 --- a/drivers/net/wireless/ath/ath5k/base.c
 +++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -466,6 +466,9 @@ ath5k_chan_set(struct ath5k_hw *ah, stru
+@@ -465,6 +465,9 @@ ath5k_chan_set(struct ath5k_hw *ah, stru
  		return -EINVAL;
  	}
  
diff --git a/package/kernel/mac80211/patches/ath9k/040-ath9k-support-DT-ieee80211-freq-limit-property-to-li.patch b/package/kernel/mac80211/patches/ath9k/040-ath9k-support-DT-ieee80211-freq-limit-property-to-li.patch
new file mode 100644
index 0000000000..7d44681760
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath9k/040-ath9k-support-DT-ieee80211-freq-limit-property-to-li.patch
@@ -0,0 +1,28 @@
+From 03469e79fee9e8e908dae3bd1a80bcd9a66f2a88 Mon Sep 17 00:00:00 2001
+From: Christian Lamparter <chunkeey@gmail.com>
+Date: Mon, 11 Oct 2021 18:18:00 +0300
+Subject: ath9k: support DT ieee80211-freq-limit property to limit channels
+
+The common DT property can be used to limit the available channels
+but ath9k has to manually call wiphy_read_of_freq_limits().
+
+I would have put this into ath9k_of_init(). But it didn't work there.
+The reason is that in ath9k_of_init() the channels and bands are not yet
+registered in the wiphy struct. So there isn't any channel to flag as
+disabled.
+
+Signed-off-by: Christian Lamparter <chunkeey@gmail.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+Link: https://lore.kernel.org/r/20211009212847.1781986-1-chunkeey@gmail.com
+---
+--- a/drivers/net/wireless/ath/ath9k/init.c
++++ b/drivers/net/wireless/ath/ath9k/init.c
+@@ -1038,6 +1038,8 @@ int ath9k_init_device(u16 devid, struct
+ 		ARRAY_SIZE(ath9k_tpt_blink));
+ #endif
+ 
++	wiphy_read_of_freq_limits(hw->wiphy);
++
+ 	/* Register with mac80211 */
+ 	error = ieee80211_register_hw(hw);
+ 	if (error)
diff --git a/package/kernel/mac80211/patches/ath/350-ath9k_hw-reset-AHB-WMAC-interface-on-AR91xx.patch b/package/kernel/mac80211/patches/ath9k/350-ath9k_hw-reset-AHB-WMAC-interface-on-AR91xx.patch
similarity index 89%
rename from package/kernel/mac80211/patches/ath/350-ath9k_hw-reset-AHB-WMAC-interface-on-AR91xx.patch
rename to package/kernel/mac80211/patches/ath9k/350-ath9k_hw-reset-AHB-WMAC-interface-on-AR91xx.patch
index d648a3a3e5..3a0171d4a2 100644
--- a/package/kernel/mac80211/patches/ath/350-ath9k_hw-reset-AHB-WMAC-interface-on-AR91xx.patch
+++ b/package/kernel/mac80211/patches/ath9k/350-ath9k_hw-reset-AHB-WMAC-interface-on-AR91xx.patch
@@ -9,7 +9,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1435,8 +1435,12 @@ static bool ath9k_hw_set_reset(struct at
+@@ -1434,8 +1434,12 @@ static bool ath9k_hw_set_reset(struct at
  	if (!AR_SREV_9100(ah))
  		REG_WRITE(ah, AR_RC, 0);
  
diff --git a/package/kernel/mac80211/patches/ath/351-ath9k_hw-issue-external-reset-for-QCA955x.patch b/package/kernel/mac80211/patches/ath9k/351-ath9k_hw-issue-external-reset-for-QCA955x.patch
similarity index 95%
rename from package/kernel/mac80211/patches/ath/351-ath9k_hw-issue-external-reset-for-QCA955x.patch
rename to package/kernel/mac80211/patches/ath9k/351-ath9k_hw-issue-external-reset-for-QCA955x.patch
index 5f265b84c2..53b7ba08bc 100644
--- a/package/kernel/mac80211/patches/ath/351-ath9k_hw-issue-external-reset-for-QCA955x.patch
+++ b/package/kernel/mac80211/patches/ath9k/351-ath9k_hw-issue-external-reset-for-QCA955x.patch
@@ -10,7 +10,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1312,39 +1312,56 @@ void ath9k_hw_get_delta_slope_vals(struc
+@@ -1311,39 +1311,56 @@ void ath9k_hw_get_delta_slope_vals(struc
  	*coef_exponent = coef_exp - 16;
  }
  
@@ -94,7 +94,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	return true;
  }
  
-@@ -1397,24 +1414,24 @@ static bool ath9k_hw_set_reset(struct at
+@@ -1396,24 +1413,24 @@ static bool ath9k_hw_set_reset(struct at
  			rst_flags |= AR_RTC_RC_MAC_COLD;
  	}
  
diff --git a/package/kernel/mac80211/patches/ath/354-ath9k-force-rx_clear-when-disabling-rx.patch b/package/kernel/mac80211/patches/ath9k/354-ath9k-force-rx_clear-when-disabling-rx.patch
similarity index 100%
rename from package/kernel/mac80211/patches/ath/354-ath9k-force-rx_clear-when-disabling-rx.patch
rename to package/kernel/mac80211/patches/ath9k/354-ath9k-force-rx_clear-when-disabling-rx.patch
diff --git a/package/kernel/mac80211/patches/ath/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch b/package/kernel/mac80211/patches/ath9k/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
similarity index 89%
rename from package/kernel/mac80211/patches/ath/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
rename to package/kernel/mac80211/patches/ath9k/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
index 406d03e2fe..385eea0116 100644
--- a/package/kernel/mac80211/patches/ath/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
+++ b/package/kernel/mac80211/patches/ath9k/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
@@ -8,7 +8,7 @@ This reverts commit 71f5137bf010c6faffab50c0ec15374c59c4a411.
 
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2979,7 +2979,8 @@ void ath9k_hw_apply_txpower(struct ath_h
+@@ -2977,7 +2977,8 @@ void ath9k_hw_apply_txpower(struct ath_h
  {
  	struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
  	struct ieee80211_channel *channel;
@@ -18,7 +18,7 @@ This reverts commit 71f5137bf010c6faffab50c0ec15374c59c4a411.
  	u16 ctl = NO_CTL;
  
  	if (!chan)
-@@ -2991,9 +2992,14 @@ void ath9k_hw_apply_txpower(struct ath_h
+@@ -2989,9 +2990,14 @@ void ath9k_hw_apply_txpower(struct ath_h
  	channel = chan->chan;
  	chan_pwr = min_t(int, channel->max_power * 2, MAX_COMBINED_POWER);
  	new_pwr = min_t(int, chan_pwr, reg->power_limit);
diff --git a/package/kernel/mac80211/patches/ath/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch b/package/kernel/mac80211/patches/ath9k/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch
similarity index 91%
rename from package/kernel/mac80211/patches/ath/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch
rename to package/kernel/mac80211/patches/ath9k/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch
index 12cbd27e1a..0c3edc1260 100644
--- a/package/kernel/mac80211/patches/ath/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch
+++ b/package/kernel/mac80211/patches/ath9k/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch
@@ -11,7 +11,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2998,6 +2998,10 @@ void ath9k_hw_apply_txpower(struct ath_h
+@@ -2996,6 +2996,10 @@ void ath9k_hw_apply_txpower(struct ath_h
  	if (ant_gain > max_gain)
  		ant_reduction = ant_gain - max_gain;
  
diff --git a/package/kernel/mac80211/patches/ath/401-ath9k_blink_default.patch b/package/kernel/mac80211/patches/ath9k/401-ath9k_blink_default.patch
similarity index 88%
rename from package/kernel/mac80211/patches/ath/401-ath9k_blink_default.patch
rename to package/kernel/mac80211/patches/ath9k/401-ath9k_blink_default.patch
index 3eb57bb1cf..7405e594fe 100644
--- a/package/kernel/mac80211/patches/ath/401-ath9k_blink_default.patch
+++ b/package/kernel/mac80211/patches/ath9k/401-ath9k_blink_default.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -48,7 +48,7 @@ int ath9k_modparam_nohwcrypt;
+@@ -47,7 +47,7 @@ int ath9k_modparam_nohwcrypt;
  module_param_named(nohwcrypt, ath9k_modparam_nohwcrypt, int, 0444);
  MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption");
  
diff --git a/package/kernel/mac80211/patches/ath/410-ath9k_allow_adhoc_and_ap.patch b/package/kernel/mac80211/patches/ath9k/410-ath9k_allow_adhoc_and_ap.patch
similarity index 73%
rename from package/kernel/mac80211/patches/ath/410-ath9k_allow_adhoc_and_ap.patch
rename to package/kernel/mac80211/patches/ath9k/410-ath9k_allow_adhoc_and_ap.patch
index 17dd8f6597..b355e8372f 100644
--- a/package/kernel/mac80211/patches/ath/410-ath9k_allow_adhoc_and_ap.patch
+++ b/package/kernel/mac80211/patches/ath9k/410-ath9k_allow_adhoc_and_ap.patch
@@ -1,10 +1,10 @@
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -830,6 +830,7 @@ static const struct ieee80211_iface_limi
+@@ -826,6 +826,7 @@ static const struct ieee80211_iface_limi
  				 BIT(NL80211_IFTYPE_AP) },
  	{ .max = 1,	.types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
  				 BIT(NL80211_IFTYPE_P2P_GO) },
 +	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
  };
  
- #ifdef CPTCFG_WIRELESS_WDS
+ #ifdef CPTCFG_ATH9K_CHANNEL_CONTEXT
diff --git a/package/kernel/mac80211/patches/ath/450-ath9k-enabled-MFP-capability-unconditionally.patch b/package/kernel/mac80211/patches/ath9k/450-ath9k-enabled-MFP-capability-unconditionally.patch
similarity index 90%
rename from package/kernel/mac80211/patches/ath/450-ath9k-enabled-MFP-capability-unconditionally.patch
rename to package/kernel/mac80211/patches/ath9k/450-ath9k-enabled-MFP-capability-unconditionally.patch
index ea94b52385..284c88ff49 100644
--- a/package/kernel/mac80211/patches/ath/450-ath9k-enabled-MFP-capability-unconditionally.patch
+++ b/package/kernel/mac80211/patches/ath9k/450-ath9k-enabled-MFP-capability-unconditionally.patch
@@ -14,7 +14,7 @@ Signed-off-by: David Bauer <mail@david-bauer.net>
 
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -927,6 +927,7 @@ static void ath9k_set_hw_capab(struct at
+@@ -907,6 +907,7 @@ static void ath9k_set_hw_capab(struct at
  	ieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING);
  	ieee80211_hw_set(hw, SUPPORT_FAST_XMIT);
  	ieee80211_hw_set(hw, SUPPORTS_CLONED_SKBS);
@@ -22,7 +22,7 @@ Signed-off-by: David Bauer <mail@david-bauer.net>
  
  	if (ath9k_ps_enable)
  		ieee80211_hw_set(hw, SUPPORTS_PS);
-@@ -939,9 +940,6 @@ static void ath9k_set_hw_capab(struct at
+@@ -919,9 +920,6 @@ static void ath9k_set_hw_capab(struct at
  				IEEE80211_RADIOTAP_MCS_HAVE_STBC;
  	}
  
diff --git a/package/kernel/mac80211/patches/ath/500-ath9k_eeprom_debugfs.patch b/package/kernel/mac80211/patches/ath9k/500-ath9k_eeprom_debugfs.patch
similarity index 100%
rename from package/kernel/mac80211/patches/ath/500-ath9k_eeprom_debugfs.patch
rename to package/kernel/mac80211/patches/ath9k/500-ath9k_eeprom_debugfs.patch
diff --git a/package/kernel/mac80211/patches/ath/501-ath9k_ahb_init.patch b/package/kernel/mac80211/patches/ath9k/501-ath9k_ahb_init.patch
similarity index 91%
rename from package/kernel/mac80211/patches/ath/501-ath9k_ahb_init.patch
rename to package/kernel/mac80211/patches/ath9k/501-ath9k_ahb_init.patch
index b9c784eb25..6ab7972b55 100644
--- a/package/kernel/mac80211/patches/ath/501-ath9k_ahb_init.patch
+++ b/package/kernel/mac80211/patches/ath9k/501-ath9k_ahb_init.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -1143,25 +1143,25 @@ static int __init ath9k_init(void)
+@@ -1122,25 +1122,25 @@ static int __init ath9k_init(void)
  {
  	int error;
  
diff --git a/package/kernel/mac80211/patches/ath/510-ath9k_intr_mitigation_tweak.patch b/package/kernel/mac80211/patches/ath9k/510-ath9k_intr_mitigation_tweak.patch
similarity index 87%
rename from package/kernel/mac80211/patches/ath/510-ath9k_intr_mitigation_tweak.patch
rename to package/kernel/mac80211/patches/ath9k/510-ath9k_intr_mitigation_tweak.patch
index 75b48b480e..fda050a8f2 100644
--- a/package/kernel/mac80211/patches/ath/510-ath9k_intr_mitigation_tweak.patch
+++ b/package/kernel/mac80211/patches/ath9k/510-ath9k_intr_mitigation_tweak.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -403,13 +403,8 @@ static void ath9k_hw_init_config(struct
+@@ -402,13 +402,8 @@ static void ath9k_hw_init_config(struct
  
  	ah->config.rx_intr_mitigation = true;
  
diff --git a/package/kernel/mac80211/patches/ath/511-ath9k_reduce_rxbuf.patch b/package/kernel/mac80211/patches/ath9k/511-ath9k_reduce_rxbuf.patch
similarity index 100%
rename from package/kernel/mac80211/patches/ath/511-ath9k_reduce_rxbuf.patch
rename to package/kernel/mac80211/patches/ath9k/511-ath9k_reduce_rxbuf.patch
diff --git a/package/kernel/mac80211/patches/ath/512-ath9k_channelbw_debugfs.patch b/package/kernel/mac80211/patches/ath9k/512-ath9k_channelbw_debugfs.patch
similarity index 100%
rename from package/kernel/mac80211/patches/ath/512-ath9k_channelbw_debugfs.patch
rename to package/kernel/mac80211/patches/ath9k/512-ath9k_channelbw_debugfs.patch
diff --git a/package/kernel/mac80211/patches/ath/513-ath9k_add_pci_ids.patch b/package/kernel/mac80211/patches/ath9k/513-ath9k_add_pci_ids.patch
similarity index 93%
rename from package/kernel/mac80211/patches/ath/513-ath9k_add_pci_ids.patch
rename to package/kernel/mac80211/patches/ath9k/513-ath9k_add_pci_ids.patch
index 113c35625f..a085e3a1fb 100644
--- a/package/kernel/mac80211/patches/ath/513-ath9k_add_pci_ids.patch
+++ b/package/kernel/mac80211/patches/ath9k/513-ath9k_add_pci_ids.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -663,6 +663,7 @@ int ath9k_hw_init(struct ath_hw *ah)
+@@ -662,6 +662,7 @@ int ath9k_hw_init(struct ath_hw *ah)
  
  	/* These are all the AR5008/AR9001/AR9002/AR9003 hardware family of chipsets */
  	switch (ah->hw_version.devid) {
diff --git a/package/kernel/mac80211/patches/ath/530-ath9k_extra_leds.patch b/package/kernel/mac80211/patches/ath9k/530-ath9k_extra_leds.patch
similarity index 96%
rename from package/kernel/mac80211/patches/ath/530-ath9k_extra_leds.patch
rename to package/kernel/mac80211/patches/ath9k/530-ath9k_extra_leds.patch
index 5fd5c73a2f..c161237827 100644
--- a/package/kernel/mac80211/patches/ath/530-ath9k_extra_leds.patch
+++ b/package/kernel/mac80211/patches/ath9k/530-ath9k_extra_leds.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/ath9k.h
 +++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -844,6 +844,9 @@ static inline int ath9k_dump_btcoex(stru
+@@ -843,6 +843,9 @@ static inline int ath9k_dump_btcoex(stru
  #ifdef CPTCFG_MAC80211_LEDS
  void ath_init_leds(struct ath_softc *sc);
  void ath_deinit_leds(struct ath_softc *sc);
@@ -10,7 +10,7 @@
  #else
  static inline void ath_init_leds(struct ath_softc *sc)
  {
-@@ -980,6 +983,13 @@ void ath_ant_comb_scan(struct ath_softc
+@@ -979,6 +982,13 @@ void ath_ant_comb_scan(struct ath_softc
  
  #define ATH9K_NUM_CHANCTX  2 /* supports 2 operating channels */
  
@@ -24,7 +24,7 @@
  struct ath_softc {
  	struct ieee80211_hw *hw;
  	struct device *dev;
-@@ -1033,9 +1043,8 @@ struct ath_softc {
+@@ -1032,9 +1042,8 @@ struct ath_softc {
  	spinlock_t chan_lock;
  
  #ifdef CPTCFG_MAC80211_LEDS
@@ -181,7 +181,7 @@
  
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -1055,7 +1055,7 @@ int ath9k_init_device(u16 devid, struct
+@@ -1032,7 +1032,7 @@ int ath9k_init_device(u16 devid, struct
  
  #ifdef CPTCFG_MAC80211_LEDS
  	/* must be initialized before ieee80211_register_hw */
diff --git a/package/kernel/mac80211/patches/ath/531-ath9k_extra_platform_leds.patch b/package/kernel/mac80211/patches/ath9k/531-ath9k_extra_platform_leds.patch
similarity index 100%
rename from package/kernel/mac80211/patches/ath/531-ath9k_extra_platform_leds.patch
rename to package/kernel/mac80211/patches/ath9k/531-ath9k_extra_platform_leds.patch
diff --git a/package/kernel/mac80211/patches/ath/540-ath9k_reduce_ani_interval.patch b/package/kernel/mac80211/patches/ath9k/540-ath9k_reduce_ani_interval.patch
similarity index 100%
rename from package/kernel/mac80211/patches/ath/540-ath9k_reduce_ani_interval.patch
rename to package/kernel/mac80211/patches/ath9k/540-ath9k_reduce_ani_interval.patch
diff --git a/package/kernel/mac80211/patches/ath/542-ath9k_debugfs_diag.patch b/package/kernel/mac80211/patches/ath9k/542-ath9k_debugfs_diag.patch
similarity index 96%
rename from package/kernel/mac80211/patches/ath/542-ath9k_debugfs_diag.patch
rename to package/kernel/mac80211/patches/ath9k/542-ath9k_debugfs_diag.patch
index 76f9846fa4..5b64f560fd 100644
--- a/package/kernel/mac80211/patches/ath/542-ath9k_debugfs_diag.patch
+++ b/package/kernel/mac80211/patches/ath9k/542-ath9k_debugfs_diag.patch
@@ -94,7 +94,7 @@
  struct ath_gen_timer *ath_gen_timer_alloc(struct ath_hw *ah,
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1882,6 +1882,20 @@ u32 ath9k_hw_get_tsf_offset(struct times
+@@ -1881,6 +1881,20 @@ u32 ath9k_hw_get_tsf_offset(struct times
  }
  EXPORT_SYMBOL(ath9k_hw_get_tsf_offset);
  
@@ -115,7 +115,7 @@
  int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
  		   struct ath9k_hw_cal_data *caldata, bool fastcc)
  {
-@@ -2090,6 +2104,7 @@ int ath9k_hw_reset(struct ath_hw *ah, st
+@@ -2089,6 +2103,7 @@ int ath9k_hw_reset(struct ath_hw *ah, st
  		ar9003_hw_disable_phy_restart(ah);
  
  	ath9k_hw_apply_gpio_override(ah);
diff --git a/package/kernel/mac80211/patches/ath/543-ath9k_entropy_from_adc.patch b/package/kernel/mac80211/patches/ath9k/543-ath9k_entropy_from_adc.patch
similarity index 94%
rename from package/kernel/mac80211/patches/ath/543-ath9k_entropy_from_adc.patch
rename to package/kernel/mac80211/patches/ath9k/543-ath9k_entropy_from_adc.patch
index 0d938a3730..ef4e659870 100644
--- a/package/kernel/mac80211/patches/ath/543-ath9k_entropy_from_adc.patch
+++ b/package/kernel/mac80211/patches/ath9k/543-ath9k_entropy_from_adc.patch
@@ -55,7 +55,7 @@
  	ops->spectral_scan_config = ar9003_hw_spectral_scan_config;
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -818,7 +818,8 @@ static void ath9k_init_txpower_limits(st
+@@ -814,7 +814,8 @@ static void ath9k_init_txpower_limits(st
  	if (ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)
  		ath9k_init_band_txpower(sc, NL80211_BAND_5GHZ);
  
@@ -65,7 +65,7 @@
  }
  
  static const struct ieee80211_iface_limit if_limits[] = {
-@@ -1015,6 +1016,18 @@ static void ath9k_set_hw_capab(struct at
+@@ -992,6 +993,18 @@ static void ath9k_set_hw_capab(struct at
  	wiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);
  }
  
@@ -84,9 +84,9 @@
  int ath9k_init_device(u16 devid, struct ath_softc *sc,
  		    const struct ath_bus_ops *bus_ops)
  {
-@@ -1060,6 +1073,8 @@ int ath9k_init_device(u16 devid, struct
- 		ARRAY_SIZE(ath9k_tpt_blink));
- #endif
+@@ -1039,6 +1052,8 @@ int ath9k_init_device(u16 devid, struct
+ 
+ 	wiphy_read_of_freq_limits(hw->wiphy);
  
 +	ath_get_initial_entropy(sc);
 +
@@ -110,7 +110,7 @@
  static inline void ath9k_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
 --- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
 +++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-@@ -1349,9 +1349,30 @@ void ar5008_hw_init_rate_txpower(struct
+@@ -1340,9 +1340,30 @@ void ar5008_hw_init_rate_txpower(struct
  	}
  }
  
@@ -141,7 +141,7 @@
  	static const u32 ar5416_cca_regs[6] = {
  		AR_PHY_CCA,
  		AR_PHY_CH1_CCA,
-@@ -1366,6 +1387,8 @@ int ar5008_hw_attach_phy_ops(struct ath_
+@@ -1357,6 +1378,8 @@ int ar5008_hw_attach_phy_ops(struct ath_
  	if (ret)
  	    return ret;
  
diff --git a/package/kernel/mac80211/patches/ath/544-ath9k-ar933x-usb-hang-workaround.patch b/package/kernel/mac80211/patches/ath9k/544-ath9k-ar933x-usb-hang-workaround.patch
similarity index 84%
rename from package/kernel/mac80211/patches/ath/544-ath9k-ar933x-usb-hang-workaround.patch
rename to package/kernel/mac80211/patches/ath9k/544-ath9k-ar933x-usb-hang-workaround.patch
index 2d2b837072..23a81864fa 100644
--- a/package/kernel/mac80211/patches/ath/544-ath9k-ar933x-usb-hang-workaround.patch
+++ b/package/kernel/mac80211/patches/ath9k/544-ath9k-ar933x-usb-hang-workaround.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -248,6 +248,19 @@ void ath9k_hw_get_channel_centers(struct
+@@ -247,6 +247,19 @@ void ath9k_hw_get_channel_centers(struct
  		centers->synth_center + (extoff * HT40_CHANNEL_CENTER_SHIFT);
  }
  
@@ -20,7 +20,7 @@
  /******************/
  /* Chip Revisions */
  /******************/
-@@ -1455,6 +1468,9 @@ static bool ath9k_hw_set_reset(struct at
+@@ -1454,6 +1467,9 @@ static bool ath9k_hw_set_reset(struct at
  		udelay(50);
  	}
  
@@ -30,7 +30,7 @@
  	return true;
  }
  
-@@ -1554,6 +1570,9 @@ static bool ath9k_hw_chip_reset(struct a
+@@ -1553,6 +1569,9 @@ static bool ath9k_hw_chip_reset(struct a
  		ar9003_hw_internal_regulator_apply(ah);
  	ath9k_hw_init_pll(ah, chan);
  
@@ -40,7 +40,7 @@
  	return true;
  }
  
-@@ -1860,8 +1879,14 @@ static int ath9k_hw_do_fastcc(struct ath
+@@ -1859,8 +1878,14 @@ static int ath9k_hw_do_fastcc(struct ath
  	if (AR_SREV_9271(ah))
  		ar9002_hw_load_ani_reg(ah, chan);
  
@@ -55,7 +55,7 @@
  	return -EINVAL;
  }
  
-@@ -2115,6 +2140,9 @@ int ath9k_hw_reset(struct ath_hw *ah, st
+@@ -2114,6 +2139,9 @@ int ath9k_hw_reset(struct ath_hw *ah, st
  		ath9k_hw_set_radar_params(ah);
  	}
  
diff --git a/package/kernel/mac80211/patches/ath/545-ath9k_ani_ws_detect.patch b/package/kernel/mac80211/patches/ath9k/545-ath9k_ani_ws_detect.patch
similarity index 98%
rename from package/kernel/mac80211/patches/ath/545-ath9k_ani_ws_detect.patch
rename to package/kernel/mac80211/patches/ath9k/545-ath9k_ani_ws_detect.patch
index 466767adb9..854bb3659a 100644
--- a/package/kernel/mac80211/patches/ath/545-ath9k_ani_ws_detect.patch
+++ b/package/kernel/mac80211/patches/ath9k/545-ath9k_ani_ws_detect.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
 +++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-@@ -978,55 +978,6 @@ static bool ar5008_hw_ani_control_new(st
+@@ -969,55 +969,6 @@ static bool ar5008_hw_ani_control_new(st
  		 * on == 0 means more noise imm
  		 */
  		u32 on = param ? 1 : 0;
diff --git a/package/kernel/mac80211/patches/ath/547-ath9k_led_defstate_fix.patch b/package/kernel/mac80211/patches/ath9k/547-ath9k_led_defstate_fix.patch
similarity index 100%
rename from package/kernel/mac80211/patches/ath/547-ath9k_led_defstate_fix.patch
rename to package/kernel/mac80211/patches/ath9k/547-ath9k_led_defstate_fix.patch
diff --git a/package/kernel/mac80211/patches/ath/548-ath9k_enable_gpio_chip.patch b/package/kernel/mac80211/patches/ath9k/548-ath9k_enable_gpio_chip.patch
similarity index 98%
rename from package/kernel/mac80211/patches/ath/548-ath9k_enable_gpio_chip.patch
rename to package/kernel/mac80211/patches/ath9k/548-ath9k_enable_gpio_chip.patch
index 88198a4562..78206d2860 100644
--- a/package/kernel/mac80211/patches/ath/548-ath9k_enable_gpio_chip.patch
+++ b/package/kernel/mac80211/patches/ath9k/548-ath9k_enable_gpio_chip.patch
@@ -18,7 +18,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  
  #include "common.h"
  #include "debug.h"
-@@ -990,6 +991,14 @@ struct ath_led {
+@@ -989,6 +990,14 @@ struct ath_led {
  	struct led_classdev cdev;
  };
  
@@ -33,7 +33,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  struct ath_softc {
  	struct ieee80211_hw *hw;
  	struct device *dev;
-@@ -1045,6 +1054,9 @@ struct ath_softc {
+@@ -1044,6 +1053,9 @@ struct ath_softc {
  #ifdef CPTCFG_MAC80211_LEDS
  	const char *led_default_trigger;
  	struct list_head leds;
diff --git a/package/kernel/mac80211/patches/ath/549-ath9k_enable_gpio_buttons.patch b/package/kernel/mac80211/patches/ath9k/549-ath9k_enable_gpio_buttons.patch
similarity index 98%
rename from package/kernel/mac80211/patches/ath/549-ath9k_enable_gpio_buttons.patch
rename to package/kernel/mac80211/patches/ath9k/549-ath9k_enable_gpio_buttons.patch
index 83076b8ae4..716e09f351 100644
--- a/package/kernel/mac80211/patches/ath/549-ath9k_enable_gpio_buttons.patch
+++ b/package/kernel/mac80211/patches/ath9k/549-ath9k_enable_gpio_buttons.patch
@@ -10,7 +10,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 ---
 --- a/drivers/net/wireless/ath/ath9k/ath9k.h
 +++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -1056,6 +1056,7 @@ struct ath_softc {
+@@ -1055,6 +1055,7 @@ struct ath_softc {
  	struct list_head leds;
  #ifdef CONFIG_GPIOLIB
  	struct ath9k_gpio_chip *gpiochip;
diff --git a/package/kernel/mac80211/patches/ath/551-ath9k_ubnt_uap_plus_hsr.patch b/package/kernel/mac80211/patches/ath9k/551-ath9k_ubnt_uap_plus_hsr.patch
similarity index 99%
rename from package/kernel/mac80211/patches/ath/551-ath9k_ubnt_uap_plus_hsr.patch
rename to package/kernel/mac80211/patches/ath9k/551-ath9k_ubnt_uap_plus_hsr.patch
index e9cf00769d..6b5c0dc514 100644
--- a/package/kernel/mac80211/patches/ath/551-ath9k_ubnt_uap_plus_hsr.patch
+++ b/package/kernel/mac80211/patches/ath9k/551-ath9k_ubnt_uap_plus_hsr.patch
@@ -371,7 +371,7 @@
  
 --- a/local-symbols
 +++ b/local-symbols
-@@ -112,6 +112,7 @@ ATH9K_WOW=
+@@ -133,6 +133,7 @@ ATH9K_WOW=
  ATH9K_RFKILL=
  ATH9K_CHANNEL_CONTEXT=
  ATH9K_PCOEM=
diff --git a/package/kernel/mac80211/patches/ath/552-ahb_of.patch b/package/kernel/mac80211/patches/ath9k/552-ath9k-ahb_of.patch
similarity index 93%
rename from package/kernel/mac80211/patches/ath/552-ahb_of.patch
rename to package/kernel/mac80211/patches/ath9k/552-ath9k-ahb_of.patch
index 8fd6e4409b..7ce8bc5b82 100644
--- a/package/kernel/mac80211/patches/ath/552-ahb_of.patch
+++ b/package/kernel/mac80211/patches/ath9k/552-ath9k-ahb_of.patch
@@ -16,7 +16,7 @@
  
  static const struct platform_device_id ath9k_platform_id_table[] = {
  	{
-@@ -69,6 +77,242 @@ static const struct ath_bus_ops ath_ahb_
+@@ -69,6 +77,236 @@ static const struct ath_bus_ops ath_ahb_
  	.eeprom_read = ath_ahb_eeprom_read,
  };
  
@@ -218,12 +218,6 @@
 +	else
 +		pdata->led_pin = -1;
 +
-+	if (of_property_read_bool(pdev->dev.of_node, "qca,disable-2ghz"))
-+		pdata->disable_2ghz = true;
-+
-+	if (of_property_read_bool(pdev->dev.of_node, "qca,disable-5ghz"))
-+		pdata->disable_5ghz = true;
-+
 +	if (of_property_read_bool(pdev->dev.of_node, "qca,tx-gain-buffalo"))
 +		pdata->tx_gain_buffalo = true;
 +
@@ -259,7 +253,7 @@
  static int ath_ahb_probe(struct platform_device *pdev)
  {
  	void __iomem *mem;
-@@ -80,6 +324,17 @@ static int ath_ahb_probe(struct platform
+@@ -80,6 +318,17 @@ static int ath_ahb_probe(struct platform
  	int ret = 0;
  	struct ath_hw *ah;
  	char hw_name[64];
@@ -277,7 +271,7 @@
  
  	if (!dev_get_platdata(&pdev->dev)) {
  		dev_err(&pdev->dev, "no platform data specified\n");
-@@ -122,13 +377,16 @@ static int ath_ahb_probe(struct platform
+@@ -122,13 +371,16 @@ static int ath_ahb_probe(struct platform
  	sc->mem = mem;
  	sc->irq = irq;
  
@@ -295,7 +289,7 @@
  	if (ret) {
  		dev_err(&pdev->dev, "failed to initialize device\n");
  		goto err_irq;
-@@ -159,6 +417,9 @@ static int ath_ahb_remove(struct platfor
+@@ -159,6 +411,9 @@ static int ath_ahb_remove(struct platfor
  		free_irq(sc->irq, sc);
  		ieee80211_free_hw(sc->hw);
  	}
@@ -305,7 +299,7 @@
  
  	return 0;
  }
-@@ -168,6 +429,9 @@ static struct platform_driver ath_ahb_dr
+@@ -168,6 +423,9 @@ static struct platform_driver ath_ahb_dr
  	.remove     = ath_ahb_remove,
  	.driver		= {
  		.name	= "ath9k",
@@ -325,7 +319,7 @@
  
  #include "common.h"
  #include "debug.h"
-@@ -1012,6 +1013,9 @@ struct ath_softc {
+@@ -1011,6 +1012,9 @@ struct ath_softc {
  	struct ath_hw *sc_ah;
  	void __iomem *mem;
  	int irq;
diff --git a/package/kernel/mac80211/patches/ath/553-ath9k_of_gpio_mask.patch b/package/kernel/mac80211/patches/ath9k/553-ath9k_of_gpio_mask.patch
similarity index 80%
rename from package/kernel/mac80211/patches/ath/553-ath9k_of_gpio_mask.patch
rename to package/kernel/mac80211/patches/ath9k/553-ath9k_of_gpio_mask.patch
index 8e0041e3ef..80e0dc4c5e 100644
--- a/package/kernel/mac80211/patches/ath/553-ath9k_of_gpio_mask.patch
+++ b/package/kernel/mac80211/patches/ath9k/553-ath9k_of_gpio_mask.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -654,6 +654,12 @@ static int ath9k_of_init(struct ath_soft
+@@ -644,6 +644,12 @@ static int ath9k_of_init(struct ath_soft
  	return 0;
  }
  
@@ -13,7 +13,7 @@
  static int ath9k_init_softc(u16 devid, struct ath_softc *sc,
  			    const struct ath_bus_ops *bus_ops)
  {
-@@ -757,6 +763,9 @@ static int ath9k_init_softc(u16 devid, s
+@@ -747,6 +753,9 @@ static int ath9k_init_softc(u16 devid, s
  	if (ret)
  		goto err_hw;
  
diff --git a/package/kernel/mac80211/patches/ath9k/600-v5.16-ath9k-fetch-calibration-data-via-nvmem-subsystem.patch b/package/kernel/mac80211/patches/ath9k/600-v5.16-ath9k-fetch-calibration-data-via-nvmem-subsystem.patch
new file mode 100644
index 0000000000..a250d2318e
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath9k/600-v5.16-ath9k-fetch-calibration-data-via-nvmem-subsystem.patch
@@ -0,0 +1,154 @@
+From dab16ef495dbb3cabb355b6c80f0771a4a25e35d Mon Sep 17 00:00:00 2001
+From: Christian Lamparter <chunkeey@gmail.com>
+Date: Fri, 20 Aug 2021 22:44:52 +0200
+Subject: [PATCH] ath9k: fetch calibration data via nvmem subsystem
+
+On most embedded ath9k devices (like range extenders,
+routers, accesspoints, ...) the calibration data is
+stored in a MTD partitions named "ART", or "caldata"/
+"calibration".
+
+Ever since commit
+4b361cfa8624 ("mtd: core: add OTP nvmem provider support")
+all MTD partitions are all automatically available through
+the nvmem subsystem. This allows drivers like ath9k to read
+the necessary data without needing any userspace helpers
+that would do this extraction.
+
+Signed-off-by: Christian Lamparter <chunkeey@gmail.com>
+---
+
+includes:
+
+From 57671351379b2051cfb07fc14e0bead9916a0880 Mon Sep 17 00:00:00 2001
+From: Dan Carpenter <dan.carpenter@oracle.com>
+Date: Mon, 11 Oct 2021 18:18:01 +0300
+Subject: ath9k: fix an IS_ERR() vs NULL check
+
+The devm_kmemdup() function doesn't return error pointers, it returns
+NULL on error.
+
+Fixes: eb3a97a69be8 ("ath9k: fetch calibration data via nvmem subsystem")
+Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+Link: https://lore.kernel.org/r/20211011123533.GA15188@kili
+
+---
+
+--- a/drivers/net/wireless/ath/ath9k/eeprom.c
++++ b/drivers/net/wireless/ath/ath9k/eeprom.c
+@@ -135,13 +135,23 @@ static bool ath9k_hw_nvram_read_firmware
+ 					 offset, data);
+ }
+ 
++static bool ath9k_hw_nvram_read_nvmem(struct ath_hw *ah, off_t offset,
++				      u16 *data)
++{
++	return ath9k_hw_nvram_read_array(ah->nvmem_blob,
++					 ah->nvmem_blob_len / sizeof(u16),
++					 offset, data);
++}
++
+ bool ath9k_hw_nvram_read(struct ath_hw *ah, u32 off, u16 *data)
+ {
+ 	struct ath_common *common = ath9k_hw_common(ah);
+ 	struct ath9k_platform_data *pdata = ah->dev->platform_data;
+ 	bool ret;
+ 
+-	if (ah->eeprom_blob)
++	if (ah->nvmem_blob)
++		ret = ath9k_hw_nvram_read_nvmem(ah, off, data);
++	else if (ah->eeprom_blob)
+ 		ret = ath9k_hw_nvram_read_firmware(ah->eeprom_blob, off, data);
+ 	else if (pdata && !pdata->use_eeprom)
+ 		ret = ath9k_hw_nvram_read_pdata(pdata, off, data);
+--- a/drivers/net/wireless/ath/ath9k/hw.h
++++ b/drivers/net/wireless/ath/ath9k/hw.h
+@@ -988,6 +988,8 @@ struct ath_hw {
+ 	bool disable_5ghz;
+ 
+ 	const struct firmware *eeprom_blob;
++	u16 *nvmem_blob;	/* devres managed */
++	size_t nvmem_blob_len;
+ 
+ 	struct ath_dynack dynack;
+ 
+--- a/drivers/net/wireless/ath/ath9k/init.c
++++ b/drivers/net/wireless/ath/ath9k/init.c
+@@ -22,6 +22,7 @@
+ #include <linux/module.h>
+ #include <linux/of.h>
+ #include <linux/of_net.h>
++#include <linux/nvmem-consumer.h>
+ #include <linux/relay.h>
+ #include <linux/dmi.h>
+ #include <net/ieee80211_radiotap.h>
+@@ -568,6 +569,57 @@ static void ath9k_eeprom_release(struct
+ 	release_firmware(sc->sc_ah->eeprom_blob);
+ }
+ 
++static int ath9k_nvmem_request_eeprom(struct ath_softc *sc)
++{
++	struct ath_hw *ah = sc->sc_ah;
++	struct nvmem_cell *cell;
++	void *buf;
++	size_t len;
++	int err;
++
++	cell = devm_nvmem_cell_get(sc->dev, "calibration");
++	if (IS_ERR(cell)) {
++		err = PTR_ERR(cell);
++
++		/* nvmem cell might not be defined, or the nvmem
++		 * subsystem isn't included. In this case, follow
++		 * the established "just return 0;" convention of
++		 * ath9k_init_platform to say:
++		 * "All good. Nothing to see here. Please go on."
++		 */
++		if (err == -ENOENT || err == -EOPNOTSUPP)
++			return 0;
++
++		return err;
++	}
++
++	buf = nvmem_cell_read(cell, &len);
++	if (IS_ERR(buf))
++		return PTR_ERR(buf);
++
++	/* run basic sanity checks on the returned nvram cell length.
++	 * That length has to be a multiple of a "u16" (i.e.: & 1).
++	 * Furthermore, it has to be more than "let's say" 512 bytes
++	 * but less than the maximum of AR9300_EEPROM_SIZE (16kb).
++	 */
++	if (((len & 1) == 1) || (len < 512) || (len >= AR9300_EEPROM_SIZE)) {
++		kfree(buf);
++		return -EINVAL;
++	}
++
++	/* devres manages the calibration values release on shutdown */
++	ah->nvmem_blob = (u16 *)devm_kmemdup(sc->dev, buf, len, GFP_KERNEL);
++	kfree(buf);
++	if (!ah->nvmem_blob)
++		return -ENOMEM;
++
++	ah->nvmem_blob_len = len;
++	ah->ah_flags &= ~AH_USE_EEPROM;
++	ah->ah_flags |= AH_NO_EEP_SWAP;
++
++	return 0;
++}
++
+ static int ath9k_init_platform(struct ath_softc *sc)
+ {
+ 	struct ath9k_platform_data *pdata = sc->dev->platform_data;
+@@ -710,6 +762,10 @@ static int ath9k_init_softc(u16 devid, s
+ 	if (ret)
+ 		return ret;
+ 
++	ret = ath9k_nvmem_request_eeprom(sc);
++	if (ret)
++		return ret;
++
+ 	if (ath9k_led_active_high != -1)
+ 		ah->config.led_active_high = ath9k_led_active_high == 1;
+ 
diff --git a/package/kernel/mac80211/patches/ath9k/601-v5.16-ath9k-owl-loader-fetch-pci-init-values-through-nvmem.patch b/package/kernel/mac80211/patches/ath9k/601-v5.16-ath9k-owl-loader-fetch-pci-init-values-through-nvmem.patch
new file mode 100644
index 0000000000..62c561d619
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath9k/601-v5.16-ath9k-owl-loader-fetch-pci-init-values-through-nvmem.patch
@@ -0,0 +1,181 @@
+From 9bf31835f11aa3c4fe5a9c1f7462c199c5d8e7ca Mon Sep 17 00:00:00 2001
+From: Christian Lamparter <chunkeey@gmail.com>
+Date: Sat, 21 Aug 2021 00:22:39 +0200
+Subject: [PATCH] ath9k: owl-loader: fetch pci init values through nvmem
+
+extends the owl loader to fetch important pci initialization
+values - which are stored together with the calibration data -
+through the nvmem subsystem.
+
+This allows for much faster WIFI/ath9k initializations on devices
+that do not require to perform any post-processing (like XOR'ing/
+reversal or unpacking) since no userspace helper is required.
+
+Signed-off-by: Christian Lamparter <chunkeey@gmail.com>
+---
+ .../wireless/ath/ath9k/ath9k_pci_owl_loader.c | 105 +++++++++++++-----
+ 1 file changed, 76 insertions(+), 29 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath9k/ath9k_pci_owl_loader.c
++++ b/drivers/net/wireless/ath/ath9k/ath9k_pci_owl_loader.c
+@@ -19,9 +19,14 @@
+ #include <linux/delay.h>
+ #include <linux/platform_device.h>
+ #include <linux/ath9k_platform.h>
++#include <linux/nvmem-consumer.h>
++#include <linux/workqueue.h>
+ 
+ struct owl_ctx {
++	struct pci_dev *pdev;
+ 	struct completion eeprom_load;
++	struct work_struct work;
++	struct nvmem_cell *cell;
+ };
+ 
+ #define EEPROM_FILENAME_LEN 100
+@@ -42,6 +47,12 @@ static int ath9k_pci_fixup(struct pci_de
+ 	u32 bar0;
+ 	bool swap_needed = false;
+ 
++	/* also note that we are doing *u16 operations on the file */
++	if (cal_len > 4096 || cal_len < 0x200 || (cal_len & 1) == 1) {
++		dev_err(&pdev->dev, "eeprom has an invalid size.\n");
++		return -EINVAL;
++	}
++
+ 	if (*cal_data != AR5416_EEPROM_MAGIC) {
+ 		if (*cal_data != swab16(AR5416_EEPROM_MAGIC)) {
+ 			dev_err(&pdev->dev, "invalid calibration data\n");
+@@ -99,38 +110,31 @@ static int ath9k_pci_fixup(struct pci_de
+ 	return 0;
+ }
+ 
+-static void owl_fw_cb(const struct firmware *fw, void *context)
++static void owl_rescan(struct pci_dev *pdev)
+ {
+-	struct pci_dev *pdev = (struct pci_dev *)context;
+-	struct owl_ctx *ctx = (struct owl_ctx *)pci_get_drvdata(pdev);
+-	struct pci_bus *bus;
+-
+-	complete(&ctx->eeprom_load);
+-
+-	if (!fw) {
+-		dev_err(&pdev->dev, "no eeprom data received.\n");
+-		goto release;
+-	}
+-
+-	/* also note that we are doing *u16 operations on the file */
+-	if (fw->size > 4096 || fw->size < 0x200 || (fw->size & 1) == 1) {
+-		dev_err(&pdev->dev, "eeprom file has an invalid size.\n");
+-		goto release;
+-	}
+-
+-	if (ath9k_pci_fixup(pdev, (const u16 *)fw->data, fw->size))
+-		goto release;
++	struct pci_bus *bus = pdev->bus;
+ 
+ 	pci_lock_rescan_remove();
+-	bus = pdev->bus;
+ 	pci_stop_and_remove_bus_device(pdev);
+ 	/* the device should come back with the proper
+ 	 * ProductId. But we have to initiate a rescan.
+ 	 */
+ 	pci_rescan_bus(bus);
+ 	pci_unlock_rescan_remove();
++}
++
++static void owl_fw_cb(const struct firmware *fw, void *context)
++{
++	struct owl_ctx *ctx = (struct owl_ctx *)context;
++
++	complete(&ctx->eeprom_load);
+ 
+-release:
++	if (fw) {
++		ath9k_pci_fixup(ctx->pdev, (const u16 *)fw->data, fw->size);
++		owl_rescan(ctx->pdev);
++	} else {
++		dev_err(&ctx->pdev->dev, "no eeprom data received.\n");
++	}
+ 	release_firmware(fw);
+ }
+ 
+@@ -152,6 +156,43 @@ static const char *owl_get_eeprom_name(s
+ 	return eeprom_name;
+ }
+ 
++static void owl_nvmem_work(struct work_struct *work)
++{
++	struct owl_ctx *ctx = container_of(work, struct owl_ctx, work);
++	void *buf;
++	size_t len;
++
++	complete(&ctx->eeprom_load);
++
++	buf = nvmem_cell_read(ctx->cell, &len);
++	if (!IS_ERR(buf)) {
++		ath9k_pci_fixup(ctx->pdev, buf, len);
++		kfree(buf);
++		owl_rescan(ctx->pdev);
++	} else {
++		dev_err(&ctx->pdev->dev, "no nvmem data received.\n");
++	}
++}
++
++static int owl_nvmem_probe(struct owl_ctx *ctx)
++{
++	int err;
++
++	ctx->cell = devm_nvmem_cell_get(&ctx->pdev->dev, "calibration");
++	if (IS_ERR(ctx->cell)) {
++		err = PTR_ERR(ctx->cell);
++		if (err == -ENOENT || err == -EOPNOTSUPP)
++			return 1; /* not present, try firmware_request */
++
++		return err;
++	}
++
++	INIT_WORK(&ctx->work, owl_nvmem_work);
++	schedule_work(&ctx->work);
++
++	return 0;
++}
++
+ static int owl_probe(struct pci_dev *pdev,
+ 		     const struct pci_device_id *id)
+ {
+@@ -164,21 +205,27 @@ static int owl_probe(struct pci_dev *pde
+ 
+ 	pcim_pin_device(pdev);
+ 
+-	eeprom_name = owl_get_eeprom_name(pdev);
+-	if (!eeprom_name) {
+-		dev_err(&pdev->dev, "no eeprom filename found.\n");
+-		return -ENODEV;
+-	}
+-
+ 	ctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);
+ 	if (!ctx)
+ 		return -ENOMEM;
+ 
+ 	init_completion(&ctx->eeprom_load);
++	ctx->pdev = pdev;
+ 
+ 	pci_set_drvdata(pdev, ctx);
++
++	err = owl_nvmem_probe(ctx);
++	if (err <= 0)
++		return err;
++
++	eeprom_name = owl_get_eeprom_name(pdev);
++	if (!eeprom_name) {
++		dev_err(&pdev->dev, "no eeprom filename found.\n");
++		return -ENODEV;
++	}
++
+ 	err = request_firmware_nowait(THIS_MODULE, true, eeprom_name,
+-				      &pdev->dev, GFP_KERNEL, pdev, owl_fw_cb);
++				      &pdev->dev, GFP_KERNEL, ctx, owl_fw_cb);
+ 	if (err)
+ 		dev_err(&pdev->dev, "failed to request caldata (%d).\n", err);
+ 
diff --git a/package/kernel/mac80211/patches/brcm/812-b43-add-antenna-control.patch b/package/kernel/mac80211/patches/brcm/812-b43-add-antenna-control.patch
index 52ae7a8eba..5dc04ecc88 100644
--- a/package/kernel/mac80211/patches/brcm/812-b43-add-antenna-control.patch
+++ b/package/kernel/mac80211/patches/brcm/812-b43-add-antenna-control.patch
@@ -42,7 +42,7 @@
  
  	if (wl->radio_enabled != phy->radio_on) {
  		if (wl->radio_enabled) {
-@@ -5176,6 +5173,47 @@ static int b43_op_get_survey(struct ieee
+@@ -5175,6 +5172,47 @@ static int b43_op_get_survey(struct ieee
  	return 0;
  }
  
@@ -90,7 +90,7 @@
  static const struct ieee80211_ops b43_hw_ops = {
  	.tx			= b43_op_tx,
  	.conf_tx		= b43_op_conf_tx,
-@@ -5197,6 +5235,8 @@ static const struct ieee80211_ops b43_hw
+@@ -5196,6 +5234,8 @@ static const struct ieee80211_ops b43_hw
  	.sw_scan_complete	= b43_op_sw_scan_complete_notifier,
  	.get_survey		= b43_op_get_survey,
  	.rfkill_poll		= b43_rfkill_poll,
@@ -99,7 +99,7 @@
  };
  
  /* Hard-reset the chip. Do not call this directly.
-@@ -5498,6 +5538,8 @@ static int b43_one_core_attach(struct b4
+@@ -5497,6 +5537,8 @@ static int b43_one_core_attach(struct b4
  	if (!wldev)
  		goto out;
  
@@ -108,7 +108,7 @@
  	wldev->use_pio = b43_modparam_pio;
  	wldev->dev = dev;
  	wldev->wl = wl;
-@@ -5592,6 +5634,9 @@ static struct b43_wl *b43_wireless_init(
+@@ -5588,6 +5630,9 @@ static struct b43_wl *b43_wireless_init(
  
  	wiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);
  
diff --git a/package/kernel/mac80211/patches/brcm/860-brcmfmac-register-wiphy-s-during-module_init.patch b/package/kernel/mac80211/patches/brcm/860-brcmfmac-register-wiphy-s-during-module_init.patch
index 4f72e62948..7b9512f741 100644
--- a/package/kernel/mac80211/patches/brcm/860-brcmfmac-register-wiphy-s-during-module_init.patch
+++ b/package/kernel/mac80211/patches/brcm/860-brcmfmac-register-wiphy-s-during-module_init.patch
@@ -13,15 +13,15 @@ Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
 
 --- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
 +++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
-@@ -433,6 +433,7 @@ struct brcmf_fw {
+@@ -431,6 +431,7 @@ struct brcmf_fw {
  	struct brcmf_fw_request *req;
  	u32 curpos;
  	void (*done)(struct device *dev, int err, struct brcmf_fw_request *req);
 +	struct completion *completion;
  };
  
- static void brcmf_fw_request_done(const struct firmware *fw, void *ctx);
-@@ -640,6 +641,8 @@ static void brcmf_fw_request_done(const
+ #ifdef CONFIG_EFI
+@@ -655,6 +656,8 @@ static void brcmf_fw_request_done(const
  		fwctx->req = NULL;
  	}
  	fwctx->done(fwctx->dev, ret, fwctx->req);
@@ -30,16 +30,16 @@ Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
  	kfree(fwctx);
  }
  
-@@ -664,6 +667,8 @@ int brcmf_fw_get_firmwares(struct device
+@@ -695,6 +698,8 @@ int brcmf_fw_get_firmwares(struct device
  {
  	struct brcmf_fw_item *first = &req->items[0];
  	struct brcmf_fw *fwctx;
 +	struct completion completion;
 +	unsigned long time_left;
+ 	char *alt_path = NULL;
  	int ret;
  
- 	brcmf_dbg(TRACE, "enter: dev=%s\n", dev_name(dev));
-@@ -680,6 +685,9 @@ int brcmf_fw_get_firmwares(struct device
+@@ -712,6 +717,9 @@ int brcmf_fw_get_firmwares(struct device
  	fwctx->dev = dev;
  	fwctx->req = req;
  	fwctx->done = fw_cb;
@@ -47,9 +47,9 @@ Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
 +	init_completion(&completion);
 +	fwctx->completion = &completion;
  
- 	ret = request_firmware_nowait(THIS_MODULE, true, first->path,
- 				      fwctx->dev, GFP_KERNEL, fwctx,
-@@ -687,6 +695,12 @@ int brcmf_fw_get_firmwares(struct device
+ 	/* First try alternative board-specific path if any */
+ 	if (fwctx->req->board_type)
+@@ -730,6 +738,12 @@ int brcmf_fw_get_firmwares(struct device
  	if (ret < 0)
  		brcmf_fw_request_done(NULL, fwctx);
  
diff --git a/package/kernel/mac80211/patches/brcm/862-brcmfmac-Disable-power-management.patch b/package/kernel/mac80211/patches/brcm/862-brcmfmac-Disable-power-management.patch
index 774656f1fd..88465f256b 100644
--- a/package/kernel/mac80211/patches/brcm/862-brcmfmac-Disable-power-management.patch
+++ b/package/kernel/mac80211/patches/brcm/862-brcmfmac-Disable-power-management.patch
@@ -14,7 +14,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.org>
 
 --- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
 +++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -2961,6 +2961,10 @@ brcmf_cfg80211_set_power_mgmt(struct wip
+@@ -2974,6 +2974,10 @@ brcmf_cfg80211_set_power_mgmt(struct wip
  	 * preference in cfg struct to apply this to
  	 * FW later while initializing the dongle
  	 */
diff --git a/package/kernel/mac80211/patches/brcm/863-brcmfmac-add-in-driver-tables-with-country-codes.patch b/package/kernel/mac80211/patches/brcm/863-brcmfmac-add-in-driver-tables-with-country-codes.patch
index 9658bda1c1..835c870a65 100644
--- a/package/kernel/mac80211/patches/brcm/863-brcmfmac-add-in-driver-tables-with-country-codes.patch
+++ b/package/kernel/mac80211/patches/brcm/863-brcmfmac-add-in-driver-tables-with-country-codes.patch
@@ -12,9 +12,9 @@ Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
 
 --- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
 +++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
-@@ -12,6 +12,36 @@
- #include "common.h"
- #include "of.h"
+@@ -58,6 +58,36 @@ static int brcmf_of_get_country_codes(st
+ 	return 0;
+ }
  
 +/* TODO: FIXME: Use DT */
 +static void brcmf_of_probe_cc(struct device *dev,
@@ -49,12 +49,12 @@ Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
  void brcmf_of_probe(struct device *dev, enum brcmf_bus_type bus_type,
  		    struct brcmf_mp_device *settings)
  {
-@@ -43,6 +73,8 @@ void brcmf_of_probe(struct device *dev,
+@@ -90,6 +120,8 @@ void brcmf_of_probe(struct device *dev,
  		of_node_put(root);
  	}
  
 +	brcmf_of_probe_cc(dev, settings);
 +
- 	if (!np || bus_type != BRCMF_BUSTYPE_SDIO ||
- 	    !of_device_is_compatible(np, "brcm,bcm4329-fmac"))
+ 	if (!np || !of_device_is_compatible(np, "brcm,bcm4329-fmac"))
  		return;
+ 
diff --git a/package/kernel/mac80211/patches/brcm/998-survey.patch b/package/kernel/mac80211/patches/brcm/998-survey.patch
index 25a12c783e..a5efc08015 100644
--- a/package/kernel/mac80211/patches/brcm/998-survey.patch
+++ b/package/kernel/mac80211/patches/brcm/998-survey.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
 +++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -2913,6 +2913,63 @@ done:
+@@ -2921,6 +2921,63 @@ done:
  }
  
  static int
@@ -64,7 +64,7 @@
  brcmf_cfg80211_dump_station(struct wiphy *wiphy, struct net_device *ndev,
  			    int idx, u8 *mac, struct station_info *sinfo)
  {
-@@ -3008,6 +3065,7 @@ static s32 brcmf_inform_single_bss(struc
+@@ -3021,6 +3078,7 @@ static s32 brcmf_inform_single_bss(struc
  	struct brcmu_chan ch;
  	u16 channel;
  	u32 freq;
@@ -72,7 +72,7 @@
  	u16 notify_capability;
  	u16 notify_interval;
  	u8 *notify_ie;
-@@ -3032,6 +3090,17 @@ static s32 brcmf_inform_single_bss(struc
+@@ -3045,6 +3103,17 @@ static s32 brcmf_inform_single_bss(struc
  		band = NL80211_BAND_5GHZ;
  
  	freq = ieee80211_channel_to_frequency(channel, band);
@@ -90,7 +90,7 @@
  	bss_data.chan = ieee80211_get_channel(wiphy, freq);
  	bss_data.scan_width = NL80211_BSS_CHAN_WIDTH_20;
  	bss_data.boottime_ns = ktime_to_ns(ktime_get_boottime());
-@@ -5518,6 +5587,7 @@ static struct cfg80211_ops brcmf_cfg8021
+@@ -5573,6 +5642,7 @@ static struct cfg80211_ops brcmf_cfg8021
  	.leave_ibss = brcmf_cfg80211_leave_ibss,
  	.get_station = brcmf_cfg80211_get_station,
  	.dump_station = brcmf_cfg80211_dump_station,
@@ -100,7 +100,7 @@
  	.add_key = brcmf_cfg80211_add_key,
 --- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
 +++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-@@ -1356,6 +1356,8 @@ int brcmf_attach(struct device *dev)
+@@ -1361,6 +1361,8 @@ int brcmf_attach(struct device *dev)
  
  	/* Link to bus module */
  	drvr->hdrlen = 0;
@@ -109,7 +109,7 @@
  
  	/* Attach and link in the protocol */
  	ret = brcmf_proto_attach(drvr);
-@@ -1438,6 +1440,12 @@ void brcmf_detach(struct device *dev)
+@@ -1443,6 +1445,12 @@ void brcmf_detach(struct device *dev)
  	if (drvr == NULL)
  		return;
  
diff --git a/package/kernel/mac80211/patches/build/003-remove_bogus_modparams.patch b/package/kernel/mac80211/patches/build/003-remove_bogus_modparams.patch
index 8fa465a7e1..aa26c8cb2a 100644
--- a/package/kernel/mac80211/patches/build/003-remove_bogus_modparams.patch
+++ b/package/kernel/mac80211/patches/build/003-remove_bogus_modparams.patch
@@ -1,6 +1,6 @@
 --- a/compat/main.c
 +++ b/compat/main.c
-@@ -20,31 +20,6 @@ MODULE_LICENSE("GPL");
+@@ -19,31 +19,6 @@ MODULE_LICENSE("GPL");
  #error "You need a CPTCFG_VERSION"
  #endif
  
diff --git a/package/kernel/mac80211/patches/build/004-kconfig_backport_fix.patch b/package/kernel/mac80211/patches/build/004-kconfig_backport_fix.patch
deleted file mode 100644
index 2c9572ec93..0000000000
--- a/package/kernel/mac80211/patches/build/004-kconfig_backport_fix.patch
+++ /dev/null
@@ -1,28 +0,0 @@
---- a/backport-include/linux/kconfig.h
-+++ b/backport-include/linux/kconfig.h
-@@ -5,6 +5,8 @@
- #include_next <linux/kconfig.h>
- #endif
- 
-+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
-+
- #ifndef __ARG_PLACEHOLDER_1
- #define __ARG_PLACEHOLDER_1 0,
- #define config_enabled(cfg) _config_enabled(cfg)
-@@ -16,6 +18,7 @@
-  * 3.1 - 3.3 had a broken version of this, so undef
-  * (they didn't have __ARG_PLACEHOLDER_1)
-  */
-+
- #undef IS_ENABLED
- #define IS_ENABLED(option) \
-         (config_enabled(option) || config_enabled(option##_MODULE))
-@@ -31,6 +34,8 @@
- #undef IS_BUILTIN
- #define IS_BUILTIN(option) config_enabled(option)
- 
-+#endif
-+
- #ifndef IS_REACHABLE
- /*
-  * IS_REACHABLE(CONFIG_FOO) evaluates to 1 if the currently compiled
diff --git a/package/kernel/mac80211/patches/build/010-disable_rfkill.patch b/package/kernel/mac80211/patches/build/010-disable_rfkill.patch
deleted file mode 100644
index d5253063ce..0000000000
--- a/package/kernel/mac80211/patches/build/010-disable_rfkill.patch
+++ /dev/null
@@ -1,15 +0,0 @@
---- a/backport-include/linux/rfkill.h
-+++ b/backport-include/linux/rfkill.h
-@@ -2,6 +2,12 @@
- #define __COMPAT_RFKILL_H
- #include <linux/version.h>
- 
-+#undef CONFIG_RFKILL
-+#undef CONFIG_RFKILL_FULL
-+#undef CONFIG_RFKILL_LEDS
-+#undef CONFIG_RFKILL_MODULE
-+#undef CONFIG_RFKILL_FULL_MODULE
-+
- #if LINUX_VERSION_IS_GEQ(3,10,0)
- #include_next <linux/rfkill.h>
- #else
diff --git a/package/kernel/mac80211/patches/build/060-no_local_ssb_bcma.patch b/package/kernel/mac80211/patches/build/060-no_local_ssb_bcma.patch
index ff2ce2071f..089ff2117b 100644
--- a/package/kernel/mac80211/patches/build/060-no_local_ssb_bcma.patch
+++ b/package/kernel/mac80211/patches/build/060-no_local_ssb_bcma.patch
@@ -1,9 +1,9 @@
 --- a/local-symbols
 +++ b/local-symbols
-@@ -437,43 +437,6 @@ USB_SIERRA_NET=
- USB_VL600=
+@@ -451,43 +451,6 @@ USB_VL600=
  USB_NET_CH9200=
  USB_NET_AQC111=
+ USB_RTL8153_ECM=
 -SSB_POSSIBLE=
 -SSB=
 -SSB_SPROM=
@@ -192,10 +192,10 @@
  	select BRCMUTIL
 --- a/Kconfig.local
 +++ b/Kconfig.local
-@@ -1315,117 +1315,6 @@ config BACKPORTED_USB_NET_CH9200
- config BACKPORTED_USB_NET_AQC111
+@@ -1357,117 +1357,6 @@ config BACKPORTED_USB_NET_AQC111
+ config BACKPORTED_USB_RTL8153_ECM
  	tristate
- 	default USB_NET_AQC111
+ 	default USB_RTL8153_ECM
 -config BACKPORTED_SSB_POSSIBLE
 -	tristate
 -	default SSB_POSSIBLE
@@ -312,7 +312,7 @@
  	default USB_ACM
 --- a/Kconfig.sources
 +++ b/Kconfig.sources
-@@ -7,9 +7,6 @@ source "$BACKPORT_DIR/net/mac80211/Kconf
+@@ -10,9 +10,6 @@ source "$BACKPORT_DIR/drivers/soc/qcom/K
  source "$BACKPORT_DIR/drivers/net/wireless/Kconfig"
  source "$BACKPORT_DIR/drivers/net/usb/Kconfig"
  
@@ -324,9 +324,9 @@
  source "$BACKPORT_DIR/drivers/staging/Kconfig"
 --- a/Makefile.kernel
 +++ b/Makefile.kernel
-@@ -40,8 +40,6 @@ obj-y += compat/
- obj-$(CPTCFG_CFG80211) += net/wireless/
- obj-$(CPTCFG_MAC80211) += net/mac80211/
+@@ -43,8 +43,6 @@ obj-$(CPTCFG_QRTR) += net/qrtr/
+ obj-$(CPTCFG_QCOM_QMI_HELPERS) += drivers/soc/qcom/
+ obj-$(CPTCFG_MHI_BUS) += drivers/bus/mhi/
  obj-$(CPTCFG_WLAN) += drivers/net/wireless/
 -obj-$(CPTCFG_SSB) += drivers/ssb/
 -obj-$(CPTCFG_BCMA) += drivers/bcma/
diff --git a/package/kernel/mac80211/patches/mwl/700-mwl8k-missing-pci-id-for-WNR854T.patch b/package/kernel/mac80211/patches/mwl/700-mwl8k-missing-pci-id-for-WNR854T.patch
index d358cfe367..140949f9a8 100644
--- a/package/kernel/mac80211/patches/mwl/700-mwl8k-missing-pci-id-for-WNR854T.patch
+++ b/package/kernel/mac80211/patches/mwl/700-mwl8k-missing-pci-id-for-WNR854T.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/marvell/mwl8k.c
 +++ b/drivers/net/wireless/marvell/mwl8k.c
-@@ -5695,6 +5695,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw")
+@@ -5699,6 +5699,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw")
  MODULE_FIRMWARE(MWL8K_8366_AP_FW(MWL8K_8366_AP_FW_API));
  
  static const struct pci_device_id mwl8k_pci_id_table[] = {
diff --git a/package/kernel/mac80211/patches/mwl/940-mwl8k_init_devices_synchronously.patch b/package/kernel/mac80211/patches/mwl/940-mwl8k_init_devices_synchronously.patch
index a35cf1875a..96b1ce77e9 100644
--- a/package/kernel/mac80211/patches/mwl/940-mwl8k_init_devices_synchronously.patch
+++ b/package/kernel/mac80211/patches/mwl/940-mwl8k_init_devices_synchronously.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/marvell/mwl8k.c
 +++ b/drivers/net/wireless/marvell/mwl8k.c
-@@ -6280,6 +6280,8 @@ static int mwl8k_probe(struct pci_dev *p
+@@ -6285,6 +6285,8 @@ static int mwl8k_probe(struct pci_dev *p
  
  	priv->running_bsses = 0;
  
@@ -9,7 +9,7 @@
  	return rc;
  
  err_stop_firmware:
-@@ -6313,8 +6315,6 @@ static void mwl8k_remove(struct pci_dev
+@@ -6318,8 +6320,6 @@ static void mwl8k_remove(struct pci_dev
  		return;
  	priv = hw->priv;
  
diff --git a/package/kernel/mac80211/patches/rt2x00/001-rt2x00-define-RF5592-in-init_eeprom-routine.patch b/package/kernel/mac80211/patches/rt2x00/001-rt2x00-define-RF5592-in-init_eeprom-routine.patch
new file mode 100644
index 0000000000..351e24a4d5
--- /dev/null
+++ b/package/kernel/mac80211/patches/rt2x00/001-rt2x00-define-RF5592-in-init_eeprom-routine.patch
@@ -0,0 +1,52 @@
+From patchwork Sat Sep 17 20:26:27 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 8bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979242
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:26:27 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 01/16] rt2x00: define RF5592 in init_eeprom routine
+Message-ID: 
+ <d7eccb2c7b8ec4cd360fa2007796abffc35abb0d.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+From: Tomislav Požega <pozega.tomislav@gmail.com>
+
+Fix incorrect RF value encoded in EEPROM on devices with Ralink Rt5592
+PCIe radio (a single chip 2T2R 802.11abgn solution).
+
+Signed-off-by: Tomislav Požega <pozega.tomislav@gmail.com>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -9435,6 +9435,8 @@ static int rt2800_init_eeprom(struct rt2
+ 		rf = RF3853;
+ 	else if (rt2x00_rt(rt2x00dev, RT5350))
+ 		rf = RF5350;
++	else if (rt2x00_rt(rt2x00dev, RT5592))
++		rf = RF5592;
+ 	else
+ 		rf = rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RF_TYPE);
+ 
diff --git a/package/kernel/mac80211/patches/rt2x00/002-rt2x00-add-throughput-LED-trigger.patch b/package/kernel/mac80211/patches/rt2x00/002-rt2x00-add-throughput-LED-trigger.patch
new file mode 100644
index 0000000000..02d1f7a2e5
--- /dev/null
+++ b/package/kernel/mac80211/patches/rt2x00/002-rt2x00-add-throughput-LED-trigger.patch
@@ -0,0 +1,76 @@
+From patchwork Sat Sep 17 20:26:40 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979243
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:26:40 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 02/16] rt2x00: add throughput LED trigger
+Message-ID: 
+ <73f5ba4134e621462a26186449400cf0c1ac1730.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+From: David Bauer <mail@david-bauer.net>
+
+This adds a (currently missing) throughput LED trigger for the rt2x00
+driver. Previously, LED triggers had to be assigned to the netdev, which
+was limited to a single VAP.
+
+Tested-by: Christoph Krapp <achterin@googlemail.com>
+Signed-off-by: David Bauer <mail@david-bauer.net>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2x00dev.c | 18 ++++++++++++++++++
+ 1 file changed, 18 insertions(+)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
+@@ -1093,6 +1093,19 @@ static void rt2x00lib_remove_hw(struct r
+ 	kfree(rt2x00dev->spec.channels_info);
+ }
+ 
++static const struct ieee80211_tpt_blink rt2x00_tpt_blink[] = {
++	{ .throughput = 0 * 1024, .blink_time = 334 },
++	{ .throughput = 1 * 1024, .blink_time = 260 },
++	{ .throughput = 2 * 1024, .blink_time = 220 },
++	{ .throughput = 5 * 1024, .blink_time = 190 },
++	{ .throughput = 10 * 1024, .blink_time = 170 },
++	{ .throughput = 25 * 1024, .blink_time = 150 },
++	{ .throughput = 54 * 1024, .blink_time = 130 },
++	{ .throughput = 120 * 1024, .blink_time = 110 },
++	{ .throughput = 265 * 1024, .blink_time = 80 },
++	{ .throughput = 586 * 1024, .blink_time = 50 },
++};
++
+ static int rt2x00lib_probe_hw(struct rt2x00_dev *rt2x00dev)
+ {
+ 	struct hw_mode_spec *spec = &rt2x00dev->spec;
+@@ -1174,6 +1187,11 @@ static int rt2x00lib_probe_hw(struct rt2
+ 
+ #undef RT2X00_TASKLET_INIT
+ 
++	ieee80211_create_tpt_led_trigger(rt2x00dev->hw,
++					 IEEE80211_TPT_LEDTRIG_FL_RADIO,
++					 rt2x00_tpt_blink,
++					 ARRAY_SIZE(rt2x00_tpt_blink));
++
+ 	/*
+ 	 * Register HW.
+ 	 */
diff --git a/package/kernel/mac80211/patches/rt2x00/002-rt2x00-define-RF5592-in-init_eeprom-routine.patch b/package/kernel/mac80211/patches/rt2x00/002-rt2x00-define-RF5592-in-init_eeprom-routine.patch
deleted file mode 100644
index a50a195285..0000000000
--- a/package/kernel/mac80211/patches/rt2x00/002-rt2x00-define-RF5592-in-init_eeprom-routine.patch
+++ /dev/null
@@ -1,51 +0,0 @@
-From patchwork Thu Dec 27 14:05:26 2018
-Content-Type: text/plain; charset="utf-8"
-MIME-Version: 1.0
-Content-Transfer-Encoding: 8bit
-X-Patchwork-Submitter: Tom Psyborg <pozega.tomislav@gmail.com>
-X-Patchwork-Id: 10743707
-X-Patchwork-Delegate: kvalo@adurom.com
-From: =?utf-8?q?Tomislav_Po=C5=BEega?= <pozega.tomislav@gmail.com>
-To: linux-wireless@vger.kernel.org
-Cc: kvalo@codeaurora.org, hauke@hauke-m.de, nbd@nbd.name,
-        john@phrozen.org, sgruszka@redhat.com, daniel@makrotopia.org
-Subject: [PATCH 2/2] rt2x00: define RF5592 in init_eeprom routine
-Date: Thu, 27 Dec 2018 15:05:26 +0100
-Message-Id: <1545919526-4074-2-git-send-email-pozega.tomislav@gmail.com>
-X-Mailer: git-send-email 1.7.0.4
-In-Reply-To: <1545919526-4074-1-git-send-email-pozega.tomislav@gmail.com>
-References: <1545919526-4074-1-git-send-email-pozega.tomislav@gmail.com>
-MIME-Version: 1.0
-Sender: linux-wireless-owner@vger.kernel.org
-Precedence: bulk
-List-ID: <linux-wireless.vger.kernel.org>
-X-Mailing-List: linux-wireless@vger.kernel.org
-X-Virus-Scanned: ClamAV using ClamSMTP
-
-This patch fixes following crash on Linksys EA2750 during 5GHz wifi
-init:
-
-[    7.955153] rt2800pci 0000:01:00.0: card - bus=0x1, slot = 0x0 irq=4
-[    7.962259] rt2800pci 0000:01:00.0: loaded eeprom from mtd device "Factory"
-[    7.969435] ieee80211 phy0: rt2x00_set_rt: Info - RT chipset 5592, rev 0222 detected
-[    7.977348] ieee80211 phy0: rt2800_init_eeprom: Error - Invalid RF chipset 0x0000 detected
-[    7.985793] ieee80211 phy0: rt2x00lib_probe_dev: Error - Failed to allocate device
-[    7.993569] CPU 0 Unable to handle kernel paging request at virtual address 00000024, epc == 800c8f54, ra == 80249ff8
-[    8.004408] Oops[#1]:
-
-Signed-off-by: Tomislav Požega <pozega.tomislav@gmail.com>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    2 ++
- 1 files changed, 2 insertions(+), 0 deletions(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -9416,6 +9416,8 @@ static int rt2800_init_eeprom(struct rt2
- 		rf = RF3853;
- 	else if (rt2x00_rt(rt2x00dev, RT5350))
- 		rf = RF5350;
-+	else if (rt2x00_rt(rt2x00dev, RT5592))
-+		rf = RF5592;
- 	else
- 		rf = rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RF_TYPE);
- 
diff --git a/package/kernel/mac80211/patches/rt2x00/650-rt2x00-add-support-for-external-PA-on-MT7620.patch b/package/kernel/mac80211/patches/rt2x00/003-rt2x00-add-support-for-external-PA-on-MT7620.patch
similarity index 58%
rename from package/kernel/mac80211/patches/rt2x00/650-rt2x00-add-support-for-external-PA-on-MT7620.patch
rename to package/kernel/mac80211/patches/rt2x00/003-rt2x00-add-support-for-external-PA-on-MT7620.patch
index 20452cd8a7..216f583063 100644
--- a/package/kernel/mac80211/patches/rt2x00/650-rt2x00-add-support-for-external-PA-on-MT7620.patch
+++ b/package/kernel/mac80211/patches/rt2x00/003-rt2x00-add-support-for-external-PA-on-MT7620.patch
@@ -1,22 +1,42 @@
-From 9782a7f7488443568fa4d6088b73c9aff7eb8510 Mon Sep 17 00:00:00 2001
+From patchwork Sat Sep 17 20:26:55 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 8bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979244
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:26:55 +0100
 From: Daniel Golle <daniel@makrotopia.org>
-Date: Wed, 19 Apr 2017 16:14:53 +0200
-Subject: [PATCH] rt2x00: add support for external PA on MT7620
-To: Stanislaw Gruszka <sgruszka@redhat.com>
-Cc: Helmut Schaa <helmut.schaa@googlemail.com>,
-    linux-wireless@vger.kernel.org,
-    Kalle Valo <kvalo@codeaurora.org>
-Content-Type: text/plain; charset="UTF-8"
-Content-Transfer-Encoding: quoted-printable
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 03/16] rt2x00: add support for external PA on MT7620
+Message-ID: 
+ <af2c68ff831816a86fc39b0c10911c129a1f03dc.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
 
-Signed-off-by: Daniel Golle <daniel@makrotopia.org>
-Signed-off-by: Tomislav Po=C5=BEega <pozega.tomislav@gmail.com>
-[pozega.tomislav@gmail.com: use chanreg and dccal helpers.]
+Implement support for external PA connected to MT7620A.
 
+Signed-off-by: Tomislav Požega <pozega.tomislav@gmail.com>
+[pozega.tomislav@gmail.com: use chanreg and dccal helpers.]
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
 ---
- drivers/net/wireless/ralink/rt2x00/rt2800.h    |  1 +
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 70 +++++++++++++++++++++++++-
- 2 files changed, 70 insertions(+), 1 deletion(-)
+ drivers/net/wireless/ralink/rt2x00/rt2800.h   |  1 +
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 52 ++++++++++++++++++-
+ 2 files changed, 52 insertions(+), 1 deletion(-)
 
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
@@ -24,21 +44,19 @@ Signed-off-by: Tomislav Po=C5=BEega <pozega.tomislav@gmail.com>
  #define EEPROM_NIC_CONF2_RX_STREAM	FIELD16(0x000f)
  #define EEPROM_NIC_CONF2_TX_STREAM	FIELD16(0x00f0)
  #define EEPROM_NIC_CONF2_CRYSTAL	FIELD16(0x0600)
-+#define EEPROM_NIC_CONF2_EXTERNAL_PA	FIELD16(0xc000)
++#define EEPROM_NIC_CONF2_EXTERNAL_PA	FIELD16(0x8000)
  
  /*
   * EEPROM LNA
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -4356,6 +4356,45 @@ static void rt2800_config_channel(struct
+@@ -4368,6 +4368,43 @@ static void rt2800_config_channel(struct
  		rt2800_iq_calibrate(rt2x00dev, rf->channel);
  	}
  
 +	if (rt2x00_rt(rt2x00dev, RT6352)) {
 +		if (test_bit(CAPABILITY_EXTERNAL_PA_TX0,
 +			     &rt2x00dev->cap_flags)) {
-+			rt2x00_warn(rt2x00dev, "Using incomplete support for " \
-+					       "external PA\n");
 +			reg = rt2800_register_read(rt2x00dev, RF_CONTROL3);
 +			reg |= 0x00000101;
 +			rt2800_register_write(rt2x00dev, RF_CONTROL3, reg);
@@ -76,7 +94,7 @@ Signed-off-by: Tomislav Po=C5=BEega <pozega.tomislav@gmail.com>
  	bbp = rt2800_bbp_read(rt2x00dev, 4);
  	rt2x00_set_field8(&bbp, BBP4_BANDWIDTH, 2 * conf_is_ht40(conf));
  	rt2800_bbp_write(rt2x00dev, 4, bbp);
-@@ -9559,7 +9598,8 @@ static int rt2800_init_eeprom(struct rt2
+@@ -9566,7 +9603,8 @@ static int rt2800_init_eeprom(struct rt2
  	 */
  	eeprom = rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1);
  
@@ -86,19 +104,19 @@ Signed-off-by: Tomislav Po=C5=BEega <pozega.tomislav@gmail.com>
  		if (rt2x00_get_field16(eeprom,
  		    EEPROM_NIC_CONF1_EXTERNAL_TX0_PA_3352))
  		    __set_bit(CAPABILITY_EXTERNAL_PA_TX0,
-@@ -9570,6 +9610,18 @@ static int rt2800_init_eeprom(struct rt2
+@@ -9577,6 +9615,18 @@ static int rt2800_init_eeprom(struct rt2
  			      &rt2x00dev->cap_flags);
  	}
  
 +	eeprom = rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF2);
 +
 +	if (rt2x00_rt(rt2x00dev, RT6352) && eeprom != 0 && eeprom != 0xffff) {
-+		if (rt2x00_get_field16(eeprom,
-+		    EEPROM_NIC_CONF2_EXTERNAL_PA)) {
-+		    __set_bit(CAPABILITY_EXTERNAL_PA_TX0,
-+			      &rt2x00dev->cap_flags);
-+		    __set_bit(CAPABILITY_EXTERNAL_PA_TX1,
-+			      &rt2x00dev->cap_flags);
++		if (!rt2x00_get_field16(eeprom,
++					EEPROM_NIC_CONF2_EXTERNAL_PA)) {
++			__clear_bit(CAPABILITY_EXTERNAL_PA_TX0,
++				    &rt2x00dev->cap_flags);
++			__clear_bit(CAPABILITY_EXTERNAL_PA_TX1,
++				    &rt2x00dev->cap_flags);
 +		}
 +	}
 +
diff --git a/package/kernel/mac80211/patches/rt2x00/004-rt2x00-move-up-and-reuse-busy-wait-functions.patch b/package/kernel/mac80211/patches/rt2x00/004-rt2x00-move-up-and-reuse-busy-wait-functions.patch
new file mode 100644
index 0000000000..da453074a1
--- /dev/null
+++ b/package/kernel/mac80211/patches/rt2x00/004-rt2x00-move-up-and-reuse-busy-wait-functions.patch
@@ -0,0 +1,178 @@
+From patchwork Sat Sep 17 20:27:10 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979245
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:27:10 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 04/16] rt2x00: move up and reuse busy wait functions
+Message-ID: 
+ <3fdb9dc15e76a9f9c1948b4a3a1308a7a5677bb8.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+Move bbp_ready and rf_ready busy wait functions up in the code so they
+can more easily be used. Allow specifying register mask in rf_ready
+function which is useful for calibration routines which will be added
+in follow-up commits.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 99 +++++++++----------
+ 1 file changed, 46 insertions(+), 53 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -2143,6 +2143,48 @@ void rt2800_config_erp(struct rt2x00_dev
+ }
+ EXPORT_SYMBOL_GPL(rt2800_config_erp);
+ 
++static int rt2800_wait_bbp_rf_ready(struct rt2x00_dev *rt2x00dev,
++				    const struct rt2x00_field32 mask)
++{
++	unsigned int i;
++	u32 reg;
++
++	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
++		reg = rt2800_register_read(rt2x00dev, MAC_STATUS_CFG);
++		if (!rt2x00_get_field32(reg, mask))
++			return 0;
++
++		udelay(REGISTER_BUSY_DELAY);
++	}
++
++	rt2x00_err(rt2x00dev, "BBP/RF register access failed, aborting\n");
++	return -EACCES;
++}
++
++static int rt2800_wait_bbp_ready(struct rt2x00_dev *rt2x00dev)
++{
++	unsigned int i;
++	u8 value;
++
++	/*
++	 * BBP was enabled after firmware was loaded,
++	 * but we need to reactivate it now.
++	 */
++	rt2800_register_write(rt2x00dev, H2M_BBP_AGENT, 0);
++	rt2800_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);
++	msleep(1);
++
++	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
++		value = rt2800_bbp_read(rt2x00dev, 0);
++		if ((value != 0xff) && (value != 0x00))
++			return 0;
++		udelay(REGISTER_BUSY_DELAY);
++	}
++
++	rt2x00_err(rt2x00dev, "BBP register access failed, aborting\n");
++	return -EACCES;
++}
++
+ static void rt2800_config_3572bt_ant(struct rt2x00_dev *rt2x00dev)
+ {
+ 	u32 reg;
+@@ -3799,10 +3841,9 @@ static void rt2800_config_alc(struct rt2
+ 			      struct ieee80211_channel *chan,
+ 			      int power_level) {
+ 	u16 eeprom, target_power, max_power;
+-	u32 mac_sys_ctrl, mac_status;
++	u32 mac_sys_ctrl;
+ 	u32 reg;
+ 	u8 bbp;
+-	int i;
+ 
+ 	/* hardware unit is 0.5dBm, limited to 23.5dBm */
+ 	power_level *= 2;
+@@ -3838,16 +3879,8 @@ static void rt2800_config_alc(struct rt2
+ 	/* Disable Tx/Rx */
+ 	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, 0);
+ 	/* Check MAC Tx/Rx idle */
+-	for (i = 0; i < 10000; i++) {
+-		mac_status = rt2800_register_read(rt2x00dev, MAC_STATUS_CFG);
+-		if (mac_status & 0x3)
+-			usleep_range(50, 200);
+-		else
+-			break;
+-	}
+-
+-	if (i == 10000)
+-		rt2x00_warn(rt2x00dev, "Wait MAC Status to MAX !!!\n");
++	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY)))
++		rt2x00_warn(rt2x00dev, "RF busy while configuring ALC\n");
+ 
+ 	if (chan->center_freq > 2457) {
+ 		bbp = rt2800_bbp_read(rt2x00dev, 30);
+@@ -6249,46 +6282,6 @@ static int rt2800_init_registers(struct
+ 	return 0;
+ }
+ 
+-static int rt2800_wait_bbp_rf_ready(struct rt2x00_dev *rt2x00dev)
+-{
+-	unsigned int i;
+-	u32 reg;
+-
+-	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
+-		reg = rt2800_register_read(rt2x00dev, MAC_STATUS_CFG);
+-		if (!rt2x00_get_field32(reg, MAC_STATUS_CFG_BBP_RF_BUSY))
+-			return 0;
+-
+-		udelay(REGISTER_BUSY_DELAY);
+-	}
+-
+-	rt2x00_err(rt2x00dev, "BBP/RF register access failed, aborting\n");
+-	return -EACCES;
+-}
+-
+-static int rt2800_wait_bbp_ready(struct rt2x00_dev *rt2x00dev)
+-{
+-	unsigned int i;
+-	u8 value;
+-
+-	/*
+-	 * BBP was enabled after firmware was loaded,
+-	 * but we need to reactivate it now.
+-	 */
+-	rt2800_register_write(rt2x00dev, H2M_BBP_AGENT, 0);
+-	rt2800_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);
+-	msleep(1);
+-
+-	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
+-		value = rt2800_bbp_read(rt2x00dev, 0);
+-		if ((value != 0xff) && (value != 0x00))
+-			return 0;
+-		udelay(REGISTER_BUSY_DELAY);
+-	}
+-
+-	rt2x00_err(rt2x00dev, "BBP register access failed, aborting\n");
+-	return -EACCES;
+-}
+ 
+ static void rt2800_bbp4_mac_if_ctrl(struct rt2x00_dev *rt2x00dev)
+ {
+@@ -9110,7 +9103,7 @@ int rt2800_enable_radio(struct rt2x00_de
+ 	/*
+ 	 * Wait BBP/RF to wake up.
+ 	 */
+-	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev)))
++	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY)))
+ 		return -EIO;
+ 
+ 	/*
diff --git a/package/kernel/mac80211/patches/rt2x00/982-rt2x00-add-rf-self-txdc-calibration.patch b/package/kernel/mac80211/patches/rt2x00/005-rt2x00-add-RF-self-TXDC-calibration-for-MT7620.patch
similarity index 51%
rename from package/kernel/mac80211/patches/rt2x00/982-rt2x00-add-rf-self-txdc-calibration.patch
rename to package/kernel/mac80211/patches/rt2x00/005-rt2x00-add-RF-self-TXDC-calibration-for-MT7620.patch
index 6be847478e..4e98d6a375 100644
--- a/package/kernel/mac80211/patches/rt2x00/982-rt2x00-add-rf-self-txdc-calibration.patch
+++ b/package/kernel/mac80211/patches/rt2x00/005-rt2x00-add-RF-self-TXDC-calibration-for-MT7620.patch
@@ -1,6 +1,48 @@
+From patchwork Sat Sep 17 20:27:26 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 8bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979246
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:27:26 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 05/16] rt2x00: add RF self TXDC calibration for MT7620
+Message-ID: 
+ <dbb6e5a0c12d6101477bd09e83253091d21512c9.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+From: Tomislav Požega <pozega.tomislav@gmail.com>
+
+Add TX self calibration based on mtk driver.
+
+Signed-off-by: Tomislav Požega <pozega.tomislav@gmail.com>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
+---
+v2: use ++i instead of i = i + 1 in loops
+
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 48 +++++++++++++++++++
+ 1 file changed, 48 insertions(+)
+
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -8419,6 +8419,56 @@ static void rt2800_init_rfcsr_5592(struc
+@@ -8428,6 +8428,53 @@ static void rt2800_init_rfcsr_5592(struc
  	rt2800_led_open_drain_enable(rt2x00dev);
  }
  
@@ -10,7 +52,6 @@
 +	u32 mac0518, mac051c, mac0528, mac052c;
 +	u8 i;
 +
-+	rt2x00_info(rt2x00dev, "RF Tx self calibration start\n");
 +	mac0518 = rt2800_register_read(rt2x00dev, RF_CONTROL0);
 +	mac051c = rt2800_register_read(rt2x00dev, RF_BYPASS0);
 +	mac0528 = rt2800_register_read(rt2x00dev, RF_CONTROL2);
@@ -27,19 +68,19 @@
 +	rfb7r1_org = rt2800_rfcsr_read_bank(rt2x00dev, 7, 1);
 +
 +	rt2800_rfcsr_write_bank(rt2x00dev, 5, 1, 0x4);
-+	for (i = 0; i < 100; i = i + 1) {
-+		udelay(50);
++	for (i = 0; i < 100; ++i) {
++		usleep_range(50, 100);
 +		rfvalue = rt2800_rfcsr_read_bank(rt2x00dev, 5, 1);
-+		if((rfvalue & 0x04) != 0x4)
++		if ((rfvalue & 0x04) != 0x4)
 +			break;
 +	}
 +	rt2800_rfcsr_write_bank(rt2x00dev, 5, 1, rfb5r1_org);
 +
 +	rt2800_rfcsr_write_bank(rt2x00dev, 7, 1, 0x4);
-+	for (i = 0; i < 100; i = i + 1) {
-+		udelay(50);
++	for (i = 0; i < 100; ++i) {
++		usleep_range(50, 100);
 +		rfvalue = rt2800_rfcsr_read_bank(rt2x00dev, 7, 1);
-+		if((rfvalue & 0x04) != 0x4)
++		if ((rfvalue & 0x04) != 0x4)
 +			break;
 +	}
 +	rt2800_rfcsr_write_bank(rt2x00dev, 7, 1, rfb7r1_org);
@@ -50,14 +91,12 @@
 +	rt2800_register_write(rt2x00dev, RF_BYPASS0, mac051c);
 +	rt2800_register_write(rt2x00dev, RF_CONTROL2, mac0528);
 +	rt2800_register_write(rt2x00dev, RF_BYPASS2, mac052c);
-+
-+	rt2x00_info(rt2x00dev, "RF Tx self calibration end\n");
 +}
 +
  static void rt2800_bbp_core_soft_reset(struct rt2x00_dev *rt2x00dev,
  				       bool set_bw, bool is_ht40)
  {
-@@ -9026,6 +9076,7 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -9035,6 +9082,7 @@ static void rt2800_init_rfcsr_6352(struc
  	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
  	rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
  
diff --git a/package/kernel/mac80211/patches/rt2x00/983-rt2x00-add-r-calibration.patch b/package/kernel/mac80211/patches/rt2x00/006-rt2x00-add-r-calibration-for-MT7620.patch
similarity index 66%
rename from package/kernel/mac80211/patches/rt2x00/983-rt2x00-add-r-calibration.patch
rename to package/kernel/mac80211/patches/rt2x00/006-rt2x00-add-r-calibration-for-MT7620.patch
index 3ed0ff7ef5..7c69970166 100644
--- a/package/kernel/mac80211/patches/rt2x00/983-rt2x00-add-r-calibration.patch
+++ b/package/kernel/mac80211/patches/rt2x00/006-rt2x00-add-r-calibration-for-MT7620.patch
@@ -1,14 +1,68 @@
+From patchwork Sat Sep 17 20:27:41 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 8bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979247
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:27:41 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 06/16] rt2x00: add r calibration for MT7620
+Message-ID: 
+ <e0c34f233089bec4eb73826bc4f512166ee25934.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+From: Tomislav Požega <pozega.tomislav@gmail.com>
+
+Add r calibration code as found in mtk driver.
+
+Signed-off-by: Tomislav Požega <pozega.tomislav@gmail.com>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
+---
+v2: use rt2800_wait_bbp_rf_ready()
+
+ drivers/net/wireless/ralink/rt2x00/rt2800.h   |   2 +
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 133 ++++++++++++++++++
+ 2 files changed, 135 insertions(+)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
+@@ -1016,6 +1016,8 @@
+  */
+ #define MAC_STATUS_CFG			0x1200
+ #define MAC_STATUS_CFG_BBP_RF_BUSY	FIELD32(0x00000003)
++#define MAC_STATUS_CFG_BBP_RF_BUSY_TX	FIELD32(0x00000001)
++#define MAC_STATUS_CFG_BBP_RF_BUSY_RX	FIELD32(0x00000002)
+ 
+ /*
+  * PWR_PIN_CFG:
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -8469,6 +8469,155 @@ static void rt2800_rf_self_txdc_cal(stru
- 	rt2x00_info(rt2x00dev, "RF Tx self calibration end\n");
+@@ -8475,6 +8475,138 @@ static void rt2800_rf_self_txdc_cal(stru
+ 	rt2800_register_write(rt2x00dev, RF_BYPASS2, mac052c);
  }
  
 +static int rt2800_calcrcalibrationcode(struct rt2x00_dev *rt2x00dev, int d1, int d2)
 +{
-+	int calcode;
-+	calcode = ((d2 - d1) * 1000) / 43;
-+	if ((calcode%10) >= 5)
++	int calcode = ((d2 - d1) * 1000) / 43;
++
++	if ((calcode % 10) >= 5)
 +		calcode += 10;
 +	calcode = (calcode / 10);
 +
@@ -28,8 +82,7 @@
 +	char d1 = 0, d2 = 0;
 +	u8 rfvalue;
 +	u32 MAC_RF_BYPASS0, MAC_RF_CONTROL0, MAC_PWR_PIN_CFG;
-+	u32 maccfg, macstatus;
-+	int i;
++	u32 maccfg;
 +
 +	saverfb0r1 = rt2800_rfcsr_read_bank(rt2x00dev, 0, 1);
 +	saverfb0r34 = rt2800_rfcsr_read_bank(rt2x00dev, 0, 34);
@@ -53,30 +106,14 @@
 +	maccfg &= (~0x04);
 +	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, maccfg);
 +
-+	for (i = 0; i < 10000; i++) {
-+		macstatus = rt2800_register_read(rt2x00dev, MAC_STATUS_CFG);
-+		if (macstatus & 0x1)
-+			udelay(50);
-+		else
-+			break;
-+	}
-+
-+	if (i == 10000)
++	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY_TX)))
 +		rt2x00_warn(rt2x00dev, "Wait MAC Tx Status to MAX !!!\n");
 +
 +	maccfg = rt2800_register_read(rt2x00dev, MAC_SYS_CTRL);
 +	maccfg &= (~0x04);
 +	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, maccfg);
 +
-+	for (i = 0; i < 10000; i++) {
-+		macstatus = rt2800_register_read(rt2x00dev, MAC_STATUS_CFG);
-+		if (macstatus & 0x2)
-+			udelay(50);
-+		else
-+			break;
-+		}
-+
-+	if (i == 10000)
++	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY_RX)))
 +		rt2x00_warn(rt2x00dev, "Wait MAC Rx Status to MAX !!!\n");
 +
 +	rfvalue = (MAC_RF_BYPASS0 | 0x3004);
@@ -98,7 +135,7 @@
 +
 +	rt2800_bbp_write(rt2x00dev, 47, 0x04);
 +	rt2800_bbp_write(rt2x00dev, 22, 0x80);
-+	udelay(100);
++	usleep_range(100, 200);
 +	bytevalue = rt2800_bbp_read(rt2x00dev, 49);
 +	if (bytevalue > 128)
 +		d1 = bytevalue - 256;
@@ -108,7 +145,7 @@
 +	rt2800_rfcsr_write_bank(rt2x00dev, 0, 35, 0x01);
 +
 +	rt2800_bbp_write(rt2x00dev, 22, 0x80);
-+	udelay(100);
++	usleep_range(100, 200);
 +	bytevalue = rt2800_bbp_read(rt2x00dev, 49);
 +	if (bytevalue > 128)
 +		d2 = bytevalue - 256;
@@ -156,7 +193,7 @@
  static void rt2800_bbp_core_soft_reset(struct rt2x00_dev *rt2x00dev,
  				       bool set_bw, bool is_ht40)
  {
-@@ -9076,6 +9225,7 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -9082,6 +9214,7 @@ static void rt2800_init_rfcsr_6352(struc
  	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
  	rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
  
diff --git a/package/kernel/mac80211/patches/rt2x00/984-rt2x00-add-rxdcoc-calibration.patch b/package/kernel/mac80211/patches/rt2x00/007-rt2x00-add-RXDCOC-calibration-for-MT7620.patch
similarity index 50%
rename from package/kernel/mac80211/patches/rt2x00/984-rt2x00-add-rxdcoc-calibration.patch
rename to package/kernel/mac80211/patches/rt2x00/007-rt2x00-add-RXDCOC-calibration-for-MT7620.patch
index 77be986d18..8da41e875a 100644
--- a/package/kernel/mac80211/patches/rt2x00/984-rt2x00-add-rxdcoc-calibration.patch
+++ b/package/kernel/mac80211/patches/rt2x00/007-rt2x00-add-RXDCOC-calibration-for-MT7620.patch
@@ -1,13 +1,54 @@
+From patchwork Sat Sep 17 20:27:56 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 8bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979248
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:27:56 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 07/16] rt2x00: add RXDCOC calibration for MT7620
+Message-ID: 
+ <850b30f652e88de30d79e968af4eb47aa5bc2511.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+From: Tomislav Požega <pozega.tomislav@gmail.com>
+
+Add RXDCOC calibration code from mtk driver.
+
+Signed-off-by: Tomislav Požega <pozega.tomislav@gmail.com>
+[fixed typo reported by Serge Vasilugin <vasilugin@yandex.ru>]
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 60 +++++++++++++++++++
+ 1 file changed, 60 insertions(+)
+
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -8618,6 +8618,70 @@ static void rt2800_r_calibration(struct
+@@ -8607,6 +8607,65 @@ static void rt2800_r_calibration(struct
  	rt2800_register_write(rt2x00dev, PWR_PIN_CFG, MAC_PWR_PIN_CFG);
  }
  
 +static void rt2800_rxdcoc_calibration(struct rt2x00_dev *rt2x00dev)
 +{
 +	u8 bbpreg = 0;
-+	u32 macvalue = 0, macvalue1 = 0;
++	u32 macvalue = 0;
 +	u8 saverfb0r2, saverfb5r4, saverfb7r4, rfvalue;
 +	int i;
 +
@@ -24,15 +65,10 @@
 +	macvalue = rt2800_register_read(rt2x00dev, MAC_SYS_CTRL);
 +	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, 0x8);
 +
-+	for (i = 0; i < 10000; i++) {
-+		macvalue1 = rt2800_register_read(rt2x00dev, MAC_STATUS_CFG);
-+		if (macvalue1 & 0x1)
-+			udelay(50);
-+		else
-+			break;
-+	}
++	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY_TX)))
++		rt2x00_warn(rt2x00dev, "RF TX busy in RX RXDCOC calibration\n");
 +
-+	saverfb5r4 = rt2800_rfcsr_read_bank(rt2x00dev, 5, 0);
++	saverfb5r4 = rt2800_rfcsr_read_bank(rt2x00dev, 5, 4);
 +	saverfb7r4 = rt2800_rfcsr_read_bank(rt2x00dev, 7, 4);
 +	saverfb5r4 = saverfb5r4 & (~0x40);
 +	saverfb7r4 = saverfb7r4 & (~0x40);
@@ -49,9 +85,9 @@
 +
 +	for (i = 0; i < 10000; i++) {
 +		bbpreg = rt2800_bbp_read(rt2x00dev, 159);
-+		if ((bbpreg & 0x40)==0)
++		if ((bbpreg & 0x40) == 0)
 +			break;
-+		udelay(50);
++		usleep_range(50, 100);
 +	}
 +
 +	bbpreg = rt2800_bbp_read(rt2x00dev, 159);
@@ -71,7 +107,7 @@
  static void rt2800_bbp_core_soft_reset(struct rt2x00_dev *rt2x00dev,
  				       bool set_bw, bool is_ht40)
  {
-@@ -9227,6 +9291,7 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -9216,6 +9275,7 @@ static void rt2800_init_rfcsr_6352(struc
  
  	rt2800_r_calibration(rt2x00dev);
  	rt2800_rf_self_txdc_cal(rt2x00dev);
diff --git a/package/kernel/mac80211/patches/rt2x00/985-rt2x00-add-rxiq-calibration.patch b/package/kernel/mac80211/patches/rt2x00/008-rt2x00-add-RXIQ-calibration-for-MT7620.patch
similarity index 63%
rename from package/kernel/mac80211/patches/rt2x00/985-rt2x00-add-rxiq-calibration.patch
rename to package/kernel/mac80211/patches/rt2x00/008-rt2x00-add-RXIQ-calibration-for-MT7620.patch
index 7352ad036c..dc516da43a 100644
--- a/package/kernel/mac80211/patches/rt2x00/985-rt2x00-add-rxiq-calibration.patch
+++ b/package/kernel/mac80211/patches/rt2x00/008-rt2x00-add-RXIQ-calibration-for-MT7620.patch
@@ -1,17 +1,62 @@
+From patchwork Sat Sep 17 20:28:10 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 8bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979249
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:28:10 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 08/16] rt2x00: add RXIQ calibration for MT7620
+Message-ID: 
+ <033a39a697d51f6df258acea4c33608e0944fe4c.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+From: Tomislav Požega <pozega.tomislav@gmail.com>
+
+Add RXIQ calibration found in mtk driver. With old openwrt builds this
+gets us ~8Mbps more of RX bandwidth (test with iPA/eLNA layout).
+
+Signed-off-by: Tomislav Požega <pozega.tomislav@gmail.com>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
+---
+v2: use rt2800_wait_bbp_rf_ready(), fix indentation
+
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 375 ++++++++++++++++++
+ 1 file changed, 375 insertions(+)
+
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -8682,6 +8682,384 @@ static void rt2800_rxdcoc_calibration(st
+@@ -8666,6 +8666,380 @@ static void rt2800_rxdcoc_calibration(st
  	rt2800_rfcsr_write_bank(rt2x00dev, 0, 2, saverfb0r2);
  }
  
-+static u32 rt2800_do_sqrt_accumulation(u32 si) {
++static u32 rt2800_do_sqrt_accumulation(u32 si)
++{
 +	u32 root, root_pre, bit;
 +	char i;
++
 +	bit = 1 << 15;
 +	root = 0;
 +	for (i = 15; i >= 0; i = i - 1) {
 +		root_pre = root + bit;
-+		if ((root_pre*root_pre) <= si)
++		if ((root_pre * root_pre) <= si)
 +			root = root_pre;
 +		bit = bit >> 1;
 +	}
@@ -19,7 +64,8 @@
 +	return root;
 +}
 +
-+static void rt2800_rxiq_calibration(struct rt2x00_dev *rt2x00dev) {
++static void rt2800_rxiq_calibration(struct rt2x00_dev *rt2x00dev)
++{
 +	u8 rfb0r1, rfb0r2, rfb0r42;
 +	u8 rfb4r0, rfb4r19;
 +	u8 rfb5r3, rfb5r4, rfb5r17, rfb5r18, rfb5r19, rfb5r20;
@@ -43,8 +89,8 @@
 +	u32 orig_RF_BYPASS1 = 0;
 +	u32 orig_RF_CONTROL3 = 0;
 +	u32 orig_RF_BYPASS3 = 0;
-+	u32 macstatus, bbpval1 = 0;
-+	u8 rf_vga_table[] = {0x20, 0x21, 0x22, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
++	u32 bbpval1 = 0;
++	static const u8 rf_vga_table[] = {0x20, 0x21, 0x22, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};
 +
 +	savemacsysctrl = rt2800_register_read(rt2x00dev, MAC_SYS_CTRL);
 +	orig_RF_CONTROL0 = rt2800_register_read(rt2x00dev, RF_CONTROL0);
@@ -59,16 +105,8 @@
 +
 +	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, 0x0);
 +
-+	for (i = 0; i < 10000; i++) {
-+		macstatus = rt2800_register_read(rt2x00dev, MAC_STATUS_CFG);
-+		if (macstatus & 0x3)
-+			udelay(50);
-+		else
-+			break;
-+	}
-+
-+	if (i == 10000)
-+		rt2x00_warn(rt2x00dev, "Wait MAC Status to MAX !!!\n");
++	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY)))
++		rt2x00_warn(rt2x00dev, "Timeout waiting for MAC status in RXIQ calibration\n");
 +
 +	bbpval = bbp4 & (~0x18);
 +	bbpval = bbp4 | 0x00;
@@ -165,7 +203,7 @@
 +			rt2800_register_write(rt2x00dev, RF_CONTROL0, 0x00001006);
 +			udelay(1);
 +
-+			bbpval = bbp1 & (~ 0x18);
++			bbpval = bbp1 & (~0x18);
 +			bbpval = bbpval | 0x00;
 +			rt2800_bbp_write(rt2x00dev, 1, bbpval);
 +
@@ -184,132 +222,133 @@
 +			rt2800_register_write(rt2x00dev, RF_CONTROL0, 0x00002006);
 +			udelay(1);
 +
-+			bbpval = bbp1 & (~ 0x18);
++			bbpval = bbp1 & (~0x18);
 +			bbpval = bbpval | 0x08;
 +			rt2800_bbp_write(rt2x00dev, 1, bbpval);
 +
 +			rt2800_bbp_dcoc_write(rt2x00dev, 1, 0x01);
 +		}
-+		udelay(500);
++		usleep_range(500, 1500);
 +
 +		vga_idx = 0;
-+			while (vga_idx < 11) {
-+				rt2800_rfcsr_write_dccal(rt2x00dev, 3, rf_vga_table[vga_idx]);
-+				rt2800_rfcsr_write_dccal(rt2x00dev, 4, rf_vga_table[vga_idx]);
-+
-+				rt2800_bbp_dcoc_write(rt2x00dev, 0, 0x93);
-+
-+				for (i = 0; i < 10000; i++) {
-+					bbpval = rt2800_bbp_read(rt2x00dev, 159);
-+					if ((bbpval & 0xff) == 0x93)
-+						udelay(50);
-+					else
-+						break;
-+					}
-+
-+				if ((bbpval & 0xff) == 0x93) {
-+					rt2x00_warn(rt2x00dev, "Fatal Error: Calibration doesn't finish");
-+					goto restore_value;
-+				}
++		while (vga_idx < 11) {
++			rt2800_rfcsr_write_dccal(rt2x00dev, 3, rf_vga_table[vga_idx]);
++			rt2800_rfcsr_write_dccal(rt2x00dev, 4, rf_vga_table[vga_idx]);
 +
-+				for (i = 0; i < 5; i++) {
-+					u32 bbptemp = 0;
-+					u8 value = 0;
-+					int result = 0;
-+
-+					rt2800_bbp_write(rt2x00dev, 158, 0x1e);
-+					rt2800_bbp_write(rt2x00dev, 159, i);
-+					rt2800_bbp_write(rt2x00dev, 158, 0x22);
-+					value = rt2800_bbp_read(rt2x00dev, 159);
-+					bbptemp = bbptemp + (value << 24);
-+					rt2800_bbp_write(rt2x00dev, 158, 0x21);
-+					value = rt2800_bbp_read(rt2x00dev, 159);
-+					bbptemp = bbptemp + (value << 16);
-+					rt2800_bbp_write(rt2x00dev, 158, 0x20);
-+					value = rt2800_bbp_read(rt2x00dev, 159);
-+					bbptemp = bbptemp + (value << 8);
-+					rt2800_bbp_write(rt2x00dev, 158, 0x1f);
-+					value = rt2800_bbp_read(rt2x00dev, 159);
-+					bbptemp = bbptemp + value;
-+
-+					if ((i < 2) && (bbptemp & 0x800000))
-+						result = (bbptemp & 0xffffff) - 0x1000000;
-+					else if (i == 4)
-+						result = bbptemp;
-+					else
-+						result = bbptemp;
-+
-+					if (i == 0)
-+						mi = result/4096;
-+					else if (i == 1)
-+						mq = result/4096;
-+					else if (i == 2)
-+						si = bbptemp/4096;
-+					else if (i == 3)
-+						sq = bbptemp/4096;
-+					else
-+						riq = result/4096;
-+				}
-+
-+				bbpval1 = si - mi*mi;
-+				rt2x00_dbg(rt2x00dev, "RXIQ si=%d, sq=%d, riq=%d, bbpval %d, vga_idx %d", si, sq, riq, bbpval1, vga_idx);
++			rt2800_bbp_dcoc_write(rt2x00dev, 0, 0x93);
 +
-+				if (bbpval1 >= (100*100))
++			for (i = 0; i < 10000; i++) {
++				bbpval = rt2800_bbp_read(rt2x00dev, 159);
++				if ((bbpval & 0xff) == 0x93)
++					usleep_range(50, 100);
++				else
 +					break;
++				}
 +
-+				if (bbpval1 <= 100)
-+					vga_idx = vga_idx + 9;
-+				else if (bbpval1 <= 158)
-+					vga_idx = vga_idx + 8;
-+				else if (bbpval1 <= 251)
-+					vga_idx = vga_idx + 7;
-+				else if (bbpval1 <= 398)
-+					vga_idx = vga_idx + 6;
-+				else if (bbpval1 <= 630)
-+					vga_idx = vga_idx + 5;
-+				else if (bbpval1 <= 1000)
-+					vga_idx = vga_idx + 4;
-+				else if (bbpval1 <= 1584)
-+					vga_idx = vga_idx + 3;
-+				else if (bbpval1 <= 2511)
-+					vga_idx = vga_idx + 2;
++			if ((bbpval & 0xff) == 0x93) {
++				rt2x00_warn(rt2x00dev, "Fatal Error: Calibration doesn't finish");
++				goto restore_value;
++			}
++			for (i = 0; i < 5; i++) {
++				u32 bbptemp = 0;
++				u8 value = 0;
++				int result = 0;
++
++				rt2800_bbp_write(rt2x00dev, 158, 0x1e);
++				rt2800_bbp_write(rt2x00dev, 159, i);
++				rt2800_bbp_write(rt2x00dev, 158, 0x22);
++				value = rt2800_bbp_read(rt2x00dev, 159);
++				bbptemp = bbptemp + (value << 24);
++				rt2800_bbp_write(rt2x00dev, 158, 0x21);
++				value = rt2800_bbp_read(rt2x00dev, 159);
++				bbptemp = bbptemp + (value << 16);
++				rt2800_bbp_write(rt2x00dev, 158, 0x20);
++				value = rt2800_bbp_read(rt2x00dev, 159);
++				bbptemp = bbptemp + (value << 8);
++				rt2800_bbp_write(rt2x00dev, 158, 0x1f);
++				value = rt2800_bbp_read(rt2x00dev, 159);
++				bbptemp = bbptemp + value;
++
++				if (i < 2 && (bbptemp & 0x800000))
++					result = (bbptemp & 0xffffff) - 0x1000000;
++				else if (i == 4)
++					result = bbptemp;
++				else
++					result = bbptemp;
++
++				if (i == 0)
++					mi = result / 4096;
++				else if (i == 1)
++					mq = result / 4096;
++				else if (i == 2)
++					si = bbptemp / 4096;
++				else if (i == 3)
++					sq = bbptemp / 4096;
 +				else
-+					vga_idx = vga_idx + 1;
++					riq = result / 4096;
 +			}
 +
-+		sigma_i = rt2800_do_sqrt_accumulation(100*(si - mi*mi));
-+		sigma_q = rt2800_do_sqrt_accumulation(100*(sq - mq*mq));
-+		r_iq = 10*(riq-(mi*mq));
++			bbpval1 = si - mi * mi;
++			rt2x00_dbg(rt2x00dev,
++				   "RXIQ si=%d, sq=%d, riq=%d, bbpval %d, vga_idx %d",
++				   si, sq, riq, bbpval1, vga_idx);
++
++			if (bbpval1 >= (100 * 100))
++				break;
++
++			if (bbpval1 <= 100)
++				vga_idx = vga_idx + 9;
++			else if (bbpval1 <= 158)
++				vga_idx = vga_idx + 8;
++			else if (bbpval1 <= 251)
++				vga_idx = vga_idx + 7;
++			else if (bbpval1 <= 398)
++				vga_idx = vga_idx + 6;
++			else if (bbpval1 <= 630)
++				vga_idx = vga_idx + 5;
++			else if (bbpval1 <= 1000)
++				vga_idx = vga_idx + 4;
++			else if (bbpval1 <= 1584)
++				vga_idx = vga_idx + 3;
++			else if (bbpval1 <= 2511)
++				vga_idx = vga_idx + 2;
++			else
++				vga_idx = vga_idx + 1;
++		}
++
++		sigma_i = rt2800_do_sqrt_accumulation(100 * (si - mi * mi));
++		sigma_q = rt2800_do_sqrt_accumulation(100 * (sq - mq * mq));
++		r_iq = 10 * (riq - (mi * mq));
 +
 +		rt2x00_dbg(rt2x00dev, "Sigma_i=%d, Sigma_q=%d, R_iq=%d", sigma_i, sigma_q, r_iq);
 +
-+		if (((sigma_i <= 1400 ) && (sigma_i >= 1000))
-+			&& ((sigma_i - sigma_q) <= 112)
-+			&& ((sigma_i - sigma_q) >= -112)
-+			&& ((mi <= 32) && (mi >= -32))
-+			&& ((mq <= 32) && (mq >= -32))) {
-+				r_iq = 10*(riq-(mi*mq));
-+				rt2x00_dbg(rt2x00dev, "RXIQ Sigma_i=%d, Sigma_q=%d, R_iq=%d\n", sigma_i, sigma_q, r_iq);
-+
-+				g_rx = (1000 * sigma_q) / sigma_i;
-+				g_imb = ((-2) * 128 * (1000 - g_rx)) / (1000 + g_rx);
-+				ph_rx = (r_iq * 2292) / (sigma_i * sigma_q);
-+				rt2x00_info(rt2x00dev, "RXIQ G_imb=%d, Ph_rx=%d\n", g_imb, ph_rx);
-+
-+				if ((ph_rx > 20) || (ph_rx < -20)) {
-+					ph_rx = 0;
-+					rt2x00_warn(rt2x00dev, "RXIQ calibration FAIL");
-+				}
++		if (sigma_i <= 1400 && sigma_i >= 1000 &&
++		    (sigma_i - sigma_q) <= 112 &&
++		    (sigma_i - sigma_q) >= -112 &&
++		    mi <= 32 && mi >= -32 &&
++		    mq <= 32 && mq >= -32) {
++			r_iq = 10 * (riq - (mi * mq));
++			rt2x00_dbg(rt2x00dev, "RXIQ Sigma_i=%d, Sigma_q=%d, R_iq=%d\n",
++				   sigma_i, sigma_q, r_iq);
++
++			g_rx = (1000 * sigma_q) / sigma_i;
++			g_imb = ((-2) * 128 * (1000 - g_rx)) / (1000 + g_rx);
++			ph_rx = (r_iq * 2292) / (sigma_i * sigma_q);
++
++			if (ph_rx > 20 || ph_rx < -20) {
++				ph_rx = 0;
++				rt2x00_warn(rt2x00dev, "RXIQ calibration FAIL");
++			}
 +
-+				if ((g_imb > 12) || (g_imb < -12)) {
-+					g_imb = 0;
-+					rt2x00_warn(rt2x00dev, "RXIQ calibration FAIL");
-+				}
++			if (g_imb > 12 || g_imb < -12) {
++				g_imb = 0;
++				rt2x00_warn(rt2x00dev, "RXIQ calibration FAIL");
 +			}
-+		else {
++		} else {
 +			g_imb = 0;
 +			ph_rx = 0;
-+			rt2x00_dbg(rt2x00dev, "RXIQ Sigma_i=%d, Sigma_q=%d, R_iq=%d\n", sigma_i, sigma_q, r_iq);
++			rt2x00_dbg(rt2x00dev, "RXIQ Sigma_i=%d, Sigma_q=%d, R_iq=%d\n",
++				   sigma_i, sigma_q, r_iq);
 +			rt2x00_warn(rt2x00dev, "RXIQ calibration FAIL");
 +		}
 +
@@ -385,7 +424,7 @@
  static void rt2800_bbp_core_soft_reset(struct rt2x00_dev *rt2x00dev,
  				       bool set_bw, bool is_ht40)
  {
-@@ -9294,6 +9672,7 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -9278,6 +9652,7 @@ static void rt2800_init_rfcsr_6352(struc
  	rt2800_rxdcoc_calibration(rt2x00dev);
  	rt2800_bw_filter_calibration(rt2x00dev, true);
  	rt2800_bw_filter_calibration(rt2x00dev, false);
diff --git a/package/kernel/mac80211/patches/rt2x00/009-rt2x00-don-t-run-Rt5592-IQ-calibration-on-MT7620.patch b/package/kernel/mac80211/patches/rt2x00/009-rt2x00-don-t-run-Rt5592-IQ-calibration-on-MT7620.patch
new file mode 100644
index 0000000000..6b27f6a705
--- /dev/null
+++ b/package/kernel/mac80211/patches/rt2x00/009-rt2x00-don-t-run-Rt5592-IQ-calibration-on-MT7620.patch
@@ -0,0 +1,52 @@
+From patchwork Sat Sep 17 20:28:29 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979250
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:28:29 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 09/16] rt2x00: don't run Rt5592 IQ calibration on MT7620
+Message-ID: 
+ <31a1c34ddbd296b82f38c18c9ae7339059215fdc.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+The function rt2800_iq_calibrate is intended for Rt5592 only.
+Don't call it for MT7620 which has it's own calibration functions.
+
+Reported-by: Serge Vasilugin <vasilugin@yandex.ru>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+v2: test for RT5592 instead of !RT6352
+
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -4398,7 +4398,8 @@ static void rt2800_config_channel(struct
+ 		reg = (rf->channel <= 14 ? 0x1c : 0x24) + 2*rt2x00dev->lna_gain;
+ 		rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, reg);
+ 
+-		rt2800_iq_calibrate(rt2x00dev, rf->channel);
++		if (rt2x00_rt(rt2x00dev, RT5592))
++			rt2800_iq_calibrate(rt2x00dev, rf->channel);
+ 	}
+ 
+ 	if (rt2x00_rt(rt2x00dev, RT6352)) {
diff --git a/package/kernel/mac80211/patches/rt2x00/986-rt2x00-add-TX-LOFT-calibration.patch b/package/kernel/mac80211/patches/rt2x00/010-rt2x00-add-TX-LOFT-calibration-for-MT7620.patch
similarity index 84%
rename from package/kernel/mac80211/patches/rt2x00/986-rt2x00-add-TX-LOFT-calibration.patch
rename to package/kernel/mac80211/patches/rt2x00/010-rt2x00-add-TX-LOFT-calibration-for-MT7620.patch
index fe0961baa7..bb01ff1dca 100644
--- a/package/kernel/mac80211/patches/rt2x00/986-rt2x00-add-TX-LOFT-calibration.patch
+++ b/package/kernel/mac80211/patches/rt2x00/010-rt2x00-add-TX-LOFT-calibration-for-MT7620.patch
@@ -1,10 +1,56 @@
+From patchwork Sat Sep 17 20:28:43 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 8bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979251
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:28:43 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 10/16] rt2x00: add TX LOFT calibration for MT7620
+Message-ID: 
+ <d9295a9138a1f552b648aacb84e1419d38f5c896.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+From: Tomislav Požega <pozega.tomislav@gmail.com>
+
+Add TX LOFT calibration from mtk driver.
+
+Signed-off-by: Tomislav Požega <pozega.tomislav@gmail.com>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+v2: use helper functions, make tables static const, remove useless
+    debug prints
+v3: don't export function not used anywhere else
+Reported-by: kernel test robot <lkp@intel.com>
+
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 902 ++++++++++++++++++
+ .../net/wireless/ralink/rt2x00/rt2800lib.h    |  10 +
+ 2 files changed, 912 insertions(+)
+
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -9060,6 +9060,943 @@ restore_value:
+@@ -9041,6 +9041,907 @@ restore_value:
  	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, savemacsysctrl);
  }
  
-+static void rt2800_rf_configstore(struct rt2x00_dev *rt2x00dev, rf_reg_pair rf_reg_record[][13], u8 chain)
++static void rt2800_rf_configstore(struct rt2x00_dev *rt2x00dev,
++				  struct rf_reg_pair rf_reg_record[][13], u8 chain)
 +{
 +	u8 rfvalue = 0;
 +
@@ -116,13 +162,11 @@
 +		rf_reg_record[CHAIN_1][12].value = rfvalue;
 +	} else {
 +		rt2x00_warn(rt2x00dev, "Unknown chain = %u\n", chain);
-+		return;
 +	}
-+
-+	return;
 +}
 +
-+static void rt2800_rf_configrecover(struct rt2x00_dev *rt2x00dev, rf_reg_pair rf_record[][13])
++static void rt2800_rf_configrecover(struct rt2x00_dev *rt2x00dev,
++				    struct rf_reg_pair rf_record[][13])
 +{
 +	u8 chain_index = 0, record_index = 0;
 +	u8 bank = 0, rf_register = 0, value = 0;
@@ -133,11 +177,10 @@
 +			rf_register = rf_record[chain_index][record_index].reg;
 +			value = rf_record[chain_index][record_index].value;
 +			rt2800_rfcsr_write_bank(rt2x00dev, bank, rf_register, value);
-+			rt2x00_dbg(rt2x00dev, "bank: %d, rf_register: %d, value: %x\n", bank, rf_register, value);
++			rt2x00_dbg(rt2x00dev, "bank: %d, rf_register: %d, value: %x\n",
++				   bank, rf_register, value);
 +		}
 +	}
-+
-+	return;
 +}
 +
 +static void rt2800_setbbptonegenerator(struct rt2x00_dev *rt2x00dev)
@@ -155,15 +198,13 @@
 +	rt2800_bbp_write(rt2x00dev, 159, 0x3F);
 +
 +	rt2800_bbp_write(rt2x00dev, 244, 0x40);
-+
-+	return;
 +}
 +
 +static u32 rt2800_do_fft_accumulation(struct rt2x00_dev *rt2x00dev, u8 tidx, u8 read_neg)
 +{
 +	u32 macvalue = 0;
 +	int fftout_i = 0, fftout_q = 0;
-+	u32 ptmp=0, pint = 0;
++	u32 ptmp = 0, pint = 0;
 +	u8 bbp = 0;
 +	u8 tidxi;
 +
@@ -173,7 +214,7 @@
 +	bbp = 0x9b;
 +
 +	while (bbp == 0x9b) {
-+		udelay(10);
++		usleep_range(10, 50);
 +		bbp = rt2800_bbp_read(rt2x00dev, 159);
 +		bbp = bbp & 0xff;
 +	}
@@ -218,10 +259,11 @@
 +	return pint;
 +}
 +
-+static u32 rt2800_read_fft_accumulation(struct rt2x00_dev *rt2x00dev, u8 tidx) {
++static u32 rt2800_read_fft_accumulation(struct rt2x00_dev *rt2x00dev, u8 tidx)
++{
 +	u32 macvalue = 0;
 +	int fftout_i = 0, fftout_q = 0;
-+	u32 ptmp=0, pint = 0;
++	u32 ptmp = 0, pint = 0;
 +
 +	rt2800_bbp_write(rt2x00dev, 158, 0xBA);
 +	rt2800_bbp_write(rt2x00dev, 159, tidx);
@@ -237,7 +279,6 @@
 +	ptmp = (fftout_i * fftout_i);
 +	ptmp = ptmp + (fftout_q * fftout_q);
 +	pint = ptmp;
-+	rt2x00_info(rt2x00dev, "I = %d,  Q = %d, power = %x\n", fftout_i, fftout_q, pint);
 +
 +	return pint;
 +}
@@ -251,18 +292,17 @@
 +	rt2800_bbp_write(rt2x00dev, 159, bbp);
 +
 +	if (ch_idx == 0)
-+		bbp = (iorq == 0) ? 0xb1: 0xb2;
++		bbp = (iorq == 0) ? 0xb1 : 0xb2;
 +	else
-+		bbp = (iorq == 0) ? 0xb8: 0xb9;
++		bbp = (iorq == 0) ? 0xb8 : 0xb9;
 +
 +	rt2800_bbp_write(rt2x00dev, 158, bbp);
 +	bbp = dc;
 +	rt2800_bbp_write(rt2x00dev, 159, bbp);
-+
-+	return;
 +}
 +
-+static void rt2800_loft_search(struct rt2x00_dev *rt2x00dev, u8 ch_idx, u8 alc_idx, u8 dc_result[][RF_ALC_NUM][2])
++static void rt2800_loft_search(struct rt2x00_dev *rt2x00dev, u8 ch_idx,
++			       u8 alc_idx, u8 dc_result[][RF_ALC_NUM][2])
 +{
 +	u32 p0 = 0, p1 = 0, pf = 0;
 +	char idx0 = 0, idx1 = 0;
@@ -276,8 +316,6 @@
 +
 +	for (bidx = 5; bidx >= 0; bidx--) {
 +		for (iorq = 0; iorq <= 1; iorq++) {
-+			rt2x00_dbg(rt2x00dev, "\n========================================================\n");
-+
 +			if (idxf[iorq] == 0x20) {
 +				idx0 = 0x20;
 +				p0 = pf;
@@ -288,16 +326,17 @@
 +				p0 = rt2800_do_fft_accumulation(rt2x00dev, 0x0A, 0);
 +			}
 +
-+			idx1 = idxf[iorq] + ((bidx == 5) ? 0 : ibit);
++			idx1 = idxf[iorq] + (bidx == 5 ? 0 : ibit);
 +			idx1 = idx1 & 0x3F;
 +			rt2800_write_dc(rt2x00dev, ch_idx, 0, iorq, idx1);
 +			p1 = rt2800_do_fft_accumulation(rt2x00dev, 0x0A, 0);
 +
-+			rt2x00_dbg(rt2x00dev, "alc=%u, IorQ=%u, idx_final=%2x\n", alc_idx, iorq, idxf[iorq]);
-+			rt2x00_dbg(rt2x00dev, "p0=%x, p1=%x, pf=%x, idx_0=%x, idx_1=%x, ibit=%x !\n", p0, p1, pf, idx0, idx1, ibit);
++			rt2x00_dbg(rt2x00dev, "alc=%u, IorQ=%u, idx_final=%2x\n",
++				   alc_idx, iorq, idxf[iorq]);
++			rt2x00_dbg(rt2x00dev, "p0=%x, p1=%x, pf=%x, idx_0=%x, idx_1=%x, ibit=%x\n",
++				   p0, p1, pf, idx0, idx1, ibit);
 +
-+			if ((bidx != 5) && (pf <= p0) && (pf < p1)) {
-+				pf = pf;
++			if (bidx != 5 && pf <= p0 && pf < p1) {
 +				idxf[iorq] = idxf[iorq];
 +			} else if (p0 < p1) {
 +				pf = p0;
@@ -306,17 +345,15 @@
 +				pf = p1;
 +				idxf[iorq] = idx1 & 0x3F;
 +			}
-+			rt2x00_dbg(rt2x00dev, "IorQ=%u, idx_final[%u]:%x, pf:%8x\n", iorq, iorq, idxf[iorq], pf);
++			rt2x00_dbg(rt2x00dev, "IorQ=%u, idx_final[%u]:%x, pf:%8x\n",
++				   iorq, iorq, idxf[iorq], pf);
 +
 +			rt2800_write_dc(rt2x00dev, ch_idx, 0, iorq, idxf[iorq]);
-+
 +		}
 +		ibit = ibit >> 1;
 +	}
 +	dc_result[ch_idx][alc_idx][0] = idxf[0];
 +	dc_result[ch_idx][alc_idx][1] = idxf[1];
-+
-+	return;
 +}
 +
 +static void rt2800_iq_search(struct rt2x00_dev *rt2x00dev, u8 ch_idx, u8 *ges, u8 *pes)
@@ -334,26 +371,25 @@
 +	u8 bbp = 0;
 +	char bidx;
 +
-+	rt2x00_info(rt2x00dev, "IQCalibration Start!\n");
 +	for (bidx = 5; bidx >= 1; bidx--) {
 +		for (gop = 0; gop < 2; gop++) {
-+			rt2x00_dbg(rt2x00dev, "\n========================================================\n");
-+
-+			if ((gop == 1) || (bidx < 4)) {
++			if (gop == 1 || bidx < 4) {
 +				if (gop == 0)
 +					iq_err = gerr;
 +				else
 +					iq_err = perr;
 +
 +				first_search = (gop == 0) ? (bidx == 3) : (bidx == 5);
-+				touch_neg_max = (gop) ? ((iq_err & 0x0F) == 0x08) : ((iq_err & 0x3F) == 0x20);
++				touch_neg_max = (gop) ? ((iq_err & 0x0F) == 0x08) :
++							((iq_err & 0x3F) == 0x20);
 +
 +				if (touch_neg_max) {
 +					p0 = pf;
 +					idx0 = iq_err;
 +				} else {
 +					idx0 = iq_err - ibit;
-+					bbp = (ch_idx == 0) ? ((gop == 0) ? 0x28 : 0x29): ((gop == 0) ? 0x46 : 0x47);
++					bbp = (ch_idx == 0) ? ((gop == 0) ? 0x28 : 0x29) :
++							      ((gop == 0) ? 0x46 : 0x47);
 +
 +					rt2800_bbp_write(rt2x00dev, 158, bbp);
 +					rt2800_bbp_write(rt2x00dev, 159, idx0);
@@ -364,26 +400,30 @@
 +				idx1 = iq_err + (first_search ? 0 : ibit);
 +				idx1 = (gop == 0) ? (idx1 & 0x0F) : (idx1 & 0x3F);
 +
-+				bbp = (ch_idx == 0) ? (gop == 0) ? 0x28 : 0x29 : (gop == 0) ? 0x46 : 0x47;
++				bbp = (ch_idx == 0) ? (gop == 0) ? 0x28 : 0x29 :
++				      (gop == 0) ? 0x46 : 0x47;
 +
 +				rt2800_bbp_write(rt2x00dev, 158, bbp);
 +				rt2800_bbp_write(rt2x00dev, 159, idx1);
 +
 +				p1 = rt2800_do_fft_accumulation(rt2x00dev, 0x14, 1);
 +
-+				rt2x00_dbg(rt2x00dev, "p0=%x, p1=%x, pwer_final=%x, idx0=%x, idx1=%x, iq_err=%x, gop=%d, ibit=%x !\n", p0, p1, pf, idx0, idx1, iq_err, gop, ibit);
-+
-+				if ((!first_search) && (pf <= p0) && (pf < p1)) {
-+					pf = pf;
-+				} else if (p0 < p1) {
-+					pf = p0;
-+					iq_err = idx0;
-+				} else {
-+					pf = p1;
-+					iq_err = idx1;
++				rt2x00_dbg(rt2x00dev,
++					   "p0=%x, p1=%x, pwer_final=%x, idx0=%x, idx1=%x, iq_err=%x, gop=%d, ibit=%x\n",
++					   p0, p1, pf, idx0, idx1, iq_err, gop, ibit);
++
++				if (!(!first_search && pf <= p0 && pf < p1)) {
++					if (p0 < p1) {
++						pf = p0;
++						iq_err = idx0;
++					} else {
++						pf = p1;
++						iq_err = idx1;
++					}
 +				}
 +
-+				bbp = (ch_idx == 0) ? (gop == 0) ? 0x28 : 0x29 : (gop == 0) ? 0x46 : 0x47;
++				bbp = (ch_idx == 0) ? (gop == 0) ? 0x28 : 0x29 :
++						      (gop == 0) ? 0x46 : 0x47;
 +
 +				rt2800_bbp_write(rt2x00dev, 158, bbp);
 +				rt2800_bbp_write(rt2x00dev, 159, iq_err);
@@ -393,8 +433,8 @@
 +				else
 +					perr = iq_err;
 +
-+				rt2x00_dbg(rt2x00dev, "IQCalibration pf=%8x (%2x, %2x) !\n", pf, gerr & 0x0F, perr & 0x3F);
-+
++				rt2x00_dbg(rt2x00dev, "IQCalibration pf=%8x (%2x, %2x) !\n",
++					   pf, gerr & 0x0F, perr & 0x3F);
 +			}
 +		}
 +
@@ -423,25 +463,21 @@
 +			rt2800_bbp_write(rt2x00dev, 159, pef & 0x3F);
 +
 +			p1 = rt2800_do_fft_accumulation(rt2x00dev, 0x14, 1);
-+			if ((gef == gsta) && (pef == psta)) {
++			if (gef == gsta && pef == psta) {
 +				pf = p1;
 +				gerr = gef;
 +				perr = pef;
-+			}
-+			else if (pf > p1){
++			} else if (pf > p1) {
 +				pf = p1;
 +				gerr = gef;
 +				perr = pef;
 +			}
-+			rt2x00_dbg(rt2x00dev, "Fine IQCalibration p1=%8x pf=%8x (%2x, %2x) !\n", p1, pf, gef & 0x0F, pef & 0x3F);
++			rt2x00_dbg(rt2x00dev, "Fine IQCalibration p1=%8x pf=%8x (%2x, %2x) !\n",
++				   p1, pf, gef & 0x0F, pef & 0x3F);
 +		}
 +
 +	ges[ch_idx] = gerr & 0x0F;
 +	pes[ch_idx] = perr & 0x3F;
-+
-+	rt2x00_info(rt2x00dev, "IQCalibration Done! CH = %u, (gain=%2x, phase=%2x)\n", ch_idx, gerr & 0x0F, perr & 0x3F);
-+
-+	return;
 +}
 +
 +static void rt2800_rf_aux_tx0_loopback(struct rt2x00_dev *rt2x00dev)
@@ -478,9 +514,9 @@
 +	rt2800_rfcsr_write_bank(rt2x00dev, 7, 20, 0x20);
 +}
 +
-+void rt2800_loft_iq_calibration(struct rt2x00_dev *rt2x00dev)
++static void rt2800_loft_iq_calibration(struct rt2x00_dev *rt2x00dev)
 +{
-+	rf_reg_pair rf_store[CHAIN_NUM][13];
++	struct rf_reg_pair rf_store[CHAIN_NUM][13];
 +	u32 macorg1 = 0;
 +	u32 macorg2 = 0;
 +	u32 macorg3 = 0;
@@ -489,7 +525,7 @@
 +	u32 orig528 = 0;
 +	u32 orig52c = 0;
 +
-+	u32 savemacsysctrl = 0, mtxcycle = 0;
++	u32 savemacsysctrl = 0;
 +	u32 macvalue = 0;
 +	u32 mac13b8 = 0;
 +	u32 p0 = 0, p1 = 0;
@@ -498,11 +534,8 @@
 +	u8 rfvalue;
 +	u8 loft_dc_search_result[CHAIN_NUM][RF_ALC_NUM][2];
 +	u8 ger[CHAIN_NUM], per[CHAIN_NUM];
-+	u8 rf_gain[] = {0x00, 0x01, 0x02, 0x04, 0x08, 0x0c};
-+	u8 rfvga_gain_table[] = {0x24, 0x25, 0x26, 0x27, 0x28, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3F};
 +
 +	u8 vga_gain[] = {14, 14};
-+	u8 bbp_2324gain[] = {0x16, 0x14, 0x12, 0x10, 0x0c, 0x08};
 +	u8 bbp = 0, ch_idx = 0, rf_alc_idx = 0, idx = 0;
 +	u8 bbpr30, rfb0r39, rfb0r42;
 +	u8 bbpr1;
@@ -510,6 +543,11 @@
 +	u8 bbpr241, bbpr242;
 +	u8 count_step;
 +
++	static const u8 rf_gain[] = {0x00, 0x01, 0x02, 0x04, 0x08, 0x0c};
++	static const u8 rfvga_gain_table[] = {0x24, 0x25, 0x26, 0x27, 0x28, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
++					      0x31, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3F};
++	static const u8 bbp_2324gain[] = {0x16, 0x14, 0x12, 0x10, 0x0c, 0x08};
++
 +	savemacsysctrl = rt2800_register_read(rt2x00dev, MAC_SYS_CTRL);
 +	macorg1 = rt2800_register_read(rt2x00dev, TX_PIN_CFG);
 +	macorg2 = rt2800_register_read(rt2x00dev, RF_CONTROL0);
@@ -524,29 +562,18 @@
 +	macvalue &= (~0x04);
 +	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, macvalue);
 +
-+	for (mtxcycle = 0; mtxcycle < 10000; mtxcycle++) {
-+		macvalue = rt2800_register_read(rt2x00dev, MAC_STATUS_CFG);
-+		if (macvalue & 0x01)
-+			udelay(50);
-+		else
-+			break;
-+	}
++	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY_TX)))
++		rt2x00_warn(rt2x00dev, "RF TX busy in LOFT IQ calibration\n");
 +
 +	macvalue = rt2800_register_read(rt2x00dev, MAC_SYS_CTRL);
 +	macvalue &= (~0x08);
 +	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, macvalue);
 +
-+	for (mtxcycle = 0; mtxcycle < 10000; mtxcycle++) {
-+		macvalue = rt2800_register_read(rt2x00dev, MAC_STATUS_CFG);
-+		if (macvalue & 0x02)
-+			udelay(50);
-+		else
-+			break;
-+	}
++	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY_RX)))
++		rt2x00_warn(rt2x00dev, "RF RX busy in LOFT IQ calibration\n");
 +
-+	for (ch_idx = 0; ch_idx < 2; ch_idx++) {
++	for (ch_idx = 0; ch_idx < 2; ch_idx++)
 +		rt2800_rf_configstore(rt2x00dev, rf_store, ch_idx);
-+	}
 +
 +	bbpr30 = rt2800_bbp_read(rt2x00dev, 30);
 +	rfb0r39 = rt2800_rfcsr_read_bank(rt2x00dev, 0, 39);
@@ -561,7 +588,7 @@
 +
 +	rt2800_setbbptonegenerator(rt2x00dev);
 +
-+	for (ch_idx = 0; ch_idx < 2; ch_idx ++) {
++	for (ch_idx = 0; ch_idx < 2; ch_idx++) {
 +		rt2800_bbp_write(rt2x00dev, 23, 0x00);
 +		rt2800_bbp_write(rt2x00dev, 24, 0x00);
 +		rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, 0x00);
@@ -571,18 +598,17 @@
 +		rt2800_register_write(rt2x00dev, 0x13b8, 0x10);
 +		udelay(1);
 +
-+		if (ch_idx == 0) {
++		if (ch_idx == 0)
 +			rt2800_rf_aux_tx0_loopback(rt2x00dev);
-+		} else {
++		else
 +			rt2800_rf_aux_tx1_loopback(rt2x00dev);
-+		}
++
 +		udelay(1);
 +
-+		if (ch_idx == 0) {
++		if (ch_idx == 0)
 +			rt2800_register_write(rt2x00dev, RF_CONTROL0, 0x00001004);
-+		} else {
++		else
 +			rt2800_register_write(rt2x00dev, RF_CONTROL0, 0x00002004);
-+		}
 +
 +		rt2800_bbp_write(rt2x00dev, 158, 0x05);
 +		rt2800_bbp_write(rt2x00dev, 159, 0x00);
@@ -608,7 +634,8 @@
 +
 +			if (rf_alc_idx == 0) {
 +				rt2800_write_dc(rt2x00dev, ch_idx, 0, 1, 0x21);
-+				for (;vga_gain[ch_idx] > 0;vga_gain[ch_idx] = vga_gain[ch_idx] - 2) {
++				for (; vga_gain[ch_idx] > 0;
++				     vga_gain[ch_idx] = vga_gain[ch_idx] - 2) {
 +					rfvalue = rfvga_gain_table[vga_gain[ch_idx]];
 +					rt2800_rfcsr_write_dccal(rt2x00dev, 3, rfvalue);
 +					rt2800_rfcsr_write_dccal(rt2x00dev, 4, rfvalue);
@@ -618,19 +645,19 @@
 +					rt2800_write_dc(rt2x00dev, ch_idx, 0, 0, 0x21);
 +					p1 = rt2800_do_fft_accumulation(rt2x00dev, 0x0A, 0);
 +					rt2x00_dbg(rt2x00dev, "LOFT AGC %d %d\n", p0, p1);
-+					if ((p0 < 7000*7000) && (p1 < (7000*7000))) {
++					if ((p0 < 7000 * 7000) && (p1 < (7000 * 7000)))
 +						break;
-+					}
 +				}
 +
 +				rt2800_write_dc(rt2x00dev, ch_idx, 0, 0, 0x00);
 +				rt2800_write_dc(rt2x00dev, ch_idx, 0, 1, 0x00);
 +
-+				rt2x00_dbg(rt2x00dev, "Used VGA %d %x\n",vga_gain[ch_idx], rfvga_gain_table[vga_gain[ch_idx]]);
++				rt2x00_dbg(rt2x00dev, "Used VGA %d %x\n", vga_gain[ch_idx],
++					   rfvga_gain_table[vga_gain[ch_idx]]);
 +
 +				if (vga_gain[ch_idx] < 0)
 +					vga_gain[ch_idx] = 0;
-+		 	}
++			}
 +
 +			rfvalue = rfvga_gain_table[vga_gain[ch_idx]];
 +
@@ -644,7 +671,7 @@
 +	for (rf_alc_idx = 0; rf_alc_idx < 3; rf_alc_idx++) {
 +		for (idx = 0; idx < 4; idx++) {
 +			rt2800_bbp_write(rt2x00dev, 158, 0xB0);
-+			bbp = (idx<<2) + rf_alc_idx;
++			bbp = (idx << 2) + rf_alc_idx;
 +			rt2800_bbp_write(rt2x00dev, 159, bbp);
 +			rt2x00_dbg(rt2x00dev, " ALC %2x,", bbp);
 +
@@ -705,8 +732,6 @@
 +	rt2800_register_write(rt2x00dev, RF_BYPASS2, orig52c);
 +	rt2800_register_write(rt2x00dev, 0x13b8, mac13b8);
 +
-+	rt2x00_info(rt2x00dev, "LOFT Calibration Done!\n");
-+
 +	savemacsysctrl = rt2800_register_read(rt2x00dev, MAC_SYS_CTRL);
 +	macorg1 = rt2800_register_read(rt2x00dev, TX_PIN_CFG);
 +	macorg2 = rt2800_register_read(rt2x00dev, RF_CONTROL0);
@@ -723,24 +748,16 @@
 +	macvalue = rt2800_register_read(rt2x00dev, MAC_SYS_CTRL);
 +	macvalue &= (~0x04);
 +	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, macvalue);
-+	for (mtxcycle = 0; mtxcycle < 10000; mtxcycle++) {
-+		macvalue = rt2800_register_read(rt2x00dev, MAC_STATUS_CFG);
-+		if (macvalue & 0x01)
-+			udelay(50);
-+		else
-+			break;
-+	}
++
++	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY_TX)))
++		rt2x00_warn(rt2x00dev, "RF TX busy in LOFT IQ calibration\n");
 +
 +	macvalue = rt2800_register_read(rt2x00dev, MAC_SYS_CTRL);
 +	macvalue &= (~0x08);
 +	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, macvalue);
-+	for (mtxcycle = 0; mtxcycle < 10000; mtxcycle++) {
-+		macvalue = rt2800_register_read(rt2x00dev, MAC_STATUS_CFG);
-+		if (macvalue & 0x02)
-+			udelay(50);
-+		else
-+			break;
-+	}
++
++	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY_RX)))
++		rt2x00_warn(rt2x00dev, "RF RX busy in LOFT IQ calibration\n");
 +
 +	if (test_bit(CAPABILITY_EXTERNAL_PA_TX0, &rt2x00dev->cap_flags)) {
 +		rt2800_register_write(rt2x00dev, RF_CONTROL3, 0x00000101);
@@ -776,9 +793,8 @@
 +
 +	rt2800_register_write(rt2x00dev, 0x13b8, 0x00000010);
 +
-+	for (ch_idx = 0; ch_idx < 2; ch_idx++) {
++	for (ch_idx = 0; ch_idx < 2; ch_idx++)
 +		rt2800_rf_configstore(rt2x00dev, rf_store, ch_idx);
-+	}
 +
 +	rt2800_rfcsr_write_dccal(rt2x00dev, 3, 0x3B);
 +	rt2800_rfcsr_write_dccal(rt2x00dev, 4, 0x3B);
@@ -788,7 +804,7 @@
 +	rt2800_bbp_write(rt2x00dev, 158, 0xB0);
 +	rt2800_bbp_write(rt2x00dev, 159, 0x80);
 +
-+	for (ch_idx = 0; ch_idx < 2; ch_idx ++) {
++	for (ch_idx = 0; ch_idx < 2; ch_idx++) {
 +		rt2800_bbp_write(rt2x00dev, 23, 0x00);
 +		rt2800_bbp_write(rt2x00dev, 24, 0x00);
 +
@@ -831,7 +847,7 @@
 +			count_step = 2;
 +		}
 +
-+		for (;vga_gain[ch_idx] < 19; vga_gain[ch_idx]=(vga_gain[ch_idx] + count_step)) {
++		for (; vga_gain[ch_idx] < 19; vga_gain[ch_idx] = (vga_gain[ch_idx] + count_step)) {
 +			rfvalue = rfvga_gain_table[vga_gain[ch_idx]];
 +			rt2800_rfcsr_write_dccal(rt2x00dev, 3, rfvalue);
 +			rt2800_rfcsr_write_dccal(rt2x00dev, 4, rfvalue);
@@ -840,37 +856,35 @@
 +			rt2800_bbp_write(rt2x00dev, 158, bbp);
 +			rt2800_bbp_write(rt2x00dev, 159, 0x00);
 +			p0 = rt2800_do_fft_accumulation(rt2x00dev, 0x14, 0);
-+			if (test_bit(CAPABILITY_EXTERNAL_PA_TX0, &rt2x00dev->cap_flags)) {
++			if (test_bit(CAPABILITY_EXTERNAL_PA_TX0, &rt2x00dev->cap_flags))
 +				p0_idx10 = rt2800_read_fft_accumulation(rt2x00dev, 0x0A);
-+			}
 +
 +			bbp = (ch_idx == 0) ? 0x29 : 0x47;
 +			rt2800_bbp_write(rt2x00dev, 158, bbp);
 +			rt2800_bbp_write(rt2x00dev, 159, 0x21);
 +			p1 = rt2800_do_fft_accumulation(rt2x00dev, 0x14, 0);
-+			if (test_bit(CAPABILITY_EXTERNAL_PA_TX1, &rt2x00dev->cap_flags)) {
++			if (test_bit(CAPABILITY_EXTERNAL_PA_TX1, &rt2x00dev->cap_flags))
 +				p1_idx10 = rt2800_read_fft_accumulation(rt2x00dev, 0x0A);
-+			}
 +
 +			rt2x00_dbg(rt2x00dev, "IQ AGC %d %d\n", p0, p1);
 +
 +			if (test_bit(CAPABILITY_EXTERNAL_PA_TX0, &rt2x00dev->cap_flags)) {
 +				rt2x00_dbg(rt2x00dev, "IQ AGC IDX 10 %d %d\n", p0_idx10, p1_idx10);
-+				if ((p0_idx10 > 7000*7000) || (p1_idx10 > 7000*7000)) {
-+					if (vga_gain[ch_idx]!=0)
-+						vga_gain[ch_idx] = vga_gain[ch_idx]-1;
++				if ((p0_idx10 > 7000 * 7000) || (p1_idx10 > 7000 * 7000)) {
++					if (vga_gain[ch_idx] != 0)
++						vga_gain[ch_idx] = vga_gain[ch_idx] - 1;
 +					break;
 +				}
 +			}
 +
-+			if ((p0 > 2500*2500) || (p1 > 2500*2500)) {
++			if ((p0 > 2500 * 2500) || (p1 > 2500 * 2500))
 +				break;
-+			}
 +		}
 +
 +		if (vga_gain[ch_idx] > 18)
 +			vga_gain[ch_idx] = 18;
-+		rt2x00_dbg(rt2x00dev, "Used VGA %d %x\n",vga_gain[ch_idx], rfvga_gain_table[vga_gain[ch_idx]]);
++		rt2x00_dbg(rt2x00dev, "Used VGA %d %x\n", vga_gain[ch_idx],
++			   rfvga_gain_table[vga_gain[ch_idx]]);
 +
 +		bbp = (ch_idx == 0) ? 0x29 : 0x47;
 +		rt2800_bbp_write(rt2x00dev, 158, bbp);
@@ -915,9 +929,8 @@
 +	rt2800_rfcsr_write_bank(rt2x00dev, 0, 39, rfb0r39);
 +	rt2800_rfcsr_write_bank(rt2x00dev, 0, 42, rfb0r42);
 +
-+	if (test_bit(CAPABILITY_EXTERNAL_PA_TX0, &rt2x00dev->cap_flags)) {
++	if (test_bit(CAPABILITY_EXTERNAL_PA_TX0, &rt2x00dev->cap_flags))
 +		rt2800_bbp_write(rt2x00dev, 4, bbpr4);
-+	}
 +
 +	rt2800_bbp_write(rt2x00dev, 21, 0x01);
 +	udelay(1);
@@ -935,16 +948,12 @@
 +	rt2800_register_write(rt2x00dev, RF_BYPASS3, macorg5);
 +	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, savemacsysctrl);
 +	rt2800_register_write(rt2x00dev, 0x13b8, mac13b8);
-+
-+	rt2x00_info(rt2x00dev, "TX IQ Calibration Done!\n");
-+
-+	return;
 +}
 +
  static void rt2800_bbp_core_soft_reset(struct rt2x00_dev *rt2x00dev,
  				       bool set_bw, bool is_ht40)
  {
-@@ -9672,6 +10609,7 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -9653,6 +10554,7 @@ static void rt2800_init_rfcsr_6352(struc
  	rt2800_rxdcoc_calibration(rt2x00dev);
  	rt2800_bw_filter_calibration(rt2x00dev, true);
  	rt2800_bw_filter_calibration(rt2x00dev, false);
@@ -963,11 +972,11 @@
 +#define RF_ALC_NUM	6
 +#define CHAIN_NUM	2
 +
-+typedef struct rf_reg_pair {
++struct rf_reg_pair {
 +	u8 bank;
 +	u8 reg;
 +	u8 value;
-+} rf_reg_pair;
++};
  
  /* RT2800 driver data structure */
  struct rt2800_drv_data {
diff --git a/package/kernel/mac80211/patches/rt2x00/011-rt2x00-move-helper-functions-up-in-file.patch b/package/kernel/mac80211/patches/rt2x00/011-rt2x00-move-helper-functions-up-in-file.patch
new file mode 100644
index 0000000000..07a32b17be
--- /dev/null
+++ b/package/kernel/mac80211/patches/rt2x00/011-rt2x00-move-helper-functions-up-in-file.patch
@@ -0,0 +1,94 @@
+From patchwork Sat Sep 17 20:28:58 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979252
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:28:58 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 11/16] rt2x00: move helper functions up in file
+Message-ID: 
+ <c27baa8efd5c29e2bcb2432925d9cdc5c913a125.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+Move register access helper functions up to the head of the file so
+they can be used in all functions.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 40 +++++++++----------
+ 1 file changed, 20 insertions(+), 20 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -198,6 +198,26 @@ static void rt2800_rfcsr_write_dccal(str
+ 	rt2800_rfcsr_write_bank(rt2x00dev, 7, reg, value);
+ }
+ 
++static void rt2800_bbp_dcoc_write(struct rt2x00_dev *rt2x00dev,
++				  const u8 reg, const u8 value)
++{
++	rt2800_bbp_write(rt2x00dev, 158, reg);
++	rt2800_bbp_write(rt2x00dev, 159, value);
++}
++
++static u8 rt2800_bbp_dcoc_read(struct rt2x00_dev *rt2x00dev, const u8 reg)
++{
++	rt2800_bbp_write(rt2x00dev, 158, reg);
++	return rt2800_bbp_read(rt2x00dev, 159);
++}
++
++static void rt2800_bbp_glrt_write(struct rt2x00_dev *rt2x00dev,
++				  const u8 reg, const u8 value)
++{
++	rt2800_bbp_write(rt2x00dev, 195, reg);
++	rt2800_bbp_write(rt2x00dev, 196, value);
++}
++
+ static u8 rt2800_rfcsr_read(struct rt2x00_dev *rt2x00dev,
+ 			    const unsigned int word)
+ {
+@@ -6947,26 +6967,6 @@ static void rt2800_init_bbp_5592(struct
+ 		rt2800_bbp_write(rt2x00dev, 103, 0xc0);
+ }
+ 
+-static void rt2800_bbp_glrt_write(struct rt2x00_dev *rt2x00dev,
+-				  const u8 reg, const u8 value)
+-{
+-	rt2800_bbp_write(rt2x00dev, 195, reg);
+-	rt2800_bbp_write(rt2x00dev, 196, value);
+-}
+-
+-static void rt2800_bbp_dcoc_write(struct rt2x00_dev *rt2x00dev,
+-				  const u8 reg, const u8 value)
+-{
+-	rt2800_bbp_write(rt2x00dev, 158, reg);
+-	rt2800_bbp_write(rt2x00dev, 159, value);
+-}
+-
+-static u8 rt2800_bbp_dcoc_read(struct rt2x00_dev *rt2x00dev, const u8 reg)
+-{
+-	rt2800_bbp_write(rt2x00dev, 158, reg);
+-	return rt2800_bbp_read(rt2x00dev, 159);
+-}
+-
+ static void rt2800_init_bbp_6352(struct rt2x00_dev *rt2x00dev)
+ {
+ 	u8 bbp;
diff --git a/package/kernel/mac80211/patches/rt2x00/012-rt2x00-fix-HT20-HT40-bandwidth-switch-on-MT7620.patch b/package/kernel/mac80211/patches/rt2x00/012-rt2x00-fix-HT20-HT40-bandwidth-switch-on-MT7620.patch
new file mode 100644
index 0000000000..e989205ba2
--- /dev/null
+++ b/package/kernel/mac80211/patches/rt2x00/012-rt2x00-fix-HT20-HT40-bandwidth-switch-on-MT7620.patch
@@ -0,0 +1,56 @@
+From patchwork Sat Sep 17 20:29:13 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979253
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:29:13 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 12/16] rt2x00: fix HT20/HT40 bandwidth switch on MT7620
+Message-ID: 
+ <1664d89ba149f7b0bcec18b2a2abaedf49654507.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+Add missing configuration of the channel bandwidth filter to the
+channel setup function for MT7620.
+
+Reported-by: Serge Vasilugin <vasilugin@yandex.ru>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -3855,6 +3855,14 @@ static void rt2800_config_channel_rf7620
+ 		rfcsr |= tx_agc_fc;
+ 		rt2800_rfcsr_write_bank(rt2x00dev, 7, 59, rfcsr);
+ 	}
++
++	if (conf_is_ht40(conf)) {
++		rt2800_bbp_glrt_write(rt2x00dev, 141, 0x10);
++		rt2800_bbp_glrt_write(rt2x00dev, 157, 0x2f);
++	} else {
++		rt2800_bbp_glrt_write(rt2x00dev, 141, 0x1a);
++		rt2800_bbp_glrt_write(rt2x00dev, 157, 0x40);
++	}
+ }
+ 
+ static void rt2800_config_alc(struct rt2x00_dev *rt2x00dev,
diff --git a/package/kernel/mac80211/patches/rt2x00/013-rt2x00-set-correct-TX_SW_CFG1-MAC-register-for-MT7620.patch b/package/kernel/mac80211/patches/rt2x00/013-rt2x00-set-correct-TX_SW_CFG1-MAC-register-for-MT7620.patch
new file mode 100644
index 0000000000..3d7af17b16
--- /dev/null
+++ b/package/kernel/mac80211/patches/rt2x00/013-rt2x00-set-correct-TX_SW_CFG1-MAC-register-for-MT7620.patch
@@ -0,0 +1,52 @@
+From patchwork Sat Sep 17 20:29:26 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979254
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:29:26 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 13/16] rt2x00: set correct TX_SW_CFG1 MAC register for
+ MT7620
+Message-ID: 
+ <4be38975ce600a34249e12d09a3cb758c6e71071.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+Set correct TX_SW_CFG1 MAC register as it is done also in v3 of the
+vendor driver[1].
+
+[1]: https://gitlab.com/dm38/padavan-ng/-/blob/master/trunk/proprietary/rt_wifi/rtpci/3.0.X.X/mt76x2/chips/rt6352.c#L531
+Reported-by: Serge Vasilugin <vasilugin@yandex.ru>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -5966,7 +5966,7 @@ static int rt2800_init_registers(struct
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
+ 	} else if (rt2x00_rt(rt2x00dev, RT6352)) {
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000401);
+-		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0000);
++		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0001);
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
+ 		rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x00000000);
+ 		rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN, 0x0);
diff --git a/package/kernel/mac80211/patches/rt2x00/014-rt2x00-set-VGC-gain-for-both-chains-of-MT7620.patch b/package/kernel/mac80211/patches/rt2x00/014-rt2x00-set-VGC-gain-for-both-chains-of-MT7620.patch
new file mode 100644
index 0000000000..27b8d92cd2
--- /dev/null
+++ b/package/kernel/mac80211/patches/rt2x00/014-rt2x00-set-VGC-gain-for-both-chains-of-MT7620.patch
@@ -0,0 +1,50 @@
+From patchwork Sat Sep 17 20:29:40 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979255
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:29:40 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 14/16] rt2x00: set VGC gain for both chains of MT7620
+Message-ID: 
+ <29e161397e5c9d9399da0fe87d44458aa2b90a78.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+Set bbp66 for all chains of the MT7620.
+
+Reported-by: Serge Vasilugin <vasilugin@yandex.ru>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -5743,7 +5743,8 @@ static inline void rt2800_set_vgc(struct
+ 	if (qual->vgc_level != vgc_level) {
+ 		if (rt2x00_rt(rt2x00dev, RT3572) ||
+ 		    rt2x00_rt(rt2x00dev, RT3593) ||
+-		    rt2x00_rt(rt2x00dev, RT3883)) {
++		    rt2x00_rt(rt2x00dev, RT3883) ||
++		    rt2x00_rt(rt2x00dev, RT6352)) {
+ 			rt2800_bbp_write_with_rx_chain(rt2x00dev, 66,
+ 						       vgc_level);
+ 		} else if (rt2x00_rt(rt2x00dev, RT5592)) {
diff --git a/package/kernel/mac80211/patches/rt2x00/015-rt2x00-set-SoC-wmac-clock-register.patch b/package/kernel/mac80211/patches/rt2x00/015-rt2x00-set-SoC-wmac-clock-register.patch
new file mode 100644
index 0000000000..3cadc91da6
--- /dev/null
+++ b/package/kernel/mac80211/patches/rt2x00/015-rt2x00-set-SoC-wmac-clock-register.patch
@@ -0,0 +1,70 @@
+From patchwork Sat Sep 17 20:29:55 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979256
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+Date: Sat, 17 Sep 2022 21:29:55 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 15/16] rt2x00: set SoC wmac clock register
+Message-ID: 
+ <3e275d259f476f597dab91a9c395015ef3fe3284.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+Instead of using the default value 33 (pci), set US_CYC_CNT init based
+on Programming guide:
+If available, set chipset bus clock with fallback to cpu clock/3.
+
+Reported-by: Serge Vasilugin <vasilugin@yandex.ru>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 21 +++++++++++++++++++
+ 1 file changed, 21 insertions(+)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -6229,6 +6229,27 @@ static int rt2800_init_registers(struct
+ 		reg = rt2800_register_read(rt2x00dev, US_CYC_CNT);
+ 		rt2x00_set_field32(&reg, US_CYC_CNT_CLOCK_CYCLE, 125);
+ 		rt2800_register_write(rt2x00dev, US_CYC_CNT, reg);
++	} else if (rt2x00_is_soc(rt2x00dev)) {
++		struct clk *clk = clk_get_sys("bus", NULL);
++		int rate;
++
++		if (IS_ERR(clk)) {
++			clk = clk_get_sys("cpu", NULL);
++
++			if (IS_ERR(clk)) {
++				rate = 125;
++			} else {
++				rate = clk_get_rate(clk) / 3000000;
++				clk_put(clk);
++			}
++		} else {
++			rate = clk_get_rate(clk) / 1000000;
++			clk_put(clk);
++		}
++
++		reg = rt2800_register_read(rt2x00dev, US_CYC_CNT);
++		rt2x00_set_field32(&reg, US_CYC_CNT_CLOCK_CYCLE, rate);
++		rt2800_register_write(rt2x00dev, US_CYC_CNT, reg);
+ 	}
+ 
+ 	reg = rt2800_register_read(rt2x00dev, HT_FBK_CFG0);
diff --git a/package/kernel/mac80211/patches/rt2x00/016-rt2x00-correctly-set-BBP-register-86-for-MT7620.patch b/package/kernel/mac80211/patches/rt2x00/016-rt2x00-correctly-set-BBP-register-86-for-MT7620.patch
new file mode 100644
index 0000000000..5ddbbf1dd6
--- /dev/null
+++ b/package/kernel/mac80211/patches/rt2x00/016-rt2x00-correctly-set-BBP-register-86-for-MT7620.patch
@@ -0,0 +1,79 @@
+From patchwork Sat Sep 17 20:30:09 2022
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 12979257
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <linux-wireless-owner@kernel.org>
+X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
+	aws-us-west-2-korg-lkml-1.web.codeaurora.org
+Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
+	by smtp.lore.kernel.org (Postfix) with ESMTP id E9118ECAAA1
+	for <linux-wireless@archiver.kernel.org>;
+ Sat, 17 Sep 2022 20:30:22 +0000 (UTC)
+Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
+        id S229639AbiIQUaV (ORCPT
+        <rfc822;linux-wireless@archiver.kernel.org>);
+        Sat, 17 Sep 2022 16:30:21 -0400
+Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53912 "EHLO
+        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
+        with ESMTP id S229628AbiIQUaT (ORCPT
+        <rfc822;linux-wireless@vger.kernel.org>);
+        Sat, 17 Sep 2022 16:30:19 -0400
+Received: from fudo.makrotopia.org (fudo.makrotopia.org
+ [IPv6:2a07:2ec0:3002::71])
+        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 1AEA822B27
+        for <linux-wireless@vger.kernel.org>;
+ Sat, 17 Sep 2022 13:30:16 -0700 (PDT)
+Received: from local
+        by fudo.makrotopia.org with esmtpsa
+ (TLS1.3:TLS_AES_256_GCM_SHA384:256)
+         (Exim 4.96)
+        (envelope-from <daniel@makrotopia.org>)
+        id 1oZeS7-0003ra-0k;
+        Sat, 17 Sep 2022 22:30:15 +0200
+Date: Sat, 17 Sep 2022 21:30:09 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: linux-wireless@vger.kernel.org, Stanislaw Gruszka <stf_xl@wp.pl>,
+        Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+        "David S. Miller" <davem@davemloft.net>,
+        Eric Dumazet <edumazet@google.com>,
+        Jakub Kicinski <kuba@kernel.org>,
+        Paolo Abeni <pabeni@redhat.com>,
+        Johannes Berg <johannes.berg@intel.com>
+Subject: [PATCH v3 16/16] rt2x00: correctly set BBP register 86 for MT7620
+Message-ID: 
+ <257267247ee4fa7ebc6a5d0c4948b3f8119c0d77.1663445157.git.daniel@makrotopia.org>
+References: <cover.1663445157.git.daniel@makrotopia.org>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <cover.1663445157.git.daniel@makrotopia.org>
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+Instead of 0 set the correct value for BBP register 86 for MT7620.
+
+Reported-by: Serge Vasilugin <vasilugin@yandex.ru>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <stf_xl@wp.pl>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -4225,7 +4225,10 @@ static void rt2800_config_channel(struct
+ 		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
+ 		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
+ 		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
+-		rt2800_bbp_write(rt2x00dev, 86, 0);
++		if (rt2x00_rt(rt2x00dev, RT6352))
++			rt2800_bbp_write(rt2x00dev, 86, 0x38);
++		else
++			rt2800_bbp_write(rt2x00dev, 86, 0);
+ 	}
+ 
+ 	if (rf->channel <= 14) {
diff --git a/package/kernel/mac80211/patches/rt2x00/602-rt2x00-introduce-rt2x00eeprom.patch b/package/kernel/mac80211/patches/rt2x00/602-rt2x00-introduce-rt2x00eeprom.patch
index e74d9a9aa0..ba16e85510 100644
--- a/package/kernel/mac80211/patches/rt2x00/602-rt2x00-introduce-rt2x00eeprom.patch
+++ b/package/kernel/mac80211/patches/rt2x00/602-rt2x00-introduce-rt2x00eeprom.patch
@@ -1,6 +1,6 @@
 --- a/local-symbols
 +++ b/local-symbols
-@@ -332,6 +332,7 @@ RT2X00_LIB_FIRMWARE=
+@@ -345,6 +345,7 @@ RT2X00_LIB_FIRMWARE=
  RT2X00_LIB_CRYPTO=
  RT2X00_LIB_LEDS=
  RT2X00_LIB_DEBUGFS=
@@ -48,7 +48,7 @@
  obj-$(CPTCFG_RT2X00_LIB_MMIO)		+= rt2x00mmio.o
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-@@ -37,6 +37,8 @@ struct rt2800_drv_data {
+@@ -47,6 +47,8 @@ struct rt2800_drv_data {
  	struct ieee80211_sta *wcid_to_sta[STA_IDS_SIZE];
  };
  
@@ -57,7 +57,7 @@
  struct rt2800_ops {
  	u32 (*register_read)(struct rt2x00_dev *rt2x00dev,
  			      const unsigned int offset);
-@@ -135,6 +137,15 @@ static inline int rt2800_read_eeprom(str
+@@ -145,6 +147,15 @@ static inline int rt2800_read_eeprom(str
  {
  	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
  
@@ -105,7 +105,7 @@
  	.drv_init_registers	= rt2800mmio_init_registers,
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -694,6 +694,7 @@ enum rt2x00_capability_flags {
+@@ -703,6 +703,7 @@ enum rt2x00_capability_flags {
  	REQUIRE_HT_TX_DESC,
  	REQUIRE_PS_AUTOWAKE,
  	REQUIRE_DELAYED_RFKILL,
@@ -113,7 +113,7 @@
  
  	/*
  	 * Capabilities
-@@ -970,6 +971,11 @@ struct rt2x00_dev {
+@@ -980,6 +981,11 @@ struct rt2x00_dev {
  	const struct firmware *fw;
  
  	/*
@@ -127,7 +127,7 @@
  	DECLARE_KFIFO_PTR(txstatus_fifo, u32);
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1406,6 +1406,10 @@ int rt2x00lib_probe_dev(struct rt2x00_de
+@@ -1419,6 +1419,10 @@ int rt2x00lib_probe_dev(struct rt2x00_de
  	INIT_DELAYED_WORK(&rt2x00dev->autowakeup_work, rt2x00lib_autowakeup);
  	INIT_WORK(&rt2x00dev->sleep_work, rt2x00lib_sleep);
  
@@ -138,7 +138,7 @@
  	/*
  	 * Let the driver probe the device to detect the capabilities.
  	 */
-@@ -1549,6 +1553,11 @@ void rt2x00lib_remove_dev(struct rt2x00_
+@@ -1559,6 +1563,11 @@ void rt2x00lib_remove_dev(struct rt2x00_
  	 * Free the driver data.
  	 */
  	kfree(rt2x00dev->drv_data);
@@ -193,7 +193,7 @@
 +	if (pdata && pdata->eeprom_file_name)
 +		return pdata->eeprom_file_name;
 +
-+	return NULL
++	return NULL;
 +}
 +
 +static int rt2x00lib_request_eeprom_file(struct rt2x00_dev *rt2x00dev)
diff --git a/package/kernel/mac80211/patches/rt2x00/603-rt2x00-of_load_eeprom_filename.patch b/package/kernel/mac80211/patches/rt2x00/603-rt2x00-of_load_eeprom_filename.patch
index 9dffef1812..431e090237 100644
--- a/package/kernel/mac80211/patches/rt2x00/603-rt2x00-of_load_eeprom_filename.patch
+++ b/package/kernel/mac80211/patches/rt2x00/603-rt2x00-of_load_eeprom_filename.patch
@@ -8,7 +8,7 @@
  
  #include "rt2x00.h"
  #include "rt2x00lib.h"
-@@ -34,11 +35,21 @@ static const char *
+@@ -34,10 +35,20 @@ static const char *
  rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
  {
  	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
@@ -20,14 +20,12 @@
  	if (pdata && pdata->eeprom_file_name)
  		return pdata->eeprom_file_name;
  
--	return NULL
 +#ifdef CONFIG_OF
 +	np = rt2x00dev->dev->of_node;
 +	if (np && of_property_read_string(np, "ralink,eeprom", &eep) == 0)
 +	    return eep;
 +#endif
 +
-+	return NULL;
+ 	return NULL;
  }
  
- static int rt2x00lib_request_eeprom_file(struct rt2x00_dev *rt2x00dev)
diff --git a/package/kernel/mac80211/patches/rt2x00/606-rt2x00-allow_disabling_bands_through_platform_data.patch b/package/kernel/mac80211/patches/rt2x00/606-rt2x00-allow_disabling_bands_through_platform_data.patch
index 6a8e594d5e..ffee2189d2 100644
--- a/package/kernel/mac80211/patches/rt2x00/606-rt2x00-allow_disabling_bands_through_platform_data.patch
+++ b/package/kernel/mac80211/patches/rt2x00/606-rt2x00-allow_disabling_bands_through_platform_data.patch
@@ -12,7 +12,7 @@
  #endif /* _RT2X00_PLATFORM_H */
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1012,6 +1012,22 @@ static int rt2x00lib_probe_hw_modes(stru
+@@ -1007,6 +1007,22 @@ static int rt2x00lib_probe_hw_modes(stru
  	unsigned int num_rates;
  	unsigned int i;
  
@@ -37,7 +37,7 @@
  		num_rates += 4;
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -399,6 +399,7 @@ struct hw_mode_spec {
+@@ -408,6 +408,7 @@ struct hw_mode_spec {
  	unsigned int supported_bands;
  #define SUPPORT_BAND_2GHZ	0x00000001
  #define SUPPORT_BAND_5GHZ	0x00000002
diff --git a/package/kernel/mac80211/patches/rt2x00/607-rt2x00-add_platform_data_mac_addr.patch b/package/kernel/mac80211/patches/rt2x00/607-rt2x00-add_platform_data_mac_addr.patch
index b5b2c61037..37553bb80a 100644
--- a/package/kernel/mac80211/patches/rt2x00/607-rt2x00-add_platform_data_mac_addr.patch
+++ b/package/kernel/mac80211/patches/rt2x00/607-rt2x00-add_platform_data_mac_addr.patch
@@ -1,19 +1,18 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -990,8 +990,13 @@ static void rt2x00lib_rate(struct ieee80
+@@ -989,6 +989,12 @@ static void rt2x00lib_rate(struct ieee80
  
  void rt2x00lib_set_mac_address(struct rt2x00_dev *rt2x00dev, u8 *eeprom_mac_addr)
  {
 +	struct rt2x00_platform_data *pdata;
- 	const char *mac_addr;
- 
++
 +	pdata = rt2x00dev->dev->platform_data;
 +	if (pdata && pdata->mac_address)
 +		ether_addr_copy(eeprom_mac_addr, pdata->mac_address);
 +
- 	mac_addr = of_get_mac_address(rt2x00dev->dev->of_node);
- 	if (!IS_ERR(mac_addr))
- 		ether_addr_copy(eeprom_mac_addr, mac_addr);
+ 	of_get_mac_address(rt2x00dev->dev->of_node, eeprom_mac_addr);
+ 
+ 	if (!is_valid_ether_addr(eeprom_mac_addr)) {
 --- a/include/linux/rt2x00_platform.h
 +++ b/include/linux/rt2x00_platform.h
 @@ -14,6 +14,7 @@
diff --git a/package/kernel/mac80211/patches/rt2x00/608-rt2x00-allow_disabling_bands_through_dts.patch b/package/kernel/mac80211/patches/rt2x00/608-rt2x00-allow_disabling_bands_through_dts.patch
index ff8b2c947b..6211809c0a 100644
--- a/package/kernel/mac80211/patches/rt2x00/608-rt2x00-allow_disabling_bands_through_dts.patch
+++ b/package/kernel/mac80211/patches/rt2x00/608-rt2x00-allow_disabling_bands_through_dts.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1016,6 +1016,16 @@ static int rt2x00lib_probe_hw_modes(stru
+@@ -1012,6 +1012,16 @@ static int rt2x00lib_probe_hw_modes(stru
  	struct ieee80211_rate *rates;
  	unsigned int num_rates;
  	unsigned int i;
diff --git a/package/kernel/mac80211/patches/rt2x00/610-rt2x00-change-led-polarity-from-OF.patch b/package/kernel/mac80211/patches/rt2x00/610-rt2x00-change-led-polarity-from-OF.patch
index 039c6f6afc..acc8a8edb8 100644
--- a/package/kernel/mac80211/patches/rt2x00/610-rt2x00-change-led-polarity-from-OF.patch
+++ b/package/kernel/mac80211/patches/rt2x00/610-rt2x00-change-led-polarity-from-OF.patch
@@ -8,7 +8,7 @@
  
  #include "rt2x00.h"
  #include "rt2800lib.h"
-@@ -9530,6 +9531,17 @@ static int rt2800_init_eeprom(struct rt2
+@@ -11131,6 +11132,17 @@ static int rt2800_init_eeprom(struct rt2
  	rt2800_init_led(rt2x00dev, &rt2x00dev->led_assoc, LED_TYPE_ASSOC);
  	rt2800_init_led(rt2x00dev, &rt2x00dev->led_qual, LED_TYPE_QUALITY);
  
diff --git a/package/kernel/mac80211/patches/rt2x00/611-rt2x00-add-AP+STA-support.patch b/package/kernel/mac80211/patches/rt2x00/611-rt2x00-add-AP+STA-support.patch
index 88d6dd559b..5ef5fc8def 100644
--- a/package/kernel/mac80211/patches/rt2x00/611-rt2x00-add-AP+STA-support.patch
+++ b/package/kernel/mac80211/patches/rt2x00/611-rt2x00-add-AP+STA-support.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1344,7 +1344,7 @@ static inline void rt2x00lib_set_if_comb
+@@ -1358,7 +1358,7 @@ static inline void rt2x00lib_set_if_comb
  	 */
  	if_limit = &rt2x00dev->if_limits_ap;
  	if_limit->max = rt2x00dev->ops->max_ap_intf;
diff --git a/package/kernel/mac80211/patches/rt2x00/612-rt2x00-led-tpt-trigger-support.patch b/package/kernel/mac80211/patches/rt2x00/612-rt2x00-led-tpt-trigger-support.patch
deleted file mode 100644
index fca1fb2cd4..0000000000
--- a/package/kernel/mac80211/patches/rt2x00/612-rt2x00-led-tpt-trigger-support.patch
+++ /dev/null
@@ -1,44 +0,0 @@
-From: David Bauer <mail@david-bauer.net>
-Date: Mon, 16 Dec 2019 20:47:06 +0100
-Subject: [PATCH] rt2x00: add throughput LED trigger
-
-This adds a (currently missing) throughput LED trigger for the rt2x00
-driver. Previously, LED triggers had to be assigned to the netdev, which
-was limited to a single VAP.
-
-Signed-off-by: David Bauer <mail@david-bauer.net>
-Tested-by: Christoph Krapp <achterin@googlemail.com>
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1129,6 +1129,19 @@ static void rt2x00lib_remove_hw(struct r
- 	kfree(rt2x00dev->spec.channels_info);
- }
- 
-+static const struct ieee80211_tpt_blink rt2x00_tpt_blink[] = {
-+	{ .throughput = 0 * 1024, .blink_time = 334 },
-+	{ .throughput = 1 * 1024, .blink_time = 260 },
-+	{ .throughput = 2 * 1024, .blink_time = 220 },
-+	{ .throughput = 5 * 1024, .blink_time = 190 },
-+	{ .throughput = 10 * 1024, .blink_time = 170 },
-+	{ .throughput = 25 * 1024, .blink_time = 150 },
-+	{ .throughput = 54 * 1024, .blink_time = 130 },
-+	{ .throughput = 120 * 1024, .blink_time = 110 },
-+	{ .throughput = 265 * 1024, .blink_time = 80 },
-+	{ .throughput = 586 * 1024, .blink_time = 50 },
-+};
-+
- static int rt2x00lib_probe_hw(struct rt2x00_dev *rt2x00dev)
- {
- 	struct hw_mode_spec *spec = &rt2x00dev->spec;
-@@ -1210,6 +1223,10 @@ static int rt2x00lib_probe_hw(struct rt2
- 
- #undef RT2X00_TASKLET_INIT
- 
-+	ieee80211_create_tpt_led_trigger(rt2x00dev->hw,
-+		IEEE80211_TPT_LEDTRIG_FL_RADIO, rt2x00_tpt_blink,
-+		ARRAY_SIZE(rt2x00_tpt_blink));
-+
- 	/*
- 	 * Register HW.
- 	 */
diff --git a/package/kernel/mac80211/patches/rt2x00/992-rt2x00-save-survey-for-every-channel-visited.patch b/package/kernel/mac80211/patches/rt2x00/992-rt2x00-save-survey-for-every-channel-visited.patch
deleted file mode 100644
index 31a7baeee7..0000000000
--- a/package/kernel/mac80211/patches/rt2x00/992-rt2x00-save-survey-for-every-channel-visited.patch
+++ /dev/null
@@ -1,183 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -1238,6 +1238,8 @@ void rt2800_watchdog(struct rt2x00_dev *
- 	if (test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags))
- 		return;
- 
-+	rt2800_update_survey(rt2x00dev);
-+
- 	queue_for_each(rt2x00dev, queue) {
- 		switch (queue->qid) {
- 		case QID_AC_VO:
-@@ -1274,6 +1276,18 @@ void rt2800_watchdog(struct rt2x00_dev *
- }
- EXPORT_SYMBOL_GPL(rt2800_watchdog);
- 
-+void rt2800_update_survey(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct ieee80211_channel *chan = rt2x00dev->hw->conf.chandef.chan;
-+	struct rt2x00_chan_survey *chan_survey =
-+		   &rt2x00dev->chan_survey[chan->hw_value];
-+
-+	chan_survey->time_idle += rt2800_register_read(rt2x00dev, CH_IDLE_STA);
-+	chan_survey->time_busy += rt2800_register_read(rt2x00dev, CH_BUSY_STA);
-+	chan_survey->time_ext_busy += rt2800_register_read(rt2x00dev, CH_BUSY_STA_SEC);
-+}
-+EXPORT_SYMBOL_GPL(rt2800_update_survey);
-+
- static unsigned int rt2800_hw_beacon_base(struct rt2x00_dev *rt2x00dev,
- 					  unsigned int index)
- {
-@@ -12199,26 +12213,30 @@ int rt2800_get_survey(struct ieee80211_h
- {
- 	struct rt2x00_dev *rt2x00dev = hw->priv;
- 	struct ieee80211_conf *conf = &hw->conf;
--	u32 idle, busy, busy_ext;
-+	struct rt2x00_chan_survey *chan_survey =
-+		   &rt2x00dev->chan_survey[idx];
-+	enum nl80211_band band = NL80211_BAND_2GHZ;
- 
--	if (idx != 0)
-+	if (idx >= rt2x00dev->bands[band].n_channels) {
-+		idx -= rt2x00dev->bands[band].n_channels;
-+		band = NL80211_BAND_5GHZ;
-+	}
-+
-+	if (idx >= rt2x00dev->bands[band].n_channels)
- 		return -ENOENT;
- 
--	survey->channel = conf->chandef.chan;
-+	if (idx == 0)
-+		rt2800_update_survey(rt2x00dev);
- 
--	idle = rt2800_register_read(rt2x00dev, CH_IDLE_STA);
--	busy = rt2800_register_read(rt2x00dev, CH_BUSY_STA);
--	busy_ext = rt2800_register_read(rt2x00dev, CH_BUSY_STA_SEC);
--
--	if (idle || busy) {
--		survey->filled = SURVEY_INFO_TIME |
--				 SURVEY_INFO_TIME_BUSY |
--				 SURVEY_INFO_TIME_EXT_BUSY;
--
--		survey->time = (idle + busy) / 1000;
--		survey->time_busy = busy / 1000;
--		survey->time_ext_busy = busy_ext / 1000;
--	}
-+	survey->channel = &rt2x00dev->bands[band].channels[idx];
-+
-+	survey->filled = SURVEY_INFO_TIME |
-+			 SURVEY_INFO_TIME_BUSY |
-+			 SURVEY_INFO_TIME_EXT_BUSY;
-+
-+	survey->time = div_u64(chan_survey->time_idle + chan_survey->time_busy, 1000);
-+	survey->time_busy = div_u64(chan_survey->time_busy, 1000);
-+	survey->time_ext_busy = div_u64(chan_survey->time_ext_busy, 1000);
- 
- 	if (!(hw->conf.flags & IEEE80211_CONF_OFFCHANNEL))
- 		survey->filled |= SURVEY_INFO_IN_USE;
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-@@ -243,6 +243,7 @@ bool rt2800_txstatus_timeout(struct rt2x
- bool rt2800_txstatus_pending(struct rt2x00_dev *rt2x00dev);
- 
- void rt2800_watchdog(struct rt2x00_dev *rt2x00dev);
-+void rt2800_update_survey(struct rt2x00_dev *rt2x00dev);
- 
- void rt2800_write_beacon(struct queue_entry *entry, struct txentry_desc *txdesc);
- void rt2800_clear_beacon(struct queue_entry *entry);
---- a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
-@@ -360,6 +360,7 @@ static const struct rt2x00lib_ops rt2800
- 	.gain_calibration	= rt2800_gain_calibration,
- 	.vco_calibration	= rt2800_vco_calibration,
- 	.watchdog		= rt2800_watchdog,
-+	.update_survey		= rt2800_update_survey,
- 	.start_queue		= rt2800mmio_start_queue,
- 	.kick_queue		= rt2800mmio_kick_queue,
- 	.stop_queue		= rt2800mmio_stop_queue,
---- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-@@ -214,6 +214,7 @@ static const struct rt2x00lib_ops rt2800
- 	.gain_calibration	= rt2800_gain_calibration,
- 	.vco_calibration	= rt2800_vco_calibration,
- 	.watchdog		= rt2800_watchdog,
-+	.update_survey		= rt2800_update_survey,
- 	.start_queue		= rt2800mmio_start_queue,
- 	.kick_queue		= rt2800mmio_kick_queue,
- 	.stop_queue		= rt2800mmio_stop_queue,
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -183,6 +183,15 @@ struct rf_channel {
- };
- 
- /*
-+ * Information structure for channel survey.
-+ */
-+struct rt2x00_chan_survey {
-+	u64 time_idle;
-+	u64 time_busy;
-+	u64 time_ext_busy;
-+};
-+
-+/*
-  * Channel information structure
-  */
- struct channel_info {
-@@ -567,6 +576,7 @@ struct rt2x00lib_ops {
- 	 * Data queue handlers.
- 	 */
- 	void (*watchdog) (struct rt2x00_dev *rt2x00dev);
-+	void (*update_survey) (struct rt2x00_dev *rt2x00dev);
- 	void (*start_queue) (struct data_queue *queue);
- 	void (*kick_queue) (struct data_queue *queue);
- 	void (*stop_queue) (struct data_queue *queue);
-@@ -755,6 +765,7 @@ struct rt2x00_dev {
- 	 */
- 	struct ieee80211_hw *hw;
- 	struct ieee80211_supported_band bands[NUM_NL80211_BANDS];
-+	struct rt2x00_chan_survey *chan_survey;
- 	enum nl80211_band curr_band;
- 	int curr_freq;
- 
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1057,6 +1057,12 @@ static int rt2x00lib_probe_hw_modes(stru
- 	if (!rates)
- 		goto exit_free_channels;
- 
-+	rt2x00dev->chan_survey =
-+		kcalloc(spec->num_channels, sizeof(struct rt2x00_chan_survey),
-+			GFP_KERNEL);
-+	if (!rt2x00dev->chan_survey)
-+		goto exit_free_rates;
-+
- 	/*
- 	 * Initialize Rate list.
- 	 */
-@@ -1108,6 +1114,8 @@ static int rt2x00lib_probe_hw_modes(stru
- 
- 	return 0;
- 
-+ exit_free_rates:
-+	kfree(rates);
-  exit_free_channels:
- 	kfree(channels);
- 	rt2x00_err(rt2x00dev, "Allocation ieee80211 modes failed\n");
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00mac.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00mac.c
-@@ -317,6 +317,15 @@ int rt2x00mac_config(struct ieee80211_hw
- 		return 0;
- 
- 	/*
-+	 * To provide correct survey data for survey-based ACS algorithm
-+	 * we have to save survey data for current channel before switching.
-+	 */
-+	if (rt2x00dev->ops->lib->update_survey &&
-+	    (changed & IEEE80211_CONF_CHANGE_CHANNEL)) {
-+		rt2x00dev->ops->lib->update_survey(rt2x00dev);
-+	}
-+
-+	/*
- 	 * Some configuration parameters (e.g. channel and antenna values) can
- 	 * only be set when the radio is enabled, but do require the RX to
- 	 * be off. During this period we should keep link tuning enabled,
diff --git a/package/kernel/mac80211/patches/rt2x00/994-rt2x00-import-support-for-external-LNA-on-MT7620.patch b/package/kernel/mac80211/patches/rt2x00/994-rt2x00-import-support-for-external-LNA-on-MT7620.patch
new file mode 100644
index 0000000000..deaa03be6c
--- /dev/null
+++ b/package/kernel/mac80211/patches/rt2x00/994-rt2x00-import-support-for-external-LNA-on-MT7620.patch
@@ -0,0 +1,161 @@
+From 0fce1109f894ec7fcd72cb098843a1eff786716a Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Fri, 16 Sep 2022 20:49:42 +0100
+Subject: [PATCH 16/16] rt2x00: import support for external LNA on MT7620
+To: linux-wireless@vger.kernel.org,
+    Stanislaw Gruszka <stf_xl@wp.pl>,
+    Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@kernel.org>,
+    David S. Miller <davem@davemloft.net>,
+    Eric Dumazet <edumazet@google.com>,
+    Jakub Kicinski <kuba@kernel.org>,
+    Paolo Abeni <pabeni@redhat.com>,
+    Johannes Berg <johannes.berg@intel.com>
+
+In order to carry out calibration on boards with ePA or eLNA the PA pin
+needs to be switch to GPIO mode on MT7620. Implement that by selecting
+pinctrl state "pa_gpio" which should be defined for MT7620 boards with
+eLNA or ePA beside the "default" state.
+
+Reported-by: Serge Vasilugin <vasilugin@yandex.ru>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 58 +++++++++++++++++++
+ drivers/net/wireless/ralink/rt2x00/rt2x00.h   |  5 ++
+ .../net/wireless/ralink/rt2x00/rt2x00soc.c    | 15 +++++
+ 3 files changed, 78 insertions(+)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -304,6 +304,24 @@ static void rt2800_rf_write(struct rt2x0
+ 	mutex_unlock(&rt2x00dev->csr_mutex);
+ }
+ 
++void rt6352_enable_pa_pin(struct rt2x00_dev *rt2x00dev, int enable)
++{
++	if (!rt2x00dev->pinctrl)
++		return;
++
++	if (enable) {
++		if (!rt2x00dev->pins_default)
++			return;
++
++		pinctrl_select_state(rt2x00dev->pinctrl, rt2x00dev->pins_default);
++	} else {
++		if (!rt2x00dev->pins_pa_gpio)
++			return;
++
++		pinctrl_select_state(rt2x00dev->pinctrl, rt2x00dev->pins_pa_gpio);
++	}
++}
++
+ static const unsigned int rt2800_eeprom_map[EEPROM_WORD_COUNT] = {
+ 	[EEPROM_CHIP_ID]		= 0x0000,
+ 	[EEPROM_VERSION]		= 0x0001,
+@@ -4469,6 +4487,29 @@ static void rt2800_config_channel(struct
+ 			rt2800_register_write(rt2x00dev, TX1_RF_GAIN_ATTEN,
+ 					      0x6C6C6B6C);
+ 		}
++
++		if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
++			reg = rt2800_register_read(rt2x00dev, RF_CONTROL3);
++			reg |= 0x00000101;
++			rt2800_register_write(rt2x00dev, RF_CONTROL3, reg);
++
++			reg = rt2800_register_read(rt2x00dev, RF_BYPASS3);
++			reg |= 0x00000101;
++			rt2800_register_write(rt2x00dev, RF_BYPASS3, reg);
++
++			rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x66);
++			rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x20);
++			rt2800_rfcsr_write_chanreg(rt2x00dev, 18, 0x42);
++			rt2800_bbp_write(rt2x00dev, 75, 0x68);
++			rt2800_bbp_write(rt2x00dev, 76, 0x4C);
++			rt2800_bbp_write(rt2x00dev, 79, 0x1C);
++			rt2800_bbp_write(rt2x00dev, 80, 0x0C);
++			rt2800_bbp_write(rt2x00dev, 82, 0xB6);
++			/* bank 0 RF reg 42 and glrt BBP reg 141 will be set in
++			 * config channel function in dependence of channel and
++			 * HT20/HT40 so don't touch it
++			 */
++		}
+ 	}
+ 
+ 	bbp = rt2800_bbp_read(rt2x00dev, 4);
+@@ -10583,6 +10624,7 @@ static void rt2800_init_rfcsr_6352(struc
+ 	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
+ 	rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
+ 
++	rt6352_enable_pa_pin(rt2x00dev, 0);
+ 	rt2800_r_calibration(rt2x00dev);
+ 	rt2800_rf_self_txdc_cal(rt2x00dev);
+ 	rt2800_rxdcoc_calibration(rt2x00dev);
+@@ -10590,6 +10632,22 @@ static void rt2800_init_rfcsr_6352(struc
+ 	rt2800_bw_filter_calibration(rt2x00dev, false);
+ 	rt2800_loft_iq_calibration(rt2x00dev);
+ 	rt2800_rxiq_calibration(rt2x00dev);
++	rt6352_enable_pa_pin(rt2x00dev, 1);
++
++	if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
++		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x66);
++		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x20);
++		rt2800_rfcsr_write_chanreg(rt2x00dev, 18, 0x42);
++		rt2800_bbp_write(rt2x00dev, 75, 0x68);
++		rt2800_bbp_write(rt2x00dev, 76, 0x4C);
++		rt2800_bbp_write(rt2x00dev, 79, 0x1C);
++		rt2800_bbp_write(rt2x00dev, 80, 0x0C);
++		rt2800_bbp_write(rt2x00dev, 82, 0xB6);
++		/* bank 0 RF reg 42 and glrt BBP reg 141 will be set in config
++		 * channel function in dependence of channel and HT20/HT40,
++		 * so don't touch them here.
++		 */
++	}
+ }
+ 
+ static void rt2800_init_rfcsr(struct rt2x00_dev *rt2x00dev)
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -28,6 +28,7 @@
+ #include <linux/average.h>
+ #include <linux/usb.h>
+ #include <linux/clk.h>
++#include <linux/pinctrl/consumer.h>
+ #include <linux/rt2x00_platform.h>
+ 
+ #include <net/mac80211.h>
+@@ -1029,6 +1030,11 @@ struct rt2x00_dev {
+ 
+ 	/* Clock for System On Chip devices. */
+ 	struct clk *clk;
++
++	/* pinctrl and states for System On Chip devices with PA/LNA. */
++	struct pinctrl *pinctrl;
++	struct pinctrl_state *pins_default;
++	struct pinctrl_state *pins_pa_gpio;
+ };
+ 
+ struct rt2x00_bar_list_entry {
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
+@@ -97,6 +97,21 @@ int rt2x00soc_probe(struct platform_devi
+ 	if (retval)
+ 		goto exit_free_reg;
+ 
++	rt2x00dev->pinctrl = devm_pinctrl_get(&pdev->dev);
++	if (IS_ERR(rt2x00dev->pinctrl)) {
++		rt2x00dev->pinctrl = NULL;
++		rt2x00dev->pins_default = NULL;
++		rt2x00dev->pins_pa_gpio = NULL;
++	} else {
++		rt2x00dev->pins_default = pinctrl_lookup_state(rt2x00dev->pinctrl, "default");
++		if (IS_ERR(rt2x00dev->pins_default))
++			rt2x00dev->pins_default = NULL;
++
++		rt2x00dev->pins_pa_gpio = pinctrl_lookup_state(rt2x00dev->pinctrl, "pa_gpio");
++		if (IS_ERR(rt2x00dev->pins_pa_gpio))
++			rt2x00dev->pins_pa_gpio = NULL;
++	}
++
+ 	return 0;
+ 
+ exit_free_reg:
diff --git a/package/kernel/mac80211/patches/rt2x00/990-rt2x00-mt7620-introduce-accessors-for-CHIP_VER-register.patch b/package/kernel/mac80211/patches/rt2x00/995-rt2x00-mt7620-introduce-accessors-for-CHIP_VER-register.patch
similarity index 100%
rename from package/kernel/mac80211/patches/rt2x00/990-rt2x00-mt7620-introduce-accessors-for-CHIP_VER-register.patch
rename to package/kernel/mac80211/patches/rt2x00/995-rt2x00-mt7620-introduce-accessors-for-CHIP_VER-register.patch
diff --git a/package/kernel/mac80211/patches/rt2x00/991-rt2x00-mt7620-differentiate-based-on-SoC-CHIP_VER.patch b/package/kernel/mac80211/patches/rt2x00/996-rt2x00-mt7620-differentiate-based-on-SoC-CHIP_VER.patch
similarity index 95%
rename from package/kernel/mac80211/patches/rt2x00/991-rt2x00-mt7620-differentiate-based-on-SoC-CHIP_VER.patch
rename to package/kernel/mac80211/patches/rt2x00/996-rt2x00-mt7620-differentiate-based-on-SoC-CHIP_VER.patch
index 3de00b2267..dab6e05ffd 100644
--- a/package/kernel/mac80211/patches/rt2x00/991-rt2x00-mt7620-differentiate-based-on-SoC-CHIP_VER.patch
+++ b/package/kernel/mac80211/patches/rt2x00/996-rt2x00-mt7620-differentiate-based-on-SoC-CHIP_VER.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
-@@ -1042,6 +1042,11 @@
+@@ -1044,6 +1044,11 @@
  #define MIMO_PS_CFG_RX_STBY_POL		FIELD32(0x00000010)
  #define MIMO_PS_CFG_RX_RX_STBY0		FIELD32(0x00000020)
  
@@ -14,7 +14,7 @@
   */
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -3685,14 +3685,16 @@ static void rt2800_config_channel_rf7620
+@@ -3778,14 +3778,16 @@ static void rt2800_config_channel_rf7620
  	rt2x00_set_field8(&rfcsr, RFCSR19_K, rf->rf4);
  	rt2800_rfcsr_write(rt2x00dev, 19, rfcsr);
  
@@ -39,7 +39,7 @@
  
  	rfcsr = rt2800_rfcsr_read(rt2x00dev, 1);
  	rt2x00_set_field8(&rfcsr, RFCSR1_TX2_EN_MT7620,
-@@ -3726,18 +3728,23 @@ static void rt2800_config_channel_rf7620
+@@ -3819,18 +3821,23 @@ static void rt2800_config_channel_rf7620
  		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x20);
  	}
  
@@ -73,9 +73,9 @@
  
  	if (!test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags)) {
  		if (conf_is_ht40(conf)) {
-@@ -3837,25 +3844,29 @@ static void rt2800_config_alc(struct rt2
- 	if (i == 10000)
- 		rt2x00_warn(rt2x00dev, "Wait MAC Status to MAX !!!\n");
+@@ -3929,25 +3936,29 @@ static void rt2800_config_alc(struct rt2
+ 	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY)))
+ 		rt2x00_warn(rt2x00dev, "RF busy while configuring ALC\n");
  
 -	if (chan->center_freq > 2457) {
 -		bbp = rt2800_bbp_read(rt2x00dev, 30);
@@ -121,12 +121,12 @@
  	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, mac_sys_ctrl);
  
  	rt2800_vco_calibration(rt2x00dev);
-@@ -5887,18 +5898,33 @@ static int rt2800_init_registers(struct
+@@ -6011,18 +6022,33 @@ static int rt2800_init_registers(struct
  	} else if (rt2x00_rt(rt2x00dev, RT5350)) {
  		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
  	} else if (rt2x00_rt(rt2x00dev, RT6352)) {
 -		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000401);
--		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0000);
+-		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0001);
 -		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
 -		rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x00000000);
 -		rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN, 0x0);
@@ -150,7 +150,7 @@
 +					      0x00550055);
 +		} else {
 +			rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000401);
-+			rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0000);
++			rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0001);
 +			rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
 +			rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x00000000);
 +			rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN, 0x0);
@@ -167,7 +167,7 @@
  		reg = rt2800_register_read(rt2x00dev, TX_ALC_CFG_1);
  		rt2x00_set_field32(&reg, TX_ALC_CFG_1_ROS_BUSY_EN, 0);
  		rt2800_register_write(rt2x00dev, TX_ALC_CFG_1, reg);
-@@ -7042,14 +7068,16 @@ static void rt2800_init_bbp_6352(struct
+@@ -7127,14 +7153,16 @@ static void rt2800_init_bbp_6352(struct
  	rt2800_bbp_write(rt2x00dev, 188, 0x00);
  	rt2800_bbp_write(rt2x00dev, 189, 0x00);
  
@@ -192,7 +192,7 @@
  
  	/* BBP for G band GLRT function (BBP_128 ~ BBP_221) */
  	rt2800_bbp_glrt_write(rt2x00dev, 0, 0x00);
-@@ -10388,31 +10416,36 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -10408,31 +10436,36 @@ static void rt2800_init_rfcsr_6352(struc
  	rt2800_rfcsr_write(rt2x00dev, 42, 0x5B);
  	rt2800_rfcsr_write(rt2x00dev, 43, 0x00);
  
@@ -254,7 +254,7 @@
  
  	/* Initialize RF channel register to default value */
  	rt2800_rfcsr_write_chanreg(rt2x00dev, 0, 0x03);
-@@ -10478,63 +10511,71 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -10498,63 +10531,71 @@ static void rt2800_init_rfcsr_6352(struc
  
  	rt2800_rfcsr_write_bank(rt2x00dev, 6, 45, 0xC5);
  
@@ -383,7 +383,7 @@
  
  	/* Initialize RF DC calibration register to default value */
  	rt2800_rfcsr_write_dccal(rt2x00dev, 0, 0x47);
-@@ -10597,12 +10638,17 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -10617,12 +10658,17 @@ static void rt2800_init_rfcsr_6352(struc
  	rt2800_rfcsr_write_dccal(rt2x00dev, 62, 0x00);
  	rt2800_rfcsr_write_dccal(rt2x00dev, 63, 0x00);
  
@@ -404,5 +404,5 @@
 +		rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
 +	}
  
+ 	rt6352_enable_pa_pin(rt2x00dev, 0);
  	rt2800_r_calibration(rt2x00dev);
- 	rt2800_rf_self_txdc_cal(rt2x00dev);
diff --git a/package/kernel/mac80211/patches/rtl/002-v5.13-rtlwifi-implement-set_tim-by-update-beacon-content.patch b/package/kernel/mac80211/patches/rtl/002-v5.13-rtlwifi-implement-set_tim-by-update-beacon-content.patch
deleted file mode 100644
index 3daf65e967..0000000000
--- a/package/kernel/mac80211/patches/rtl/002-v5.13-rtlwifi-implement-set_tim-by-update-beacon-content.patch
+++ /dev/null
@@ -1,118 +0,0 @@
-Date: Mon, 19 Apr 2021 14:59:56 +0800
-From: Ping-Ke Shih <pkshih@realtek.com>
-To: <kvalo@codeaurora.org>
-CC: <linux-wireless@vger.kernel.org>, <mail@maciej.szmigiero.name>,
-        <Larry.Finger@lwfinger.net>
-Subject: [PATCH] rtlwifi: implement set_tim by update beacon content
-
-Once beacon content is changed, we update the content to wifi card by
-send_beacon_frame(). Then, STA with PS can wake up properly to receive its
-packets.
-
-Since we update beacon content to PCI wifi devices every beacon interval,
-the only one usb device, 8192CU, needs to update beacon content when
-mac80211 calling set_tim.
-
-Reported-by: Maciej S. Szmigiero <mail@maciej.szmigiero.name>
-Signed-off-by: Ping-Ke Shih <pkshih@realtek.com>
-Tested-by: Maciej S. Szmigiero <mail@maciej.szmigiero.name>
----
- drivers/net/wireless/realtek/rtlwifi/core.c | 32 +++++++++++++++++++++
- drivers/net/wireless/realtek/rtlwifi/core.h |  1 +
- drivers/net/wireless/realtek/rtlwifi/usb.c  |  3 ++
- drivers/net/wireless/realtek/rtlwifi/wifi.h |  1 +
- 4 files changed, 37 insertions(+)
-
---- a/drivers/net/wireless/realtek/rtlwifi/core.c
-+++ b/drivers/net/wireless/realtek/rtlwifi/core.c
-@@ -1018,6 +1018,25 @@ static void send_beacon_frame(struct iee
- 	}
- }
- 
-+void rtl_update_beacon_work_callback(struct work_struct *work)
-+{
-+	struct rtl_works *rtlworks =
-+	    container_of(work, struct rtl_works, update_beacon_work);
-+	struct ieee80211_hw *hw = rtlworks->hw;
-+	struct rtl_priv *rtlpriv = rtl_priv(hw);
-+	struct ieee80211_vif *vif = rtlpriv->mac80211.vif;
-+
-+	if (!vif) {
-+		WARN_ONCE(true, "no vif to update beacon\n");
-+		return;
-+	}
-+
-+	mutex_lock(&rtlpriv->locks.conf_mutex);
-+	send_beacon_frame(hw, vif);
-+	mutex_unlock(&rtlpriv->locks.conf_mutex);
-+}
-+EXPORT_SYMBOL_GPL(rtl_update_beacon_work_callback);
-+
- static void rtl_op_bss_info_changed(struct ieee80211_hw *hw,
- 				    struct ieee80211_vif *vif,
- 				    struct ieee80211_bss_conf *bss_conf,
-@@ -1747,6 +1766,18 @@ static void rtl_op_flush(struct ieee8021
- 		rtlpriv->intf_ops->flush(hw, queues, drop);
- }
- 
-+static int rtl_op_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta,
-+			  bool set)
-+{
-+	struct rtl_priv *rtlpriv = rtl_priv(hw);
-+	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-+
-+	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8192CU)
-+		schedule_work(&rtlpriv->works.update_beacon_work);
-+
-+	return 0;
-+}
-+
- /*	Description:
-  *		This routine deals with the Power Configuration CMD
-  *		 parsing for RTL8723/RTL8188E Series IC.
-@@ -1903,6 +1934,7 @@ const struct ieee80211_ops rtl_ops = {
- 	.sta_add = rtl_op_sta_add,
- 	.sta_remove = rtl_op_sta_remove,
- 	.flush = rtl_op_flush,
-+	.set_tim = rtl_op_set_tim,
- };
- EXPORT_SYMBOL_GPL(rtl_ops);
- 
---- a/drivers/net/wireless/realtek/rtlwifi/core.h
-+++ b/drivers/net/wireless/realtek/rtlwifi/core.h
-@@ -60,5 +60,6 @@ void rtl_bb_delay(struct ieee80211_hw *h
- bool rtl_cmd_send_packet(struct ieee80211_hw *hw, struct sk_buff *skb);
- bool rtl_btc_status_false(void);
- void rtl_dm_diginit(struct ieee80211_hw *hw, u32 cur_igval);
-+void rtl_update_beacon_work_callback(struct work_struct *work);
- 
- #endif
---- a/drivers/net/wireless/realtek/rtlwifi/usb.c
-+++ b/drivers/net/wireless/realtek/rtlwifi/usb.c
-@@ -807,6 +807,7 @@ static void rtl_usb_stop(struct ieee8021
- 
- 	tasklet_kill(&rtlusb->rx_work_tasklet);
- 	cancel_work_sync(&rtlpriv->works.lps_change_work);
-+	cancel_work_sync(&rtlpriv->works.update_beacon_work);
- 
- 	flush_workqueue(rtlpriv->works.rtl_wq);
- 
-@@ -1033,6 +1034,8 @@ int rtl_usb_probe(struct usb_interface *
- 		  rtl_fill_h2c_cmd_work_callback);
- 	INIT_WORK(&rtlpriv->works.lps_change_work,
- 		  rtl_lps_change_work_callback);
-+	INIT_WORK(&rtlpriv->works.update_beacon_work,
-+		  rtl_update_beacon_work_callback);
- 
- 	rtlpriv->usb_data_index = 0;
- 	init_completion(&rtlpriv->firmware_loading_complete);
---- a/drivers/net/wireless/realtek/rtlwifi/wifi.h
-+++ b/drivers/net/wireless/realtek/rtlwifi/wifi.h
-@@ -2487,6 +2487,7 @@ struct rtl_works {
- 
- 	struct work_struct lps_change_work;
- 	struct work_struct fill_h2c_cmd;
-+	struct work_struct update_beacon_work;
- };
- 
- struct rtl_debug {
diff --git a/package/kernel/mac80211/patches/subsys/010-sync-nl80211_h.patch b/package/kernel/mac80211/patches/subsys/010-sync-nl80211_h.patch
deleted file mode 100644
index e1f66ac1c3..0000000000
--- a/package/kernel/mac80211/patches/subsys/010-sync-nl80211_h.patch
+++ /dev/null
@@ -1,297 +0,0 @@
---- a/include/uapi/linux/nl80211.h
-+++ b/include/uapi/linux/nl80211.h
-@@ -655,6 +655,9 @@
-  *	When a security association was established on an 802.1X network using
-  *	fast transition, this event should be followed by an
-  *	%NL80211_CMD_PORT_AUTHORIZED event.
-+ *	Following a %NL80211_CMD_ROAM event userspace can issue
-+ *	%NL80211_CMD_GET_SCAN in order to obtain the scan information for the
-+ *	new BSS the card/driver roamed to.
-  * @NL80211_CMD_DISCONNECT: drop a given connection; also used to notify
-  *	userspace that a connection was dropped by the AP or due to other
-  *	reasons, for this the %NL80211_ATTR_DISCONNECTED_BY_AP and
-@@ -757,7 +760,8 @@
-  *	of any other interfaces, and other interfaces will again take
-  *	precedence when they are used.
-  *
-- * @NL80211_CMD_SET_WDS_PEER: Set the MAC address of the peer on a WDS interface.
-+ * @NL80211_CMD_SET_WDS_PEER: Set the MAC address of the peer on a WDS interface
-+ *	(no longer supported).
-  *
-  * @NL80211_CMD_SET_MULTICAST_TO_UNICAST: Configure if this AP should perform
-  *	multicast to unicast conversion. When enabled, all multicast packets
-@@ -1177,6 +1181,10 @@
-  *	includes the contents of the frame. %NL80211_ATTR_ACK flag is included
-  *	if the recipient acknowledged the frame.
-  *
-+ * @NL80211_CMD_SET_SAR_SPECS: SAR power limitation configuration is
-+ *	passed using %NL80211_ATTR_SAR_SPEC. %NL80211_ATTR_WIPHY is used to
-+ *	specify the wiphy index to be applied to.
-+ *
-  * @NL80211_CMD_MAX: highest used command number
-  * @__NL80211_CMD_AFTER_LAST: internal use
-  */
-@@ -1407,6 +1415,8 @@ enum nl80211_commands {
- 
- 	NL80211_CMD_CONTROL_PORT_FRAME_TX_STATUS,
- 
-+	NL80211_CMD_SET_SAR_SPECS,
-+
- 	/* add new commands above here */
- 
- 	/* used to define NL80211_CMD_MAX below */
-@@ -1750,8 +1760,9 @@ enum nl80211_commands {
-  *	specify just a single bitrate, which is to be used for the beacon.
-  *	The driver must also specify support for this with the extended
-  *	features NL80211_EXT_FEATURE_BEACON_RATE_LEGACY,
-- *	NL80211_EXT_FEATURE_BEACON_RATE_HT and
-- *	NL80211_EXT_FEATURE_BEACON_RATE_VHT.
-+ *	NL80211_EXT_FEATURE_BEACON_RATE_HT,
-+ *	NL80211_EXT_FEATURE_BEACON_RATE_VHT and
-+ *	NL80211_EXT_FEATURE_BEACON_RATE_HE.
-  *
-  * @NL80211_ATTR_FRAME_MATCH: A binary attribute which typically must contain
-  *	at least one byte, currently used with @NL80211_CMD_REGISTER_FRAME.
-@@ -1955,8 +1966,15 @@ enum nl80211_commands {
-  * @NL80211_ATTR_PROBE_RESP: Probe Response template data. Contains the entire
-  *	probe-response frame. The DA field in the 802.11 header is zero-ed out,
-  *	to be filled by the FW.
-- * @NL80211_ATTR_DISABLE_HT:  Force HT capable interfaces to disable
-- *      this feature.  Currently, only supported in mac80211 drivers.
-+ * @NL80211_ATTR_DISABLE_HT: Force HT capable interfaces to disable
-+ *      this feature during association. This is a flag attribute.
-+ *	Currently only supported in mac80211 drivers.
-+ * @NL80211_ATTR_DISABLE_VHT: Force VHT capable interfaces to disable
-+ *      this feature during association. This is a flag attribute.
-+ *	Currently only supported in mac80211 drivers.
-+ * @NL80211_ATTR_DISABLE_HE: Force HE capable interfaces to disable
-+ *      this feature during association. This is a flag attribute.
-+ *	Currently only supported in mac80211 drivers.
-  * @NL80211_ATTR_HT_CAPABILITY_MASK: Specify which bits of the
-  *      ATTR_HT_CAPABILITY to which attention should be paid.
-  *      Currently, only mac80211 NICs support this feature.
-@@ -2077,7 +2095,8 @@ enum nl80211_commands {
-  *	until the channel switch event.
-  * @NL80211_ATTR_CH_SWITCH_BLOCK_TX: flag attribute specifying that transmission
-  *	must be blocked on the current channel (before the channel switch
-- *	operation).
-+ *	operation). Also included in the channel switch started event if quiet
-+ *	was requested by the AP.
-  * @NL80211_ATTR_CSA_IES: Nested set of attributes containing the IE information
-  *	for the time while performing a channel switch.
-  * @NL80211_ATTR_CNTDWN_OFFS_BEACON: An array of offsets (u16) to the channel
-@@ -2527,6 +2546,20 @@ enum nl80211_commands {
-  *	override mask. Used with NL80211_ATTR_S1G_CAPABILITY in
-  *	NL80211_CMD_ASSOCIATE or NL80211_CMD_CONNECT.
-  *
-+ * @NL80211_ATTR_SAE_PWE: Indicates the mechanism(s) allowed for SAE PWE
-+ *	derivation in WPA3-Personal networks which are using SAE authentication.
-+ *	This is a u8 attribute that encapsulates one of the values from
-+ *	&enum nl80211_sae_pwe_mechanism.
-+ *
-+ * @NL80211_ATTR_SAR_SPEC: SAR power limitation specification when
-+ *	used with %NL80211_CMD_SET_SAR_SPECS. The message contains fields
-+ *	of %nl80211_sar_attrs which specifies the sar type and related
-+ *	sar specs. Sar specs contains array of %nl80211_sar_specs_attrs.
-+ *
-+ * @NL80211_ATTR_RECONNECT_REQUESTED: flag attribute, used with deauth and
-+ *	disassoc events to indicate that an immediate reconnect to the AP
-+ *	is desired.
-+ *
-  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
-  * @NL80211_ATTR_MAX: highest attribute number currently defined
-  * @__NL80211_ATTR_AFTER_LAST: internal use
-@@ -3016,6 +3049,14 @@ enum nl80211_attrs {
- 	NL80211_ATTR_S1G_CAPABILITY,
- 	NL80211_ATTR_S1G_CAPABILITY_MASK,
- 
-+	NL80211_ATTR_SAE_PWE,
-+
-+	NL80211_ATTR_RECONNECT_REQUESTED,
-+
-+	NL80211_ATTR_SAR_SPEC,
-+
-+	NL80211_ATTR_DISABLE_HE,
-+
- 	/* add attributes here, update the policy in nl80211.c */
- 
- 	__NL80211_ATTR_AFTER_LAST,
-@@ -5896,6 +5937,19 @@ enum nl80211_feature_flags {
-  * @NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP: Driver/device supports
-  *	unsolicited broadcast probe response transmission
-  *
-+ * @NL80211_EXT_FEATURE_BEACON_RATE_HE: Driver supports beacon rate
-+ *	configuration (AP/mesh) with HE rates.
-+ *
-+ * @NL80211_EXT_FEATURE_SECURE_LTF: Device supports secure LTF measurement
-+ *      exchange protocol.
-+ *
-+ * @NL80211_EXT_FEATURE_SECURE_RTT: Device supports secure RTT measurement
-+ *      exchange protocol.
-+ *
-+ * @NL80211_EXT_FEATURE_PROT_RANGE_NEGO_AND_MEASURE: Device supports management
-+ *      frame protection for all management frames exchanged during the
-+ *      negotiation and range measurement procedure.
-+ *
-  * @NUM_NL80211_EXT_FEATURES: number of extended features.
-  * @MAX_NL80211_EXT_FEATURES: highest extended feature index.
-  */
-@@ -5956,6 +6010,10 @@ enum nl80211_ext_feature_index {
- 	NL80211_EXT_FEATURE_SAE_OFFLOAD_AP,
- 	NL80211_EXT_FEATURE_FILS_DISCOVERY,
- 	NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP,
-+	NL80211_EXT_FEATURE_BEACON_RATE_HE,
-+	NL80211_EXT_FEATURE_SECURE_LTF,
-+	NL80211_EXT_FEATURE_SECURE_RTT,
-+	NL80211_EXT_FEATURE_PROT_RANGE_NEGO_AND_MEASURE,
- 
- 	/* add new features before the definition below */
- 	NUM_NL80211_EXT_FEATURES,
-@@ -6253,11 +6311,13 @@ struct nl80211_vendor_cmd_info {
-  * @NL80211_TDLS_PEER_HT: TDLS peer is HT capable.
-  * @NL80211_TDLS_PEER_VHT: TDLS peer is VHT capable.
-  * @NL80211_TDLS_PEER_WMM: TDLS peer is WMM capable.
-+ * @NL80211_TDLS_PEER_HE: TDLS peer is HE capable.
-  */
- enum nl80211_tdls_peer_capability {
- 	NL80211_TDLS_PEER_HT = 1<<0,
- 	NL80211_TDLS_PEER_VHT = 1<<1,
- 	NL80211_TDLS_PEER_WMM = 1<<2,
-+	NL80211_TDLS_PEER_HE = 1<<3,
- };
- 
- /**
-@@ -6849,6 +6909,9 @@ enum nl80211_peer_measurement_ftm_capa {
-  *      if neither %NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED nor
-  *	%NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED is set, EDCA based
-  *	ranging will be used.
-+ * @NL80211_PMSR_FTM_REQ_ATTR_LMR_FEEDBACK: negotiate for LMR feedback. Only
-+ *	valid if either %NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED or
-+ *	%NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED is set.
-  *
-  * @NUM_NL80211_PMSR_FTM_REQ_ATTR: internal
-  * @NL80211_PMSR_FTM_REQ_ATTR_MAX: highest attribute number
-@@ -6867,6 +6930,7 @@ enum nl80211_peer_measurement_ftm_req {
- 	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC,
- 	NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED,
- 	NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED,
-+	NL80211_PMSR_FTM_REQ_ATTR_LMR_FEEDBACK,
- 
- 	/* keep last */
- 	NUM_NL80211_PMSR_FTM_REQ_ATTR,
-@@ -7124,4 +7188,115 @@ enum nl80211_unsol_bcast_probe_resp_attr
- 	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX =
- 		__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_LAST - 1
- };
-+
-+/**
-+ * enum nl80211_sae_pwe_mechanism - The mechanism(s) allowed for SAE PWE
-+ *	derivation. Applicable only when WPA3-Personal SAE authentication is
-+ *	used.
-+ *
-+ * @NL80211_SAE_PWE_UNSPECIFIED: not specified, used internally to indicate that
-+ *	attribute is not present from userspace.
-+ * @NL80211_SAE_PWE_HUNT_AND_PECK: hunting-and-pecking loop only
-+ * @NL80211_SAE_PWE_HASH_TO_ELEMENT: hash-to-element only
-+ * @NL80211_SAE_PWE_BOTH: both hunting-and-pecking loop and hash-to-element
-+ *	can be used.
-+ */
-+enum nl80211_sae_pwe_mechanism {
-+	NL80211_SAE_PWE_UNSPECIFIED,
-+	NL80211_SAE_PWE_HUNT_AND_PECK,
-+	NL80211_SAE_PWE_HASH_TO_ELEMENT,
-+	NL80211_SAE_PWE_BOTH,
-+};
-+
-+/**
-+ * enum nl80211_sar_type - type of SAR specs
-+ *
-+ * @NL80211_SAR_TYPE_POWER: power limitation specified in 0.25dBm unit
-+ *
-+ */
-+enum nl80211_sar_type {
-+	NL80211_SAR_TYPE_POWER,
-+
-+	/* add new type here */
-+
-+	/* Keep last */
-+	NUM_NL80211_SAR_TYPE,
-+};
-+
-+/**
-+ * enum nl80211_sar_attrs - Attributes for SAR spec
-+ *
-+ * @NL80211_SAR_ATTR_TYPE: the SAR type as defined in &enum nl80211_sar_type.
-+ *
-+ * @NL80211_SAR_ATTR_SPECS: Nested array of SAR power
-+ *	limit specifications. Each specification contains a set
-+ *	of %nl80211_sar_specs_attrs.
-+ *
-+ *	For SET operation, it contains array of %NL80211_SAR_ATTR_SPECS_POWER
-+ *	and %NL80211_SAR_ATTR_SPECS_RANGE_INDEX.
-+ *
-+ *	For sar_capa dump, it contains array of
-+ *	%NL80211_SAR_ATTR_SPECS_START_FREQ
-+ *	and %NL80211_SAR_ATTR_SPECS_END_FREQ.
-+ *
-+ * @__NL80211_SAR_ATTR_LAST: Internal
-+ * @NL80211_SAR_ATTR_MAX: highest sar attribute
-+ *
-+ * These attributes are used with %NL80211_CMD_SET_SAR_SPEC
-+ */
-+enum nl80211_sar_attrs {
-+	__NL80211_SAR_ATTR_INVALID,
-+
-+	NL80211_SAR_ATTR_TYPE,
-+	NL80211_SAR_ATTR_SPECS,
-+
-+	__NL80211_SAR_ATTR_LAST,
-+	NL80211_SAR_ATTR_MAX = __NL80211_SAR_ATTR_LAST - 1,
-+};
-+
-+/**
-+ * enum nl80211_sar_specs_attrs - Attributes for SAR power limit specs
-+ *
-+ * @NL80211_SAR_ATTR_SPECS_POWER: Required (s32)value to specify the actual
-+ *	power limit value in units of 0.25 dBm if type is
-+ *	NL80211_SAR_TYPE_POWER. (i.e., a value of 44 represents 11 dBm).
-+ *	0 means userspace doesn't have SAR limitation on this associated range.
-+ *
-+ * @NL80211_SAR_ATTR_SPECS_RANGE_INDEX: Required (u32) value to specify the
-+ *	index of exported freq range table and the associated power limitation
-+ *	is applied to this range.
-+ *
-+ *	Userspace isn't required to set all the ranges advertised by WLAN driver,
-+ *	and userspace can skip some certain ranges. These skipped ranges don't
-+ *	have SAR limitations, and they are same as setting the
-+ *	%NL80211_SAR_ATTR_SPECS_POWER to any unreasonable high value because any
-+ *	value higher than regulatory allowed value just means SAR power
-+ *	limitation is removed, but it's required to set at least one range.
-+ *	It's not allowed to set duplicated range in one SET operation.
-+ *
-+ *	Every SET operation overwrites previous SET operation.
-+ *
-+ * @NL80211_SAR_ATTR_SPECS_START_FREQ: Required (u32) value to specify the start
-+ *	frequency of this range edge when registering SAR capability to wiphy.
-+ *	It's not a channel center frequency. The unit is kHz.
-+ *
-+ * @NL80211_SAR_ATTR_SPECS_END_FREQ: Required (u32) value to specify the end
-+ *	frequency of this range edge when registering SAR capability to wiphy.
-+ *	It's not a channel center frequency. The unit is kHz.
-+ *
-+ * @__NL80211_SAR_ATTR_SPECS_LAST: Internal
-+ * @NL80211_SAR_ATTR_SPECS_MAX: highest sar specs attribute
-+ */
-+enum nl80211_sar_specs_attrs {
-+	__NL80211_SAR_ATTR_SPECS_INVALID,
-+
-+	NL80211_SAR_ATTR_SPECS_POWER,
-+	NL80211_SAR_ATTR_SPECS_RANGE_INDEX,
-+	NL80211_SAR_ATTR_SPECS_START_FREQ,
-+	NL80211_SAR_ATTR_SPECS_END_FREQ,
-+
-+	__NL80211_SAR_ATTR_SPECS_LAST,
-+	NL80211_SAR_ATTR_SPECS_MAX = __NL80211_SAR_ATTR_SPECS_LAST - 1,
-+};
-+
- #endif /* __LINUX_NL80211_H */
diff --git a/package/kernel/mac80211/patches/subsys/100-remove-cryptoapi-dependencies.patch b/package/kernel/mac80211/patches/subsys/100-remove-cryptoapi-dependencies.patch
deleted file mode 100644
index a03b060918..0000000000
--- a/package/kernel/mac80211/patches/subsys/100-remove-cryptoapi-dependencies.patch
+++ /dev/null
@@ -1,699 +0,0 @@
---- a/net/mac80211/Makefile
-+++ b/net/mac80211/Makefile
-@@ -7,7 +7,6 @@ mac80211-y := \
- 	driver-ops.o \
- 	sta_info.o \
- 	wep.o \
--	aead_api.o \
- 	wpa.o \
- 	scan.o offchannel.o \
- 	ht.o agg-tx.o agg-rx.o \
-@@ -19,8 +18,8 @@ mac80211-y := \
- 	rate.o \
- 	michael.o \
- 	tkip.o \
-+	aes_ccm.o \
- 	aes_cmac.o \
--	aes_gmac.o \
- 	fils_aead.o \
- 	cfg.o \
- 	ethtool.o \
---- a/net/mac80211/aead_api.c
-+++ /dev/null
-@@ -1,113 +0,0 @@
--// SPDX-License-Identifier: GPL-2.0-only
--/*
-- * Copyright 2003-2004, Instant802 Networks, Inc.
-- * Copyright 2005-2006, Devicescape Software, Inc.
-- * Copyright 2014-2015, Qualcomm Atheros, Inc.
-- *
-- * Rewrite: Copyright (C) 2013 Linaro Ltd <ard.biesheuvel@linaro.org>
-- */
--
--#include <linux/kernel.h>
--#include <linux/types.h>
--#include <linux/err.h>
--#include <linux/scatterlist.h>
--#include <crypto/aead.h>
--
--#include "aead_api.h"
--
--int aead_encrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad, size_t aad_len,
--		 u8 *data, size_t data_len, u8 *mic)
--{
--	size_t mic_len = crypto_aead_authsize(tfm);
--	struct scatterlist sg[3];
--	struct aead_request *aead_req;
--	int reqsize = sizeof(*aead_req) + crypto_aead_reqsize(tfm);
--	u8 *__aad;
--	int ret;
--
--	aead_req = kzalloc(reqsize + aad_len, GFP_ATOMIC);
--	if (!aead_req)
--		return -ENOMEM;
--
--	__aad = (u8 *)aead_req + reqsize;
--	memcpy(__aad, aad, aad_len);
--
--	sg_init_table(sg, 3);
--	sg_set_buf(&sg[0], __aad, aad_len);
--	sg_set_buf(&sg[1], data, data_len);
--	sg_set_buf(&sg[2], mic, mic_len);
--
--	aead_request_set_tfm(aead_req, tfm);
--	aead_request_set_crypt(aead_req, sg, sg, data_len, b_0);
--	aead_request_set_ad(aead_req, sg[0].length);
--
--	ret = crypto_aead_encrypt(aead_req);
--	kfree_sensitive(aead_req);
--
--	return ret;
--}
--
--int aead_decrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad, size_t aad_len,
--		 u8 *data, size_t data_len, u8 *mic)
--{
--	size_t mic_len = crypto_aead_authsize(tfm);
--	struct scatterlist sg[3];
--	struct aead_request *aead_req;
--	int reqsize = sizeof(*aead_req) + crypto_aead_reqsize(tfm);
--	u8 *__aad;
--	int err;
--
--	if (data_len == 0)
--		return -EINVAL;
--
--	aead_req = kzalloc(reqsize + aad_len, GFP_ATOMIC);
--	if (!aead_req)
--		return -ENOMEM;
--
--	__aad = (u8 *)aead_req + reqsize;
--	memcpy(__aad, aad, aad_len);
--
--	sg_init_table(sg, 3);
--	sg_set_buf(&sg[0], __aad, aad_len);
--	sg_set_buf(&sg[1], data, data_len);
--	sg_set_buf(&sg[2], mic, mic_len);
--
--	aead_request_set_tfm(aead_req, tfm);
--	aead_request_set_crypt(aead_req, sg, sg, data_len + mic_len, b_0);
--	aead_request_set_ad(aead_req, sg[0].length);
--
--	err = crypto_aead_decrypt(aead_req);
--	kfree_sensitive(aead_req);
--
--	return err;
--}
--
--struct crypto_aead *
--aead_key_setup_encrypt(const char *alg, const u8 key[],
--		       size_t key_len, size_t mic_len)
--{
--	struct crypto_aead *tfm;
--	int err;
--
--	tfm = crypto_alloc_aead(alg, 0, CRYPTO_ALG_ASYNC);
--	if (IS_ERR(tfm))
--		return tfm;
--
--	err = crypto_aead_setkey(tfm, key, key_len);
--	if (err)
--		goto free_aead;
--	err = crypto_aead_setauthsize(tfm, mic_len);
--	if (err)
--		goto free_aead;
--
--	return tfm;
--
--free_aead:
--	crypto_free_aead(tfm);
--	return ERR_PTR(err);
--}
--
--void aead_key_free(struct crypto_aead *tfm)
--{
--	crypto_free_aead(tfm);
--}
---- a/net/mac80211/aead_api.h
-+++ /dev/null
-@@ -1,23 +0,0 @@
--/* SPDX-License-Identifier: GPL-2.0-only */
--
--#ifndef _AEAD_API_H
--#define _AEAD_API_H
--
--#include <crypto/aead.h>
--#include <linux/crypto.h>
--
--struct crypto_aead *
--aead_key_setup_encrypt(const char *alg, const u8 key[],
--		       size_t key_len, size_t mic_len);
--
--int aead_encrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
--		 size_t aad_len, u8 *data,
--		 size_t data_len, u8 *mic);
--
--int aead_decrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
--		 size_t aad_len, u8 *data,
--		 size_t data_len, u8 *mic);
--
--void aead_key_free(struct crypto_aead *tfm);
--
--#endif /* _AEAD_API_H */
---- a/net/mac80211/aes_ccm.h
-+++ b/net/mac80211/aes_ccm.h
-@@ -7,39 +7,17 @@
- #ifndef AES_CCM_H
- #define AES_CCM_H
- 
--#include "aead_api.h"
-+#include <linux/crypto.h>
- 
--#define CCM_AAD_LEN	32
--
--static inline struct crypto_aead *
--ieee80211_aes_key_setup_encrypt(const u8 key[], size_t key_len, size_t mic_len)
--{
--	return aead_key_setup_encrypt("ccm(aes)", key, key_len, mic_len);
--}
--
--static inline int
--ieee80211_aes_ccm_encrypt(struct crypto_aead *tfm,
--			  u8 *b_0, u8 *aad, u8 *data,
--			  size_t data_len, u8 *mic)
--{
--	return aead_encrypt(tfm, b_0, aad + 2,
--			    be16_to_cpup((__be16 *)aad),
--			    data, data_len, mic);
--}
--
--static inline int
--ieee80211_aes_ccm_decrypt(struct crypto_aead *tfm,
--			  u8 *b_0, u8 *aad, u8 *data,
--			  size_t data_len, u8 *mic)
--{
--	return aead_decrypt(tfm, b_0, aad + 2,
--			    be16_to_cpup((__be16 *)aad),
--			    data, data_len, mic);
--}
--
--static inline void ieee80211_aes_key_free(struct crypto_aead *tfm)
--{
--	return aead_key_free(tfm);
--}
-+struct crypto_cipher *ieee80211_aes_key_setup_encrypt(const u8 key[],
-+						      size_t key_len,
-+						      size_t mic_len);
-+void ieee80211_aes_ccm_encrypt(struct crypto_cipher *tfm, u8 *b_0, u8 *aad,
-+			       u8 *data, size_t data_len, u8 *mic,
-+			       size_t mic_len);
-+int ieee80211_aes_ccm_decrypt(struct crypto_cipher *tfm, u8 *b_0, u8 *aad,
-+			      u8 *data, size_t data_len, u8 *mic,
-+			      size_t mic_len);
-+void ieee80211_aes_key_free(struct crypto_cipher *tfm);
- 
- #endif /* AES_CCM_H */
---- /dev/null
-+++ b/net/mac80211/aes_gcm.c
-@@ -0,0 +1,109 @@
-+/*
-+ * Copyright 2014-2015, Qualcomm Atheros, Inc.
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/types.h>
-+#include <linux/err.h>
-+#include <crypto/aead.h>
-+
-+#include <net/mac80211.h>
-+#include "key.h"
-+#include "aes_gcm.h"
-+
-+int ieee80211_aes_gcm_encrypt(struct crypto_aead *tfm, u8 *j_0, u8 *aad,
-+			      u8 *data, size_t data_len, u8 *mic)
-+{
-+	struct scatterlist sg[3];
-+	struct aead_request *aead_req;
-+	int reqsize = sizeof(*aead_req) + crypto_aead_reqsize(tfm);
-+	u8 *__aad;
-+
-+	aead_req = kzalloc(reqsize + GCM_AAD_LEN, GFP_ATOMIC);
-+	if (!aead_req)
-+		return -ENOMEM;
-+
-+	__aad = (u8 *)aead_req + reqsize;
-+	memcpy(__aad, aad, GCM_AAD_LEN);
-+
-+	sg_init_table(sg, 3);
-+	sg_set_buf(&sg[0], &__aad[2], be16_to_cpup((__be16 *)__aad));
-+	sg_set_buf(&sg[1], data, data_len);
-+	sg_set_buf(&sg[2], mic, IEEE80211_GCMP_MIC_LEN);
-+
-+	aead_request_set_tfm(aead_req, tfm);
-+	aead_request_set_crypt(aead_req, sg, sg, data_len, j_0);
-+	aead_request_set_ad(aead_req, sg[0].length);
-+
-+	crypto_aead_encrypt(aead_req);
-+	kzfree(aead_req);
-+	return 0;
-+}
-+
-+int ieee80211_aes_gcm_decrypt(struct crypto_aead *tfm, u8 *j_0, u8 *aad,
-+			      u8 *data, size_t data_len, u8 *mic)
-+{
-+	struct scatterlist sg[3];
-+	struct aead_request *aead_req;
-+	int reqsize = sizeof(*aead_req) + crypto_aead_reqsize(tfm);
-+	u8 *__aad;
-+	int err;
-+
-+	if (data_len == 0)
-+		return -EINVAL;
-+
-+	aead_req = kzalloc(reqsize + GCM_AAD_LEN, GFP_ATOMIC);
-+	if (!aead_req)
-+		return -ENOMEM;
-+
-+	__aad = (u8 *)aead_req + reqsize;
-+	memcpy(__aad, aad, GCM_AAD_LEN);
-+
-+	sg_init_table(sg, 3);
-+	sg_set_buf(&sg[0], &__aad[2], be16_to_cpup((__be16 *)__aad));
-+	sg_set_buf(&sg[1], data, data_len);
-+	sg_set_buf(&sg[2], mic, IEEE80211_GCMP_MIC_LEN);
-+
-+	aead_request_set_tfm(aead_req, tfm);
-+	aead_request_set_crypt(aead_req, sg, sg,
-+			       data_len + IEEE80211_GCMP_MIC_LEN, j_0);
-+	aead_request_set_ad(aead_req, sg[0].length);
-+
-+	err = crypto_aead_decrypt(aead_req);
-+	kzfree(aead_req);
-+
-+	return err;
-+}
-+
-+struct crypto_aead *ieee80211_aes_gcm_key_setup_encrypt(const u8 key[],
-+							size_t key_len)
-+{
-+	struct crypto_aead *tfm;
-+	int err;
-+
-+	tfm = crypto_alloc_aead("gcm(aes)", 0, CRYPTO_ALG_ASYNC);
-+	if (IS_ERR(tfm))
-+		return tfm;
-+
-+	err = crypto_aead_setkey(tfm, key, key_len);
-+	if (err)
-+		goto free_aead;
-+	err = crypto_aead_setauthsize(tfm, IEEE80211_GCMP_MIC_LEN);
-+	if (err)
-+		goto free_aead;
-+
-+	return tfm;
-+
-+free_aead:
-+	crypto_free_aead(tfm);
-+	return ERR_PTR(err);
-+}
-+
-+void ieee80211_aes_gcm_key_free(struct crypto_aead *tfm)
-+{
-+	crypto_free_aead(tfm);
-+}
---- a/net/mac80211/aes_gcm.h
-+++ b/net/mac80211/aes_gcm.h
-@@ -6,38 +6,30 @@
- #ifndef AES_GCM_H
- #define AES_GCM_H
- 
--#include "aead_api.h"
-+#include <linux/crypto.h>
- 
--#define GCM_AAD_LEN	32
--
--static inline int ieee80211_aes_gcm_encrypt(struct crypto_aead *tfm,
--					    u8 *j_0, u8 *aad,  u8 *data,
--					    size_t data_len, u8 *mic)
-+static inline void
-+ieee80211_aes_gcm_encrypt(struct crypto_aead *tfm, u8 *j_0, u8 *aad,
-+			  u8 *data, size_t data_len, u8 *mic)
- {
--	return aead_encrypt(tfm, j_0, aad + 2,
--			    be16_to_cpup((__be16 *)aad),
--			    data, data_len, mic);
- }
- 
--static inline int ieee80211_aes_gcm_decrypt(struct crypto_aead *tfm,
--					    u8 *j_0, u8 *aad, u8 *data,
--					    size_t data_len, u8 *mic)
-+static inline int
-+ieee80211_aes_gcm_decrypt(struct crypto_aead *tfm, u8 *j_0, u8 *aad,
-+			  u8 *data, size_t data_len, u8 *mic)
- {
--	return aead_decrypt(tfm, j_0, aad + 2,
--			    be16_to_cpup((__be16 *)aad),
--			    data, data_len, mic);
-+    return -EOPNOTSUPP;
- }
- 
- static inline struct crypto_aead *
- ieee80211_aes_gcm_key_setup_encrypt(const u8 key[], size_t key_len)
- {
--	return aead_key_setup_encrypt("gcm(aes)", key,
--				      key_len, IEEE80211_GCMP_MIC_LEN);
-+    return NULL;
- }
- 
--static inline void ieee80211_aes_gcm_key_free(struct crypto_aead *tfm)
-+static inline void
-+ieee80211_aes_gcm_key_free(struct crypto_aead *tfm)
- {
--	return aead_key_free(tfm);
- }
- 
- #endif /* AES_GCM_H */
---- a/net/mac80211/wpa.c
-+++ b/net/mac80211/wpa.c
-@@ -312,7 +312,8 @@ ieee80211_crypto_tkip_decrypt(struct iee
- }
- 
- 
--static void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *b_0, u8 *aad)
-+static void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *b_0, u8 *aad,
-+				u16 data_len)
- {
- 	__le16 mask_fc;
- 	int a4_included, mgmt;
-@@ -342,14 +343,8 @@ static void ccmp_special_blocks(struct s
- 	else
- 		qos_tid = 0;
- 
--	/* In CCM, the initial vectors (IV) used for CTR mode encryption and CBC
--	 * mode authentication are not allowed to collide, yet both are derived
--	 * from this vector b_0. We only set L := 1 here to indicate that the
--	 * data size can be represented in (L+1) bytes. The CCM layer will take
--	 * care of storing the data length in the top (L+1) bytes and setting
--	 * and clearing the other bits as is required to derive the two IVs.
--	 */
--	b_0[0] = 0x1;
-+	/* First block, b_0 */
-+	b_0[0] = 0x59; /* flags: Adata: 1, M: 011, L: 001 */
- 
- 	/* Nonce: Nonce Flags | A2 | PN
- 	 * Nonce Flags: Priority (b0..b3) | Management (b4) | Reserved (b5..b7)
-@@ -357,6 +352,8 @@ static void ccmp_special_blocks(struct s
- 	b_0[1] = qos_tid | (mgmt << 4);
- 	memcpy(&b_0[2], hdr->addr2, ETH_ALEN);
- 	memcpy(&b_0[8], pn, IEEE80211_CCMP_PN_LEN);
-+	/* l(m) */
-+	put_unaligned_be16(data_len, &b_0[14]);
- 
- 	/* AAD (extra authenticate-only data) / masked 802.11 header
- 	 * FC | A1 | A2 | A3 | SC | [A4] | [QC] */
-@@ -413,7 +410,7 @@ static int ccmp_encrypt_skb(struct ieee8
- 	u8 *pos;
- 	u8 pn[6];
- 	u64 pn64;
--	u8 aad[CCM_AAD_LEN];
-+	u8 aad[2 * AES_BLOCK_SIZE];
- 	u8 b_0[AES_BLOCK_SIZE];
- 
- 	if (info->control.hw_key &&
-@@ -468,9 +465,11 @@ static int ccmp_encrypt_skb(struct ieee8
- 		return 0;
- 
- 	pos += IEEE80211_CCMP_HDR_LEN;
--	ccmp_special_blocks(skb, pn, b_0, aad);
--	return ieee80211_aes_ccm_encrypt(key->u.ccmp.tfm, b_0, aad, pos, len,
--					 skb_put(skb, mic_len));
-+	ccmp_special_blocks(skb, pn, b_0, aad, len);
-+	ieee80211_aes_ccm_encrypt(key->u.ccmp.tfm, b_0, aad, pos, len,
-+				  skb_put(skb, mic_len), mic_len);
-+
-+	return 0;
- }
- 
- 
-@@ -546,13 +545,13 @@ ieee80211_crypto_ccmp_decrypt(struct iee
- 			u8 aad[2 * AES_BLOCK_SIZE];
- 			u8 b_0[AES_BLOCK_SIZE];
- 			/* hardware didn't decrypt/verify MIC */
--			ccmp_special_blocks(skb, pn, b_0, aad);
-+			ccmp_special_blocks(skb, pn, b_0, aad, data_len);
- 
- 			if (ieee80211_aes_ccm_decrypt(
- 				    key->u.ccmp.tfm, b_0, aad,
- 				    skb->data + hdrlen + IEEE80211_CCMP_HDR_LEN,
- 				    data_len,
--				    skb->data + skb->len - mic_len))
-+				    skb->data + skb->len - mic_len, mic_len))
- 				return RX_DROP_UNUSABLE;
- 		}
- 
-@@ -649,7 +648,7 @@ static int gcmp_encrypt_skb(struct ieee8
- 	u8 *pos;
- 	u8 pn[6];
- 	u64 pn64;
--	u8 aad[GCM_AAD_LEN];
-+	u8 aad[2 * AES_BLOCK_SIZE];
- 	u8 j_0[AES_BLOCK_SIZE];
- 
- 	if (info->control.hw_key &&
-@@ -706,8 +705,10 @@ static int gcmp_encrypt_skb(struct ieee8
- 
- 	pos += IEEE80211_GCMP_HDR_LEN;
- 	gcmp_special_blocks(skb, pn, j_0, aad);
--	return ieee80211_aes_gcm_encrypt(key->u.gcmp.tfm, j_0, aad, pos, len,
--					 skb_put(skb, IEEE80211_GCMP_MIC_LEN));
-+	ieee80211_aes_gcm_encrypt(key->u.gcmp.tfm, j_0, aad, pos, len,
-+				  skb_put(skb, IEEE80211_GCMP_MIC_LEN));
-+
-+	return 0;
- }
- 
- ieee80211_tx_result
-@@ -1139,9 +1140,9 @@ ieee80211_crypto_aes_gmac_encrypt(struct
- 	struct ieee80211_key *key = tx->key;
- 	struct ieee80211_mmie_16 *mmie;
- 	struct ieee80211_hdr *hdr;
--	u8 aad[GMAC_AAD_LEN];
-+	u8 aad[20];
- 	u64 pn64;
--	u8 nonce[GMAC_NONCE_LEN];
-+	u8 nonce[12];
- 
- 	if (WARN_ON(skb_queue_len(&tx->skbs) != 1))
- 		return TX_DROP;
-@@ -1187,7 +1188,7 @@ ieee80211_crypto_aes_gmac_decrypt(struct
- 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
- 	struct ieee80211_key *key = rx->key;
- 	struct ieee80211_mmie_16 *mmie;
--	u8 aad[GMAC_AAD_LEN], *mic, ipn[6], nonce[GMAC_NONCE_LEN];
-+	u8 aad[20], *mic, ipn[6], nonce[12];
- 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
- 
- 	if (!ieee80211_is_mgmt(hdr->frame_control))
---- /dev/null
-+++ b/net/mac80211/aes_ccm.c
-@@ -0,0 +1,144 @@
-+/*
-+ * Copyright 2003-2004, Instant802 Networks, Inc.
-+ * Copyright 2005-2006, Devicescape Software, Inc.
-+ *
-+ * Rewrite: Copyright (C) 2013 Linaro Ltd <ard.biesheuvel@linaro.org>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/types.h>
-+#include <linux/err.h>
-+#include <crypto/aead.h>
-+#include <crypto/aes.h>
-+
-+#include <net/mac80211.h>
-+#include "key.h"
-+#include "aes_ccm.h"
-+
-+static void aes_ccm_prepare(struct crypto_cipher *tfm, u8 *b_0, u8 *aad, u8 *s_0,
-+			    u8 *a, u8 *b)
-+{
-+	int i;
-+
-+	crypto_cipher_encrypt_one(tfm, b, b_0);
-+
-+	/* Extra Authenticate-only data (always two AES blocks) */
-+	for (i = 0; i < AES_BLOCK_SIZE; i++)
-+		aad[i] ^= b[i];
-+	crypto_cipher_encrypt_one(tfm, b, aad);
-+
-+	aad += AES_BLOCK_SIZE;
-+
-+	for (i = 0; i < AES_BLOCK_SIZE; i++)
-+		aad[i] ^= b[i];
-+	crypto_cipher_encrypt_one(tfm, a, aad);
-+
-+	/* Mask out bits from auth-only-b_0 */
-+	b_0[0] &= 0x07;
-+
-+	/* S_0 is used to encrypt T (= MIC) */
-+	b_0[14] = 0;
-+	b_0[15] = 0;
-+	crypto_cipher_encrypt_one(tfm, s_0, b_0);
-+}
-+
-+
-+void ieee80211_aes_ccm_encrypt(struct crypto_cipher *tfm, u8 *b_0, u8 *aad,
-+			       u8 *data, size_t data_len, u8 *mic,
-+			       size_t mic_len)
-+{
-+	int i, j, last_len, num_blocks;
-+	u8 b[AES_BLOCK_SIZE];
-+	u8 s_0[AES_BLOCK_SIZE];
-+	u8 e[AES_BLOCK_SIZE];
-+	u8 *pos, *cpos;
-+
-+	num_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);
-+	last_len = data_len % AES_BLOCK_SIZE;
-+	aes_ccm_prepare(tfm, b_0, aad, s_0, b, b);
-+
-+	/* Process payload blocks */
-+	pos = data;
-+	cpos = data;
-+	for (j = 1; j <= num_blocks; j++) {
-+		int blen = (j == num_blocks && last_len) ?
-+			last_len : AES_BLOCK_SIZE;
-+
-+		/* Authentication followed by encryption */
-+		for (i = 0; i < blen; i++)
-+			b[i] ^= pos[i];
-+		crypto_cipher_encrypt_one(tfm, b, b);
-+
-+		b_0[14] = (j >> 8) & 0xff;
-+		b_0[15] = j & 0xff;
-+		crypto_cipher_encrypt_one(tfm, e, b_0);
-+		for (i = 0; i < blen; i++)
-+			*cpos++ = *pos++ ^ e[i];
-+	}
-+
-+	for (i = 0; i < mic_len; i++)
-+		mic[i] = b[i] ^ s_0[i];
-+}
-+
-+int ieee80211_aes_ccm_decrypt(struct crypto_cipher *tfm, u8 *b_0, u8 *aad,
-+			      u8 *data, size_t data_len, u8 *mic,
-+			      size_t mic_len)
-+{
-+	int i, j, last_len, num_blocks;
-+	u8 *pos, *cpos;
-+	u8 a[AES_BLOCK_SIZE];
-+	u8 b[AES_BLOCK_SIZE];
-+	u8 s_0[AES_BLOCK_SIZE];
-+
-+	num_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);
-+	last_len = data_len % AES_BLOCK_SIZE;
-+	aes_ccm_prepare(tfm, b_0, aad, s_0, a, b);
-+
-+	/* Process payload blocks */
-+	cpos = data;
-+	pos = data;
-+	for (j = 1; j <= num_blocks; j++) {
-+		int blen = (j == num_blocks && last_len) ?
-+			last_len : AES_BLOCK_SIZE;
-+
-+		/* Decryption followed by authentication */
-+		b_0[14] = (j >> 8) & 0xff;
-+		b_0[15] = j & 0xff;
-+		crypto_cipher_encrypt_one(tfm, b, b_0);
-+		for (i = 0; i < blen; i++) {
-+			*pos = *cpos++ ^ b[i];
-+			a[i] ^= *pos++;
-+		}
-+		crypto_cipher_encrypt_one(tfm, a, a);
-+	}
-+
-+	for (i = 0; i < mic_len; i++) {
-+		if ((mic[i] ^ s_0[i]) != a[i])
-+			return -1;
-+	}
-+
-+	return 0;
-+}
-+
-+struct crypto_cipher *ieee80211_aes_key_setup_encrypt(const u8 key[],
-+						      size_t key_len,
-+						      size_t mic_len)
-+{
-+	struct crypto_cipher *tfm;
-+
-+	tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);
-+	if (!IS_ERR(tfm))
-+		crypto_cipher_setkey(tfm, key, key_len);
-+
-+	return tfm;
-+}
-+
-+
-+void ieee80211_aes_key_free(struct crypto_cipher *tfm)
-+{
-+	crypto_free_cipher(tfm);
-+}
---- a/net/mac80211/Kconfig
-+++ b/net/mac80211/Kconfig
-@@ -6,8 +6,6 @@ config MAC80211
- 	depends on CRYPTO
- 	select BPAUTO_CRYPTO_LIB_ARC4
- 	depends on CRYPTO_AES
--	depends on CRYPTO_CCM
--	depends on CRYPTO_GCM
- 	depends on CRYPTO_CMAC
- 	depends on CRC32
- 	help
---- a/net/mac80211/aes_gmac.h
-+++ b/net/mac80211/aes_gmac.h
-@@ -12,10 +12,22 @@
- #define GMAC_MIC_LEN	16
- #define GMAC_NONCE_LEN	12
- 
--struct crypto_aead *ieee80211_aes_gmac_key_setup(const u8 key[],
--						 size_t key_len);
--int ieee80211_aes_gmac(struct crypto_aead *tfm, const u8 *aad, u8 *nonce,
--		       const u8 *data, size_t data_len, u8 *mic);
--void ieee80211_aes_gmac_key_free(struct crypto_aead *tfm);
-+static inline struct crypto_aead *
-+ieee80211_aes_gmac_key_setup(const u8 key[], size_t key_len)
-+{
-+	return NULL;
-+}
-+
-+static inline int
-+ieee80211_aes_gmac(struct crypto_aead *tfm, const u8 *aad, u8 *nonce,
-+		   const u8 *data, size_t data_len, u8 *mic)
-+{
-+	return -EOPNOTSUPP;
-+}
-+
-+static inline void
-+ieee80211_aes_gmac_key_free(struct crypto_aead *tfm)
-+{
-+}
- 
- #endif /* AES_GMAC_H */
---- a/net/mac80211/key.h
-+++ b/net/mac80211/key.h
-@@ -89,7 +89,7 @@ struct ieee80211_key {
- 			 * Management frames.
- 			 */
- 			u8 rx_pn[IEEE80211_NUM_TIDS + 1][IEEE80211_CCMP_PN_LEN];
--			struct crypto_aead *tfm;
-+			struct crypto_cipher *tfm;
- 			u32 replays; /* dot11RSNAStatsCCMPReplays */
- 		} ccmp;
- 		struct {
diff --git a/package/kernel/mac80211/patches/subsys/110-mac80211_keep_keys_on_stop_ap.patch b/package/kernel/mac80211/patches/subsys/110-mac80211_keep_keys_on_stop_ap.patch
index 45cd0e3dc0..5307fd355c 100644
--- a/package/kernel/mac80211/patches/subsys/110-mac80211_keep_keys_on_stop_ap.patch
+++ b/package/kernel/mac80211/patches/subsys/110-mac80211_keep_keys_on_stop_ap.patch
@@ -2,7 +2,7 @@ Used for AP+STA support in OpenWrt - preserve AP mode keys across STA reconnects
 
 --- a/net/mac80211/cfg.c
 +++ b/net/mac80211/cfg.c
-@@ -1310,7 +1310,6 @@ static int ieee80211_stop_ap(struct wiph
+@@ -1319,7 +1319,6 @@ static int ieee80211_stop_ap(struct wiph
  	sdata->vif.bss_conf.ftmr_params = NULL;
  
  	__sta_info_flush(sdata, true);
diff --git a/package/kernel/mac80211/patches/subsys/120-cfg80211_allow_perm_addr_change.patch b/package/kernel/mac80211/patches/subsys/120-cfg80211_allow_perm_addr_change.patch
index 172e5b04fd..ffd8807ccc 100644
--- a/package/kernel/mac80211/patches/subsys/120-cfg80211_allow_perm_addr_change.patch
+++ b/package/kernel/mac80211/patches/subsys/120-cfg80211_allow_perm_addr_change.patch
@@ -1,6 +1,6 @@
 --- a/net/wireless/sysfs.c
 +++ b/net/wireless/sysfs.c
-@@ -23,18 +23,35 @@ static inline struct cfg80211_registered
+@@ -24,18 +24,35 @@ static inline struct cfg80211_registered
  	return container_of(dev, struct cfg80211_registered_device, wiphy.dev);
  }
  
diff --git a/package/kernel/mac80211/patches/subsys/130-disable-fils.patch b/package/kernel/mac80211/patches/subsys/130-disable-fils.patch
deleted file mode 100644
index 9c6e971f9d..0000000000
--- a/package/kernel/mac80211/patches/subsys/130-disable-fils.patch
+++ /dev/null
@@ -1,32 +0,0 @@
-Disable FILS support, since it pulls in crypto hash support
-
---- a/net/mac80211/fils_aead.h
-+++ b/net/mac80211/fils_aead.h
-@@ -7,7 +7,7 @@
- #ifndef FILS_AEAD_H
- #define FILS_AEAD_H
- 
--#if LINUX_VERSION_IS_GEQ(4,3,0)
-+#if 0 /* LINUX_VERSION_IS_GEQ(4,3,0) */
- int fils_encrypt_assoc_req(struct sk_buff *skb,
- 			   struct ieee80211_mgd_assoc_data *assoc_data);
- int fils_decrypt_assoc_resp(struct ieee80211_sub_if_data *sdata,
---- a/net/mac80211/fils_aead.c
-+++ b/net/mac80211/fils_aead.c
-@@ -1,4 +1,4 @@
--#if LINUX_VERSION_IS_GEQ(4,3,0)
-+#if 0 /* LINUX_VERSION_IS_GEQ(4,3,0) */
- // SPDX-License-Identifier: GPL-2.0-only
- /*
-  * FILS AEAD for (Re)Association Request/Response frames
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -591,7 +591,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
- 			   NL80211_FEATURE_MAC_ON_CREATE |
- 			   NL80211_FEATURE_USERSPACE_MPM |
- 			   NL80211_FEATURE_FULL_AP_CLIENT_STATE;
--#if LINUX_VERSION_IS_GEQ(4,3,0)
-+#if 0 /* LINUX_VERSION_IS_GEQ(4,3,0) */
- 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_FILS_STA);
- #endif
- 	wiphy_ext_feature_set(wiphy,
diff --git a/package/kernel/mac80211/patches/subsys/131-Revert-mac80211-aes-cmac-switch-to-shash-CMAC-driver.patch b/package/kernel/mac80211/patches/subsys/131-Revert-mac80211-aes-cmac-switch-to-shash-CMAC-driver.patch
deleted file mode 100644
index c3bf7ccc7a..0000000000
--- a/package/kernel/mac80211/patches/subsys/131-Revert-mac80211-aes-cmac-switch-to-shash-CMAC-driver.patch
+++ /dev/null
@@ -1,230 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 7 Oct 2017 09:37:28 +0200
-Subject: [PATCH] Revert "mac80211: aes-cmac: switch to shash CMAC
- driver"
-
-This reverts commit 26717828b75dd5c46e97f7f4a9b937d038bb2852.
-Reduces mac80211 dependencies for LEDE
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/aes_cmac.c
-+++ b/net/mac80211/aes_cmac.c
-@@ -19,67 +19,151 @@
- #define CMAC_TLEN_256 16 /* CMAC TLen = 128 bits (16 octets) */
- #define AAD_LEN 20
- 
--static const u8 zero[CMAC_TLEN_256];
- 
--void ieee80211_aes_cmac(struct crypto_shash *tfm, const u8 *aad,
-+void gf_mulx(u8 *pad)
-+{
-+	int i, carry;
-+
-+	carry = pad[0] & 0x80;
-+	for (i = 0; i < AES_BLOCK_SIZE - 1; i++)
-+		pad[i] = (pad[i] << 1) | (pad[i + 1] >> 7);
-+	pad[AES_BLOCK_SIZE - 1] <<= 1;
-+	if (carry)
-+		pad[AES_BLOCK_SIZE - 1] ^= 0x87;
-+}
-+
-+void aes_cmac_vector(struct crypto_cipher *tfm, size_t num_elem,
-+		     const u8 *addr[], const size_t *len, u8 *mac,
-+		     size_t mac_len)
-+{
-+	u8 cbc[AES_BLOCK_SIZE], pad[AES_BLOCK_SIZE];
-+	const u8 *pos, *end;
-+	size_t i, e, left, total_len;
-+
-+	memset(cbc, 0, AES_BLOCK_SIZE);
-+
-+	total_len = 0;
-+	for (e = 0; e < num_elem; e++)
-+		total_len += len[e];
-+	left = total_len;
-+
-+	e = 0;
-+	pos = addr[0];
-+	end = pos + len[0];
-+
-+	while (left >= AES_BLOCK_SIZE) {
-+		for (i = 0; i < AES_BLOCK_SIZE; i++) {
-+			cbc[i] ^= *pos++;
-+			if (pos >= end) {
-+				e++;
-+				pos = addr[e];
-+				end = pos + len[e];
-+			}
-+		}
-+		if (left > AES_BLOCK_SIZE)
-+			crypto_cipher_encrypt_one(tfm, cbc, cbc);
-+		left -= AES_BLOCK_SIZE;
-+	}
-+
-+	memset(pad, 0, AES_BLOCK_SIZE);
-+	crypto_cipher_encrypt_one(tfm, pad, pad);
-+	gf_mulx(pad);
-+
-+	if (left || total_len == 0) {
-+		for (i = 0; i < left; i++) {
-+			cbc[i] ^= *pos++;
-+			if (pos >= end) {
-+				e++;
-+				pos = addr[e];
-+				end = pos + len[e];
-+			}
-+		}
-+		cbc[left] ^= 0x80;
-+		gf_mulx(pad);
-+	}
-+
-+	for (i = 0; i < AES_BLOCK_SIZE; i++)
-+		pad[i] ^= cbc[i];
-+	crypto_cipher_encrypt_one(tfm, pad, pad);
-+	memcpy(mac, pad, mac_len);
-+}
-+
-+
-+void ieee80211_aes_cmac(struct crypto_cipher *tfm, const u8 *aad,
- 			const u8 *data, size_t data_len, u8 *mic)
- {
--	SHASH_DESC_ON_STACK(desc, tfm);
--	u8 out[AES_BLOCK_SIZE];
-+	const u8 *addr[4];
-+	size_t len[4];
-+	u8 zero[CMAC_TLEN];
- 	const __le16 *fc;
- 
--	desc->tfm = tfm;
--
--	crypto_shash_init(desc);
--	crypto_shash_update(desc, aad, AAD_LEN);
-+	memset(zero, 0, CMAC_TLEN);
-+	addr[0] = aad;
-+	len[0] = AAD_LEN;
- 	fc = (const __le16 *)aad;
- 	if (ieee80211_is_beacon(*fc)) {
- 		/* mask Timestamp field to zero */
--		crypto_shash_update(desc, zero, 8);
--		crypto_shash_update(desc, data + 8, data_len - 8 - CMAC_TLEN);
-+		addr[1] = zero;
-+		len[1] = 8;
-+		addr[2] = data + 8;
-+		len[2] = data_len - 8 - CMAC_TLEN;
-+		addr[3] = zero;
-+		len[3] = CMAC_TLEN;
-+		aes_cmac_vector(tfm, 4, addr, len, mic, CMAC_TLEN);
- 	} else {
--		crypto_shash_update(desc, data, data_len - CMAC_TLEN);
-+		addr[1] = data;
-+		len[1] = data_len - CMAC_TLEN;
-+		addr[2] = zero;
-+		len[2] = CMAC_TLEN;
-+		aes_cmac_vector(tfm, 3, addr, len, mic, CMAC_TLEN);
- 	}
--	crypto_shash_finup(desc, zero, CMAC_TLEN, out);
--
--	memcpy(mic, out, CMAC_TLEN);
- }
- 
--void ieee80211_aes_cmac_256(struct crypto_shash *tfm, const u8 *aad,
-+void ieee80211_aes_cmac_256(struct crypto_cipher *tfm, const u8 *aad,
- 			    const u8 *data, size_t data_len, u8 *mic)
- {
--	SHASH_DESC_ON_STACK(desc, tfm);
-+	const u8 *addr[4];
-+	size_t len[4];
-+	u8 zero[CMAC_TLEN_256];
- 	const __le16 *fc;
- 
--	desc->tfm = tfm;
--
--	crypto_shash_init(desc);
--	crypto_shash_update(desc, aad, AAD_LEN);
-+	memset(zero, 0, CMAC_TLEN_256);
-+	addr[0] = aad;
-+	len[0] = AAD_LEN;
-+	addr[1] = data;
- 	fc = (const __le16 *)aad;
- 	if (ieee80211_is_beacon(*fc)) {
- 		/* mask Timestamp field to zero */
--		crypto_shash_update(desc, zero, 8);
--		crypto_shash_update(desc, data + 8,
--				    data_len - 8 - CMAC_TLEN_256);
-+		addr[1] = zero;
-+		len[1] = 8;
-+		addr[2] = data + 8;
-+		len[2] = data_len - 8 - CMAC_TLEN_256;
-+		addr[3] = zero;
-+		len[3] = CMAC_TLEN_256;
-+		aes_cmac_vector(tfm, 4, addr, len, mic, CMAC_TLEN_256);
- 	} else {
--		crypto_shash_update(desc, data, data_len - CMAC_TLEN_256);
-+		addr[1] = data;
-+		len[1] = data_len - CMAC_TLEN_256;
-+		addr[2] = zero;
-+		len[2] = CMAC_TLEN_256;
-+		aes_cmac_vector(tfm, 3, addr, len, mic, CMAC_TLEN_256);
- 	}
--	crypto_shash_finup(desc, zero, CMAC_TLEN_256, mic);
- }
- 
--struct crypto_shash *ieee80211_aes_cmac_key_setup(const u8 key[],
--						  size_t key_len)
-+struct crypto_cipher *ieee80211_aes_cmac_key_setup(const u8 key[],
-+						   size_t key_len)
- {
--	struct crypto_shash *tfm;
-+	struct crypto_cipher *tfm;
- 
--	tfm = crypto_alloc_shash("cmac(aes)", 0, 0);
-+	tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);
- 	if (!IS_ERR(tfm))
--		crypto_shash_setkey(tfm, key, key_len);
-+		crypto_cipher_setkey(tfm, key, key_len);
- 
- 	return tfm;
- }
- 
--void ieee80211_aes_cmac_key_free(struct crypto_shash *tfm)
-+
-+void ieee80211_aes_cmac_key_free(struct crypto_cipher *tfm)
- {
--	crypto_free_shash(tfm);
-+	crypto_free_cipher(tfm);
- }
---- a/net/mac80211/aes_cmac.h
-+++ b/net/mac80211/aes_cmac.h
-@@ -7,14 +7,13 @@
- #define AES_CMAC_H
- 
- #include <linux/crypto.h>
--#include <crypto/hash.h>
- 
--struct crypto_shash *ieee80211_aes_cmac_key_setup(const u8 key[],
--						  size_t key_len);
--void ieee80211_aes_cmac(struct crypto_shash *tfm, const u8 *aad,
-+struct crypto_cipher *ieee80211_aes_cmac_key_setup(const u8 key[],
-+						   size_t key_len);
-+void ieee80211_aes_cmac(struct crypto_cipher *tfm, const u8 *aad,
- 			const u8 *data, size_t data_len, u8 *mic);
--void ieee80211_aes_cmac_256(struct crypto_shash *tfm, const u8 *aad,
-+void ieee80211_aes_cmac_256(struct crypto_cipher *tfm, const u8 *aad,
- 			    const u8 *data, size_t data_len, u8 *mic);
--void ieee80211_aes_cmac_key_free(struct crypto_shash *tfm);
-+void ieee80211_aes_cmac_key_free(struct crypto_cipher *tfm);
- 
- #endif /* AES_CMAC_H */
---- a/net/mac80211/key.h
-+++ b/net/mac80211/key.h
-@@ -94,7 +94,7 @@ struct ieee80211_key {
- 		} ccmp;
- 		struct {
- 			u8 rx_pn[IEEE80211_CMAC_PN_LEN];
--			struct crypto_shash *tfm;
-+			struct crypto_cipher *tfm;
- 			u32 replays; /* dot11RSNAStatsCMACReplays */
- 			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */
- 		} aes_cmac;
diff --git a/package/kernel/mac80211/patches/subsys/132-mac80211-remove-cmac-dependency.patch b/package/kernel/mac80211/patches/subsys/132-mac80211-remove-cmac-dependency.patch
deleted file mode 100644
index df67d2f101..0000000000
--- a/package/kernel/mac80211/patches/subsys/132-mac80211-remove-cmac-dependency.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/net/mac80211/Kconfig
-+++ b/net/mac80211/Kconfig
-@@ -6,7 +6,6 @@ config MAC80211
- 	depends on CRYPTO
- 	select BPAUTO_CRYPTO_LIB_ARC4
- 	depends on CRYPTO_AES
--	depends on CRYPTO_CMAC
- 	depends on CRC32
- 	help
- 	  This option enables the hardware independent IEEE 802.11
diff --git a/package/kernel/mac80211/patches/subsys/150-disable_addr_notifier.patch b/package/kernel/mac80211/patches/subsys/150-disable_addr_notifier.patch
index 8d086625e4..2dc6ab3601 100644
--- a/package/kernel/mac80211/patches/subsys/150-disable_addr_notifier.patch
+++ b/package/kernel/mac80211/patches/subsys/150-disable_addr_notifier.patch
@@ -1,6 +1,6 @@
 --- a/net/mac80211/main.c
 +++ b/net/mac80211/main.c
-@@ -321,7 +321,7 @@ void ieee80211_restart_hw(struct ieee802
+@@ -337,7 +337,7 @@ void ieee80211_restart_hw(struct ieee802
  }
  EXPORT_SYMBOL(ieee80211_restart_hw);
  
@@ -9,7 +9,7 @@
  static int ieee80211_ifa_changed(struct notifier_block *nb,
  				 unsigned long data, void *arg)
  {
-@@ -380,7 +380,7 @@ static int ieee80211_ifa_changed(struct
+@@ -396,7 +396,7 @@ static int ieee80211_ifa_changed(struct
  }
  #endif
  
@@ -18,8 +18,8 @@
  static int ieee80211_ifa6_changed(struct notifier_block *nb,
  				  unsigned long data, void *arg)
  {
-@@ -1315,14 +1315,14 @@ int ieee80211_register_hw(struct ieee802
- 
+@@ -1321,14 +1321,14 @@ int ieee80211_register_hw(struct ieee802
+ 	wiphy_unlock(hw->wiphy);
  	rtnl_unlock();
  
 -#ifdef CONFIG_INET
@@ -35,7 +35,7 @@
  	local->ifa6_notifier.notifier_call = ieee80211_ifa6_changed;
  	result = register_inet6addr_notifier(&local->ifa6_notifier);
  	if (result)
-@@ -1331,13 +1331,13 @@ int ieee80211_register_hw(struct ieee802
+@@ -1337,13 +1337,13 @@ int ieee80211_register_hw(struct ieee802
  
  	return 0;
  
@@ -52,7 +52,7 @@
   fail_ifa:
  #endif
  	wiphy_unregister(local->hw.wiphy);
-@@ -1365,10 +1365,10 @@ void ieee80211_unregister_hw(struct ieee
+@@ -1371,10 +1371,10 @@ void ieee80211_unregister_hw(struct ieee
  	tasklet_kill(&local->tx_pending_tasklet);
  	tasklet_kill(&local->tasklet);
  
diff --git a/package/kernel/mac80211/patches/subsys/210-ap_scan.patch b/package/kernel/mac80211/patches/subsys/210-ap_scan.patch
index f8c3821c51..0c06829ce4 100644
--- a/package/kernel/mac80211/patches/subsys/210-ap_scan.patch
+++ b/package/kernel/mac80211/patches/subsys/210-ap_scan.patch
@@ -1,6 +1,6 @@
 --- a/net/mac80211/cfg.c
 +++ b/net/mac80211/cfg.c
-@@ -2463,7 +2463,7 @@ static int ieee80211_scan(struct wiphy *
+@@ -2497,7 +2497,7 @@ static int ieee80211_scan(struct wiphy *
  		 * the  frames sent while scanning on other channel will be
  		 * lost)
  		 */
diff --git a/package/kernel/mac80211/patches/subsys/300-cfg80211-support-immediate-reconnect-request-hint.patch b/package/kernel/mac80211/patches/subsys/300-cfg80211-support-immediate-reconnect-request-hint.patch
deleted file mode 100644
index 886f58e8c3..0000000000
--- a/package/kernel/mac80211/patches/subsys/300-cfg80211-support-immediate-reconnect-request-hint.patch
+++ /dev/null
@@ -1,279 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Sun, 6 Dec 2020 14:54:42 +0200
-Subject: [PATCH] cfg80211: support immediate reconnect request hint
-
-There are cases where it's necessary to disconnect, but an
-immediate reconnection is desired. Support a hint to userspace
-that this is the case, by including a new attribute in the
-deauth or disassoc event.
-
-Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
-Link: https://lore.kernel.org/r/iwlwifi.20201206145305.58d33941fb9d.I0e7168c205c7949529c8e3b86f3c9b12c01a7017@changeid
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -6408,13 +6408,15 @@ void cfg80211_abandon_assoc(struct net_d
-  * @dev: network device
-  * @buf: 802.11 frame (header + body)
-  * @len: length of the frame data
-+ * @reconnect: immediate reconnect is desired (include the nl80211 attribute)
-  *
-  * This function is called whenever deauthentication has been processed in
-  * station mode. This includes both received deauthentication frames and
-  * locally generated ones. This function may sleep. The caller must hold the
-  * corresponding wdev's mutex.
-  */
--void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);
-+void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len,
-+			   bool reconnect);
- 
- /**
-  * cfg80211_rx_unprot_mlme_mgmt - notification of unprotected mlme mgmt frame
---- a/net/mac80211/mlme.c
-+++ b/net/mac80211/mlme.c
-@@ -2733,7 +2733,7 @@ static void ieee80211_report_disconnect(
- 	};
- 
- 	if (tx)
--		cfg80211_tx_mlme_mgmt(sdata->dev, buf, len);
-+		cfg80211_tx_mlme_mgmt(sdata->dev, buf, len, false);
- 	else
- 		cfg80211_rx_mlme_mgmt(sdata->dev, buf, len);
- 
-@@ -4745,7 +4745,8 @@ void ieee80211_mgd_quiesce(struct ieee80
- 		if (ifmgd->auth_data)
- 			ieee80211_destroy_auth_data(sdata, false);
- 		cfg80211_tx_mlme_mgmt(sdata->dev, frame_buf,
--				      IEEE80211_DEAUTH_FRAME_LEN);
-+				      IEEE80211_DEAUTH_FRAME_LEN,
-+				      false);
- 	}
- 
- 	/* This is a bit of a hack - we should find a better and more generic
---- a/net/wireless/mlme.c
-+++ b/net/wireless/mlme.c
-@@ -4,7 +4,7 @@
-  *
-  * Copyright (c) 2009, Jouni Malinen <j@w1.fi>
-  * Copyright (c) 2015		Intel Deutschland GmbH
-- * Copyright (C) 2019 Intel Corporation
-+ * Copyright (C) 2019-2020 Intel Corporation
-  */
- 
- #include <linux/kernel.h>
-@@ -81,7 +81,8 @@ static void cfg80211_process_auth(struct
- }
- 
- static void cfg80211_process_deauth(struct wireless_dev *wdev,
--				    const u8 *buf, size_t len)
-+				    const u8 *buf, size_t len,
-+				    bool reconnect)
- {
- 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
- 	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;
-@@ -89,7 +90,7 @@ static void cfg80211_process_deauth(stru
- 	u16 reason_code = le16_to_cpu(mgmt->u.deauth.reason_code);
- 	bool from_ap = !ether_addr_equal(mgmt->sa, wdev->netdev->dev_addr);
- 
--	nl80211_send_deauth(rdev, wdev->netdev, buf, len, GFP_KERNEL);
-+	nl80211_send_deauth(rdev, wdev->netdev, buf, len, reconnect, GFP_KERNEL);
- 
- 	if (!wdev->current_bss ||
- 	    !ether_addr_equal(wdev->current_bss->pub.bssid, bssid))
-@@ -100,7 +101,8 @@ static void cfg80211_process_deauth(stru
- }
- 
- static void cfg80211_process_disassoc(struct wireless_dev *wdev,
--				      const u8 *buf, size_t len)
-+				      const u8 *buf, size_t len,
-+				      bool reconnect)
- {
- 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
- 	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;
-@@ -108,7 +110,8 @@ static void cfg80211_process_disassoc(st
- 	u16 reason_code = le16_to_cpu(mgmt->u.disassoc.reason_code);
- 	bool from_ap = !ether_addr_equal(mgmt->sa, wdev->netdev->dev_addr);
- 
--	nl80211_send_disassoc(rdev, wdev->netdev, buf, len, GFP_KERNEL);
-+	nl80211_send_disassoc(rdev, wdev->netdev, buf, len, reconnect,
-+			      GFP_KERNEL);
- 
- 	if (WARN_ON(!wdev->current_bss ||
- 		    !ether_addr_equal(wdev->current_bss->pub.bssid, bssid)))
-@@ -133,9 +136,9 @@ void cfg80211_rx_mlme_mgmt(struct net_de
- 	if (ieee80211_is_auth(mgmt->frame_control))
- 		cfg80211_process_auth(wdev, buf, len);
- 	else if (ieee80211_is_deauth(mgmt->frame_control))
--		cfg80211_process_deauth(wdev, buf, len);
-+		cfg80211_process_deauth(wdev, buf, len, false);
- 	else if (ieee80211_is_disassoc(mgmt->frame_control))
--		cfg80211_process_disassoc(wdev, buf, len);
-+		cfg80211_process_disassoc(wdev, buf, len, false);
- }
- EXPORT_SYMBOL(cfg80211_rx_mlme_mgmt);
- 
-@@ -180,22 +183,23 @@ void cfg80211_abandon_assoc(struct net_d
- }
- EXPORT_SYMBOL(cfg80211_abandon_assoc);
- 
--void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len)
-+void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len,
-+			   bool reconnect)
- {
- 	struct wireless_dev *wdev = dev->ieee80211_ptr;
- 	struct ieee80211_mgmt *mgmt = (void *)buf;
- 
- 	ASSERT_WDEV_LOCK(wdev);
- 
--	trace_cfg80211_tx_mlme_mgmt(dev, buf, len);
-+	trace_cfg80211_tx_mlme_mgmt(dev, buf, len, reconnect);
- 
- 	if (WARN_ON(len < 2))
- 		return;
- 
- 	if (ieee80211_is_deauth(mgmt->frame_control))
--		cfg80211_process_deauth(wdev, buf, len);
-+		cfg80211_process_deauth(wdev, buf, len, reconnect);
- 	else
--		cfg80211_process_disassoc(wdev, buf, len);
-+		cfg80211_process_disassoc(wdev, buf, len, reconnect);
- }
- EXPORT_SYMBOL(cfg80211_tx_mlme_mgmt);
- 
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -741,6 +741,7 @@ static const struct nla_policy nl80211_p
- 		NLA_POLICY_EXACT_LEN(IEEE80211_S1G_CAPABILITY_LEN),
- 	[NL80211_ATTR_S1G_CAPABILITY_MASK] =
- 		NLA_POLICY_EXACT_LEN(IEEE80211_S1G_CAPABILITY_LEN),
-+	[NL80211_ATTR_RECONNECT_REQUESTED] = { .type = NLA_REJECT },
- };
- 
- /* policy for the key attributes */
-@@ -15934,7 +15935,7 @@ static void nl80211_send_mlme_event(stru
- 				    const u8 *buf, size_t len,
- 				    enum nl80211_commands cmd, gfp_t gfp,
- 				    int uapsd_queues, const u8 *req_ies,
--				    size_t req_ies_len)
-+				    size_t req_ies_len, bool reconnect)
- {
- 	struct sk_buff *msg;
- 	void *hdr;
-@@ -15956,6 +15957,9 @@ static void nl80211_send_mlme_event(stru
- 	     nla_put(msg, NL80211_ATTR_REQ_IE, req_ies_len, req_ies)))
- 		goto nla_put_failure;
- 
-+	if (reconnect && nla_put_flag(msg, NL80211_ATTR_RECONNECT_REQUESTED))
-+		goto nla_put_failure;
-+
- 	if (uapsd_queues >= 0) {
- 		struct nlattr *nla_wmm =
- 			nla_nest_start_noflag(msg, NL80211_ATTR_STA_WME);
-@@ -15984,7 +15988,8 @@ void nl80211_send_rx_auth(struct cfg8021
- 			  size_t len, gfp_t gfp)
- {
- 	nl80211_send_mlme_event(rdev, netdev, buf, len,
--				NL80211_CMD_AUTHENTICATE, gfp, -1, NULL, 0);
-+				NL80211_CMD_AUTHENTICATE, gfp, -1, NULL, 0,
-+				false);
- }
- 
- void nl80211_send_rx_assoc(struct cfg80211_registered_device *rdev,
-@@ -15994,23 +15999,25 @@ void nl80211_send_rx_assoc(struct cfg802
- {
- 	nl80211_send_mlme_event(rdev, netdev, buf, len,
- 				NL80211_CMD_ASSOCIATE, gfp, uapsd_queues,
--				req_ies, req_ies_len);
-+				req_ies, req_ies_len, false);
- }
- 
- void nl80211_send_deauth(struct cfg80211_registered_device *rdev,
- 			 struct net_device *netdev, const u8 *buf,
--			 size_t len, gfp_t gfp)
-+			 size_t len, bool reconnect, gfp_t gfp)
- {
- 	nl80211_send_mlme_event(rdev, netdev, buf, len,
--				NL80211_CMD_DEAUTHENTICATE, gfp, -1, NULL, 0);
-+				NL80211_CMD_DEAUTHENTICATE, gfp, -1, NULL, 0,
-+				reconnect);
- }
- 
- void nl80211_send_disassoc(struct cfg80211_registered_device *rdev,
- 			   struct net_device *netdev, const u8 *buf,
--			   size_t len, gfp_t gfp)
-+			   size_t len, bool reconnect, gfp_t gfp)
- {
- 	nl80211_send_mlme_event(rdev, netdev, buf, len,
--				NL80211_CMD_DISASSOCIATE, gfp, -1, NULL, 0);
-+				NL80211_CMD_DISASSOCIATE, gfp, -1, NULL, 0,
-+				reconnect);
- }
- 
- void cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev, const u8 *buf,
-@@ -16041,7 +16048,7 @@ void cfg80211_rx_unprot_mlme_mgmt(struct
- 
- 	trace_cfg80211_rx_unprot_mlme_mgmt(dev, buf, len);
- 	nl80211_send_mlme_event(rdev, dev, buf, len, cmd, GFP_ATOMIC, -1,
--				NULL, 0);
-+				NULL, 0, false);
- }
- EXPORT_SYMBOL(cfg80211_rx_unprot_mlme_mgmt);
- 
---- a/net/wireless/nl80211.h
-+++ b/net/wireless/nl80211.h
-@@ -1,7 +1,7 @@
- /* SPDX-License-Identifier: GPL-2.0 */
- /*
-  * Portions of this file
-- * Copyright (C) 2018 Intel Corporation
-+ * Copyright (C) 2018, 2020 Intel Corporation
-  */
- #ifndef __NET_WIRELESS_NL80211_H
- #define __NET_WIRELESS_NL80211_H
-@@ -69,10 +69,12 @@ void nl80211_send_rx_assoc(struct cfg802
- 			   const u8 *req_ies, size_t req_ies_len);
- void nl80211_send_deauth(struct cfg80211_registered_device *rdev,
- 			 struct net_device *netdev,
--			 const u8 *buf, size_t len, gfp_t gfp);
-+			 const u8 *buf, size_t len,
-+			 bool reconnect, gfp_t gfp);
- void nl80211_send_disassoc(struct cfg80211_registered_device *rdev,
- 			   struct net_device *netdev,
--			   const u8 *buf, size_t len, gfp_t gfp);
-+			   const u8 *buf, size_t len,
-+			   bool reconnect, gfp_t gfp);
- void nl80211_send_auth_timeout(struct cfg80211_registered_device *rdev,
- 			       struct net_device *netdev,
- 			       const u8 *addr, gfp_t gfp);
---- a/net/wireless/trace.h
-+++ b/net/wireless/trace.h
-@@ -2684,19 +2684,23 @@ DEFINE_EVENT(netdev_frame_event, cfg8021
- );
- 
- TRACE_EVENT(cfg80211_tx_mlme_mgmt,
--	TP_PROTO(struct net_device *netdev, const u8 *buf, int len),
--	TP_ARGS(netdev, buf, len),
-+	TP_PROTO(struct net_device *netdev, const u8 *buf, int len,
-+		 bool reconnect),
-+	TP_ARGS(netdev, buf, len, reconnect),
- 	TP_STRUCT__entry(
- 		NETDEV_ENTRY
- 		__dynamic_array(u8, frame, len)
-+		__field(int, reconnect)
- 	),
- 	TP_fast_assign(
- 		NETDEV_ASSIGN;
- 		memcpy(__get_dynamic_array(frame), buf, len);
-+		__entry->reconnect = reconnect;
- 	),
--	TP_printk(NETDEV_PR_FMT ", ftype:0x%.2x",
-+	TP_printk(NETDEV_PR_FMT ", ftype:0x%.2x reconnect:%d",
- 		  NETDEV_PR_ARG,
--		  le16_to_cpup((__le16 *)__get_dynamic_array(frame)))
-+		  le16_to_cpup((__le16 *)__get_dynamic_array(frame)),
-+		  __entry->reconnect)
- );
- 
- DECLARE_EVENT_CLASS(netdev_mac_evt,
diff --git a/package/kernel/mac80211/patches/subsys/304-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch b/package/kernel/mac80211/patches/subsys/301-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch
similarity index 100%
rename from package/kernel/mac80211/patches/subsys/304-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch
rename to package/kernel/mac80211/patches/subsys/301-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch
diff --git a/package/kernel/mac80211/patches/subsys/301-mac80211-support-driver-based-disconnect-with-reconn.patch b/package/kernel/mac80211/patches/subsys/301-mac80211-support-driver-based-disconnect-with-reconn.patch
deleted file mode 100644
index 167a877a76..0000000000
--- a/package/kernel/mac80211/patches/subsys/301-mac80211-support-driver-based-disconnect-with-reconn.patch
+++ /dev/null
@@ -1,271 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Sun, 6 Dec 2020 14:54:43 +0200
-Subject: [PATCH] mac80211: support driver-based disconnect with reconnect hint
-
-Support the driver indicating that a disconnection needs
-to be performed, and pass through the reconnect hint in
-this case.
-
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
-Link: https://lore.kernel.org/r/iwlwifi.20201206145305.5c8dab7a22a0.I58459fdf6968b16c90cab9c574f0f04ca22b0c79@changeid
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -5885,6 +5885,17 @@ void ieee80211_beacon_loss(struct ieee80
- void ieee80211_connection_loss(struct ieee80211_vif *vif);
- 
- /**
-+ * ieee80211_disconnect - request disconnection
-+ *
-+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
-+ * @reconnect: immediate reconnect is desired
-+ *
-+ * Request disconnection from the current network and, if enabled, send a
-+ * hint to the higher layers that immediate reconnect is desired.
-+ */
-+void ieee80211_disconnect(struct ieee80211_vif *vif, bool reconnect);
-+
-+/**
-  * ieee80211_resume_disconnect - disconnect from AP after resume
-  *
-  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -450,7 +450,9 @@ struct ieee80211_if_managed {
- 	unsigned long probe_timeout;
- 	int probe_send_count;
- 	bool nullfunc_failed;
--	bool connection_loss;
-+	u8 connection_loss:1,
-+	   driver_disconnect:1,
-+	   reconnect:1;
- 
- 	struct cfg80211_bss *associated;
- 	struct ieee80211_mgd_auth_data *auth_data;
---- a/net/mac80211/mlme.c
-+++ b/net/mac80211/mlme.c
-@@ -2724,7 +2724,7 @@ EXPORT_SYMBOL(ieee80211_ap_probereq_get)
- 
- static void ieee80211_report_disconnect(struct ieee80211_sub_if_data *sdata,
- 					const u8 *buf, size_t len, bool tx,
--					u16 reason)
-+					u16 reason, bool reconnect)
- {
- 	struct ieee80211_event event = {
- 		.type = MLME_EVENT,
-@@ -2733,7 +2733,7 @@ static void ieee80211_report_disconnect(
- 	};
- 
- 	if (tx)
--		cfg80211_tx_mlme_mgmt(sdata->dev, buf, len, false);
-+		cfg80211_tx_mlme_mgmt(sdata->dev, buf, len, reconnect);
- 	else
- 		cfg80211_rx_mlme_mgmt(sdata->dev, buf, len);
- 
-@@ -2755,13 +2755,18 @@ static void __ieee80211_disconnect(struc
- 
- 	tx = !sdata->csa_block_tx;
- 
--	/* AP is probably out of range (or not reachable for another reason) so
--	 * remove the bss struct for that AP.
--	 */
--	cfg80211_unlink_bss(local->hw.wiphy, ifmgd->associated);
-+	if (!ifmgd->driver_disconnect) {
-+		/*
-+		 * AP is probably out of range (or not reachable for another
-+		 * reason) so remove the bss struct for that AP.
-+		 */
-+		cfg80211_unlink_bss(local->hw.wiphy, ifmgd->associated);
-+	}
- 
- 	ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
--			       WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,
-+			       ifmgd->driver_disconnect ?
-+					WLAN_REASON_DEAUTH_LEAVING :
-+					WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,
- 			       tx, frame_buf);
- 	mutex_lock(&local->mtx);
- 	sdata->vif.csa_active = false;
-@@ -2774,7 +2779,9 @@ static void __ieee80211_disconnect(struc
- 	mutex_unlock(&local->mtx);
- 
- 	ieee80211_report_disconnect(sdata, frame_buf, sizeof(frame_buf), tx,
--				    WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY);
-+				    WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,
-+				    ifmgd->reconnect);
-+	ifmgd->reconnect = false;
- 
- 	sdata_unlock(sdata);
- }
-@@ -2793,6 +2800,13 @@ static void ieee80211_beacon_connection_
- 		sdata_info(sdata, "Connection to AP %pM lost\n",
- 			   ifmgd->bssid);
- 		__ieee80211_disconnect(sdata);
-+		ifmgd->connection_loss = false;
-+	} else if (ifmgd->driver_disconnect) {
-+		sdata_info(sdata,
-+			   "Driver requested disconnection from AP %pM\n",
-+			   ifmgd->bssid);
-+		__ieee80211_disconnect(sdata);
-+		ifmgd->driver_disconnect = false;
- 	} else {
- 		ieee80211_mgd_probe_ap(sdata, true);
- 	}
-@@ -2831,6 +2845,21 @@ void ieee80211_connection_loss(struct ie
- }
- EXPORT_SYMBOL(ieee80211_connection_loss);
- 
-+void ieee80211_disconnect(struct ieee80211_vif *vif, bool reconnect)
-+{
-+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-+	struct ieee80211_hw *hw = &sdata->local->hw;
-+
-+	trace_api_disconnect(sdata, reconnect);
-+
-+	if (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION))
-+		return;
-+
-+	sdata->u.mgd.driver_disconnect = true;
-+	sdata->u.mgd.reconnect = reconnect;
-+	ieee80211_queue_work(hw, &sdata->u.mgd.beacon_connection_loss_work);
-+}
-+EXPORT_SYMBOL(ieee80211_disconnect);
- 
- static void ieee80211_destroy_auth_data(struct ieee80211_sub_if_data *sdata,
- 					bool assoc)
-@@ -3142,7 +3171,7 @@ static void ieee80211_rx_mgmt_deauth(str
- 		ieee80211_set_disassoc(sdata, 0, 0, false, NULL);
- 
- 		ieee80211_report_disconnect(sdata, (u8 *)mgmt, len, false,
--					    reason_code);
-+					    reason_code, false);
- 		return;
- 	}
- 
-@@ -3191,7 +3220,8 @@ static void ieee80211_rx_mgmt_disassoc(s
- 
- 	ieee80211_set_disassoc(sdata, 0, 0, false, NULL);
- 
--	ieee80211_report_disconnect(sdata, (u8 *)mgmt, len, false, reason_code);
-+	ieee80211_report_disconnect(sdata, (u8 *)mgmt, len, false, reason_code,
-+				    false);
- }
- 
- static void ieee80211_get_rates(struct ieee80211_supported_band *sband,
-@@ -4223,7 +4253,8 @@ static void ieee80211_rx_mgmt_beacon(str
- 				       true, deauth_buf);
- 		ieee80211_report_disconnect(sdata, deauth_buf,
- 					    sizeof(deauth_buf), true,
--					    WLAN_REASON_DEAUTH_LEAVING);
-+					    WLAN_REASON_DEAUTH_LEAVING,
-+					    false);
- 		goto free;
- 	}
- 
-@@ -4370,7 +4401,7 @@ static void ieee80211_sta_connection_los
- 			       tx, frame_buf);
- 
- 	ieee80211_report_disconnect(sdata, frame_buf, sizeof(frame_buf), true,
--				    reason);
-+				    reason, false);
- }
- 
- static int ieee80211_auth(struct ieee80211_sub_if_data *sdata)
-@@ -5460,7 +5491,8 @@ int ieee80211_mgd_auth(struct ieee80211_
- 
- 		ieee80211_report_disconnect(sdata, frame_buf,
- 					    sizeof(frame_buf), true,
--					    WLAN_REASON_UNSPECIFIED);
-+					    WLAN_REASON_UNSPECIFIED,
-+					    false);
- 	}
- 
- 	sdata_info(sdata, "authenticate with %pM\n", req->bss->bssid);
-@@ -5532,7 +5564,8 @@ int ieee80211_mgd_assoc(struct ieee80211
- 
- 		ieee80211_report_disconnect(sdata, frame_buf,
- 					    sizeof(frame_buf), true,
--					    WLAN_REASON_UNSPECIFIED);
-+					    WLAN_REASON_UNSPECIFIED,
-+					    false);
- 	}
- 
- 	if (ifmgd->auth_data && !ifmgd->auth_data->done) {
-@@ -5835,7 +5868,7 @@ int ieee80211_mgd_deauth(struct ieee8021
- 		ieee80211_destroy_auth_data(sdata, false);
- 		ieee80211_report_disconnect(sdata, frame_buf,
- 					    sizeof(frame_buf), true,
--					    req->reason_code);
-+					    req->reason_code, false);
- 
- 		return 0;
- 	}
-@@ -5855,7 +5888,7 @@ int ieee80211_mgd_deauth(struct ieee8021
- 		ieee80211_destroy_assoc_data(sdata, false, true);
- 		ieee80211_report_disconnect(sdata, frame_buf,
- 					    sizeof(frame_buf), true,
--					    req->reason_code);
-+					    req->reason_code, false);
- 		return 0;
- 	}
- 
-@@ -5870,7 +5903,7 @@ int ieee80211_mgd_deauth(struct ieee8021
- 				       req->reason_code, tx, frame_buf);
- 		ieee80211_report_disconnect(sdata, frame_buf,
- 					    sizeof(frame_buf), true,
--					    req->reason_code);
-+					    req->reason_code, false);
- 		return 0;
- 	}
- 
-@@ -5903,7 +5936,7 @@ int ieee80211_mgd_disassoc(struct ieee80
- 			       frame_buf);
- 
- 	ieee80211_report_disconnect(sdata, frame_buf, sizeof(frame_buf), true,
--				    req->reason_code);
-+				    req->reason_code, false);
- 
- 	return 0;
- }
---- a/net/mac80211/trace.h
-+++ b/net/mac80211/trace.h
-@@ -2,7 +2,7 @@
- /*
- * Portions of this file
- * Copyright(c) 2016-2017 Intel Deutschland GmbH
--* Copyright (C) 2018 - 2019 Intel Corporation
-+* Copyright (C) 2018 - 2020 Intel Corporation
- */
- 
- #if !defined(__MAC80211_DRIVER_TRACE) || defined(TRACE_HEADER_MULTI_READ)
-@@ -2086,6 +2086,27 @@ TRACE_EVENT(api_connection_loss,
- 	)
- );
- 
-+TRACE_EVENT(api_disconnect,
-+	TP_PROTO(struct ieee80211_sub_if_data *sdata, bool reconnect),
-+
-+	TP_ARGS(sdata, reconnect),
-+
-+	TP_STRUCT__entry(
-+		VIF_ENTRY
-+		__field(int, reconnect)
-+	),
-+
-+	TP_fast_assign(
-+		VIF_ASSIGN;
-+		__entry->reconnect = reconnect;
-+	),
-+
-+	TP_printk(
-+		VIF_PR_FMT " reconnect:%d",
-+		VIF_PR_ARG, __entry->reconnect
-+	)
-+);
-+
- TRACE_EVENT(api_cqm_rssi_notify,
- 	TP_PROTO(struct ieee80211_sub_if_data *sdata,
- 		 enum nl80211_cqm_rssi_threshold_event rssi_event,
diff --git a/package/kernel/mac80211/patches/subsys/302-cfg80211-Add-support-to-configure-SAE-PWE-value-to-d.patch b/package/kernel/mac80211/patches/subsys/302-cfg80211-Add-support-to-configure-SAE-PWE-value-to-d.patch
deleted file mode 100644
index 514a8cee13..0000000000
--- a/package/kernel/mac80211/patches/subsys/302-cfg80211-Add-support-to-configure-SAE-PWE-value-to-d.patch
+++ /dev/null
@@ -1,74 +0,0 @@
-From: Rohan Dutta <drohan@codeaurora.org>
-Date: Tue, 27 Oct 2020 12:09:10 +0200
-Subject: [PATCH] cfg80211: Add support to configure SAE PWE value to drivers
-
-Add support to configure SAE PWE preference from userspace to drivers in
-both AP and STA modes. This is needed for cases where the driver takes
-care of Authentication frame processing (SME in the driver) so that
-correct enforcement of the acceptable PWE derivation mechanism can be
-performed.
-
-The userspace applications can pass the sae_pwe value using the
-NL80211_ATTR_SAE_PWE attribute in the NL80211_CMD_CONNECT and
-NL80211_CMD_START_AP commands to the driver. This allows selection
-between the hunting-and-pecking loop and hash-to-element options for PWE
-derivation. For backwards compatibility, this new attribute is optional
-and if not included, the driver is notified of the value being
-unspecified.
-
-Signed-off-by: Rohan Dutta <drohan@codeaurora.org>
-Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
-Link: https://lore.kernel.org/r/20201027100910.22283-1-jouni@codeaurora.org
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -1009,6 +1009,14 @@ struct survey_info {
-  * @sae_pwd: password for SAE authentication (for devices supporting SAE
-  *	offload)
-  * @sae_pwd_len: length of SAE password (for devices supporting SAE offload)
-+ * @sae_pwe: The mechanisms allowed for SAE PWE derivation
-+ *	NL80211_SAE_PWE_UNSPECIFIED: Not-specified, used to indicate userspace
-+ *		did not specify any preference. The driver should follow its
-+ *		internal policy in such a scenario.
-+ *	NL80211_SAE_PWE_HUNT_AND_PECK: Allow hunting-and-pecking loop only
-+ *	NL80211_SAE_PWE_HASH_TO_ELEMENT: Allow hash-to-element only
-+ *	NL80211_SAE_PWE_BOTH: Allow either hunting-and-pecking loop
-+ *		or hash-to-element
-  */
- struct cfg80211_crypto_settings {
- 	u32 wpa_versions;
-@@ -1027,6 +1035,7 @@ struct cfg80211_crypto_settings {
- 	const u8 *psk;
- 	const u8 *sae_pwd;
- 	u8 sae_pwd_len;
-+	enum nl80211_sae_pwe_mechanism sae_pwe;
- };
- 
- /**
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -741,6 +741,9 @@ static const struct nla_policy nl80211_p
- 		NLA_POLICY_EXACT_LEN(IEEE80211_S1G_CAPABILITY_LEN),
- 	[NL80211_ATTR_S1G_CAPABILITY_MASK] =
- 		NLA_POLICY_EXACT_LEN(IEEE80211_S1G_CAPABILITY_LEN),
-+	[NL80211_ATTR_SAE_PWE] =
-+		NLA_POLICY_RANGE(NLA_U8, NL80211_SAE_PWE_HUNT_AND_PECK,
-+				 NL80211_SAE_PWE_BOTH),
- 	[NL80211_ATTR_RECONNECT_REQUESTED] = { .type = NLA_REJECT },
- };
- 
-@@ -9778,6 +9781,12 @@ static int nl80211_crypto_settings(struc
- 			nla_len(info->attrs[NL80211_ATTR_SAE_PASSWORD]);
- 	}
- 
-+	if (info->attrs[NL80211_ATTR_SAE_PWE])
-+		settings->sae_pwe =
-+			nla_get_u8(info->attrs[NL80211_ATTR_SAE_PWE]);
-+	else
-+		settings->sae_pwe = NL80211_SAE_PWE_UNSPECIFIED;
-+
- 	return 0;
- }
- 
diff --git a/package/kernel/mac80211/patches/subsys/306-mac80211-set-up-the-fwd_skb-dev-for-mesh-forwarding.patch b/package/kernel/mac80211/patches/subsys/303-mac80211-set-up-the-fwd_skb-dev-for-mesh-forwarding.patch
similarity index 97%
rename from package/kernel/mac80211/patches/subsys/306-mac80211-set-up-the-fwd_skb-dev-for-mesh-forwarding.patch
rename to package/kernel/mac80211/patches/subsys/303-mac80211-set-up-the-fwd_skb-dev-for-mesh-forwarding.patch
index 9370a5846d..159aad564b 100644
--- a/package/kernel/mac80211/patches/subsys/306-mac80211-set-up-the-fwd_skb-dev-for-mesh-forwarding.patch
+++ b/package/kernel/mac80211/patches/subsys/303-mac80211-set-up-the-fwd_skb-dev-for-mesh-forwarding.patch
@@ -52,7 +52,7 @@ Signed-off-by: Xing Song <xing.song@mediatek.com>
 
 --- a/net/mac80211/rx.c
 +++ b/net/mac80211/rx.c
-@@ -2942,6 +2942,7 @@ ieee80211_rx_h_mesh_fwding(struct ieee80
+@@ -2950,6 +2950,7 @@ ieee80211_rx_h_mesh_fwding(struct ieee80
  	if (!fwd_skb)
  		goto out;
  
diff --git a/package/kernel/mac80211/patches/subsys/395-mac80211-use-coarse-boottime-for-airtime-fairness-co.patch b/package/kernel/mac80211/patches/subsys/306-mac80211-use-coarse-boottime-for-airtime-fairness-co.patch
similarity index 84%
rename from package/kernel/mac80211/patches/subsys/395-mac80211-use-coarse-boottime-for-airtime-fairness-co.patch
rename to package/kernel/mac80211/patches/subsys/306-mac80211-use-coarse-boottime-for-airtime-fairness-co.patch
index 1c940d3db2..c43cd3acb9 100644
--- a/package/kernel/mac80211/patches/subsys/395-mac80211-use-coarse-boottime-for-airtime-fairness-co.patch
+++ b/package/kernel/mac80211/patches/subsys/306-mac80211-use-coarse-boottime-for-airtime-fairness-co.patch
@@ -13,7 +13,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 
 --- a/net/mac80211/tx.c
 +++ b/net/mac80211/tx.c
-@@ -3834,7 +3834,7 @@ struct ieee80211_txq *ieee80211_next_txq
+@@ -3820,7 +3820,7 @@ struct ieee80211_txq *ieee80211_next_txq
  {
  	struct ieee80211_local *local = hw_to_local(hw);
  	struct airtime_sched_info *air_sched;
@@ -22,7 +22,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	struct ieee80211_txq *ret = NULL;
  	struct airtime_info *air_info;
  	struct txq_info *txqi = NULL;
-@@ -3961,7 +3961,7 @@ void ieee80211_update_airtime_weight(str
+@@ -3947,7 +3947,7 @@ void ieee80211_update_airtime_weight(str
  	u64 weight_sum = 0;
  
  	if (unlikely(!now))
@@ -31,7 +31,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  
  	lockdep_assert_held(&air_sched->lock);
  
-@@ -3987,7 +3987,7 @@ void ieee80211_schedule_txq(struct ieee8
+@@ -3973,7 +3973,7 @@ void ieee80211_schedule_txq(struct ieee8
  	struct ieee80211_local *local = hw_to_local(hw);
  	struct txq_info *txqi = to_txq_info(txq);
  	struct airtime_sched_info *air_sched;
@@ -40,7 +40,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	struct airtime_info *air_info;
  	u8 ac = txq->ac;
  	bool was_active;
-@@ -4045,7 +4045,7 @@ static void __ieee80211_unschedule_txq(s
+@@ -4031,7 +4031,7 @@ static void __ieee80211_unschedule_txq(s
  
  	if (!purge)
  		airtime_set_active(air_sched, air_info,
@@ -49,7 +49,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  
  	rb_erase_cached(&txqi->schedule_order,
  			&air_sched->active_txqs);
-@@ -4133,7 +4133,7 @@ bool ieee80211_txq_may_transmit(struct i
+@@ -4119,7 +4119,7 @@ bool ieee80211_txq_may_transmit(struct i
  	if (RB_EMPTY_NODE(&txqi->schedule_order))
  		goto out;
  
diff --git a/package/kernel/mac80211/patches/subsys/307-mac80211_hwsim-make-6-GHz-channels-usable.patch b/package/kernel/mac80211/patches/subsys/307-mac80211_hwsim-make-6-GHz-channels-usable.patch
new file mode 100644
index 0000000000..80c86e3d92
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/307-mac80211_hwsim-make-6-GHz-channels-usable.patch
@@ -0,0 +1,74 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 24 May 2021 11:46:09 +0200
+Subject: [PATCH] mac80211_hwsim: make 6 GHz channels usable
+
+The previous commit that claimed to add 6 GHz channels didn't actually make
+them usable, since the 6 GHz band was not registered with mac80211.
+
+Fixes: 28881922abd7 ("mac80211_hwsim: add 6GHz channels")
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/drivers/net/wireless/mac80211_hwsim.c
++++ b/drivers/net/wireless/mac80211_hwsim.c
+@@ -3003,15 +3003,19 @@ static void mac80211_hwsim_he_capab(stru
+ {
+ 	u16 n_iftype_data;
+ 
+-	if (sband->band == NL80211_BAND_2GHZ) {
++	switch (sband->band) {
++	case NL80211_BAND_2GHZ:
+ 		n_iftype_data = ARRAY_SIZE(he_capa_2ghz);
+ 		sband->iftype_data =
+ 			(struct ieee80211_sband_iftype_data *)he_capa_2ghz;
+-	} else if (sband->band == NL80211_BAND_5GHZ) {
++		break;
++	case NL80211_BAND_5GHZ:
++	case NL80211_BAND_6GHZ:
+ 		n_iftype_data = ARRAY_SIZE(he_capa_5ghz);
+ 		sband->iftype_data =
+ 			(struct ieee80211_sband_iftype_data *)he_capa_5ghz;
+-	} else {
++		break;
++	default:
+ 		return;
+ 	}
+ 
+@@ -3301,6 +3305,12 @@ static int mac80211_hwsim_new_radio(stru
+ 			sband->vht_cap.vht_mcs.tx_mcs_map =
+ 				sband->vht_cap.vht_mcs.rx_mcs_map;
+ 			break;
++		case NL80211_BAND_6GHZ:
++			sband->channels = data->channels_6ghz;
++			sband->n_channels = ARRAY_SIZE(hwsim_channels_6ghz);
++			sband->bitrates = data->rates + 4;
++			sband->n_bitrates = ARRAY_SIZE(hwsim_rates) - 4;
++			break;
+ 		case NL80211_BAND_S1GHZ:
+ 			memcpy(&sband->s1g_cap, &hwsim_s1g_cap,
+ 			       sizeof(sband->s1g_cap));
+@@ -3311,6 +3321,13 @@ static int mac80211_hwsim_new_radio(stru
+ 			continue;
+ 		}
+ 
++		mac80211_hwsim_he_capab(sband);
++
++		hw->wiphy->bands[band] = sband;
++
++		if (band == NL80211_BAND_6GHZ)
++			continue;
++
+ 		sband->ht_cap.ht_supported = true;
+ 		sband->ht_cap.cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
+ 				    IEEE80211_HT_CAP_GRN_FLD |
+@@ -3324,10 +3341,6 @@ static int mac80211_hwsim_new_radio(stru
+ 		sband->ht_cap.mcs.rx_mask[0] = 0xff;
+ 		sband->ht_cap.mcs.rx_mask[1] = 0xff;
+ 		sband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;
+-
+-		mac80211_hwsim_he_capab(sband);
+-
+-		hw->wiphy->bands[band] = sband;
+ 	}
+ 
+ 	/* By default all radios belong to the first group */
diff --git a/package/kernel/mac80211/patches/subsys/308-mac80211-add-support-for-.ndo_fill_forward_path.patch b/package/kernel/mac80211/patches/subsys/308-mac80211-add-support-for-.ndo_fill_forward_path.patch
new file mode 100644
index 0000000000..a9a6182ab2
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/308-mac80211-add-support-for-.ndo_fill_forward_path.patch
@@ -0,0 +1,178 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 12 Nov 2021 12:22:23 +0100
+Subject: [PATCH] mac80211: add support for .ndo_fill_forward_path
+
+This allows drivers to provide a destination device + info for flow offload
+Only supported in combination with 802.3 encap offload
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+Tested-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Link: https://lore.kernel.org/r/20211112112223.1209-1-nbd@nbd.name
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -3937,6 +3937,8 @@ struct ieee80211_prep_tx_info {
+  *	twt structure.
+  * @twt_teardown_request: Update the hw with TWT teardown request received
+  *	from the peer.
++ * @net_fill_forward_path: Called from .ndo_fill_forward_path in order to
++ *	resolve a path for hardware flow offloading
+  */
+ struct ieee80211_ops {
+ 	void (*tx)(struct ieee80211_hw *hw,
+@@ -4265,6 +4267,13 @@ struct ieee80211_ops {
+ 			      struct ieee80211_twt_setup *twt);
+ 	void (*twt_teardown_request)(struct ieee80211_hw *hw,
+ 				     struct ieee80211_sta *sta, u8 flowid);
++#if LINUX_VERSION_IS_GEQ(5,10,0)
++	int (*net_fill_forward_path)(struct ieee80211_hw *hw,
++				     struct ieee80211_vif *vif,
++				     struct ieee80211_sta *sta,
++				     struct net_device_path_ctx *ctx,
++				     struct net_device_path *path);
++#endif
+ };
+ 
+ /**
+--- a/net/mac80211/driver-ops.h
++++ b/net/mac80211/driver-ops.h
+@@ -1486,4 +1486,28 @@ static inline void drv_twt_teardown_requ
+ 	trace_drv_return_void(local);
+ }
+ 
++#if LINUX_VERSION_IS_GEQ(5,10,0)
++static inline int drv_net_fill_forward_path(struct ieee80211_local *local,
++					    struct ieee80211_sub_if_data *sdata,
++					    struct ieee80211_sta *sta,
++					    struct net_device_path_ctx *ctx,
++					    struct net_device_path *path)
++{
++	int ret = -EOPNOTSUPP;
++
++	sdata = get_bss_sdata(sdata);
++	if (!check_sdata_in_driver(sdata))
++		return -EIO;
++
++	trace_drv_net_fill_forward_path(local, sdata, sta);
++	if (local->ops->net_fill_forward_path)
++		ret = local->ops->net_fill_forward_path(&local->hw,
++							&sdata->vif, sta,
++							ctx, path);
++	trace_drv_return_int(local, ret);
++
++	return ret;
++}
++#endif
++
+ #endif /* __MAC80211_DRIVER_OPS */
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -1489,7 +1489,7 @@ struct ieee80211_local {
+ };
+ 
+ static inline struct ieee80211_sub_if_data *
+-IEEE80211_DEV_TO_SUB_IF(struct net_device *dev)
++IEEE80211_DEV_TO_SUB_IF(const struct net_device *dev)
+ {
+ 	return netdev_priv(dev);
+ }
+--- a/net/mac80211/iface.c
++++ b/net/mac80211/iface.c
+@@ -822,6 +822,66 @@ static const struct net_device_ops ieee8
+ 
+ };
+ 
++#if LINUX_VERSION_IS_GEQ(5,10,0)
++static int ieee80211_netdev_fill_forward_path(struct net_device_path_ctx *ctx,
++					      struct net_device_path *path)
++{
++	struct ieee80211_sub_if_data *sdata;
++	struct ieee80211_local *local;
++	struct sta_info *sta;
++	int ret = -ENOENT;
++
++	sdata = IEEE80211_DEV_TO_SUB_IF(ctx->dev);
++	local = sdata->local;
++
++	if (!local->ops->net_fill_forward_path)
++		return -EOPNOTSUPP;
++
++	rcu_read_lock();
++	switch (sdata->vif.type) {
++	case NL80211_IFTYPE_AP_VLAN:
++		sta = rcu_dereference(sdata->u.vlan.sta);
++		if (sta)
++			break;
++		if (sdata->wdev.use_4addr)
++			goto out;
++		if (is_multicast_ether_addr(ctx->daddr))
++			goto out;
++		sta = sta_info_get_bss(sdata, ctx->daddr);
++		break;
++	case NL80211_IFTYPE_AP:
++		if (is_multicast_ether_addr(ctx->daddr))
++			goto out;
++		sta = sta_info_get(sdata, ctx->daddr);
++		break;
++	case NL80211_IFTYPE_STATION:
++		if (sdata->wdev.wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS) {
++			sta = sta_info_get(sdata, ctx->daddr);
++			if (sta && test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {
++				if (!test_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH))
++					goto out;
++
++				break;
++			}
++		}
++
++		sta = sta_info_get(sdata, sdata->u.mgd.bssid);
++		break;
++	default:
++		goto out;
++	}
++
++	if (!sta)
++		goto out;
++
++	ret = drv_net_fill_forward_path(local, sdata, &sta->sta, ctx, path);
++out:
++	rcu_read_unlock();
++
++	return ret;
++}
++#endif
++
+ static const struct net_device_ops ieee80211_dataif_8023_ops = {
+ #if LINUX_VERSION_IS_LESS(4,10,0)
+ 	.ndo_change_mtu = __change_mtu,
+@@ -839,7 +899,9 @@ static const struct net_device_ops ieee8
+ #else
+ 	.ndo_get_stats64 = bp_ieee80211_get_stats64,
+ #endif
+-
++#if LINUX_VERSION_IS_GEQ(5,10,0)
++	.ndo_fill_forward_path = ieee80211_netdev_fill_forward_path,
++#endif
+ };
+ 
+ static bool ieee80211_iftype_supports_hdr_offload(enum nl80211_iftype iftype)
+--- a/net/mac80211/trace.h
++++ b/net/mac80211/trace.h
+@@ -2892,6 +2892,15 @@ TRACE_EVENT(drv_twt_teardown_request,
+ 	)
+ );
+ 
++#if LINUX_VERSION_IS_GEQ(5,10,0)
++DEFINE_EVENT(sta_event, drv_net_fill_forward_path,
++	TP_PROTO(struct ieee80211_local *local,
++		 struct ieee80211_sub_if_data *sdata,
++		 struct ieee80211_sta *sta),
++	TP_ARGS(local, sdata, sta)
++);
++#endif
++
+ #endif /* !__MAC80211_DRIVER_TRACE || TRACE_HEADER_MULTI_READ */
+ 
+ #undef TRACE_INCLUDE_PATH
diff --git a/package/kernel/mac80211/patches/subsys/353-mac80211-minstrel_ht-fix-MINSTREL_FRAC-macro.patch b/package/kernel/mac80211/patches/subsys/309-mac80211-minstrel_ht-fix-MINSTREL_FRAC-macro.patch
similarity index 100%
rename from package/kernel/mac80211/patches/subsys/353-mac80211-minstrel_ht-fix-MINSTREL_FRAC-macro.patch
rename to package/kernel/mac80211/patches/subsys/309-mac80211-minstrel_ht-fix-MINSTREL_FRAC-macro.patch
diff --git a/package/kernel/mac80211/patches/subsys/354-mac80211-minstrel_ht-reduce-fluctuations-in-rate-pro.patch b/package/kernel/mac80211/patches/subsys/310-mac80211-minstrel_ht-reduce-fluctuations-in-rate-pro.patch
similarity index 94%
rename from package/kernel/mac80211/patches/subsys/354-mac80211-minstrel_ht-reduce-fluctuations-in-rate-pro.patch
rename to package/kernel/mac80211/patches/subsys/310-mac80211-minstrel_ht-reduce-fluctuations-in-rate-pro.patch
index 16bcbc2ef9..3be43b8782 100644
--- a/package/kernel/mac80211/patches/subsys/354-mac80211-minstrel_ht-reduce-fluctuations-in-rate-pro.patch
+++ b/package/kernel/mac80211/patches/subsys/310-mac80211-minstrel_ht-reduce-fluctuations-in-rate-pro.patch
@@ -18,7 +18,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 
 --- a/net/mac80211/rc80211_minstrel_ht.c
 +++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -700,7 +700,8 @@ minstrel_ht_calc_rate_stats(struct minst
+@@ -703,7 +703,8 @@ minstrel_ht_calc_rate_stats(struct minst
  	unsigned int cur_prob;
  
  	if (unlikely(mrs->attempts > 0)) {
diff --git a/package/kernel/mac80211/patches/subsys/310-net-fq_impl-bulk-free-packets-from-a-flow-on-overmem.patch b/package/kernel/mac80211/patches/subsys/310-net-fq_impl-bulk-free-packets-from-a-flow-on-overmem.patch
deleted file mode 100644
index 05a888006e..0000000000
--- a/package/kernel/mac80211/patches/subsys/310-net-fq_impl-bulk-free-packets-from-a-flow-on-overmem.patch
+++ /dev/null
@@ -1,95 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Wed, 25 Nov 2020 18:03:46 +0100
-Subject: [PATCH] net/fq_impl: bulk-free packets from a flow on overmemory
-
-This is similar to what sch_fq_codel does. It also amortizes the worst
-case cost of a follow-up patch that changes the selection of the biggest
-flow for dropping packets
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/include/net/fq_impl.h
-+++ b/include/net/fq_impl.h
-@@ -11,17 +11,25 @@
- 
- /* functions that are embedded into includer */
- 
-+
-+static void
-+__fq_adjust_removal(struct fq *fq, struct fq_flow *flow, unsigned int packets,
-+		    unsigned int bytes, unsigned int truesize)
-+{
-+	struct fq_tin *tin = flow->tin;
-+
-+	tin->backlog_bytes -= bytes;
-+	tin->backlog_packets -= packets;
-+	flow->backlog -= bytes;
-+	fq->backlog -= packets;
-+	fq->memory_usage -= truesize;
-+}
-+
- static void fq_adjust_removal(struct fq *fq,
- 			      struct fq_flow *flow,
- 			      struct sk_buff *skb)
- {
--	struct fq_tin *tin = flow->tin;
--
--	tin->backlog_bytes -= skb->len;
--	tin->backlog_packets--;
--	flow->backlog -= skb->len;
--	fq->backlog--;
--	fq->memory_usage -= skb->truesize;
-+	__fq_adjust_removal(fq, flow, 1, skb->len, skb->truesize);
- }
- 
- static void fq_rejigger_backlog(struct fq *fq, struct fq_flow *flow)
-@@ -59,6 +67,34 @@ static struct sk_buff *fq_flow_dequeue(s
- 	return skb;
- }
- 
-+static int fq_flow_drop(struct fq *fq, struct fq_flow *flow,
-+			fq_skb_free_t free_func)
-+{
-+	unsigned int packets = 0, bytes = 0, truesize = 0;
-+	struct fq_tin *tin = flow->tin;
-+	struct sk_buff *skb;
-+	int pending;
-+
-+	lockdep_assert_held(&fq->lock);
-+
-+	pending = min_t(int, 32, skb_queue_len(&flow->queue) / 2);
-+	do {
-+		skb = __skb_dequeue(&flow->queue);
-+		if (!skb)
-+			break;
-+
-+		packets++;
-+		bytes += skb->len;
-+		truesize += skb->truesize;
-+		free_func(fq, tin, flow, skb);
-+	} while (packets < pending);
-+
-+	__fq_adjust_removal(fq, flow, packets, bytes, truesize);
-+	fq_rejigger_backlog(fq, flow);
-+
-+	return packets;
-+}
-+
- static struct sk_buff *fq_tin_dequeue(struct fq *fq,
- 				      struct fq_tin *tin,
- 				      fq_tin_dequeue_t dequeue_func)
-@@ -190,12 +226,9 @@ static void fq_tin_enqueue(struct fq *fq
- 		if (!flow)
- 			return;
- 
--		skb = fq_flow_dequeue(fq, flow);
--		if (!skb)
-+		if (!fq_flow_drop(fq, flow, free_func))
- 			return;
- 
--		free_func(fq, flow->tin, flow, skb);
--
- 		flow->tin->overlimit++;
- 		fq->overlimit++;
- 		if (oom) {
diff --git a/package/kernel/mac80211/patches/subsys/355-mac80211-minstrel_ht-rework-rate-downgrade-code-and-.patch b/package/kernel/mac80211/patches/subsys/311-mac80211-minstrel_ht-rework-rate-downgrade-code-and-.patch
similarity index 90%
rename from package/kernel/mac80211/patches/subsys/355-mac80211-minstrel_ht-rework-rate-downgrade-code-and-.patch
rename to package/kernel/mac80211/patches/subsys/311-mac80211-minstrel_ht-rework-rate-downgrade-code-and-.patch
index aec2e07781..13bed48ec6 100644
--- a/package/kernel/mac80211/patches/subsys/355-mac80211-minstrel_ht-rework-rate-downgrade-code-and-.patch
+++ b/package/kernel/mac80211/patches/subsys/311-mac80211-minstrel_ht-rework-rate-downgrade-code-and-.patch
@@ -18,7 +18,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 
 --- a/net/mac80211/rc80211_minstrel_ht.c
 +++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -511,6 +511,14 @@ minstrel_ht_set_best_prob_rate(struct mi
+@@ -514,6 +514,14 @@ minstrel_ht_set_best_prob_rate(struct mi
  	int cur_tp_avg, cur_group, cur_idx;
  	int max_gpr_group, max_gpr_idx;
  	int max_gpr_tp_avg, max_gpr_prob;
@@ -33,7 +33,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  
  	cur_group = MI_RATE_GROUP(index);
  	cur_idx = MI_RATE_IDX(index);
-@@ -532,11 +540,6 @@ minstrel_ht_set_best_prob_rate(struct mi
+@@ -535,11 +543,6 @@ minstrel_ht_set_best_prob_rate(struct mi
  	    !minstrel_ht_is_legacy_group(max_tp_group))
  		return;
  
@@ -45,7 +45,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	max_gpr_group = MI_RATE_GROUP(mg->max_group_prob_rate);
  	max_gpr_idx = MI_RATE_IDX(mg->max_group_prob_rate);
  	max_gpr_prob = mi->groups[max_gpr_group].rates[max_gpr_idx].prob_avg;
-@@ -594,40 +597,6 @@ minstrel_ht_assign_best_tp_rates(struct
+@@ -597,40 +600,6 @@ minstrel_ht_assign_best_tp_rates(struct
  
  }
  
@@ -86,7 +86,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  static u16
  __minstrel_ht_get_sample_rate(struct minstrel_ht_sta *mi,
  			      enum minstrel_sample_type type)
-@@ -1111,8 +1080,6 @@ minstrel_ht_update_stats(struct minstrel
+@@ -1110,8 +1079,6 @@ minstrel_ht_update_stats(struct minstrel
  
  	mi->max_prob_rate = tmp_max_prob_rate;
  
@@ -95,7 +95,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	minstrel_ht_refill_sample_rates(mi);
  
  #ifdef CPTCFG_MAC80211_DEBUGFS
-@@ -1157,7 +1124,7 @@ minstrel_ht_txstat_valid(struct minstrel
+@@ -1156,7 +1123,7 @@ minstrel_ht_txstat_valid(struct minstrel
  }
  
  static void
@@ -104,7 +104,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  {
  	int group, orig_group;
  
-@@ -1172,11 +1139,7 @@ minstrel_downgrade_rate(struct minstrel_
+@@ -1171,11 +1138,7 @@ minstrel_downgrade_rate(struct minstrel_
  		    minstrel_mcs_groups[orig_group].streams)
  			continue;
  
@@ -117,7 +117,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	}
  }
  
-@@ -1210,7 +1173,7 @@ minstrel_ht_tx_status(void *priv, struct
+@@ -1186,7 +1149,7 @@ minstrel_ht_tx_status(void *priv, struct
  	struct ieee80211_tx_info *info = st->info;
  	struct minstrel_ht_sta *mi = priv_sta;
  	struct ieee80211_tx_rate *ar = info->status.rates;
@@ -126,7 +126,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	struct minstrel_priv *mp = priv;
  	u32 update_interval = mp->update_interval;
  	bool last, update = false;
-@@ -1256,18 +1219,13 @@ minstrel_ht_tx_status(void *priv, struct
+@@ -1236,18 +1199,13 @@ minstrel_ht_tx_status(void *priv, struct
  		/*
  		 * check for sudden death of spatial multiplexing,
  		 * downgrade to a lower number of streams if necessary.
diff --git a/package/kernel/mac80211/patches/subsys/311-net-fq_impl-drop-get_default_func-move-default-flow-.patch b/package/kernel/mac80211/patches/subsys/311-net-fq_impl-drop-get_default_func-move-default-flow-.patch
deleted file mode 100644
index 9ff376a022..0000000000
--- a/package/kernel/mac80211/patches/subsys/311-net-fq_impl-drop-get_default_func-move-default-flow-.patch
+++ /dev/null
@@ -1,144 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Wed, 25 Nov 2020 18:09:10 +0100
-Subject: [PATCH] net/fq_impl: drop get_default_func, move default flow to
- fq_tin
-
-Simplifies the code and prepares for a rework of scanning for flows on
-overmemory drop.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/include/net/fq.h
-+++ b/include/net/fq.h
-@@ -47,6 +47,7 @@ struct fq_flow {
- struct fq_tin {
- 	struct list_head new_flows;
- 	struct list_head old_flows;
-+	struct fq_flow default_flow;
- 	u32 backlog_bytes;
- 	u32 backlog_packets;
- 	u32 overlimit;
---- a/include/net/fq_impl.h
-+++ b/include/net/fq_impl.h
-@@ -151,8 +151,7 @@ static u32 fq_flow_idx(struct fq *fq, st
- 
- static struct fq_flow *fq_flow_classify(struct fq *fq,
- 					struct fq_tin *tin, u32 idx,
--					struct sk_buff *skb,
--					fq_flow_get_default_t get_default_func)
-+					struct sk_buff *skb)
- {
- 	struct fq_flow *flow;
- 
-@@ -160,7 +159,7 @@ static struct fq_flow *fq_flow_classify(
- 
- 	flow = &fq->flows[idx];
- 	if (flow->tin && flow->tin != tin) {
--		flow = get_default_func(fq, tin, idx, skb);
-+		flow = &tin->default_flow;
- 		tin->collisions++;
- 		fq->collisions++;
- 	}
-@@ -192,15 +191,14 @@ static void fq_recalc_backlog(struct fq
- static void fq_tin_enqueue(struct fq *fq,
- 			   struct fq_tin *tin, u32 idx,
- 			   struct sk_buff *skb,
--			   fq_skb_free_t free_func,
--			   fq_flow_get_default_t get_default_func)
-+			   fq_skb_free_t free_func)
- {
- 	struct fq_flow *flow;
- 	bool oom;
- 
- 	lockdep_assert_held(&fq->lock);
- 
--	flow = fq_flow_classify(fq, tin, idx, skb, get_default_func);
-+	flow = fq_flow_classify(fq, tin, idx, skb);
- 
- 	flow->tin = tin;
- 	flow->backlog += skb->len;
-@@ -331,6 +329,7 @@ static void fq_tin_init(struct fq_tin *t
- {
- 	INIT_LIST_HEAD(&tin->new_flows);
- 	INIT_LIST_HEAD(&tin->old_flows);
-+	fq_flow_init(&tin->default_flow);
- }
- 
- static int fq_init(struct fq *fq, int flows_cnt)
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -846,7 +846,6 @@ enum txq_info_flags {
-  */
- struct txq_info {
- 	struct fq_tin tin;
--	struct fq_flow def_flow;
- 	struct codel_vars def_cvars;
- 	struct codel_stats cstats;
- 	struct sk_buff_head frags;
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -1322,7 +1322,7 @@ static struct sk_buff *codel_dequeue_fun
- 	fq = &local->fq;
- 
- 	if (cvars == &txqi->def_cvars)
--		flow = &txqi->def_flow;
-+		flow = &txqi->tin.default_flow;
- 	else
- 		flow = &fq->flows[cvars - local->cvars];
- 
-@@ -1365,7 +1365,7 @@ static struct sk_buff *fq_tin_dequeue_fu
- 		cparams = &local->cparams;
- 	}
- 
--	if (flow == &txqi->def_flow)
-+	if (flow == &tin->default_flow)
- 		cvars = &txqi->def_cvars;
- 	else
- 		cvars = &local->cvars[flow - fq->flows];
-@@ -1392,17 +1392,6 @@ static void fq_skb_free_func(struct fq *
- 	ieee80211_free_txskb(&local->hw, skb);
- }
- 
--static struct fq_flow *fq_flow_get_default_func(struct fq *fq,
--						struct fq_tin *tin,
--						int idx,
--						struct sk_buff *skb)
--{
--	struct txq_info *txqi;
--
--	txqi = container_of(tin, struct txq_info, tin);
--	return &txqi->def_flow;
--}
--
- static void ieee80211_txq_enqueue(struct ieee80211_local *local,
- 				  struct txq_info *txqi,
- 				  struct sk_buff *skb)
-@@ -1415,8 +1404,7 @@ static void ieee80211_txq_enqueue(struct
- 
- 	spin_lock_bh(&fq->lock);
- 	fq_tin_enqueue(fq, tin, flow_idx, skb,
--		       fq_skb_free_func,
--		       fq_flow_get_default_func);
-+		       fq_skb_free_func);
- 	spin_unlock_bh(&fq->lock);
- }
- 
-@@ -1459,7 +1447,6 @@ void ieee80211_txq_init(struct ieee80211
- 			struct txq_info *txqi, int tid)
- {
- 	fq_tin_init(&txqi->tin);
--	fq_flow_init(&txqi->def_flow);
- 	codel_vars_init(&txqi->def_cvars);
- 	codel_stats_init(&txqi->cstats);
- 	__skb_queue_head_init(&txqi->frags);
-@@ -3336,8 +3323,7 @@ static bool ieee80211_amsdu_aggregate(st
- 	 */
- 
- 	tin = &txqi->tin;
--	flow = fq_flow_classify(fq, tin, flow_idx, skb,
--				fq_flow_get_default_func);
-+	flow = fq_flow_classify(fq, tin, flow_idx, skb);
- 	head = skb_peek_tail(&flow->queue);
- 	if (!head || skb_is_gso(head))
- 		goto out;
diff --git a/package/kernel/mac80211/patches/subsys/312-mac80211-split-beacon-retrieval-functions.patch b/package/kernel/mac80211/patches/subsys/312-mac80211-split-beacon-retrieval-functions.patch
new file mode 100644
index 0000000000..18b1951f6e
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/312-mac80211-split-beacon-retrieval-functions.patch
@@ -0,0 +1,262 @@
+From: Aloka Dixit <alokad@codeaurora.org>
+Date: Tue, 5 Oct 2021 21:09:36 -0700
+Subject: [PATCH] mac80211: split beacon retrieval functions
+
+Split __ieee80211_beacon_get() into a separate function for AP mode
+ieee80211_beacon_get_ap().
+Also, move the code common to all modes (AP, adhoc and mesh) to
+a separate function ieee80211_beacon_get_finish().
+
+Signed-off-by: Aloka Dixit <alokad@codeaurora.org>
+Link: https://lore.kernel.org/r/20211006040938.9531-2-alokad@codeaurora.org
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -4987,6 +4987,115 @@ static int ieee80211_beacon_protect(stru
+ 	return 0;
+ }
+ 
++static void
++ieee80211_beacon_get_finish(struct ieee80211_hw *hw,
++			    struct ieee80211_vif *vif,
++			    struct ieee80211_mutable_offsets *offs,
++			    struct beacon_data *beacon,
++			    struct sk_buff *skb,
++			    struct ieee80211_chanctx_conf *chanctx_conf,
++			    u16 csa_off_base)
++{
++	struct ieee80211_local *local = hw_to_local(hw);
++	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
++	struct ieee80211_tx_info *info;
++	enum nl80211_band band;
++	struct ieee80211_tx_rate_control txrc;
++
++	/* CSA offsets */
++	if (offs && beacon) {
++		u16 i;
++
++		for (i = 0; i < IEEE80211_MAX_CNTDWN_COUNTERS_NUM; i++) {
++			u16 csa_off = beacon->cntdwn_counter_offsets[i];
++
++			if (!csa_off)
++				continue;
++
++			offs->cntdwn_counter_offs[i] = csa_off_base + csa_off;
++		}
++	}
++
++	band = chanctx_conf->def.chan->band;
++	info = IEEE80211_SKB_CB(skb);
++	info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
++	info->flags |= IEEE80211_TX_CTL_NO_ACK;
++	info->band = band;
++
++	memset(&txrc, 0, sizeof(txrc));
++	txrc.hw = hw;
++	txrc.sband = local->hw.wiphy->bands[band];
++	txrc.bss_conf = &sdata->vif.bss_conf;
++	txrc.skb = skb;
++	txrc.reported_rate.idx = -1;
++	if (sdata->beacon_rate_set && sdata->beacon_rateidx_mask[band])
++		txrc.rate_idx_mask = sdata->beacon_rateidx_mask[band];
++	else
++		txrc.rate_idx_mask = sdata->rc_rateidx_mask[band];
++	txrc.bss = true;
++	rate_control_get_rate(sdata, NULL, &txrc);
++
++	info->control.vif = vif;
++	info->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT |
++		       IEEE80211_TX_CTL_ASSIGN_SEQ |
++		       IEEE80211_TX_CTL_FIRST_FRAGMENT;
++}
++
++static struct sk_buff *
++ieee80211_beacon_get_ap(struct ieee80211_hw *hw,
++			struct ieee80211_vif *vif,
++			struct ieee80211_mutable_offsets *offs,
++			bool is_template,
++			struct beacon_data *beacon,
++			struct ieee80211_chanctx_conf *chanctx_conf)
++{
++	struct ieee80211_local *local = hw_to_local(hw);
++	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
++	struct ieee80211_if_ap *ap = &sdata->u.ap;
++	struct sk_buff *skb = NULL;
++	u16 csa_off_base = 0;
++
++	if (beacon->cntdwn_counter_offsets[0]) {
++		if (!is_template)
++			ieee80211_beacon_update_cntdwn(vif);
++
++		ieee80211_set_beacon_cntdwn(sdata, beacon);
++	}
++
++	/* headroom, head length,
++	 * tail length and maximum TIM length
++	 */
++	skb = dev_alloc_skb(local->tx_headroom + beacon->head_len +
++			    beacon->tail_len + 256 +
++			    local->hw.extra_beacon_tailroom);
++	if (!skb)
++		return NULL;
++
++	skb_reserve(skb, local->tx_headroom);
++	skb_put_data(skb, beacon->head, beacon->head_len);
++
++	ieee80211_beacon_add_tim(sdata, &ap->ps, skb, is_template);
++
++	if (offs) {
++		offs->tim_offset = beacon->head_len;
++		offs->tim_length = skb->len - beacon->head_len;
++		offs->cntdwn_counter_offs[0] = beacon->cntdwn_counter_offsets[0];
++
++		/* for AP the csa offsets are from tail */
++		csa_off_base = skb->len;
++	}
++
++	if (beacon->tail)
++		skb_put_data(skb, beacon->tail, beacon->tail_len);
++
++	if (ieee80211_beacon_protect(skb, local, sdata) < 0)
++		return NULL;
++
++	ieee80211_beacon_get_finish(hw, vif, offs, beacon, skb, chanctx_conf,
++				    csa_off_base);
++	return skb;
++}
++
+ static struct sk_buff *
+ __ieee80211_beacon_get(struct ieee80211_hw *hw,
+ 		       struct ieee80211_vif *vif,
+@@ -4996,12 +5105,8 @@ __ieee80211_beacon_get(struct ieee80211_
+ 	struct ieee80211_local *local = hw_to_local(hw);
+ 	struct beacon_data *beacon = NULL;
+ 	struct sk_buff *skb = NULL;
+-	struct ieee80211_tx_info *info;
+ 	struct ieee80211_sub_if_data *sdata = NULL;
+-	enum nl80211_band band;
+-	struct ieee80211_tx_rate_control txrc;
+ 	struct ieee80211_chanctx_conf *chanctx_conf;
+-	int csa_off_base = 0;
+ 
+ 	rcu_read_lock();
+ 
+@@ -5018,48 +5123,11 @@ __ieee80211_beacon_get(struct ieee80211_
+ 		struct ieee80211_if_ap *ap = &sdata->u.ap;
+ 
+ 		beacon = rcu_dereference(ap->beacon);
+-		if (beacon) {
+-			if (beacon->cntdwn_counter_offsets[0]) {
+-				if (!is_template)
+-					ieee80211_beacon_update_cntdwn(vif);
+-
+-				ieee80211_set_beacon_cntdwn(sdata, beacon);
+-			}
+-
+-			/*
+-			 * headroom, head length,
+-			 * tail length and maximum TIM length
+-			 */
+-			skb = dev_alloc_skb(local->tx_headroom +
+-					    beacon->head_len +
+-					    beacon->tail_len + 256 +
+-					    local->hw.extra_beacon_tailroom);
+-			if (!skb)
+-				goto out;
+-
+-			skb_reserve(skb, local->tx_headroom);
+-			skb_put_data(skb, beacon->head, beacon->head_len);
+-
+-			ieee80211_beacon_add_tim(sdata, &ap->ps, skb,
+-						 is_template);
+-
+-			if (offs) {
+-				offs->tim_offset = beacon->head_len;
+-				offs->tim_length = skb->len - beacon->head_len;
+-				offs->cntdwn_counter_offs[0] = beacon->cntdwn_counter_offsets[0];
+-
+-				/* for AP the csa offsets are from tail */
+-				csa_off_base = skb->len;
+-			}
+-
+-			if (beacon->tail)
+-				skb_put_data(skb, beacon->tail,
+-					     beacon->tail_len);
+-
+-			if (ieee80211_beacon_protect(skb, local, sdata) < 0)
+-				goto out;
+-		} else
++		if (!beacon)
+ 			goto out;
++
++		skb = ieee80211_beacon_get_ap(hw, vif, offs, is_template,
++					      beacon, chanctx_conf);
+ 	} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {
+ 		struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+ 		struct ieee80211_hdr *hdr;
+@@ -5085,6 +5153,9 @@ __ieee80211_beacon_get(struct ieee80211_
+ 		hdr = (struct ieee80211_hdr *) skb->data;
+ 		hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+ 						 IEEE80211_STYPE_BEACON);
++
++		ieee80211_beacon_get_finish(hw, vif, offs, beacon, skb,
++					    chanctx_conf, 0);
+ 	} else if (ieee80211_vif_is_mesh(&sdata->vif)) {
+ 		struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+ 
+@@ -5124,51 +5195,13 @@ __ieee80211_beacon_get(struct ieee80211_
+ 		}
+ 
+ 		skb_put_data(skb, beacon->tail, beacon->tail_len);
++		ieee80211_beacon_get_finish(hw, vif, offs, beacon, skb,
++					    chanctx_conf, 0);
+ 	} else {
+ 		WARN_ON(1);
+ 		goto out;
+ 	}
+ 
+-	/* CSA offsets */
+-	if (offs && beacon) {
+-		int i;
+-
+-		for (i = 0; i < IEEE80211_MAX_CNTDWN_COUNTERS_NUM; i++) {
+-			u16 csa_off = beacon->cntdwn_counter_offsets[i];
+-
+-			if (!csa_off)
+-				continue;
+-
+-			offs->cntdwn_counter_offs[i] = csa_off_base + csa_off;
+-		}
+-	}
+-
+-	band = chanctx_conf->def.chan->band;
+-
+-	info = IEEE80211_SKB_CB(skb);
+-
+-	info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
+-	info->flags |= IEEE80211_TX_CTL_NO_ACK;
+-	info->band = band;
+-
+-	memset(&txrc, 0, sizeof(txrc));
+-	txrc.hw = hw;
+-	txrc.sband = local->hw.wiphy->bands[band];
+-	txrc.bss_conf = &sdata->vif.bss_conf;
+-	txrc.skb = skb;
+-	txrc.reported_rate.idx = -1;
+-	if (sdata->beacon_rate_set && sdata->beacon_rateidx_mask[band])
+-		txrc.rate_idx_mask = sdata->beacon_rateidx_mask[band];
+-	else
+-		txrc.rate_idx_mask = sdata->rc_rateidx_mask[band];
+-	txrc.bss = true;
+-	rate_control_get_rate(sdata, NULL, &txrc);
+-
+-	info->control.vif = vif;
+-
+-	info->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT |
+-			IEEE80211_TX_CTL_ASSIGN_SEQ |
+-			IEEE80211_TX_CTL_FIRST_FRAGMENT;
+  out:
+ 	rcu_read_unlock();
+ 	return skb;
diff --git a/package/kernel/mac80211/patches/subsys/312-net-fq_impl-do-not-maintain-a-backlog-sorted-list-of.patch b/package/kernel/mac80211/patches/subsys/312-net-fq_impl-do-not-maintain-a-backlog-sorted-list-of.patch
deleted file mode 100644
index 1d7bbee400..0000000000
--- a/package/kernel/mac80211/patches/subsys/312-net-fq_impl-do-not-maintain-a-backlog-sorted-list-of.patch
+++ /dev/null
@@ -1,317 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Wed, 25 Nov 2020 18:10:34 +0100
-Subject: [PATCH] net/fq_impl: do not maintain a backlog-sorted list of
- flows
-
-A sorted flow list is only needed to drop packets in the biggest flow when
-hitting the overmemory condition.
-By scanning flows only when needed, we can avoid paying the cost of
-maintaining the list under normal conditions
-In order to avoid scanning lots of empty flows and touching too many cold
-cache lines, a bitmap of flows with backlog is maintained
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/include/net/fq.h
-+++ b/include/net/fq.h
-@@ -19,8 +19,6 @@ struct fq_tin;
-  * @flowchain: can be linked to fq_tin's new_flows or old_flows. Used for DRR++
-  *	(deficit round robin) based round robin queuing similar to the one
-  *	found in net/sched/sch_fq_codel.c
-- * @backlogchain: can be linked to other fq_flow and fq. Used to keep track of
-- *	fat flows and efficient head-dropping if packet limit is reached
-  * @queue: sk_buff queue to hold packets
-  * @backlog: number of bytes pending in the queue. The number of packets can be
-  *	found in @queue.qlen
-@@ -29,7 +27,6 @@ struct fq_tin;
- struct fq_flow {
- 	struct fq_tin *tin;
- 	struct list_head flowchain;
--	struct list_head backlogchain;
- 	struct sk_buff_head queue;
- 	u32 backlog;
- 	int deficit;
-@@ -47,6 +44,7 @@ struct fq_flow {
- struct fq_tin {
- 	struct list_head new_flows;
- 	struct list_head old_flows;
-+	struct list_head tin_list;
- 	struct fq_flow default_flow;
- 	u32 backlog_bytes;
- 	u32 backlog_packets;
-@@ -60,14 +58,14 @@ struct fq_tin {
- /**
-  * struct fq - main container for fair queuing purposes
-  *
-- * @backlogs: linked to fq_flows. Used to maintain fat flows for efficient
-- *	head-dropping when @backlog reaches @limit
-  * @limit: max number of packets that can be queued across all flows
-  * @backlog: number of packets queued across all flows
-  */
- struct fq {
- 	struct fq_flow *flows;
--	struct list_head backlogs;
-+	unsigned long *flows_bitmap;
-+
-+	struct list_head tin_backlog;
- 	spinlock_t lock;
- 	u32 flows_cnt;
- 	u32 limit;
---- a/include/net/fq_impl.h
-+++ b/include/net/fq_impl.h
-@@ -17,12 +17,24 @@ __fq_adjust_removal(struct fq *fq, struc
- 		    unsigned int bytes, unsigned int truesize)
- {
- 	struct fq_tin *tin = flow->tin;
-+	int idx;
- 
- 	tin->backlog_bytes -= bytes;
- 	tin->backlog_packets -= packets;
- 	flow->backlog -= bytes;
- 	fq->backlog -= packets;
- 	fq->memory_usage -= truesize;
-+
-+	if (flow->backlog)
-+		return;
-+
-+	if (flow == &tin->default_flow) {
-+		list_del_init(&tin->tin_list);
-+		return;
-+	}
-+
-+	idx = flow - fq->flows;
-+	__clear_bit(idx, fq->flows_bitmap);
- }
- 
- static void fq_adjust_removal(struct fq *fq,
-@@ -32,24 +44,6 @@ static void fq_adjust_removal(struct fq
- 	__fq_adjust_removal(fq, flow, 1, skb->len, skb->truesize);
- }
- 
--static void fq_rejigger_backlog(struct fq *fq, struct fq_flow *flow)
--{
--	struct fq_flow *i;
--
--	if (flow->backlog == 0) {
--		list_del_init(&flow->backlogchain);
--	} else {
--		i = flow;
--
--		list_for_each_entry_continue(i, &fq->backlogs, backlogchain)
--			if (i->backlog < flow->backlog)
--				break;
--
--		list_move_tail(&flow->backlogchain,
--			       &i->backlogchain);
--	}
--}
--
- static struct sk_buff *fq_flow_dequeue(struct fq *fq,
- 				       struct fq_flow *flow)
- {
-@@ -62,7 +56,6 @@ static struct sk_buff *fq_flow_dequeue(s
- 		return NULL;
- 
- 	fq_adjust_removal(fq, flow, skb);
--	fq_rejigger_backlog(fq, flow);
- 
- 	return skb;
- }
-@@ -90,7 +83,6 @@ static int fq_flow_drop(struct fq *fq, s
- 	} while (packets < pending);
- 
- 	__fq_adjust_removal(fq, flow, packets, bytes, truesize);
--	fq_rejigger_backlog(fq, flow);
- 
- 	return packets;
- }
-@@ -170,22 +162,36 @@ static struct fq_flow *fq_flow_classify(
- 	return flow;
- }
- 
--static void fq_recalc_backlog(struct fq *fq,
--			      struct fq_tin *tin,
--			      struct fq_flow *flow)
--{
--	struct fq_flow *i;
--
--	if (list_empty(&flow->backlogchain))
--		list_add_tail(&flow->backlogchain, &fq->backlogs);
--
--	i = flow;
--	list_for_each_entry_continue_reverse(i, &fq->backlogs,
--					     backlogchain)
--		if (i->backlog > flow->backlog)
--			break;
-+static struct fq_flow *fq_find_fattest_flow(struct fq *fq)
-+{
-+	struct fq_tin *tin;
-+	struct fq_flow *flow = NULL;
-+	u32 len = 0;
-+	int i;
-+
-+	for_each_set_bit(i, fq->flows_bitmap, fq->flows_cnt) {
-+		struct fq_flow *cur = &fq->flows[i];
-+		unsigned int cur_len;
-+
-+		cur_len = cur->backlog;
-+		if (cur_len <= len)
-+			continue;
-+
-+		flow = cur;
-+		len = cur_len;
-+	}
- 
--	list_move(&flow->backlogchain, &i->backlogchain);
-+	list_for_each_entry(tin, &fq->tin_backlog, tin_list) {
-+		unsigned int cur_len = tin->default_flow.backlog;
-+
-+		if (cur_len <= len)
-+			continue;
-+
-+		flow = &tin->default_flow;
-+		len = cur_len;
-+	}
-+
-+	return flow;
- }
- 
- static void fq_tin_enqueue(struct fq *fq,
-@@ -200,6 +206,13 @@ static void fq_tin_enqueue(struct fq *fq
- 
- 	flow = fq_flow_classify(fq, tin, idx, skb);
- 
-+	if (!flow->backlog) {
-+		if (flow != &tin->default_flow)
-+			__set_bit(idx, fq->flows_bitmap);
-+		else if (list_empty(&tin->tin_list))
-+			list_add(&tin->tin_list, &fq->tin_backlog);
-+	}
-+
- 	flow->tin = tin;
- 	flow->backlog += skb->len;
- 	tin->backlog_bytes += skb->len;
-@@ -207,8 +220,6 @@ static void fq_tin_enqueue(struct fq *fq
- 	fq->memory_usage += skb->truesize;
- 	fq->backlog++;
- 
--	fq_recalc_backlog(fq, tin, flow);
--
- 	if (list_empty(&flow->flowchain)) {
- 		flow->deficit = fq->quantum;
- 		list_add_tail(&flow->flowchain,
-@@ -218,9 +229,7 @@ static void fq_tin_enqueue(struct fq *fq
- 	__skb_queue_tail(&flow->queue, skb);
- 	oom = (fq->memory_usage > fq->memory_limit);
- 	while (fq->backlog > fq->limit || oom) {
--		flow = list_first_entry_or_null(&fq->backlogs,
--						struct fq_flow,
--						backlogchain);
-+		flow = fq_find_fattest_flow(fq);
- 		if (!flow)
- 			return;
- 
-@@ -255,8 +264,6 @@ static void fq_flow_filter(struct fq *fq
- 		fq_adjust_removal(fq, flow, skb);
- 		free_func(fq, tin, flow, skb);
- 	}
--
--	fq_rejigger_backlog(fq, flow);
- }
- 
- static void fq_tin_filter(struct fq *fq,
-@@ -279,16 +286,18 @@ static void fq_flow_reset(struct fq *fq,
- 			  struct fq_flow *flow,
- 			  fq_skb_free_t free_func)
- {
-+	struct fq_tin *tin = flow->tin;
- 	struct sk_buff *skb;
- 
- 	while ((skb = fq_flow_dequeue(fq, flow)))
--		free_func(fq, flow->tin, flow, skb);
-+		free_func(fq, tin, flow, skb);
- 
--	if (!list_empty(&flow->flowchain))
-+	if (!list_empty(&flow->flowchain)) {
- 		list_del_init(&flow->flowchain);
--
--	if (!list_empty(&flow->backlogchain))
--		list_del_init(&flow->backlogchain);
-+		if (list_empty(&tin->new_flows) &&
-+		    list_empty(&tin->old_flows))
-+			list_del_init(&tin->tin_list);
-+	}
- 
- 	flow->tin = NULL;
- 
-@@ -314,6 +323,7 @@ static void fq_tin_reset(struct fq *fq,
- 		fq_flow_reset(fq, flow, free_func);
- 	}
- 
-+	WARN_ON_ONCE(!list_empty(&tin->tin_list));
- 	WARN_ON_ONCE(tin->backlog_bytes);
- 	WARN_ON_ONCE(tin->backlog_packets);
- }
-@@ -321,7 +331,6 @@ static void fq_tin_reset(struct fq *fq,
- static void fq_flow_init(struct fq_flow *flow)
- {
- 	INIT_LIST_HEAD(&flow->flowchain);
--	INIT_LIST_HEAD(&flow->backlogchain);
- 	__skb_queue_head_init(&flow->queue);
- }
- 
-@@ -329,6 +338,7 @@ static void fq_tin_init(struct fq_tin *t
- {
- 	INIT_LIST_HEAD(&tin->new_flows);
- 	INIT_LIST_HEAD(&tin->old_flows);
-+	INIT_LIST_HEAD(&tin->tin_list);
- 	fq_flow_init(&tin->default_flow);
- }
- 
-@@ -337,8 +347,8 @@ static int fq_init(struct fq *fq, int fl
- 	int i;
- 
- 	memset(fq, 0, sizeof(fq[0]));
--	INIT_LIST_HEAD(&fq->backlogs);
- 	spin_lock_init(&fq->lock);
-+	INIT_LIST_HEAD(&fq->tin_backlog);
- 	fq->flows_cnt = max_t(u32, flows_cnt, 1);
- 	fq->quantum = 300;
- 	fq->limit = 8192;
-@@ -348,6 +358,14 @@ static int fq_init(struct fq *fq, int fl
- 	if (!fq->flows)
- 		return -ENOMEM;
- 
-+	fq->flows_bitmap = kcalloc(BITS_TO_LONGS(fq->flows_cnt), sizeof(long),
-+				   GFP_KERNEL);
-+	if (!fq->flows_bitmap) {
-+		kvfree(fq->flows);
-+		fq->flows = NULL;
-+		return -ENOMEM;
-+	}
-+
- 	for (i = 0; i < fq->flows_cnt; i++)
- 		fq_flow_init(&fq->flows[i]);
- 
-@@ -364,6 +382,9 @@ static void fq_reset(struct fq *fq,
- 
- 	kvfree(fq->flows);
- 	fq->flows = NULL;
-+
-+	kfree(fq->flows_bitmap);
-+	fq->flows_bitmap = NULL;
- }
- 
- #endif
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -3398,8 +3398,6 @@ out_recalc:
- 	if (head->len != orig_len) {
- 		flow->backlog += head->len - orig_len;
- 		tin->backlog_bytes += head->len - orig_len;
--
--		fq_recalc_backlog(fq, tin, flow);
- 	}
- out:
- 	spin_unlock_bh(&fq->lock);
diff --git a/package/kernel/mac80211/patches/subsys/313-nl80211-MBSSID-and-EMA-support-in-AP-mode.patch b/package/kernel/mac80211/patches/subsys/313-nl80211-MBSSID-and-EMA-support-in-AP-mode.patch
new file mode 100644
index 0000000000..429886d701
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/313-nl80211-MBSSID-and-EMA-support-in-AP-mode.patch
@@ -0,0 +1,493 @@
+From: John Crispin <john@phrozen.org>
+Date: Wed, 15 Sep 2021 19:54:34 -0700
+Subject: [PATCH] nl80211: MBSSID and EMA support in AP mode
+
+Add new attributes to configure support for multiple BSSID
+and advanced multi-BSSID advertisements (EMA) in AP mode.
+
+- NL80211_ATTR_MBSSID_CONFIG used for per interface configuration.
+- NL80211_ATTR_MBSSID_ELEMS used to MBSSID elements for beacons.
+
+Memory for the elements is allocated dynamically. This change frees
+the memory in existing functions which call nl80211_parse_beacon(),
+a comment is added to indicate the new references to do the same.
+
+Signed-off-by: John Crispin <john@phrozen.org>
+Co-developed-by: Aloka Dixit <alokad@codeaurora.org>
+Signed-off-by: Aloka Dixit <alokad@codeaurora.org>
+Link: https://lore.kernel.org/r/20210916025437.29138-2-alokad@codeaurora.org
+[don't leave ERR_PTR hanging around]
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/cfg80211.h
++++ b/include/net/cfg80211.h
+@@ -1046,6 +1046,36 @@ struct cfg80211_crypto_settings {
+ };
+ 
+ /**
++ * struct cfg80211_mbssid_config - AP settings for multi bssid
++ *
++ * @tx_wdev: pointer to the transmitted interface in the MBSSID set
++ * @index: index of this AP in the multi bssid group.
++ * @ema: set to true if the beacons should be sent out in EMA mode.
++ */
++struct cfg80211_mbssid_config {
++	struct wireless_dev *tx_wdev;
++	u8 index;
++	bool ema;
++};
++
++/**
++ * struct cfg80211_mbssid_elems - Multiple BSSID elements
++ *
++ * @cnt: Number of elements in array %elems.
++ *
++ * @elem: Array of multiple BSSID element(s) to be added into Beacon frames.
++ * @elem.data: Data for multiple BSSID elements.
++ * @elem.len: Length of data.
++ */
++struct cfg80211_mbssid_elems {
++	u8 cnt;
++	struct {
++		const u8 *data;
++		size_t len;
++	} elem[];
++};
++
++/**
+  * struct cfg80211_beacon_data - beacon data
+  * @head: head portion of beacon (before TIM IE)
+  *	or %NULL if not changed
+@@ -1063,6 +1093,7 @@ struct cfg80211_crypto_settings {
+  * @assocresp_ies_len: length of assocresp_ies in octets
+  * @probe_resp_len: length of probe response template (@probe_resp)
+  * @probe_resp: probe response template (AP mode only)
++ * @mbssid_ies: multiple BSSID elements
+  * @ftm_responder: enable FTM responder functionality; -1 for no change
+  *	(which also implies no change in LCI/civic location data)
+  * @lci: Measurement Report element content, starting with Measurement Token
+@@ -1080,6 +1111,7 @@ struct cfg80211_beacon_data {
+ 	const u8 *probe_resp;
+ 	const u8 *lci;
+ 	const u8 *civicloc;
++	struct cfg80211_mbssid_elems *mbssid_ies;
+ 	s8 ftm_responder;
+ 
+ 	size_t head_len, tail_len;
+@@ -1194,6 +1226,7 @@ enum cfg80211_ap_settings_flags {
+  * @he_oper: HE operation IE (or %NULL if HE isn't enabled)
+  * @fils_discovery: FILS discovery transmission parameters
+  * @unsol_bcast_probe_resp: Unsolicited broadcast probe response parameters
++ * @mbssid_config: AP settings for multiple bssid
+  */
+ struct cfg80211_ap_settings {
+ 	struct cfg80211_chan_def chandef;
+@@ -1226,6 +1259,7 @@ struct cfg80211_ap_settings {
+ 	struct cfg80211_he_bss_color he_bss_color;
+ 	struct cfg80211_fils_discovery fils_discovery;
+ 	struct cfg80211_unsol_bcast_probe_resp unsol_bcast_probe_resp;
++	struct cfg80211_mbssid_config mbssid_config;
+ };
+ 
+ /**
+@@ -4986,6 +5020,13 @@ struct wiphy_iftype_akm_suites {
+  *	%NL80211_TID_CONFIG_ATTR_RETRY_LONG attributes
+  * @sar_capa: SAR control capabilities
+  * @rfkill: a pointer to the rfkill structure
++ *
++ * @mbssid_max_interfaces: maximum number of interfaces supported by the driver
++ *	in a multiple BSSID set. This field must be set to a non-zero value
++ *	by the driver to advertise MBSSID support.
++ * @mbssid_max_ema_profile_periodicity: maximum profile periodicity supported by
++ *	the driver. Setting this field to a non-zero value indicates that the
++ *	driver supports enhanced multi-BSSID advertisements (EMA AP).
+  */
+ struct wiphy {
+ 	struct mutex mtx;
+@@ -5133,6 +5174,9 @@ struct wiphy {
+ 
+ 	struct rfkill *rfkill;
+ 
++	u8 mbssid_max_interfaces;
++	u8 ema_max_profile_periodicity;
++
+ 	char priv[] __aligned(NETDEV_ALIGN);
+ };
+ 
+--- a/include/uapi/linux/nl80211.h
++++ b/include/uapi/linux/nl80211.h
+@@ -337,7 +337,10 @@
+  * @NL80211_CMD_DEL_INTERFACE: Virtual interface was deleted, has attributes
+  *	%NL80211_ATTR_IFINDEX and %NL80211_ATTR_WIPHY. Can also be sent from
+  *	userspace to request deletion of a virtual interface, then requires
+- *	attribute %NL80211_ATTR_IFINDEX.
++ *	attribute %NL80211_ATTR_IFINDEX. If multiple BSSID advertisements are
++ *	enabled using %NL80211_ATTR_MBSSID_CONFIG, %NL80211_ATTR_MBSSID_ELEMS,
++ *	and if this command is used for the transmitting interface, then all
++ *	the non-transmitting interfaces are deleted as well.
+  *
+  * @NL80211_CMD_GET_KEY: Get sequence counter information for a key specified
+  *	by %NL80211_ATTR_KEY_IDX and/or %NL80211_ATTR_MAC.
+@@ -2593,6 +2596,18 @@ enum nl80211_commands {
+  * @NL80211_ATTR_COLOR_CHANGE_ELEMS: Nested set of attributes containing the IE
+  *	information for the time while performing a color switch.
+  *
++ * @NL80211_ATTR_MBSSID_CONFIG: Nested attribute for multiple BSSID
++ *	advertisements (MBSSID) parameters in AP mode.
++ *	Kernel uses this attribute to indicate the driver's support for MBSSID
++ *	and enhanced multi-BSSID advertisements (EMA AP) to the userspace.
++ *	Userspace should use this attribute to configure per interface MBSSID
++ *	parameters.
++ *	See &enum nl80211_mbssid_config_attributes for details.
++ *
++ * @NL80211_ATTR_MBSSID_ELEMS: Nested parameter to pass multiple BSSID elements.
++ *	Mandatory parameter for the transmitting interface to enable MBSSID.
++ *	Optional for the non-transmitting interfaces.
++ *
+  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
+  * @NL80211_ATTR_MAX: highest attribute number currently defined
+  * @__NL80211_ATTR_AFTER_LAST: internal use
+@@ -3096,6 +3111,9 @@ enum nl80211_attrs {
+ 	NL80211_ATTR_COLOR_CHANGE_COLOR,
+ 	NL80211_ATTR_COLOR_CHANGE_ELEMS,
+ 
++	NL80211_ATTR_MBSSID_CONFIG,
++	NL80211_ATTR_MBSSID_ELEMS,
++
+ 	/* add attributes here, update the policy in nl80211.c */
+ 
+ 	__NL80211_ATTR_AFTER_LAST,
+@@ -7349,4 +7367,60 @@ enum nl80211_sar_specs_attrs {
+ 	NL80211_SAR_ATTR_SPECS_MAX = __NL80211_SAR_ATTR_SPECS_LAST - 1,
+ };
+ 
++/**
++ * enum nl80211_mbssid_config_attributes - multiple BSSID (MBSSID) and enhanced
++ * multi-BSSID advertisements (EMA) in AP mode.
++ * Kernel uses some of these attributes to advertise driver's support for
++ * MBSSID and EMA.
++ * Remaining attributes should be used by the userspace to configure the
++ * features.
++ *
++ * @__NL80211_MBSSID_CONFIG_ATTR_INVALID: Invalid
++ *
++ * @NL80211_MBSSID_CONFIG_ATTR_MAX_INTERFACES: Used by the kernel to advertise
++ *	the maximum number of MBSSID interfaces supported by the driver.
++ *	Driver should indicate MBSSID support by setting
++ *	wiphy->mbssid_max_interfaces to a value more than or equal to 2.
++ *
++ * @NL80211_MBSSID_CONFIG_ATTR_MAX_EMA_PROFILE_PERIODICITY: Used by the kernel
++ *	to advertise the maximum profile periodicity supported by the driver
++ *	if EMA is enabled. Driver should indicate EMA support to the userspace
++ *	by setting wiphy->mbssid_max_ema_profile_periodicity to
++ *	a non-zero value.
++ *
++ * @NL80211_MBSSID_CONFIG_ATTR_INDEX: Mandatory parameter to pass the index of
++ *	this BSS (u8) in the multiple BSSID set.
++ *	Value must be set to 0 for the transmitting interface and non-zero for
++ *	all non-transmitting interfaces. The userspace will be responsible
++ *	for using unique indices for the interfaces.
++ *	Range: 0 to wiphy->mbssid_max_interfaces-1.
++ *
++ * @NL80211_MBSSID_CONFIG_ATTR_TX_IFINDEX: Mandatory parameter for
++ *	a non-transmitted profile which provides the interface index (u32) of
++ *	the transmitted profile. The value must match one of the interface
++ *	indices advertised by the kernel. Optional if the interface being set up
++ *	is the transmitting one, however, if provided then the value must match
++ *	the interface index of the same.
++ *
++ * @NL80211_MBSSID_CONFIG_ATTR_EMA: Flag used to enable EMA AP feature.
++ *	Setting this flag is permitted only if the driver advertises EMA support
++ *	by setting wiphy->mbssid_max_ema_profile_periodicity to non-zero.
++ *
++ * @__NL80211_MBSSID_CONFIG_ATTR_LAST: Internal
++ * @NL80211_MBSSID_CONFIG_ATTR_MAX: highest attribute
++ */
++enum nl80211_mbssid_config_attributes {
++	__NL80211_MBSSID_CONFIG_ATTR_INVALID,
++
++	NL80211_MBSSID_CONFIG_ATTR_MAX_INTERFACES,
++	NL80211_MBSSID_CONFIG_ATTR_MAX_EMA_PROFILE_PERIODICITY,
++	NL80211_MBSSID_CONFIG_ATTR_INDEX,
++	NL80211_MBSSID_CONFIG_ATTR_TX_IFINDEX,
++	NL80211_MBSSID_CONFIG_ATTR_EMA,
++
++	/* keep last */
++	__NL80211_MBSSID_CONFIG_ATTR_LAST,
++	NL80211_MBSSID_CONFIG_ATTR_MAX = __NL80211_MBSSID_CONFIG_ATTR_LAST - 1,
++};
++
+ #endif /* __LINUX_NL80211_H */
+--- a/net/wireless/nl80211.c
++++ b/net/wireless/nl80211.c
+@@ -442,6 +442,16 @@ sar_policy[NL80211_SAR_ATTR_MAX + 1] = {
+ 	[NL80211_SAR_ATTR_SPECS] = NLA_POLICY_NESTED_ARRAY(sar_specs_policy),
+ };
+ 
++static const struct nla_policy
++nl80211_mbssid_config_policy[NL80211_MBSSID_CONFIG_ATTR_MAX + 1] = {
++	[NL80211_MBSSID_CONFIG_ATTR_MAX_INTERFACES] = NLA_POLICY_MIN(NLA_U8, 2),
++	[NL80211_MBSSID_CONFIG_ATTR_MAX_EMA_PROFILE_PERIODICITY] =
++						NLA_POLICY_MIN(NLA_U8, 1),
++	[NL80211_MBSSID_CONFIG_ATTR_INDEX] = { .type = NLA_U8 },
++	[NL80211_MBSSID_CONFIG_ATTR_TX_IFINDEX] = { .type = NLA_U32 },
++	[NL80211_MBSSID_CONFIG_ATTR_EMA] = { .type = NLA_FLAG },
++};
++
+ static const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
+ 	[0] = { .strict_start_type = NL80211_ATTR_HE_OBSS_PD },
+ 	[NL80211_ATTR_WIPHY] = { .type = NLA_U32 },
+@@ -788,6 +798,9 @@ static const struct nla_policy nl80211_p
+ 	[NL80211_ATTR_COLOR_CHANGE_COUNT] = { .type = NLA_U8 },
+ 	[NL80211_ATTR_COLOR_CHANGE_COLOR] = { .type = NLA_U8 },
+ 	[NL80211_ATTR_COLOR_CHANGE_ELEMS] = NLA_POLICY_NESTED(nl80211_policy),
++	[NL80211_ATTR_MBSSID_CONFIG] =
++			NLA_POLICY_NESTED(nl80211_mbssid_config_policy),
++	[NL80211_ATTR_MBSSID_ELEMS] = { .type = NLA_NESTED },
+ };
+ 
+ /* policy for the key attributes */
+@@ -2236,6 +2249,35 @@ fail:
+ 	return -ENOBUFS;
+ }
+ 
++static int nl80211_put_mbssid_support(struct wiphy *wiphy, struct sk_buff *msg)
++{
++	struct nlattr *config;
++
++	if (!wiphy->mbssid_max_interfaces)
++		return 0;
++
++	config = nla_nest_start(msg, NL80211_ATTR_MBSSID_CONFIG);
++	if (!config)
++		return -ENOBUFS;
++
++	if (nla_put_u8(msg, NL80211_MBSSID_CONFIG_ATTR_MAX_INTERFACES,
++		       wiphy->mbssid_max_interfaces))
++		goto fail;
++
++	if (wiphy->ema_max_profile_periodicity &&
++	    nla_put_u8(msg,
++		       NL80211_MBSSID_CONFIG_ATTR_MAX_EMA_PROFILE_PERIODICITY,
++		       wiphy->ema_max_profile_periodicity))
++		goto fail;
++
++	nla_nest_end(msg, config);
++	return 0;
++
++fail:
++	nla_nest_cancel(msg, config);
++	return -ENOBUFS;
++}
++
+ struct nl80211_dump_wiphy_state {
+ 	s64 filter_wiphy;
+ 	long start;
+@@ -2821,6 +2863,9 @@ static int nl80211_send_wiphy(struct cfg
+ 		if (nl80211_put_sar_specs(rdev, msg))
+ 			goto nla_put_failure;
+ 
++		if (nl80211_put_mbssid_support(&rdev->wiphy, msg))
++			goto nla_put_failure;
++
+ 		/* done */
+ 		state->split_start = 0;
+ 		break;
+@@ -5020,6 +5065,96 @@ static int validate_beacon_tx_rate(struc
+ 	return 0;
+ }
+ 
++static int nl80211_parse_mbssid_config(struct wiphy *wiphy,
++				       struct net_device *dev,
++				       struct nlattr *attrs,
++				       struct cfg80211_mbssid_config *config,
++				       u8 num_elems)
++{
++	struct nlattr *tb[NL80211_MBSSID_CONFIG_ATTR_MAX + 1];
++
++	if (!wiphy->mbssid_max_interfaces)
++		return -EOPNOTSUPP;
++
++	if (nla_parse_nested(tb, NL80211_MBSSID_CONFIG_ATTR_MAX, attrs, NULL,
++			     NULL) ||
++	    !tb[NL80211_MBSSID_CONFIG_ATTR_INDEX])
++		return -EINVAL;
++
++	config->ema = nla_get_flag(tb[NL80211_MBSSID_CONFIG_ATTR_EMA]);
++	if (config->ema) {
++		if (!wiphy->ema_max_profile_periodicity)
++			return -EOPNOTSUPP;
++
++		if (num_elems > wiphy->ema_max_profile_periodicity)
++			return -EINVAL;
++	}
++
++	config->index = nla_get_u8(tb[NL80211_MBSSID_CONFIG_ATTR_INDEX]);
++	if (config->index >= wiphy->mbssid_max_interfaces ||
++	    (!config->index && !num_elems))
++		return -EINVAL;
++
++	if (tb[NL80211_MBSSID_CONFIG_ATTR_TX_IFINDEX]) {
++		u32 tx_ifindex =
++			nla_get_u32(tb[NL80211_MBSSID_CONFIG_ATTR_TX_IFINDEX]);
++
++		if ((!config->index && tx_ifindex != dev->ifindex) ||
++		    (config->index && tx_ifindex == dev->ifindex))
++			return -EINVAL;
++
++		if (tx_ifindex != dev->ifindex) {
++			struct net_device *tx_netdev =
++				dev_get_by_index(wiphy_net(wiphy), tx_ifindex);
++
++			if (!tx_netdev || !tx_netdev->ieee80211_ptr ||
++			    tx_netdev->ieee80211_ptr->wiphy != wiphy ||
++			    tx_netdev->ieee80211_ptr->iftype !=
++							NL80211_IFTYPE_AP) {
++				dev_put(tx_netdev);
++				return -EINVAL;
++			}
++
++			config->tx_wdev = tx_netdev->ieee80211_ptr;
++		} else {
++			config->tx_wdev = dev->ieee80211_ptr;
++		}
++	} else if (!config->index) {
++		config->tx_wdev = dev->ieee80211_ptr;
++	} else {
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
++static struct cfg80211_mbssid_elems *
++nl80211_parse_mbssid_elems(struct wiphy *wiphy, struct nlattr *attrs)
++{
++	struct nlattr *nl_elems;
++	struct cfg80211_mbssid_elems *elems;
++	int rem_elems;
++	u8 i = 0, num_elems = 0;
++
++	if (!wiphy->mbssid_max_interfaces)
++		return ERR_PTR(-EINVAL);
++
++	nla_for_each_nested(nl_elems, attrs, rem_elems)
++		num_elems++;
++
++	elems = kzalloc(struct_size(elems, elem, num_elems), GFP_KERNEL);
++	if (!elems)
++		return ERR_PTR(-ENOMEM);
++
++	nla_for_each_nested(nl_elems, attrs, rem_elems) {
++		elems->elem[i].data = nla_data(nl_elems);
++		elems->elem[i].len = nla_len(nl_elems);
++		i++;
++	}
++	elems->cnt = num_elems;
++	return elems;
++}
++
+ static int nl80211_parse_beacon(struct cfg80211_registered_device *rdev,
+ 				struct nlattr *attrs[],
+ 				struct cfg80211_beacon_data *bcn)
+@@ -5100,6 +5235,17 @@ static int nl80211_parse_beacon(struct c
+ 		bcn->ftm_responder = -1;
+ 	}
+ 
++	if (attrs[NL80211_ATTR_MBSSID_ELEMS]) {
++		struct cfg80211_mbssid_elems *mbssid =
++			nl80211_parse_mbssid_elems(&rdev->wiphy,
++						   attrs[NL80211_ATTR_MBSSID_ELEMS]);
++
++		if (IS_ERR(mbssid))
++			return PTR_ERR(mbssid);
++
++		bcn->mbssid_ies = mbssid;
++	}
++
+ 	return 0;
+ }
+ 
+@@ -5556,6 +5702,17 @@ static int nl80211_start_ap(struct sk_bu
+ 			goto out;
+ 	}
+ 
++	if (info->attrs[NL80211_ATTR_MBSSID_CONFIG]) {
++		err = nl80211_parse_mbssid_config(&rdev->wiphy, dev,
++						  info->attrs[NL80211_ATTR_MBSSID_CONFIG],
++						  &params.mbssid_config,
++						  params.beacon.mbssid_ies ?
++							params.beacon.mbssid_ies->cnt :
++							0);
++		if (err)
++			goto out;
++	}
++
+ 	nl80211_calculate_ap_params(&params);
+ 
+ 	if (info->attrs[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT])
+@@ -5577,6 +5734,11 @@ static int nl80211_start_ap(struct sk_bu
+ 
+ out:
+ 	kfree(params.acl);
++	kfree(params.beacon.mbssid_ies);
++	if (params.mbssid_config.tx_wdev &&
++	    params.mbssid_config.tx_wdev->netdev &&
++	    params.mbssid_config.tx_wdev->netdev != dev)
++		dev_put(params.mbssid_config.tx_wdev->netdev);
+ 
+ 	return err;
+ }
+@@ -5601,12 +5763,14 @@ static int nl80211_set_beacon(struct sk_
+ 
+ 	err = nl80211_parse_beacon(rdev, info->attrs, &params);
+ 	if (err)
+-		return err;
++		goto out;
+ 
+ 	wdev_lock(wdev);
+ 	err = rdev_change_beacon(rdev, dev, &params);
+ 	wdev_unlock(wdev);
+ 
++out:
++	kfree(params.mbssid_ies);
+ 	return err;
+ }
+ 
+@@ -9283,12 +9447,14 @@ static int nl80211_channel_switch(struct
+ 
+ 	err = nl80211_parse_beacon(rdev, info->attrs, &params.beacon_after);
+ 	if (err)
+-		return err;
++		goto free;
+ 
+ 	csa_attrs = kcalloc(NL80211_ATTR_MAX + 1, sizeof(*csa_attrs),
+ 			    GFP_KERNEL);
+-	if (!csa_attrs)
+-		return -ENOMEM;
++	if (!csa_attrs) {
++		err = -ENOMEM;
++		goto free;
++	}
+ 
+ 	err = nla_parse_nested_deprecated(csa_attrs, NL80211_ATTR_MAX,
+ 					  info->attrs[NL80211_ATTR_CSA_IES],
+@@ -9407,6 +9573,8 @@ skip_beacons:
+ 	wdev_unlock(wdev);
+ 
+ free:
++	kfree(params.beacon_after.mbssid_ies);
++	kfree(params.beacon_csa.mbssid_ies);
+ 	kfree(csa_attrs);
+ 	return err;
+ }
+@@ -14959,6 +15127,8 @@ static int nl80211_color_change(struct s
+ 	wdev_unlock(wdev);
+ 
+ out:
++	kfree(params.beacon_next.mbssid_ies);
++	kfree(params.beacon_color_change.mbssid_ies);
+ 	kfree(tb);
+ 	return err;
+ }
diff --git a/package/kernel/mac80211/patches/subsys/314-cfg80211-implement-APIs-for-dedicated-radar-detectio.patch b/package/kernel/mac80211/patches/subsys/314-cfg80211-implement-APIs-for-dedicated-radar-detectio.patch
new file mode 100644
index 0000000000..2038ee69db
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/314-cfg80211-implement-APIs-for-dedicated-radar-detectio.patch
@@ -0,0 +1,378 @@
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Sat, 23 Oct 2021 11:10:50 +0200
+Subject: [PATCH] cfg80211: implement APIs for dedicated radar detection HW
+
+If a dedicated (off-channel) radar detection hardware (chain)
+is available in the hardware/driver, allow this to be used by
+calling the NL80211_CMD_RADAR_DETECT command with a new flag
+attribute requesting off-channel radar detection is used.
+
+Offchannel CAC (channel availability check) avoids the CAC
+downtime when switching to a radar channel or when turning on
+the AP.
+
+Drivers advertise support for this using the new feature flag
+NL80211_EXT_FEATURE_RADAR_OFFCHAN.
+
+Tested-by: Evelyn Tsai <evelyn.tsai@mediatek.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Link: https://lore.kernel.org/r/7468e291ef5d05d692c1738d25b8f778d8ea5c3f.1634979655.git.lorenzo@kernel.org
+Link: https://lore.kernel.org/r/1e60e60fef00e14401adae81c3d49f3e5f307537.1634979655.git.lorenzo@kernel.org
+Link: https://lore.kernel.org/r/85fa50f57fc3adb2934c8d9ca0be30394de6b7e8.1634979655.git.lorenzo@kernel.org
+Link: https://lore.kernel.org/r/4b6c08671ad59aae0ac46fc94c02f31b1610eb72.1634979655.git.lorenzo@kernel.org
+Link: https://lore.kernel.org/r/241849ccaf2c228873c6f8495bf87b19159ba458.1634979655.git.lorenzo@kernel.org
+[remove offchan_mutex, fix cfg80211_stop_offchan_radar_detection(),
+ remove gfp_t argument, fix documentation, fix tracing]
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/cfg80211.h
++++ b/include/net/cfg80211.h
+@@ -4057,6 +4057,15 @@ struct mgmt_frame_regs {
+  * @set_sar_specs: Update the SAR (TX power) settings.
+  *
+  * @color_change: Initiate a color change.
++ *
++ * @set_radar_offchan: Configure dedicated offchannel chain available for
++ *	radar/CAC detection on some hw. This chain can't be used to transmit
++ *	or receive frames and it is bounded to a running wdev.
++ *	Offchannel radar/CAC detection allows to avoid the CAC downtime
++ *	switching to a different channel during CAC detection on the selected
++ *	radar channel.
++ *	The caller is expected to set chandef pointer to NULL in order to
++ *	disable offchannel CAC/radar detection.
+  */
+ struct cfg80211_ops {
+ 	int	(*suspend)(struct wiphy *wiphy, struct cfg80211_wowlan *wow);
+@@ -4387,6 +4396,8 @@ struct cfg80211_ops {
+ 	int	(*color_change)(struct wiphy *wiphy,
+ 				struct net_device *dev,
+ 				struct cfg80211_color_change_settings *params);
++	int	(*set_radar_offchan)(struct wiphy *wiphy,
++				     struct cfg80211_chan_def *chandef);
+ };
+ 
+ /*
+@@ -7608,6 +7619,20 @@ void cfg80211_cac_event(struct net_devic
+ 			const struct cfg80211_chan_def *chandef,
+ 			enum nl80211_radar_event event, gfp_t gfp);
+ 
++/**
++ * cfg80211_offchan_cac_event - Channel Availability Check (CAC) offchan event
++ * @wiphy: the wiphy
++ * @chandef: chandef for the current channel
++ * @event: type of event
++ *
++ * This function is called when a Channel Availability Check (CAC) is finished,
++ * started or aborted by a offchannel dedicated chain.
++ *
++ * Note that this acquires the wiphy lock.
++ */
++void cfg80211_offchan_cac_event(struct wiphy *wiphy,
++				const struct cfg80211_chan_def *chandef,
++				enum nl80211_radar_event event);
+ 
+ /**
+  * cfg80211_gtk_rekey_notify - notify userspace about driver rekeying
+--- a/include/uapi/linux/nl80211.h
++++ b/include/uapi/linux/nl80211.h
+@@ -2608,6 +2608,13 @@ enum nl80211_commands {
+  *	Mandatory parameter for the transmitting interface to enable MBSSID.
+  *	Optional for the non-transmitting interfaces.
+  *
++ * @NL80211_ATTR_RADAR_OFFCHAN: Configure dedicated offchannel chain available for
++ *	radar/CAC detection on some hw. This chain can't be used to transmit
++ *	or receive frames and it is bounded to a running wdev.
++ *	Offchannel radar/CAC detection allows to avoid the CAC downtime
++ *	switching on a different channel during CAC detection on the selected
++ *	radar channel.
++ *
+  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
+  * @NL80211_ATTR_MAX: highest attribute number currently defined
+  * @__NL80211_ATTR_AFTER_LAST: internal use
+@@ -3114,6 +3121,8 @@ enum nl80211_attrs {
+ 	NL80211_ATTR_MBSSID_CONFIG,
+ 	NL80211_ATTR_MBSSID_ELEMS,
+ 
++	NL80211_ATTR_RADAR_OFFCHAN,
++
+ 	/* add attributes here, update the policy in nl80211.c */
+ 
+ 	__NL80211_ATTR_AFTER_LAST,
+@@ -6013,6 +6022,9 @@ enum nl80211_feature_flags {
+  * @NL80211_EXT_FEATURE_BSS_COLOR: The driver supports BSS color collision
+  *	detection and change announcemnts.
+  *
++ * @NL80211_EXT_FEATURE_RADAR_OFFCHAN: Device supports offchannel radar/CAC
++ *	detection.
++ *
+  * @NUM_NL80211_EXT_FEATURES: number of extended features.
+  * @MAX_NL80211_EXT_FEATURES: highest extended feature index.
+  */
+@@ -6078,6 +6090,7 @@ enum nl80211_ext_feature_index {
+ 	NL80211_EXT_FEATURE_SECURE_RTT,
+ 	NL80211_EXT_FEATURE_PROT_RANGE_NEGO_AND_MEASURE,
+ 	NL80211_EXT_FEATURE_BSS_COLOR,
++	NL80211_EXT_FEATURE_RADAR_OFFCHAN,
+ 
+ 	/* add new features before the definition below */
+ 	NUM_NL80211_EXT_FEATURES,
+--- a/net/wireless/core.c
++++ b/net/wireless/core.c
+@@ -543,6 +543,7 @@ use_default_name:
+ 	INIT_WORK(&rdev->rfkill_block, cfg80211_rfkill_block_work);
+ 	INIT_WORK(&rdev->conn_work, cfg80211_conn_work);
+ 	INIT_WORK(&rdev->event_work, cfg80211_event_work);
++	INIT_DELAYED_WORK(&rdev->offchan_cac_work, cfg80211_offchan_cac_work);
+ 
+ 	init_waitqueue_head(&rdev->dev_wait);
+ 
+@@ -1205,6 +1206,8 @@ void __cfg80211_leave(struct cfg80211_re
+ 
+ 	cfg80211_pmsr_wdev_down(wdev);
+ 
++	cfg80211_stop_offchan_radar_detection(wdev);
++
+ 	switch (wdev->iftype) {
+ 	case NL80211_IFTYPE_ADHOC:
+ 		__cfg80211_leave_ibss(rdev, dev, true);
+--- a/net/wireless/core.h
++++ b/net/wireless/core.h
+@@ -84,6 +84,10 @@ struct cfg80211_registered_device {
+ 
+ 	struct delayed_work dfs_update_channels_wk;
+ 
++	struct wireless_dev *offchan_radar_wdev;
++	struct cfg80211_chan_def offchan_radar_chandef;
++	struct delayed_work offchan_cac_work;
++
+ 	/* netlink port which started critical protocol (0 means not started) */
+ 	u32 crit_proto_nlportid;
+ 
+@@ -491,6 +495,15 @@ cfg80211_chandef_dfs_cac_time(struct wip
+ 
+ void cfg80211_sched_dfs_chan_update(struct cfg80211_registered_device *rdev);
+ 
++int
++cfg80211_start_offchan_radar_detection(struct cfg80211_registered_device *rdev,
++				       struct wireless_dev *wdev,
++				       struct cfg80211_chan_def *chandef);
++
++void cfg80211_stop_offchan_radar_detection(struct wireless_dev *wdev);
++
++void cfg80211_offchan_cac_work(struct work_struct *work);
++
+ bool cfg80211_any_wiphy_oper_chan(struct wiphy *wiphy,
+ 				  struct ieee80211_channel *chan);
+ 
+--- a/net/wireless/mlme.c
++++ b/net/wireless/mlme.c
+@@ -970,3 +970,116 @@ void cfg80211_cac_event(struct net_devic
+ 	nl80211_radar_notify(rdev, chandef, event, netdev, gfp);
+ }
+ EXPORT_SYMBOL(cfg80211_cac_event);
++
++void cfg80211_offchan_cac_work(struct work_struct *work)
++{
++	struct delayed_work *delayed_work = to_delayed_work(work);
++	struct cfg80211_registered_device *rdev;
++
++	rdev = container_of(delayed_work, struct cfg80211_registered_device,
++			    offchan_cac_work);
++	cfg80211_offchan_cac_event(&rdev->wiphy, &rdev->offchan_radar_chandef,
++				   NL80211_RADAR_CAC_FINISHED);
++}
++
++static void
++__cfg80211_offchan_cac_event(struct cfg80211_registered_device *rdev,
++			     struct wireless_dev *wdev,
++			     const struct cfg80211_chan_def *chandef,
++			     enum nl80211_radar_event event)
++{
++	struct wiphy *wiphy = &rdev->wiphy;
++	struct net_device *netdev;
++
++	lockdep_assert_wiphy(&rdev->wiphy);
++
++	if (event != NL80211_RADAR_CAC_STARTED && !rdev->offchan_radar_wdev)
++		return;
++
++	switch (event) {
++	case NL80211_RADAR_CAC_FINISHED:
++		cfg80211_set_dfs_state(wiphy, chandef, NL80211_DFS_AVAILABLE);
++		memcpy(&rdev->cac_done_chandef, chandef, sizeof(*chandef));
++		queue_work(cfg80211_wq, &rdev->propagate_cac_done_wk);
++		cfg80211_sched_dfs_chan_update(rdev);
++		wdev = rdev->offchan_radar_wdev;
++		rdev->offchan_radar_wdev = NULL;
++		break;
++	case NL80211_RADAR_CAC_ABORTED:
++		cancel_delayed_work(&rdev->offchan_cac_work);
++		wdev = rdev->offchan_radar_wdev;
++		rdev->offchan_radar_wdev = NULL;
++		break;
++	case NL80211_RADAR_CAC_STARTED:
++		WARN_ON(!wdev);
++		rdev->offchan_radar_wdev = wdev;
++		break;
++	default:
++		return;
++	}
++
++	netdev = wdev ? wdev->netdev : NULL;
++	nl80211_radar_notify(rdev, chandef, event, netdev, GFP_KERNEL);
++}
++
++void cfg80211_offchan_cac_event(struct wiphy *wiphy,
++				const struct cfg80211_chan_def *chandef,
++				enum nl80211_radar_event event)
++{
++	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
++
++	wiphy_lock(wiphy);
++	__cfg80211_offchan_cac_event(rdev, NULL, chandef, event);
++	wiphy_unlock(wiphy);
++}
++EXPORT_SYMBOL(cfg80211_offchan_cac_event);
++
++int
++cfg80211_start_offchan_radar_detection(struct cfg80211_registered_device *rdev,
++				       struct wireless_dev *wdev,
++				       struct cfg80211_chan_def *chandef)
++{
++	unsigned int cac_time_ms;
++	int err;
++
++	lockdep_assert_wiphy(&rdev->wiphy);
++
++	if (!wiphy_ext_feature_isset(&rdev->wiphy,
++				     NL80211_EXT_FEATURE_RADAR_OFFCHAN))
++		return -EOPNOTSUPP;
++
++	if (rdev->offchan_radar_wdev)
++		return -EBUSY;
++
++	err = rdev_set_radar_offchan(rdev, chandef);
++	if (err)
++		return err;
++
++	cac_time_ms = cfg80211_chandef_dfs_cac_time(&rdev->wiphy, chandef);
++	if (!cac_time_ms)
++		cac_time_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;
++
++	rdev->offchan_radar_chandef = *chandef;
++	__cfg80211_offchan_cac_event(rdev, wdev, chandef,
++				     NL80211_RADAR_CAC_STARTED);
++	queue_delayed_work(cfg80211_wq, &rdev->offchan_cac_work,
++			   msecs_to_jiffies(cac_time_ms));
++
++	return 0;
++}
++
++void cfg80211_stop_offchan_radar_detection(struct wireless_dev *wdev)
++{
++	struct wiphy *wiphy = wdev->wiphy;
++	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
++
++	lockdep_assert_wiphy(wiphy);
++
++	if (wdev != rdev->offchan_radar_wdev)
++		return;
++
++	rdev_set_radar_offchan(rdev, NULL);
++
++	__cfg80211_offchan_cac_event(rdev, NULL, NULL,
++				     NL80211_RADAR_CAC_ABORTED);
++}
+--- a/net/wireless/nl80211.c
++++ b/net/wireless/nl80211.c
+@@ -801,6 +801,7 @@ static const struct nla_policy nl80211_p
+ 	[NL80211_ATTR_MBSSID_CONFIG] =
+ 			NLA_POLICY_NESTED(nl80211_mbssid_config_policy),
+ 	[NL80211_ATTR_MBSSID_ELEMS] = { .type = NLA_NESTED },
++	[NL80211_ATTR_RADAR_OFFCHAN] = { .type = NLA_FLAG },
+ };
+ 
+ /* policy for the key attributes */
+@@ -9287,12 +9288,6 @@ static int nl80211_start_radar_detection
+ 	if (err)
+ 		return err;
+ 
+-	if (netif_carrier_ok(dev))
+-		return -EBUSY;
+-
+-	if (wdev->cac_started)
+-		return -EBUSY;
+-
+ 	err = cfg80211_chandef_dfs_required(wiphy, &chandef, wdev->iftype);
+ 	if (err < 0)
+ 		return err;
+@@ -9303,6 +9298,16 @@ static int nl80211_start_radar_detection
+ 	if (!cfg80211_chandef_dfs_usable(wiphy, &chandef))
+ 		return -EINVAL;
+ 
++	if (nla_get_flag(info->attrs[NL80211_ATTR_RADAR_OFFCHAN]))
++		return cfg80211_start_offchan_radar_detection(rdev, wdev,
++							      &chandef);
++
++	if (netif_carrier_ok(dev))
++		return -EBUSY;
++
++	if (wdev->cac_started)
++		return -EBUSY;
++
+ 	/* CAC start is offloaded to HW and can't be started manually */
+ 	if (wiphy_ext_feature_isset(wiphy, NL80211_EXT_FEATURE_DFS_OFFLOAD))
+ 		return -EOPNOTSUPP;
+--- a/net/wireless/rdev-ops.h
++++ b/net/wireless/rdev-ops.h
+@@ -1381,4 +1381,21 @@ static inline int rdev_color_change(stru
+ 	return ret;
+ }
+ 
++static inline int
++rdev_set_radar_offchan(struct cfg80211_registered_device *rdev,
++		       struct cfg80211_chan_def *chandef)
++{
++	struct wiphy *wiphy = &rdev->wiphy;
++	int ret;
++
++	if (!rdev->ops->set_radar_offchan)
++		return -EOPNOTSUPP;
++
++	trace_rdev_set_radar_offchan(wiphy, chandef);
++	ret = rdev->ops->set_radar_offchan(wiphy, chandef);
++	trace_rdev_return_int(wiphy, ret);
++
++	return ret;
++}
++
+ #endif /* __CFG80211_RDEV_OPS */
+--- a/net/wireless/trace.h
++++ b/net/wireless/trace.h
+@@ -3643,6 +3643,25 @@ TRACE_EVENT(cfg80211_bss_color_notify,
+ 		  __entry->color_bitmap)
+ );
+ 
++TRACE_EVENT(rdev_set_radar_offchan,
++	TP_PROTO(struct wiphy *wiphy, struct cfg80211_chan_def *chandef),
++
++	TP_ARGS(wiphy, chandef),
++
++	TP_STRUCT__entry(
++		WIPHY_ENTRY
++		CHAN_DEF_ENTRY
++	),
++
++	TP_fast_assign(
++		WIPHY_ASSIGN;
++		CHAN_DEF_ASSIGN(chandef)
++	),
++
++	TP_printk(WIPHY_PR_FMT ", " CHAN_DEF_PR_FMT,
++		  WIPHY_PR_ARG, CHAN_DEF_PR_ARG)
++);
++
+ #endif /* !__RDEV_OPS_TRACE || TRACE_HEADER_MULTI_READ */
+ 
+ #undef TRACE_INCLUDE_PATH
diff --git a/package/kernel/mac80211/patches/subsys/315-cfg80211-move-offchan_cac_event-to-a-dedicated-work.patch b/package/kernel/mac80211/patches/subsys/315-cfg80211-move-offchan_cac_event-to-a-dedicated-work.patch
new file mode 100644
index 0000000000..b1a1d2c894
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/315-cfg80211-move-offchan_cac_event-to-a-dedicated-work.patch
@@ -0,0 +1,183 @@
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Wed, 27 Oct 2021 11:03:42 +0200
+Subject: [PATCH] cfg80211: move offchan_cac_event to a dedicated work
+
+In order to make cfg80211_offchan_cac_abort() (renamed from
+cfg80211_offchan_cac_event) callable in other contexts and
+without so much locking restrictions, make it trigger a new
+work instead of operating directly.
+
+Do some other renames while at it to clarify.
+
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Link: https://lore.kernel.org/r/6145c3d0f30400a568023f67981981d24c7c6133.1635325205.git.lorenzo@kernel.org
+[rewrite commit log]
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/cfg80211.h
++++ b/include/net/cfg80211.h
+@@ -7620,19 +7620,13 @@ void cfg80211_cac_event(struct net_devic
+ 			enum nl80211_radar_event event, gfp_t gfp);
+ 
+ /**
+- * cfg80211_offchan_cac_event - Channel Availability Check (CAC) offchan event
++ * cfg80211_offchan_cac_abort - Channel Availability Check offchan abort event
+  * @wiphy: the wiphy
+- * @chandef: chandef for the current channel
+- * @event: type of event
+  *
+- * This function is called when a Channel Availability Check (CAC) is finished,
+- * started or aborted by a offchannel dedicated chain.
+- *
+- * Note that this acquires the wiphy lock.
++ * This function is called by the driver when a Channel Availability Check
++ * (CAC) is aborted by a offchannel dedicated chain.
+  */
+-void cfg80211_offchan_cac_event(struct wiphy *wiphy,
+-				const struct cfg80211_chan_def *chandef,
+-				enum nl80211_radar_event event);
++void cfg80211_offchan_cac_abort(struct wiphy *wiphy);
+ 
+ /**
+  * cfg80211_gtk_rekey_notify - notify userspace about driver rekeying
+--- a/net/wireless/core.c
++++ b/net/wireless/core.c
+@@ -543,7 +543,9 @@ use_default_name:
+ 	INIT_WORK(&rdev->rfkill_block, cfg80211_rfkill_block_work);
+ 	INIT_WORK(&rdev->conn_work, cfg80211_conn_work);
+ 	INIT_WORK(&rdev->event_work, cfg80211_event_work);
+-	INIT_DELAYED_WORK(&rdev->offchan_cac_work, cfg80211_offchan_cac_work);
++	INIT_WORK(&rdev->offchan_cac_abort_wk, cfg80211_offchan_cac_abort_wk);
++	INIT_DELAYED_WORK(&rdev->offchan_cac_done_wk,
++			  cfg80211_offchan_cac_done_wk);
+ 
+ 	init_waitqueue_head(&rdev->dev_wait);
+ 
+@@ -1053,11 +1055,13 @@ void wiphy_unregister(struct wiphy *wiph
+ 	cancel_work_sync(&rdev->conn_work);
+ 	flush_work(&rdev->event_work);
+ 	cancel_delayed_work_sync(&rdev->dfs_update_channels_wk);
++	cancel_delayed_work_sync(&rdev->offchan_cac_done_wk);
+ 	flush_work(&rdev->destroy_work);
+ 	flush_work(&rdev->sched_scan_stop_wk);
+ 	flush_work(&rdev->propagate_radar_detect_wk);
+ 	flush_work(&rdev->propagate_cac_done_wk);
+ 	flush_work(&rdev->mgmt_registrations_update_wk);
++	flush_work(&rdev->offchan_cac_abort_wk);
+ 
+ #ifdef CONFIG_PM
+ 	if (rdev->wiphy.wowlan_config && rdev->ops->set_wakeup)
+--- a/net/wireless/core.h
++++ b/net/wireless/core.h
+@@ -86,7 +86,8 @@ struct cfg80211_registered_device {
+ 
+ 	struct wireless_dev *offchan_radar_wdev;
+ 	struct cfg80211_chan_def offchan_radar_chandef;
+-	struct delayed_work offchan_cac_work;
++	struct delayed_work offchan_cac_done_wk;
++	struct work_struct offchan_cac_abort_wk;
+ 
+ 	/* netlink port which started critical protocol (0 means not started) */
+ 	u32 crit_proto_nlportid;
+@@ -502,7 +503,9 @@ cfg80211_start_offchan_radar_detection(s
+ 
+ void cfg80211_stop_offchan_radar_detection(struct wireless_dev *wdev);
+ 
+-void cfg80211_offchan_cac_work(struct work_struct *work);
++void cfg80211_offchan_cac_done_wk(struct work_struct *work);
++
++void cfg80211_offchan_cac_abort_wk(struct work_struct *work);
+ 
+ bool cfg80211_any_wiphy_oper_chan(struct wiphy *wiphy,
+ 				  struct ieee80211_channel *chan);
+--- a/net/wireless/mlme.c
++++ b/net/wireless/mlme.c
+@@ -971,17 +971,6 @@ void cfg80211_cac_event(struct net_devic
+ }
+ EXPORT_SYMBOL(cfg80211_cac_event);
+ 
+-void cfg80211_offchan_cac_work(struct work_struct *work)
+-{
+-	struct delayed_work *delayed_work = to_delayed_work(work);
+-	struct cfg80211_registered_device *rdev;
+-
+-	rdev = container_of(delayed_work, struct cfg80211_registered_device,
+-			    offchan_cac_work);
+-	cfg80211_offchan_cac_event(&rdev->wiphy, &rdev->offchan_radar_chandef,
+-				   NL80211_RADAR_CAC_FINISHED);
+-}
+-
+ static void
+ __cfg80211_offchan_cac_event(struct cfg80211_registered_device *rdev,
+ 			     struct wireless_dev *wdev,
+@@ -1006,7 +995,7 @@ __cfg80211_offchan_cac_event(struct cfg8
+ 		rdev->offchan_radar_wdev = NULL;
+ 		break;
+ 	case NL80211_RADAR_CAC_ABORTED:
+-		cancel_delayed_work(&rdev->offchan_cac_work);
++		cancel_delayed_work(&rdev->offchan_cac_done_wk);
+ 		wdev = rdev->offchan_radar_wdev;
+ 		rdev->offchan_radar_wdev = NULL;
+ 		break;
+@@ -1022,17 +1011,44 @@ __cfg80211_offchan_cac_event(struct cfg8
+ 	nl80211_radar_notify(rdev, chandef, event, netdev, GFP_KERNEL);
+ }
+ 
+-void cfg80211_offchan_cac_event(struct wiphy *wiphy,
+-				const struct cfg80211_chan_def *chandef,
+-				enum nl80211_radar_event event)
++static void
++cfg80211_offchan_cac_event(struct cfg80211_registered_device *rdev,
++			   const struct cfg80211_chan_def *chandef,
++			   enum nl80211_radar_event event)
++{
++	wiphy_lock(&rdev->wiphy);
++	__cfg80211_offchan_cac_event(rdev, NULL, chandef, event);
++	wiphy_unlock(&rdev->wiphy);
++}
++
++void cfg80211_offchan_cac_done_wk(struct work_struct *work)
++{
++	struct delayed_work *delayed_work = to_delayed_work(work);
++	struct cfg80211_registered_device *rdev;
++
++	rdev = container_of(delayed_work, struct cfg80211_registered_device,
++			    offchan_cac_done_wk);
++	cfg80211_offchan_cac_event(rdev, &rdev->offchan_radar_chandef,
++				   NL80211_RADAR_CAC_FINISHED);
++}
++
++void cfg80211_offchan_cac_abort_wk(struct work_struct *work)
++{
++	struct cfg80211_registered_device *rdev;
++
++	rdev = container_of(work, struct cfg80211_registered_device,
++			    offchan_cac_abort_wk);
++	cfg80211_offchan_cac_event(rdev, &rdev->offchan_radar_chandef,
++				   NL80211_RADAR_CAC_ABORTED);
++}
++
++void cfg80211_offchan_cac_abort(struct wiphy *wiphy)
+ {
+ 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+ 
+-	wiphy_lock(wiphy);
+-	__cfg80211_offchan_cac_event(rdev, NULL, chandef, event);
+-	wiphy_unlock(wiphy);
++	queue_work(cfg80211_wq, &rdev->offchan_cac_abort_wk);
+ }
+-EXPORT_SYMBOL(cfg80211_offchan_cac_event);
++EXPORT_SYMBOL(cfg80211_offchan_cac_abort);
+ 
+ int
+ cfg80211_start_offchan_radar_detection(struct cfg80211_registered_device *rdev,
+@@ -1062,7 +1078,7 @@ cfg80211_start_offchan_radar_detection(s
+ 	rdev->offchan_radar_chandef = *chandef;
+ 	__cfg80211_offchan_cac_event(rdev, wdev, chandef,
+ 				     NL80211_RADAR_CAC_STARTED);
+-	queue_delayed_work(cfg80211_wq, &rdev->offchan_cac_work,
++	queue_delayed_work(cfg80211_wq, &rdev->offchan_cac_done_wk,
+ 			   msecs_to_jiffies(cac_time_ms));
+ 
+ 	return 0;
diff --git a/package/kernel/mac80211/patches/subsys/315-mac80211-add-rx-decapsulation-offload-support.patch b/package/kernel/mac80211/patches/subsys/315-mac80211-add-rx-decapsulation-offload-support.patch
deleted file mode 100644
index 1214ccb27b..0000000000
--- a/package/kernel/mac80211/patches/subsys/315-mac80211-add-rx-decapsulation-offload-support.patch
+++ /dev/null
@@ -1,570 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Wed, 16 Dec 2020 21:34:03 +0100
-Subject: [PATCH] mac80211: add rx decapsulation offload support
-
-This allows drivers to pass 802.3 frames to mac80211, with some restrictions:
-
-- the skb must be passed with a valid sta
-- fast-rx needs to be active for the sta
-- monitor mode needs to be disabled
-
-mac80211 will tell the driver when it is safe to enable rx decap offload for
-a particular station.
-
-In order to implement support, a driver must:
-
-- call ieee80211_hw_set(hw, SUPPORTS_RX_DECAP_OFFLOAD)
-- implement ops->sta_set_decap_offload
-- mark 802.3 frames with RX_FLAG_8023
-
-If it doesn't want to enable offload for some vif types, it can mask out
-IEEE80211_OFFLOAD_DECAP_ENABLED in vif->offload_flags from within the
-.add_interface or .update_vif_offload driver ops
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -1297,6 +1297,8 @@ ieee80211_tx_info_clear_status(struct ie
-  *	the "0-length PSDU" field included there.  The value for it is
-  *	in &struct ieee80211_rx_status.  Note that if this value isn't
-  *	known the frame shouldn't be reported.
-+ * @RX_FLAG_8023: the frame has an 802.3 header (decap offload performed by
-+ *	hardware or driver)
-  */
- enum mac80211_rx_flags {
- 	RX_FLAG_MMIC_ERROR		= BIT(0),
-@@ -1329,6 +1331,7 @@ enum mac80211_rx_flags {
- 	RX_FLAG_RADIOTAP_HE_MU		= BIT(27),
- 	RX_FLAG_RADIOTAP_LSIG		= BIT(28),
- 	RX_FLAG_NO_PSDU			= BIT(29),
-+	RX_FLAG_8023			= BIT(30),
- };
- 
- /**
-@@ -1650,11 +1653,15 @@ enum ieee80211_vif_flags {
-  *	The driver supports sending frames passed as 802.3 frames by mac80211.
-  *	It must also support sending 802.11 packets for the same interface.
-  * @IEEE80211_OFFLOAD_ENCAP_4ADDR: support 4-address mode encapsulation offload
-+ * @IEEE80211_OFFLOAD_DECAP_ENABLED: rx encapsulation offload is enabled
-+ *	The driver supports passing received 802.11 frames as 802.3 frames to
-+ *	mac80211.
-  */
- 
- enum ieee80211_offload_flags {
- 	IEEE80211_OFFLOAD_ENCAP_ENABLED		= BIT(0),
- 	IEEE80211_OFFLOAD_ENCAP_4ADDR		= BIT(1),
-+	IEEE80211_OFFLOAD_DECAP_ENABLED		= BIT(2),
- };
- 
- /**
-@@ -2390,6 +2397,9 @@ struct ieee80211_txq {
-  * @IEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD: Hardware supports tx encapsulation
-  *	offload
-  *
-+ * @IEEE80211_HW_SUPPORTS_RX_DECAP_OFFLOAD: Hardware supports rx decapsulation
-+ *	offload
-+ *
-  * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays
-  */
- enum ieee80211_hw_flags {
-@@ -2443,6 +2453,7 @@ enum ieee80211_hw_flags {
- 	IEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID,
- 	IEEE80211_HW_AMPDU_KEYBORDER_SUPPORT,
- 	IEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD,
-+	IEEE80211_HW_SUPPORTS_RX_DECAP_OFFLOAD,
- 
- 	/* keep last, obviously */
- 	NUM_IEEE80211_HW_FLAGS
-@@ -4196,6 +4207,9 @@ struct ieee80211_ops {
- 				   struct ieee80211_vif *vif);
- 	void (*sta_set_4addr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
- 			      struct ieee80211_sta *sta, bool enabled);
-+	void (*sta_set_decap_offload)(struct ieee80211_hw *hw,
-+				      struct ieee80211_vif *vif,
-+				      struct ieee80211_sta *sta, bool enabled);
- };
- 
- /**
---- a/net/mac80211/debugfs.c
-+++ b/net/mac80211/debugfs.c
-@@ -405,6 +405,7 @@ static const char *hw_flag_names[] = {
- 	FLAG(SUPPORTS_ONLY_HE_MULTI_BSSID),
- 	FLAG(AMPDU_KEYBORDER_SUPPORT),
- 	FLAG(SUPPORTS_TX_ENCAP_OFFLOAD),
-+	FLAG(SUPPORTS_RX_DECAP_OFFLOAD),
- #undef FLAG
- };
- 
---- a/net/mac80211/debugfs_sta.c
-+++ b/net/mac80211/debugfs_sta.c
-@@ -79,6 +79,7 @@ static const char * const sta_flag_names
- 	FLAG(MPSP_RECIPIENT),
- 	FLAG(PS_DELIVER),
- 	FLAG(USES_ENCRYPTION),
-+	FLAG(DECAP_OFFLOAD),
- #undef FLAG
- };
- 
---- a/net/mac80211/driver-ops.h
-+++ b/net/mac80211/driver-ops.h
-@@ -1416,4 +1416,20 @@ static inline void drv_sta_set_4addr(str
- 	trace_drv_return_void(local);
- }
- 
-+static inline void drv_sta_set_decap_offload(struct ieee80211_local *local,
-+					     struct ieee80211_sub_if_data *sdata,
-+					     struct ieee80211_sta *sta,
-+					     bool enabled)
-+{
-+	sdata = get_bss_sdata(sdata);
-+	if (!check_sdata_in_driver(sdata))
-+		return;
-+
-+	trace_drv_sta_set_decap_offload(local, sdata, sta, enabled);
-+	if (local->ops->sta_set_decap_offload)
-+		local->ops->sta_set_decap_offload(&local->hw, &sdata->vif, sta,
-+						  enabled);
-+	trace_drv_return_void(local);
-+}
-+
- #endif /* __MAC80211_DRIVER_OPS */
---- a/net/mac80211/iface.c
-+++ b/net/mac80211/iface.c
-@@ -856,7 +856,7 @@ static const struct net_device_ops ieee8
- 
- };
- 
--static bool ieee80211_iftype_supports_encap_offload(enum nl80211_iftype iftype)
-+static bool ieee80211_iftype_supports_hdr_offload(enum nl80211_iftype iftype)
- {
- 	switch (iftype) {
- 	/* P2P GO and client are mapped to AP/STATION types */
-@@ -876,7 +876,7 @@ static bool ieee80211_set_sdata_offload_
- 	flags = sdata->vif.offload_flags;
- 
- 	if (ieee80211_hw_check(&local->hw, SUPPORTS_TX_ENCAP_OFFLOAD) &&
--	    ieee80211_iftype_supports_encap_offload(sdata->vif.type)) {
-+	    ieee80211_iftype_supports_hdr_offload(sdata->vif.type)) {
- 		flags |= IEEE80211_OFFLOAD_ENCAP_ENABLED;
- 
- 		if (!ieee80211_hw_check(&local->hw, SUPPORTS_TX_FRAG) &&
-@@ -889,10 +889,21 @@ static bool ieee80211_set_sdata_offload_
- 		flags &= ~IEEE80211_OFFLOAD_ENCAP_ENABLED;
- 	}
- 
-+	if (ieee80211_hw_check(&local->hw, SUPPORTS_RX_DECAP_OFFLOAD) &&
-+	    ieee80211_iftype_supports_hdr_offload(sdata->vif.type)) {
-+		flags |= IEEE80211_OFFLOAD_DECAP_ENABLED;
-+
-+		if (local->monitors)
-+			flags &= ~IEEE80211_OFFLOAD_DECAP_ENABLED;
-+	} else {
-+		flags &= ~IEEE80211_OFFLOAD_DECAP_ENABLED;
-+	}
-+
- 	if (sdata->vif.offload_flags == flags)
- 		return false;
- 
- 	sdata->vif.offload_flags = flags;
-+	ieee80211_check_fast_rx_iface(sdata);
- 	return true;
- }
- 
-@@ -910,7 +921,7 @@ static void ieee80211_set_vif_encap_ops(
- 	}
- 
- 	if (!ieee80211_hw_check(&local->hw, SUPPORTS_TX_ENCAP_OFFLOAD) ||
--	    !ieee80211_iftype_supports_encap_offload(bss->vif.type))
-+	    !ieee80211_iftype_supports_hdr_offload(bss->vif.type))
- 		return;
- 
- 	enabled = bss->vif.offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED;
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -4199,7 +4199,9 @@ void ieee80211_check_fast_rx(struct sta_
- 		.vif_type = sdata->vif.type,
- 		.control_port_protocol = sdata->control_port_protocol,
- 	}, *old, *new = NULL;
-+	bool set_offload = false;
- 	bool assign = false;
-+	bool offload;
- 
- 	/* use sparse to check that we don't return without updating */
- 	__acquire(check_fast_rx);
-@@ -4312,6 +4314,17 @@ void ieee80211_check_fast_rx(struct sta_
- 	if (assign)
- 		new = kmemdup(&fastrx, sizeof(fastrx), GFP_KERNEL);
- 
-+	offload = assign &&
-+		  (sdata->vif.offload_flags & IEEE80211_OFFLOAD_DECAP_ENABLED);
-+
-+	if (offload)
-+		set_offload = !test_and_set_sta_flag(sta, WLAN_STA_DECAP_OFFLOAD);
-+	else
-+		set_offload = test_and_clear_sta_flag(sta, WLAN_STA_DECAP_OFFLOAD);
-+
-+	if (set_offload)
-+		drv_sta_set_decap_offload(local, sdata, &sta->sta, assign);
-+
- 	spin_lock_bh(&sta->lock);
- 	old = rcu_dereference_protected(sta->fast_rx, true);
- 	rcu_assign_pointer(sta->fast_rx, new);
-@@ -4358,6 +4371,108 @@ void ieee80211_check_fast_rx_iface(struc
- 	mutex_unlock(&local->sta_mtx);
- }
- 
-+static void ieee80211_rx_8023(struct ieee80211_rx_data *rx,
-+			      struct ieee80211_fast_rx *fast_rx,
-+			      int orig_len)
-+{
-+	struct ieee80211_sta_rx_stats *stats;
-+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
-+	struct sta_info *sta = rx->sta;
-+	struct sk_buff *skb = rx->skb;
-+	void *sa = skb->data + ETH_ALEN;
-+	void *da = skb->data;
-+
-+	stats = &sta->rx_stats;
-+	if (fast_rx->uses_rss)
-+		stats = this_cpu_ptr(sta->pcpu_rx_stats);
-+
-+	/* statistics part of ieee80211_rx_h_sta_process() */
-+	if (!(status->flag & RX_FLAG_NO_SIGNAL_VAL)) {
-+		stats->last_signal = status->signal;
-+		if (!fast_rx->uses_rss)
-+			ewma_signal_add(&sta->rx_stats_avg.signal,
-+					-status->signal);
-+	}
-+
-+	if (status->chains) {
-+		int i;
-+
-+		stats->chains = status->chains;
-+		for (i = 0; i < ARRAY_SIZE(status->chain_signal); i++) {
-+			int signal = status->chain_signal[i];
-+
-+			if (!(status->chains & BIT(i)))
-+				continue;
-+
-+			stats->chain_signal_last[i] = signal;
-+			if (!fast_rx->uses_rss)
-+				ewma_signal_add(&sta->rx_stats_avg.chain_signal[i],
-+						-signal);
-+		}
-+	}
-+	/* end of statistics */
-+
-+	stats->last_rx = jiffies;
-+	stats->last_rate = sta_stats_encode_rate(status);
-+
-+	stats->fragments++;
-+	stats->packets++;
-+
-+	skb->dev = fast_rx->dev;
-+
-+	ieee80211_rx_stats(fast_rx->dev, skb->len);
-+
-+	/* The seqno index has the same property as needed
-+	 * for the rx_msdu field, i.e. it is IEEE80211_NUM_TIDS
-+	 * for non-QoS-data frames. Here we know it's a data
-+	 * frame, so count MSDUs.
-+	 */
-+	u64_stats_update_begin(&stats->syncp);
-+	stats->msdu[rx->seqno_idx]++;
-+	stats->bytes += orig_len;
-+	u64_stats_update_end(&stats->syncp);
-+
-+	if (fast_rx->internal_forward) {
-+		struct sk_buff *xmit_skb = NULL;
-+		if (is_multicast_ether_addr(da)) {
-+			xmit_skb = skb_copy(skb, GFP_ATOMIC);
-+		} else if (!ether_addr_equal(da, sa) &&
-+			   sta_info_get(rx->sdata, da)) {
-+			xmit_skb = skb;
-+			skb = NULL;
-+		}
-+
-+		if (xmit_skb) {
-+			/*
-+			 * Send to wireless media and increase priority by 256
-+			 * to keep the received priority instead of
-+			 * reclassifying the frame (see cfg80211_classify8021d).
-+			 */
-+			xmit_skb->priority += 256;
-+			xmit_skb->protocol = htons(ETH_P_802_3);
-+			skb_reset_network_header(xmit_skb);
-+			skb_reset_mac_header(xmit_skb);
-+			dev_queue_xmit(xmit_skb);
-+		}
-+
-+		if (!skb)
-+			return;
-+	}
-+
-+	/* deliver to local stack */
-+	skb->protocol = eth_type_trans(skb, fast_rx->dev);
-+	memset(skb->cb, 0, sizeof(skb->cb));
-+	if (rx->list)
-+#if LINUX_VERSION_IS_GEQ(4,19,0)
-+		list_add_tail(&skb->list, rx->list);
-+#else
-+		__skb_queue_tail(rx->list, skb);
-+#endif
-+	else
-+		netif_receive_skb(skb);
-+
-+}
-+
- static bool ieee80211_invoke_fast_rx(struct ieee80211_rx_data *rx,
- 				     struct ieee80211_fast_rx *fast_rx)
- {
-@@ -4378,9 +4493,6 @@ static bool ieee80211_invoke_fast_rx(str
- 	} addrs __aligned(2);
- 	struct ieee80211_sta_rx_stats *stats = &sta->rx_stats;
- 
--	if (fast_rx->uses_rss)
--		stats = this_cpu_ptr(sta->pcpu_rx_stats);
--
- 	/* for parallel-rx, we need to have DUP_VALIDATED, otherwise we write
- 	 * to a common data structure; drivers can implement that per queue
- 	 * but we don't have that information in mac80211
-@@ -4454,32 +4566,6 @@ static bool ieee80211_invoke_fast_rx(str
- 	    pskb_trim(skb, skb->len - fast_rx->icv_len))
- 		goto drop;
- 
--	/* statistics part of ieee80211_rx_h_sta_process() */
--	if (!(status->flag & RX_FLAG_NO_SIGNAL_VAL)) {
--		stats->last_signal = status->signal;
--		if (!fast_rx->uses_rss)
--			ewma_signal_add(&sta->rx_stats_avg.signal,
--					-status->signal);
--	}
--
--	if (status->chains) {
--		int i;
--
--		stats->chains = status->chains;
--		for (i = 0; i < ARRAY_SIZE(status->chain_signal); i++) {
--			int signal = status->chain_signal[i];
--
--			if (!(status->chains & BIT(i)))
--				continue;
--
--			stats->chain_signal_last[i] = signal;
--			if (!fast_rx->uses_rss)
--				ewma_signal_add(&sta->rx_stats_avg.chain_signal[i],
--						-signal);
--		}
--	}
--	/* end of statistics */
--
- 	if (rx->key && !ieee80211_has_protected(hdr->frame_control))
- 		goto drop;
- 
-@@ -4491,12 +4577,6 @@ static bool ieee80211_invoke_fast_rx(str
- 		return true;
- 	}
- 
--	stats->last_rx = jiffies;
--	stats->last_rate = sta_stats_encode_rate(status);
--
--	stats->fragments++;
--	stats->packets++;
--
- 	/* do the header conversion - first grab the addresses */
- 	ether_addr_copy(addrs.da, skb->data + fast_rx->da_offs);
- 	ether_addr_copy(addrs.sa, skb->data + fast_rx->sa_offs);
-@@ -4505,62 +4585,14 @@ static bool ieee80211_invoke_fast_rx(str
- 	/* push the addresses in front */
- 	memcpy(skb_push(skb, sizeof(addrs)), &addrs, sizeof(addrs));
- 
--	skb->dev = fast_rx->dev;
--
--	ieee80211_rx_stats(fast_rx->dev, skb->len);
--
--	/* The seqno index has the same property as needed
--	 * for the rx_msdu field, i.e. it is IEEE80211_NUM_TIDS
--	 * for non-QoS-data frames. Here we know it's a data
--	 * frame, so count MSDUs.
--	 */
--	u64_stats_update_begin(&stats->syncp);
--	stats->msdu[rx->seqno_idx]++;
--	stats->bytes += orig_len;
--	u64_stats_update_end(&stats->syncp);
--
--	if (fast_rx->internal_forward) {
--		struct sk_buff *xmit_skb = NULL;
--		if (is_multicast_ether_addr(addrs.da)) {
--			xmit_skb = skb_copy(skb, GFP_ATOMIC);
--		} else if (!ether_addr_equal(addrs.da, addrs.sa) &&
--			   sta_info_get(rx->sdata, addrs.da)) {
--			xmit_skb = skb;
--			skb = NULL;
--		}
--
--		if (xmit_skb) {
--			/*
--			 * Send to wireless media and increase priority by 256
--			 * to keep the received priority instead of
--			 * reclassifying the frame (see cfg80211_classify8021d).
--			 */
--			xmit_skb->priority += 256;
--			xmit_skb->protocol = htons(ETH_P_802_3);
--			skb_reset_network_header(xmit_skb);
--			skb_reset_mac_header(xmit_skb);
--			dev_queue_xmit(xmit_skb);
--		}
--
--		if (!skb)
--			return true;
--	}
--
--	/* deliver to local stack */
--	skb->protocol = eth_type_trans(skb, fast_rx->dev);
--	memset(skb->cb, 0, sizeof(skb->cb));
--	if (rx->list)
--#if LINUX_VERSION_IS_GEQ(4,19,0)
--		list_add_tail(&skb->list, rx->list);
--#else
--		__skb_queue_tail(rx->list, skb);
--#endif
--	else
--		netif_receive_skb(skb);
-+	ieee80211_rx_8023(rx, fast_rx, orig_len);
- 
- 	return true;
-  drop:
- 	dev_kfree_skb(skb);
-+	if (fast_rx->uses_rss)
-+		stats = this_cpu_ptr(sta->pcpu_rx_stats);
-+
- 	stats->dropped++;
- 	return true;
- }
-@@ -4614,6 +4646,47 @@ static bool ieee80211_prepare_and_rx_han
- 	return true;
- }
- 
-+static void __ieee80211_rx_handle_8023(struct ieee80211_hw *hw,
-+				       struct ieee80211_sta *pubsta,
-+				       struct sk_buff *skb,
-+#if LINUX_VERSION_IS_GEQ(4,19,0)
-+				       struct list_head *list)
-+#else
-+				       struct sk_buff_head *list)
-+#endif
-+{
-+	struct ieee80211_local *local = hw_to_local(hw);
-+	struct ieee80211_fast_rx *fast_rx;
-+	struct ieee80211_rx_data rx;
-+
-+	memset(&rx, 0, sizeof(rx));
-+	rx.skb = skb;
-+	rx.local = local;
-+	rx.list = list;
-+
-+	I802_DEBUG_INC(local->dot11ReceivedFragmentCount);
-+
-+	/* drop frame if too short for header */
-+	if (skb->len < sizeof(struct ethhdr))
-+		goto drop;
-+
-+	if (!pubsta)
-+		goto drop;
-+
-+	rx.sta = container_of(pubsta, struct sta_info, sta);
-+	rx.sdata = rx.sta->sdata;
-+
-+	fast_rx = rcu_dereference(rx.sta->fast_rx);
-+	if (!fast_rx)
-+		goto drop;
-+
-+	ieee80211_rx_8023(&rx, fast_rx, skb->len);
-+	return;
-+
-+drop:
-+	dev_kfree_skb(skb);
-+}
-+
- /*
-  * This is the actual Rx frames handler. as it belongs to Rx path it must
-  * be called with rcu_read_lock protection.
-@@ -4851,15 +4924,20 @@ void ieee80211_rx_list(struct ieee80211_
- 	 * if it was previously present.
- 	 * Also, frames with less than 16 bytes are dropped.
- 	 */
--	skb = ieee80211_rx_monitor(local, skb, rate);
--	if (!skb)
--		return;
-+	if (!(status->flag & RX_FLAG_8023)) {
-+		skb = ieee80211_rx_monitor(local, skb, rate);
-+		if (!skb)
-+			return;
-+	}
- 
- 	ieee80211_tpt_led_trig_rx(local,
- 			((struct ieee80211_hdr *)skb->data)->frame_control,
- 			skb->len);
- 
--	__ieee80211_rx_handle_packet(hw, pubsta, skb, list);
-+	if (status->flag & RX_FLAG_8023)
-+		__ieee80211_rx_handle_8023(hw, pubsta, skb, list);
-+	else
-+		__ieee80211_rx_handle_packet(hw, pubsta, skb, list);
- 
- 	return;
-  drop:
---- a/net/mac80211/sta_info.h
-+++ b/net/mac80211/sta_info.h
-@@ -71,6 +71,7 @@
-  *	until pending frames are delivered
-  * @WLAN_STA_USES_ENCRYPTION: This station was configured for encryption,
-  *	so drop all packets without a key later.
-+ * @WLAN_STA_DECAP_OFFLOAD: This station uses rx decap offload
-  *
-  * @NUM_WLAN_STA_FLAGS: number of defined flags
-  */
-@@ -102,6 +103,7 @@ enum ieee80211_sta_info_flags {
- 	WLAN_STA_MPSP_RECIPIENT,
- 	WLAN_STA_PS_DELIVER,
- 	WLAN_STA_USES_ENCRYPTION,
-+	WLAN_STA_DECAP_OFFLOAD,
- 
- 	NUM_WLAN_STA_FLAGS,
- };
---- a/net/mac80211/trace.h
-+++ b/net/mac80211/trace.h
-@@ -2761,7 +2761,7 @@ DEFINE_EVENT(local_sdata_addr_evt, drv_u
- 	TP_ARGS(local, sdata)
- );
- 
--TRACE_EVENT(drv_sta_set_4addr,
-+DECLARE_EVENT_CLASS(sta_flag_evt,
- 	TP_PROTO(struct ieee80211_local *local,
- 		 struct ieee80211_sub_if_data *sdata,
- 		 struct ieee80211_sta *sta, bool enabled),
-@@ -2788,6 +2788,22 @@ TRACE_EVENT(drv_sta_set_4addr,
- 	)
- );
- 
-+DEFINE_EVENT(sta_flag_evt, drv_sta_set_4addr,
-+	TP_PROTO(struct ieee80211_local *local,
-+		 struct ieee80211_sub_if_data *sdata,
-+		 struct ieee80211_sta *sta, bool enabled),
-+
-+	TP_ARGS(local, sdata, sta, enabled)
-+);
-+
-+DEFINE_EVENT(sta_flag_evt, drv_sta_set_decap_offload,
-+	TP_PROTO(struct ieee80211_local *local,
-+		 struct ieee80211_sub_if_data *sdata,
-+		 struct ieee80211_sta *sta, bool enabled),
-+
-+	TP_ARGS(local, sdata, sta, enabled)
-+);
-+
- #endif /* !__MAC80211_DRIVER_TRACE || TRACE_HEADER_MULTI_READ */
- 
- #undef TRACE_INCLUDE_PATH
diff --git a/package/kernel/mac80211/patches/subsys/316-cfg80211-fix-possible-NULL-pointer-dereference-in-cf.patch b/package/kernel/mac80211/patches/subsys/316-cfg80211-fix-possible-NULL-pointer-dereference-in-cf.patch
new file mode 100644
index 0000000000..362bb885d7
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/316-cfg80211-fix-possible-NULL-pointer-dereference-in-cf.patch
@@ -0,0 +1,99 @@
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Wed, 3 Nov 2021 18:02:35 +0100
+Subject: [PATCH] cfg80211: fix possible NULL pointer dereference in
+ cfg80211_stop_offchan_radar_detection
+
+Fix the following NULL pointer dereference in
+cfg80211_stop_offchan_radar_detection routine that occurs when hostapd
+is stopped during the CAC on offchannel chain:
+
+Sat Jan  1 0[  779.567851]   ESR = 0x96000005
+0:12:50 2000 dae[  779.572346]   EC = 0x25: DABT (current EL), IL = 32 bits
+mon.debug hostap[  779.578984]   SET = 0, FnV = 0
+d: hostapd_inter[  779.583445]   EA = 0, S1PTW = 0
+face_deinit_free[  779.587936] Data abort info:
+: num_bss=1 conf[  779.592224]   ISV = 0, ISS = 0x00000005
+->num_bss=1
+Sat[  779.597403]   CM = 0, WnR = 0
+ Jan  1 00:12:50[  779.601749] user pgtable: 4k pages, 39-bit VAs, pgdp=00000000418b2000
+ 2000 daemon.deb[  779.609601] [0000000000000000] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000
+ug hostapd: host[  779.619657] Internal error: Oops: 96000005 [#1] SMP
+[  779.770810] CPU: 0 PID: 2202 Comm: hostapd Not tainted 5.10.75 #0
+[  779.776892] Hardware name: MediaTek MT7622 RFB1 board (DT)
+[  779.782370] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO BTYPE=--)
+[  779.788384] pc : cfg80211_chandef_valid+0x10/0x490 [cfg80211]
+[  779.794128] lr : cfg80211_check_station_change+0x3190/0x3950 [cfg80211]
+[  779.800731] sp : ffffffc01204b7e0
+[  779.804036] x29: ffffffc01204b7e0 x28: ffffff80039bdc00
+[  779.809340] x27: 0000000000000000 x26: ffffffc008cb3050
+[  779.814644] x25: 0000000000000000 x24: 0000000000000002
+[  779.819948] x23: ffffff8002630000 x22: ffffff8003e748d0
+[  779.825252] x21: 0000000000000cc0 x20: ffffff8003da4a00
+[  779.830556] x19: 0000000000000000 x18: ffffff8001bf7ce0
+[  779.835860] x17: 00000000ffffffff x16: 0000000000000000
+[  779.841164] x15: 0000000040d59200 x14: 00000000000019c0
+[  779.846467] x13: 00000000000001c8 x12: 000636b9e9dab1c6
+[  779.851771] x11: 0000000000000141 x10: 0000000000000820
+[  779.857076] x9 : 0000000000000000 x8 : ffffff8003d7d038
+[  779.862380] x7 : 0000000000000000 x6 : ffffff8003d7d038
+[  779.867683] x5 : 0000000000000e90 x4 : 0000000000000038
+[  779.872987] x3 : 0000000000000002 x2 : 0000000000000004
+[  779.878291] x1 : 0000000000000000 x0 : 0000000000000000
+[  779.883594] Call trace:
+[  779.886039]  cfg80211_chandef_valid+0x10/0x490 [cfg80211]
+[  779.891434]  cfg80211_check_station_change+0x3190/0x3950 [cfg80211]
+[  779.897697]  nl80211_radar_notify+0x138/0x19c [cfg80211]
+[  779.903005]  cfg80211_stop_offchan_radar_detection+0x7c/0x8c [cfg80211]
+[  779.909616]  __cfg80211_leave+0x2c/0x190 [cfg80211]
+[  779.914490]  cfg80211_register_netdevice+0x1c0/0x6d0 [cfg80211]
+[  779.920404]  raw_notifier_call_chain+0x50/0x70
+[  779.924841]  call_netdevice_notifiers_info+0x54/0xa0
+[  779.929796]  __dev_close_many+0x40/0x100
+[  779.933712]  __dev_change_flags+0x98/0x190
+[  779.937800]  dev_change_flags+0x20/0x60
+[  779.941628]  devinet_ioctl+0x534/0x6d0
+[  779.945370]  inet_ioctl+0x1bc/0x230
+[  779.948849]  sock_do_ioctl+0x44/0x200
+[  779.952502]  sock_ioctl+0x268/0x4c0
+[  779.955985]  __arm64_sys_ioctl+0xac/0xd0
+[  779.959900]  el0_svc_common.constprop.0+0x60/0x110
+[  779.964682]  do_el0_svc+0x1c/0x24
+[  779.967990]  el0_svc+0x10/0x1c
+[  779.971036]  el0_sync_handler+0x9c/0x120
+[  779.974950]  el0_sync+0x148/0x180
+[  779.978259] Code: a9bc7bfd 910003fd a90153f3 aa0003f3 (f9400000)
+[  779.984344] ---[ end trace 0e67b4f5d6cdeec7 ]---
+[  779.996400] Kernel panic - not syncing: Oops: Fatal exception
+[  780.002139] SMP: stopping secondary CPUs
+[  780.006057] Kernel Offset: disabled
+[  780.009537] CPU features: 0x0000002,04002004
+[  780.013796] Memory Limit: none
+
+Fixes: b8f5facf286b ("cfg80211: implement APIs for dedicated radar detection HW")
+Reported-by: Evelyn Tsai <evelyn.tsai@mediatek.com>
+Tested-by: Evelyn Tsai <evelyn.tsai@mediatek.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Link: https://lore.kernel.org/r/c2e34c065bf8839c5ffa45498ae154021a72a520.1635958796.git.lorenzo@kernel.org
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/net/wireless/mlme.c
++++ b/net/wireless/mlme.c
+@@ -982,6 +982,9 @@ __cfg80211_offchan_cac_event(struct cfg8
+ 
+ 	lockdep_assert_wiphy(&rdev->wiphy);
+ 
++	if (!cfg80211_chandef_valid(chandef))
++		return;
++
+ 	if (event != NL80211_RADAR_CAC_STARTED && !rdev->offchan_radar_wdev)
+ 		return;
+ 
+@@ -1096,6 +1099,6 @@ void cfg80211_stop_offchan_radar_detecti
+ 
+ 	rdev_set_radar_offchan(rdev, NULL);
+ 
+-	__cfg80211_offchan_cac_event(rdev, NULL, NULL,
++	__cfg80211_offchan_cac_event(rdev, wdev, &rdev->offchan_radar_chandef,
+ 				     NL80211_RADAR_CAC_ABORTED);
+ }
diff --git a/package/kernel/mac80211/patches/subsys/316-mac80211-enable-QoS-support-for-nl80211-ctrl-port.patch b/package/kernel/mac80211/patches/subsys/316-mac80211-enable-QoS-support-for-nl80211-ctrl-port.patch
deleted file mode 100644
index 91987ed759..0000000000
--- a/package/kernel/mac80211/patches/subsys/316-mac80211-enable-QoS-support-for-nl80211-ctrl-port.patch
+++ /dev/null
@@ -1,116 +0,0 @@
-From: Markus Theil <markus.theil@tu-ilmenau.de>
-Date: Sat, 6 Feb 2021 12:51:12 +0100
-Subject: [PATCH] mac80211: enable QoS support for nl80211 ctrl port
-
-This patch unifies sending control port frames
-over nl80211 and AF_PACKET sockets a little more.
-
-Before this patch, EAPOL frames got QoS prioritization
-only when using AF_PACKET sockets.
-
-__ieee80211_select_queue only selects a QoS-enabled queue
-for control port frames, when the control port protocol
-is set correctly on the skb. For the AF_PACKET path this
-works, but the nl80211 path used ETH_P_802_3.
-
-Another check for injected frames in wme.c then prevented
-the QoS TID to be copied in the frame.
-
-In order to fix this, get rid of the frame injection marking
-for nl80211 ctrl port and set the correct ethernet protocol.
-
-Please note:
-An erlier version of this path tried to prevent
-frame aggregation for control port frames in order to speed up
-the initial connection setup a little. This seemed to cause
-issues on my older Intel dvm-based hardware, and was therefore
-removed again. Future commits which try to reintroduce this
-have to check carefully how hw behaves with aggregated and
-non-aggregated traffic for the same TID.
-My NIC: Intel(R) Centrino(R) Ultimate-N 6300 AGN, REV=0x74
-
-Reported-by: kernel test robot <lkp@intel.com>
-Signed-off-by: Markus Theil <markus.theil@tu-ilmenau.de>
-Link: https://lore.kernel.org/r/20210206115112.567881-1-markus.theil@tu-ilmenau.de
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/net/mac80211/status.c
-+++ b/net/mac80211/status.c
-@@ -628,16 +628,12 @@ static void ieee80211_report_ack_skb(str
- 		u64 cookie = IEEE80211_SKB_CB(skb)->ack.cookie;
- 		struct ieee80211_sub_if_data *sdata;
- 		struct ieee80211_hdr *hdr = (void *)skb->data;
--		__be16 ethertype = 0;
--
--		if (skb->len >= ETH_HLEN && skb->protocol == cpu_to_be16(ETH_P_802_3))
--			skb_copy_bits(skb, 2 * ETH_ALEN, &ethertype, ETH_TLEN);
- 
- 		rcu_read_lock();
- 		sdata = ieee80211_sdata_from_skb(local, skb);
- 		if (sdata) {
--			if (ethertype == sdata->control_port_protocol ||
--			    ethertype == cpu_to_be16(ETH_P_PREAUTH))
-+			if (skb->protocol == sdata->control_port_protocol ||
-+			    skb->protocol == cpu_to_be16(ETH_P_PREAUTH))
- 				cfg80211_control_port_tx_status(&sdata->wdev,
- 								cookie,
- 								skb->data,
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -1195,9 +1195,7 @@ ieee80211_tx_prepare(struct ieee80211_su
- 			tx->sta = rcu_dereference(sdata->u.vlan.sta);
- 			if (!tx->sta && sdata->wdev.use_4addr)
- 				return TX_DROP;
--		} else if (info->flags & (IEEE80211_TX_INTFL_NL80211_FRAME_TX |
--					  IEEE80211_TX_CTL_INJECTED) ||
--			   tx->sdata->control_port_protocol == tx->skb->protocol) {
-+		} else if (tx->sdata->control_port_protocol == tx->skb->protocol) {
- 			tx->sta = sta_info_get_bss(sdata, hdr->addr1);
- 		}
- 		if (!tx->sta && !is_multicast_ether_addr(hdr->addr1))
-@@ -5455,6 +5453,7 @@ int ieee80211_tx_control_port(struct wip
- {
- 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
- 	struct ieee80211_local *local = sdata->local;
-+	struct sta_info *sta;
- 	struct sk_buff *skb;
- 	struct ethhdr *ehdr;
- 	u32 ctrl_flags = 0;
-@@ -5477,8 +5476,7 @@ int ieee80211_tx_control_port(struct wip
- 	if (cookie)
- 		ctrl_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;
- 
--	flags |= IEEE80211_TX_INTFL_NL80211_FRAME_TX |
--		 IEEE80211_TX_CTL_INJECTED;
-+	flags |= IEEE80211_TX_INTFL_NL80211_FRAME_TX;
- 
- 	skb = dev_alloc_skb(local->hw.extra_tx_headroom +
- 			    sizeof(struct ethhdr) + len);
-@@ -5495,10 +5493,25 @@ int ieee80211_tx_control_port(struct wip
- 	ehdr->h_proto = proto;
- 
- 	skb->dev = dev;
--	skb->protocol = htons(ETH_P_802_3);
-+	skb->protocol = proto;
- 	skb_reset_network_header(skb);
- 	skb_reset_mac_header(skb);
- 
-+	/* update QoS header to prioritize control port frames if possible,
-+	 * priorization also happens for control port frames send over
-+	 * AF_PACKET
-+	 */
-+	rcu_read_lock();
-+
-+	if (ieee80211_lookup_ra_sta(sdata, skb, &sta) == 0 && !IS_ERR(sta)) {
-+		u16 queue = __ieee80211_select_queue(sdata, sta, skb);
-+
-+		skb_set_queue_mapping(skb, queue);
-+		skb_get_hash(skb);
-+	}
-+
-+	rcu_read_unlock();
-+
- 	/* mutex lock is only needed for incrementing the cookie counter */
- 	mutex_lock(&local->mtx);
- 
diff --git a/package/kernel/mac80211/patches/subsys/317-cfg80211-schedule-offchan_cac_abort_wk-in-cfg80211_r.patch b/package/kernel/mac80211/patches/subsys/317-cfg80211-schedule-offchan_cac_abort_wk-in-cfg80211_r.patch
new file mode 100644
index 0000000000..df7afefb34
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/317-cfg80211-schedule-offchan_cac_abort_wk-in-cfg80211_r.patch
@@ -0,0 +1,136 @@
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Tue, 16 Nov 2021 12:41:52 +0100
+Subject: [PATCH] cfg80211: schedule offchan_cac_abort_wk in
+ cfg80211_radar_event
+
+If necessary schedule offchan_cac_abort_wk work in cfg80211_radar_event
+routine adding offchan parameter to cfg80211_radar_event signature.
+Rename cfg80211_radar_event in __cfg80211_radar_event and introduce
+the two following inline helpers:
+- cfg80211_radar_event
+- cfg80211_offchan_radar_event
+Doing so the drv will not need to run cfg80211_offchan_cac_abort() after
+radar detection on the offchannel chain.
+
+Tested-by: Owen Peng <owen.peng@mediatek.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Link: https://lore.kernel.org/r/3ff583e021e3343a3ced54a7b09b5e184d1880dc.1637062727.git.lorenzo@kernel.org
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/cfg80211.h
++++ b/include/net/cfg80211.h
+@@ -7580,15 +7580,33 @@ void cfg80211_cqm_txe_notify(struct net_
+ void cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp);
+ 
+ /**
+- * cfg80211_radar_event - radar detection event
++ * __cfg80211_radar_event - radar detection event
+  * @wiphy: the wiphy
+  * @chandef: chandef for the current channel
++ * @offchan: the radar has been detected on the offchannel chain
+  * @gfp: context flags
+  *
+  * This function is called when a radar is detected on the current chanenl.
+  */
+-void cfg80211_radar_event(struct wiphy *wiphy,
+-			  struct cfg80211_chan_def *chandef, gfp_t gfp);
++void __cfg80211_radar_event(struct wiphy *wiphy,
++			    struct cfg80211_chan_def *chandef,
++			    bool offchan, gfp_t gfp);
++
++static inline void
++cfg80211_radar_event(struct wiphy *wiphy,
++		     struct cfg80211_chan_def *chandef,
++		     gfp_t gfp)
++{
++	__cfg80211_radar_event(wiphy, chandef, false, gfp);
++}
++
++static inline void
++cfg80211_offchan_radar_event(struct wiphy *wiphy,
++			     struct cfg80211_chan_def *chandef,
++			     gfp_t gfp)
++{
++	__cfg80211_radar_event(wiphy, chandef, true, gfp);
++}
+ 
+ /**
+  * cfg80211_sta_opmode_change_notify - STA's ht/vht operation mode change event
+--- a/net/wireless/mlme.c
++++ b/net/wireless/mlme.c
+@@ -905,13 +905,13 @@ void cfg80211_dfs_channels_update_work(s
+ }
+ 
+ 
+-void cfg80211_radar_event(struct wiphy *wiphy,
+-			  struct cfg80211_chan_def *chandef,
+-			  gfp_t gfp)
++void __cfg80211_radar_event(struct wiphy *wiphy,
++			    struct cfg80211_chan_def *chandef,
++			    bool offchan, gfp_t gfp)
+ {
+ 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+ 
+-	trace_cfg80211_radar_event(wiphy, chandef);
++	trace_cfg80211_radar_event(wiphy, chandef, offchan);
+ 
+ 	/* only set the chandef supplied channel to unavailable, in
+ 	 * case the radar is detected on only one of multiple channels
+@@ -919,6 +919,9 @@ void cfg80211_radar_event(struct wiphy *
+ 	 */
+ 	cfg80211_set_dfs_state(wiphy, chandef, NL80211_DFS_UNAVAILABLE);
+ 
++	if (offchan)
++		queue_work(cfg80211_wq, &rdev->offchan_cac_abort_wk);
++
+ 	cfg80211_sched_dfs_chan_update(rdev);
+ 
+ 	nl80211_radar_notify(rdev, chandef, NL80211_RADAR_DETECTED, NULL, gfp);
+@@ -926,7 +929,7 @@ void cfg80211_radar_event(struct wiphy *
+ 	memcpy(&rdev->radar_chandef, chandef, sizeof(struct cfg80211_chan_def));
+ 	queue_work(cfg80211_wq, &rdev->propagate_radar_detect_wk);
+ }
+-EXPORT_SYMBOL(cfg80211_radar_event);
++EXPORT_SYMBOL(__cfg80211_radar_event);
+ 
+ void cfg80211_cac_event(struct net_device *netdev,
+ 			const struct cfg80211_chan_def *chandef,
+@@ -998,7 +1001,8 @@ __cfg80211_offchan_cac_event(struct cfg8
+ 		rdev->offchan_radar_wdev = NULL;
+ 		break;
+ 	case NL80211_RADAR_CAC_ABORTED:
+-		cancel_delayed_work(&rdev->offchan_cac_done_wk);
++		if (!cancel_delayed_work(&rdev->offchan_cac_done_wk))
++			return;
+ 		wdev = rdev->offchan_radar_wdev;
+ 		rdev->offchan_radar_wdev = NULL;
+ 		break;
+--- a/net/wireless/trace.h
++++ b/net/wireless/trace.h
+@@ -3022,18 +3022,21 @@ TRACE_EVENT(cfg80211_ch_switch_started_n
+ );
+ 
+ TRACE_EVENT(cfg80211_radar_event,
+-	TP_PROTO(struct wiphy *wiphy, struct cfg80211_chan_def *chandef),
+-	TP_ARGS(wiphy, chandef),
++	TP_PROTO(struct wiphy *wiphy, struct cfg80211_chan_def *chandef,
++		 bool offchan),
++	TP_ARGS(wiphy, chandef, offchan),
+ 	TP_STRUCT__entry(
+ 		WIPHY_ENTRY
+ 		CHAN_DEF_ENTRY
++		__field(bool, offchan)
+ 	),
+ 	TP_fast_assign(
+ 		WIPHY_ASSIGN;
+ 		CHAN_DEF_ASSIGN(chandef);
++		__entry->offchan = offchan;
+ 	),
+-	TP_printk(WIPHY_PR_FMT ", " CHAN_DEF_PR_FMT,
+-		  WIPHY_PR_ARG, CHAN_DEF_PR_ARG)
++	TP_printk(WIPHY_PR_FMT ", " CHAN_DEF_PR_FMT ", offchan %d",
++		  WIPHY_PR_ARG, CHAN_DEF_PR_ARG, __entry->offchan)
+ );
+ 
+ TRACE_EVENT(cfg80211_cac_event,
diff --git a/package/kernel/mac80211/patches/subsys/318-cfg80211-allow-continuous-radar-monitoring-on-offcha.patch b/package/kernel/mac80211/patches/subsys/318-cfg80211-allow-continuous-radar-monitoring-on-offcha.patch
new file mode 100644
index 0000000000..a1b6e3c80d
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/318-cfg80211-allow-continuous-radar-monitoring-on-offcha.patch
@@ -0,0 +1,220 @@
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Tue, 16 Nov 2021 15:03:36 +0100
+Subject: [PATCH] cfg80211: allow continuous radar monitoring on offchannel
+ chain
+
+Allow continuous radar detection on the offchannel chain in order
+to switch to the monitored channel whenever the underlying driver
+reports a radar pattern on the main channel.
+
+Tested-by: Owen Peng <owen.peng@mediatek.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Link: https://lore.kernel.org/r/d46217310a49b14ff0e9c002f0a6e0547d70fd2c.1637071350.git.lorenzo@kernel.org
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/net/wireless/chan.c
++++ b/net/wireless/chan.c
+@@ -712,6 +712,19 @@ static bool cfg80211_is_wiphy_oper_chan(
+ 	return false;
+ }
+ 
++static bool
++cfg80211_offchan_chain_is_active(struct cfg80211_registered_device *rdev,
++				 struct ieee80211_channel *channel)
++{
++	if (!rdev->offchan_radar_wdev)
++		return false;
++
++	if (!cfg80211_chandef_valid(&rdev->offchan_radar_chandef))
++		return false;
++
++	return cfg80211_is_sub_chan(&rdev->offchan_radar_chandef, channel);
++}
++
+ bool cfg80211_any_wiphy_oper_chan(struct wiphy *wiphy,
+ 				  struct ieee80211_channel *chan)
+ {
+@@ -728,6 +741,9 @@ bool cfg80211_any_wiphy_oper_chan(struct
+ 
+ 		if (cfg80211_is_wiphy_oper_chan(&rdev->wiphy, chan))
+ 			return true;
++
++		if (cfg80211_offchan_chain_is_active(rdev, chan))
++			return true;
+ 	}
+ 
+ 	return false;
+--- a/net/wireless/mlme.c
++++ b/net/wireless/mlme.c
+@@ -988,7 +988,7 @@ __cfg80211_offchan_cac_event(struct cfg8
+ 	if (!cfg80211_chandef_valid(chandef))
+ 		return;
+ 
+-	if (event != NL80211_RADAR_CAC_STARTED && !rdev->offchan_radar_wdev)
++	if (!rdev->offchan_radar_wdev)
+ 		return;
+ 
+ 	switch (event) {
+@@ -998,17 +998,13 @@ __cfg80211_offchan_cac_event(struct cfg8
+ 		queue_work(cfg80211_wq, &rdev->propagate_cac_done_wk);
+ 		cfg80211_sched_dfs_chan_update(rdev);
+ 		wdev = rdev->offchan_radar_wdev;
+-		rdev->offchan_radar_wdev = NULL;
+ 		break;
+ 	case NL80211_RADAR_CAC_ABORTED:
+ 		if (!cancel_delayed_work(&rdev->offchan_cac_done_wk))
+ 			return;
+ 		wdev = rdev->offchan_radar_wdev;
+-		rdev->offchan_radar_wdev = NULL;
+ 		break;
+ 	case NL80211_RADAR_CAC_STARTED:
+-		WARN_ON(!wdev);
+-		rdev->offchan_radar_wdev = wdev;
+ 		break;
+ 	default:
+ 		return;
+@@ -1024,7 +1020,8 @@ cfg80211_offchan_cac_event(struct cfg802
+ 			   enum nl80211_radar_event event)
+ {
+ 	wiphy_lock(&rdev->wiphy);
+-	__cfg80211_offchan_cac_event(rdev, NULL, chandef, event);
++	__cfg80211_offchan_cac_event(rdev, rdev->offchan_radar_wdev,
++				     chandef, event);
+ 	wiphy_unlock(&rdev->wiphy);
+ }
+ 
+@@ -1071,7 +1068,13 @@ cfg80211_start_offchan_radar_detection(s
+ 				     NL80211_EXT_FEATURE_RADAR_OFFCHAN))
+ 		return -EOPNOTSUPP;
+ 
+-	if (rdev->offchan_radar_wdev)
++	/* Offchannel chain already locked by another wdev */
++	if (rdev->offchan_radar_wdev && rdev->offchan_radar_wdev != wdev)
++		return -EBUSY;
++
++	/* CAC already in progress on the offchannel chain */
++	if (rdev->offchan_radar_wdev == wdev &&
++	    delayed_work_pending(&rdev->offchan_cac_done_wk))
+ 		return -EBUSY;
+ 
+ 	err = rdev_set_radar_offchan(rdev, chandef);
+@@ -1083,6 +1086,8 @@ cfg80211_start_offchan_radar_detection(s
+ 		cac_time_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;
+ 
+ 	rdev->offchan_radar_chandef = *chandef;
++	rdev->offchan_radar_wdev = wdev; /* Get offchain ownership */
++
+ 	__cfg80211_offchan_cac_event(rdev, wdev, chandef,
+ 				     NL80211_RADAR_CAC_STARTED);
+ 	queue_delayed_work(cfg80211_wq, &rdev->offchan_cac_done_wk,
+@@ -1102,6 +1107,7 @@ void cfg80211_stop_offchan_radar_detecti
+ 		return;
+ 
+ 	rdev_set_radar_offchan(rdev, NULL);
++	rdev->offchan_radar_wdev = NULL; /* Release offchain ownership */
+ 
+ 	__cfg80211_offchan_cac_event(rdev, wdev, &rdev->offchan_radar_chandef,
+ 				     NL80211_RADAR_CAC_ABORTED);
+--- a/net/wireless/nl80211.c
++++ b/net/wireless/nl80211.c
+@@ -9278,42 +9278,60 @@ static int nl80211_start_radar_detection
+ 	struct cfg80211_chan_def chandef;
+ 	enum nl80211_dfs_regions dfs_region;
+ 	unsigned int cac_time_ms;
+-	int err;
++	int err = -EINVAL;
++
++	flush_delayed_work(&rdev->dfs_update_channels_wk);
++
++	wiphy_lock(wiphy);
+ 
+ 	dfs_region = reg_get_dfs_region(wiphy);
+ 	if (dfs_region == NL80211_DFS_UNSET)
+-		return -EINVAL;
++		goto unlock;
+ 
+ 	err = nl80211_parse_chandef(rdev, info, &chandef);
+ 	if (err)
+-		return err;
++		goto unlock;
+ 
+ 	err = cfg80211_chandef_dfs_required(wiphy, &chandef, wdev->iftype);
+ 	if (err < 0)
+-		return err;
++		goto unlock;
+ 
+-	if (err == 0)
+-		return -EINVAL;
++	if (err == 0) {
++		err = -EINVAL;
++		goto unlock;
++	}
+ 
+-	if (!cfg80211_chandef_dfs_usable(wiphy, &chandef))
+-		return -EINVAL;
++	if (!cfg80211_chandef_dfs_usable(wiphy, &chandef)) {
++		err = -EINVAL;
++		goto unlock;
++	}
+ 
+-	if (nla_get_flag(info->attrs[NL80211_ATTR_RADAR_OFFCHAN]))
+-		return cfg80211_start_offchan_radar_detection(rdev, wdev,
+-							      &chandef);
++	if (nla_get_flag(info->attrs[NL80211_ATTR_RADAR_OFFCHAN])) {
++		err = cfg80211_start_offchan_radar_detection(rdev, wdev,
++							     &chandef);
++		goto unlock;
++	}
+ 
+-	if (netif_carrier_ok(dev))
+-		return -EBUSY;
++	if (netif_carrier_ok(dev)) {
++		err = -EBUSY;
++		goto unlock;
++	}
+ 
+-	if (wdev->cac_started)
+-		return -EBUSY;
++	if (wdev->cac_started) {
++		err = -EBUSY;
++		goto unlock;
++	}
+ 
+ 	/* CAC start is offloaded to HW and can't be started manually */
+-	if (wiphy_ext_feature_isset(wiphy, NL80211_EXT_FEATURE_DFS_OFFLOAD))
+-		return -EOPNOTSUPP;
++	if (wiphy_ext_feature_isset(wiphy, NL80211_EXT_FEATURE_DFS_OFFLOAD)) {
++		err = -EOPNOTSUPP;
++		goto unlock;
++	}
+ 
+-	if (!rdev->ops->start_radar_detection)
+-		return -EOPNOTSUPP;
++	if (!rdev->ops->start_radar_detection) {
++		err = -EOPNOTSUPP;
++		goto unlock;
++	}
+ 
+ 	cac_time_ms = cfg80211_chandef_dfs_cac_time(&rdev->wiphy, &chandef);
+ 	if (WARN_ON(!cac_time_ms))
+@@ -9326,6 +9344,9 @@ static int nl80211_start_radar_detection
+ 		wdev->cac_start_time = jiffies;
+ 		wdev->cac_time_ms = cac_time_ms;
+ 	}
++unlock:
++	wiphy_unlock(wiphy);
++
+ 	return err;
+ }
+ 
+@@ -15961,7 +15982,8 @@ static const struct genl_small_ops nl802
+ 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
+ 		.doit = nl80211_start_radar_detection,
+ 		.flags = GENL_UNS_ADMIN_PERM,
+-		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,
++		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
++				  NL80211_FLAG_NO_WIPHY_MTX,
+ 	},
+ 	{
+ 		.cmd = NL80211_CMD_GET_PROTOCOL_FEATURES,
diff --git a/package/kernel/mac80211/patches/subsys/319-mac80211-introduce-set_radar_offchan-callback.patch b/package/kernel/mac80211/patches/subsys/319-mac80211-introduce-set_radar_offchan-callback.patch
new file mode 100644
index 0000000000..eb80afbccb
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/319-mac80211-introduce-set_radar_offchan-callback.patch
@@ -0,0 +1,67 @@
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Sat, 23 Oct 2021 11:10:51 +0200
+Subject: [PATCH] mac80211: introduce set_radar_offchan callback
+
+Similar to cfg80211, introduce set_radar_offchan callback in mac80211_ops
+in order to configure a dedicated offchannel chain available on some hw
+(e.g. mt7915) to perform offchannel CAC detection and avoid tx/rx downtime.
+
+Tested-by: Evelyn Tsai <evelyn.tsai@mediatek.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Link: https://lore.kernel.org/r/201110606d4f3a7dfdf31440e351f2e2c375d4f0.1634979655.git.lorenzo@kernel.org
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -3937,6 +3937,14 @@ struct ieee80211_prep_tx_info {
+  *	twt structure.
+  * @twt_teardown_request: Update the hw with TWT teardown request received
+  *	from the peer.
++ * @set_radar_offchan: Configure dedicated offchannel chain available for
++ *	radar/CAC detection on some hw. This chain can't be used to transmit
++ *	or receive frames and it is bounded to a running wdev.
++ *	Offchannel radar/CAC detection allows to avoid the CAC downtime
++ *	switching to a different channel during CAC detection on the selected
++ *	radar channel.
++ *	The caller is expected to set chandef pointer to NULL in order to
++ *	disable offchannel CAC/radar detection.
+  * @net_fill_forward_path: Called from .ndo_fill_forward_path in order to
+  *	resolve a path for hardware flow offloading
+  */
+@@ -4267,6 +4275,8 @@ struct ieee80211_ops {
+ 			      struct ieee80211_twt_setup *twt);
+ 	void (*twt_teardown_request)(struct ieee80211_hw *hw,
+ 				     struct ieee80211_sta *sta, u8 flowid);
++	int (*set_radar_offchan)(struct ieee80211_hw *hw,
++				 struct cfg80211_chan_def *chandef);
+ #if LINUX_VERSION_IS_GEQ(5,10,0)
+ 	int (*net_fill_forward_path)(struct ieee80211_hw *hw,
+ 				     struct ieee80211_vif *vif,
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -4344,6 +4344,18 @@ out:
+ 	return err;
+ }
+ 
++static int
++ieee80211_set_radar_offchan(struct wiphy *wiphy,
++			    struct cfg80211_chan_def *chandef)
++{
++	struct ieee80211_local *local = wiphy_priv(wiphy);
++
++	if (!local->ops->set_radar_offchan)
++		return -EOPNOTSUPP;
++
++	return local->ops->set_radar_offchan(&local->hw, chandef);
++}
++
+ const struct cfg80211_ops mac80211_config_ops = {
+ 	.add_virtual_intf = ieee80211_add_iface,
+ 	.del_virtual_intf = ieee80211_del_iface,
+@@ -4448,4 +4460,5 @@ const struct cfg80211_ops mac80211_confi
+ 	.reset_tid_config = ieee80211_reset_tid_config,
+ 	.set_sar_specs = ieee80211_set_sar_specs,
+ 	.color_change = ieee80211_color_change,
++	.set_radar_offchan = ieee80211_set_radar_offchan,
+ };
diff --git a/package/kernel/mac80211/patches/subsys/320-cfg80211-rename-offchannel_chain-structs-to-backgrou.patch b/package/kernel/mac80211/patches/subsys/320-cfg80211-rename-offchannel_chain-structs-to-backgrou.patch
new file mode 100644
index 0000000000..483b87cd88
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/320-cfg80211-rename-offchannel_chain-structs-to-backgrou.patch
@@ -0,0 +1,532 @@
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Mon, 29 Nov 2021 14:11:24 +0100
+Subject: [PATCH] cfg80211: rename offchannel_chain structs to background_chain
+ to avoid confusion with ETSI standard
+
+ETSI standard defines "Offchannel CAC" as:
+"Off-Channel CAC is performed by a number of non-continuous checks
+spread over a period in time. This period, which is required to
+determine the presence of radar signals, is defined as the Off-Channel
+CAC Time..
+Minimum Off-Channel CAC Time 6 minutes and Maximum Off-Channel CAC Time
+4 hours..".
+mac80211 implementation refers to a dedicated hw chain used for continuous
+radar monitoring. Rename offchannel_* references to background_* in
+order to avoid confusion with ETSI standard.
+
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Link: https://lore.kernel.org/r/4204cc1d648d76b44557981713231e030a3bd991.1638190762.git.lorenzo@kernel.org
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/cfg80211.h
++++ b/include/net/cfg80211.h
+@@ -4058,14 +4058,14 @@ struct mgmt_frame_regs {
+  *
+  * @color_change: Initiate a color change.
+  *
+- * @set_radar_offchan: Configure dedicated offchannel chain available for
++ * @set_radar_background: Configure dedicated offchannel chain available for
+  *	radar/CAC detection on some hw. This chain can't be used to transmit
+  *	or receive frames and it is bounded to a running wdev.
+- *	Offchannel radar/CAC detection allows to avoid the CAC downtime
++ *	Background radar/CAC detection allows to avoid the CAC downtime
+  *	switching to a different channel during CAC detection on the selected
+  *	radar channel.
+  *	The caller is expected to set chandef pointer to NULL in order to
+- *	disable offchannel CAC/radar detection.
++ *	disable background CAC/radar detection.
+  */
+ struct cfg80211_ops {
+ 	int	(*suspend)(struct wiphy *wiphy, struct cfg80211_wowlan *wow);
+@@ -4396,8 +4396,8 @@ struct cfg80211_ops {
+ 	int	(*color_change)(struct wiphy *wiphy,
+ 				struct net_device *dev,
+ 				struct cfg80211_color_change_settings *params);
+-	int	(*set_radar_offchan)(struct wiphy *wiphy,
+-				     struct cfg80211_chan_def *chandef);
++	int	(*set_radar_background)(struct wiphy *wiphy,
++					struct cfg80211_chan_def *chandef);
+ };
+ 
+ /*
+@@ -7601,9 +7601,9 @@ cfg80211_radar_event(struct wiphy *wiphy
+ }
+ 
+ static inline void
+-cfg80211_offchan_radar_event(struct wiphy *wiphy,
+-			     struct cfg80211_chan_def *chandef,
+-			     gfp_t gfp)
++cfg80211_background_radar_event(struct wiphy *wiphy,
++				struct cfg80211_chan_def *chandef,
++				gfp_t gfp)
+ {
+ 	__cfg80211_radar_event(wiphy, chandef, true, gfp);
+ }
+@@ -7638,13 +7638,13 @@ void cfg80211_cac_event(struct net_devic
+ 			enum nl80211_radar_event event, gfp_t gfp);
+ 
+ /**
+- * cfg80211_offchan_cac_abort - Channel Availability Check offchan abort event
++ * cfg80211_background_cac_abort - Channel Availability Check offchan abort event
+  * @wiphy: the wiphy
+  *
+  * This function is called by the driver when a Channel Availability Check
+  * (CAC) is aborted by a offchannel dedicated chain.
+  */
+-void cfg80211_offchan_cac_abort(struct wiphy *wiphy);
++void cfg80211_background_cac_abort(struct wiphy *wiphy);
+ 
+ /**
+  * cfg80211_gtk_rekey_notify - notify userspace about driver rekeying
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -3937,14 +3937,14 @@ struct ieee80211_prep_tx_info {
+  *	twt structure.
+  * @twt_teardown_request: Update the hw with TWT teardown request received
+  *	from the peer.
+- * @set_radar_offchan: Configure dedicated offchannel chain available for
++ * @set_radar_background: Configure dedicated offchannel chain available for
+  *	radar/CAC detection on some hw. This chain can't be used to transmit
+  *	or receive frames and it is bounded to a running wdev.
+- *	Offchannel radar/CAC detection allows to avoid the CAC downtime
++ *	Background radar/CAC detection allows to avoid the CAC downtime
+  *	switching to a different channel during CAC detection on the selected
+  *	radar channel.
+  *	The caller is expected to set chandef pointer to NULL in order to
+- *	disable offchannel CAC/radar detection.
++ *	disable background CAC/radar detection.
+  * @net_fill_forward_path: Called from .ndo_fill_forward_path in order to
+  *	resolve a path for hardware flow offloading
+  */
+@@ -4275,8 +4275,8 @@ struct ieee80211_ops {
+ 			      struct ieee80211_twt_setup *twt);
+ 	void (*twt_teardown_request)(struct ieee80211_hw *hw,
+ 				     struct ieee80211_sta *sta, u8 flowid);
+-	int (*set_radar_offchan)(struct ieee80211_hw *hw,
+-				 struct cfg80211_chan_def *chandef);
++	int (*set_radar_background)(struct ieee80211_hw *hw,
++				    struct cfg80211_chan_def *chandef);
+ #if LINUX_VERSION_IS_GEQ(5,10,0)
+ 	int (*net_fill_forward_path)(struct ieee80211_hw *hw,
+ 				     struct ieee80211_vif *vif,
+--- a/include/uapi/linux/nl80211.h
++++ b/include/uapi/linux/nl80211.h
+@@ -2608,10 +2608,10 @@ enum nl80211_commands {
+  *	Mandatory parameter for the transmitting interface to enable MBSSID.
+  *	Optional for the non-transmitting interfaces.
+  *
+- * @NL80211_ATTR_RADAR_OFFCHAN: Configure dedicated offchannel chain available for
+- *	radar/CAC detection on some hw. This chain can't be used to transmit
+- *	or receive frames and it is bounded to a running wdev.
+- *	Offchannel radar/CAC detection allows to avoid the CAC downtime
++ * @NL80211_ATTR_RADAR_BACKGROUND: Configure dedicated offchannel chain
++ *	available for radar/CAC detection on some hw. This chain can't be used
++ *	to transmit or receive frames and it is bounded to a running wdev.
++ *	Background radar/CAC detection allows to avoid the CAC downtime
+  *	switching on a different channel during CAC detection on the selected
+  *	radar channel.
+  *
+@@ -3121,7 +3121,7 @@ enum nl80211_attrs {
+ 	NL80211_ATTR_MBSSID_CONFIG,
+ 	NL80211_ATTR_MBSSID_ELEMS,
+ 
+-	NL80211_ATTR_RADAR_OFFCHAN,
++	NL80211_ATTR_RADAR_BACKGROUND,
+ 
+ 	/* add attributes here, update the policy in nl80211.c */
+ 
+@@ -6022,7 +6022,7 @@ enum nl80211_feature_flags {
+  * @NL80211_EXT_FEATURE_BSS_COLOR: The driver supports BSS color collision
+  *	detection and change announcemnts.
+  *
+- * @NL80211_EXT_FEATURE_RADAR_OFFCHAN: Device supports offchannel radar/CAC
++ * @NL80211_EXT_FEATURE_RADAR_BACKGROUND: Device supports background radar/CAC
+  *	detection.
+  *
+  * @NUM_NL80211_EXT_FEATURES: number of extended features.
+@@ -6090,7 +6090,7 @@ enum nl80211_ext_feature_index {
+ 	NL80211_EXT_FEATURE_SECURE_RTT,
+ 	NL80211_EXT_FEATURE_PROT_RANGE_NEGO_AND_MEASURE,
+ 	NL80211_EXT_FEATURE_BSS_COLOR,
+-	NL80211_EXT_FEATURE_RADAR_OFFCHAN,
++	NL80211_EXT_FEATURE_RADAR_BACKGROUND,
+ 
+ 	/* add new features before the definition below */
+ 	NUM_NL80211_EXT_FEATURES,
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -4345,15 +4345,15 @@ out:
+ }
+ 
+ static int
+-ieee80211_set_radar_offchan(struct wiphy *wiphy,
+-			    struct cfg80211_chan_def *chandef)
++ieee80211_set_radar_background(struct wiphy *wiphy,
++			       struct cfg80211_chan_def *chandef)
+ {
+ 	struct ieee80211_local *local = wiphy_priv(wiphy);
+ 
+-	if (!local->ops->set_radar_offchan)
++	if (!local->ops->set_radar_background)
+ 		return -EOPNOTSUPP;
+ 
+-	return local->ops->set_radar_offchan(&local->hw, chandef);
++	return local->ops->set_radar_background(&local->hw, chandef);
+ }
+ 
+ const struct cfg80211_ops mac80211_config_ops = {
+@@ -4460,5 +4460,5 @@ const struct cfg80211_ops mac80211_confi
+ 	.reset_tid_config = ieee80211_reset_tid_config,
+ 	.set_sar_specs = ieee80211_set_sar_specs,
+ 	.color_change = ieee80211_color_change,
+-	.set_radar_offchan = ieee80211_set_radar_offchan,
++	.set_radar_background = ieee80211_set_radar_background,
+ };
+--- a/net/wireless/chan.c
++++ b/net/wireless/chan.c
+@@ -716,13 +716,13 @@ static bool
+ cfg80211_offchan_chain_is_active(struct cfg80211_registered_device *rdev,
+ 				 struct ieee80211_channel *channel)
+ {
+-	if (!rdev->offchan_radar_wdev)
++	if (!rdev->background_radar_wdev)
+ 		return false;
+ 
+-	if (!cfg80211_chandef_valid(&rdev->offchan_radar_chandef))
++	if (!cfg80211_chandef_valid(&rdev->background_radar_chandef))
+ 		return false;
+ 
+-	return cfg80211_is_sub_chan(&rdev->offchan_radar_chandef, channel);
++	return cfg80211_is_sub_chan(&rdev->background_radar_chandef, channel);
+ }
+ 
+ bool cfg80211_any_wiphy_oper_chan(struct wiphy *wiphy,
+--- a/net/wireless/core.c
++++ b/net/wireless/core.c
+@@ -543,9 +543,10 @@ use_default_name:
+ 	INIT_WORK(&rdev->rfkill_block, cfg80211_rfkill_block_work);
+ 	INIT_WORK(&rdev->conn_work, cfg80211_conn_work);
+ 	INIT_WORK(&rdev->event_work, cfg80211_event_work);
+-	INIT_WORK(&rdev->offchan_cac_abort_wk, cfg80211_offchan_cac_abort_wk);
+-	INIT_DELAYED_WORK(&rdev->offchan_cac_done_wk,
+-			  cfg80211_offchan_cac_done_wk);
++	INIT_WORK(&rdev->background_cac_abort_wk,
++		  cfg80211_background_cac_abort_wk);
++	INIT_DELAYED_WORK(&rdev->background_cac_done_wk,
++			  cfg80211_background_cac_done_wk);
+ 
+ 	init_waitqueue_head(&rdev->dev_wait);
+ 
+@@ -1055,13 +1056,13 @@ void wiphy_unregister(struct wiphy *wiph
+ 	cancel_work_sync(&rdev->conn_work);
+ 	flush_work(&rdev->event_work);
+ 	cancel_delayed_work_sync(&rdev->dfs_update_channels_wk);
+-	cancel_delayed_work_sync(&rdev->offchan_cac_done_wk);
++	cancel_delayed_work_sync(&rdev->background_cac_done_wk);
+ 	flush_work(&rdev->destroy_work);
+ 	flush_work(&rdev->sched_scan_stop_wk);
+ 	flush_work(&rdev->propagate_radar_detect_wk);
+ 	flush_work(&rdev->propagate_cac_done_wk);
+ 	flush_work(&rdev->mgmt_registrations_update_wk);
+-	flush_work(&rdev->offchan_cac_abort_wk);
++	flush_work(&rdev->background_cac_abort_wk);
+ 
+ #ifdef CONFIG_PM
+ 	if (rdev->wiphy.wowlan_config && rdev->ops->set_wakeup)
+@@ -1210,7 +1211,7 @@ void __cfg80211_leave(struct cfg80211_re
+ 
+ 	cfg80211_pmsr_wdev_down(wdev);
+ 
+-	cfg80211_stop_offchan_radar_detection(wdev);
++	cfg80211_stop_background_radar_detection(wdev);
+ 
+ 	switch (wdev->iftype) {
+ 	case NL80211_IFTYPE_ADHOC:
+--- a/net/wireless/core.h
++++ b/net/wireless/core.h
+@@ -84,10 +84,10 @@ struct cfg80211_registered_device {
+ 
+ 	struct delayed_work dfs_update_channels_wk;
+ 
+-	struct wireless_dev *offchan_radar_wdev;
+-	struct cfg80211_chan_def offchan_radar_chandef;
+-	struct delayed_work offchan_cac_done_wk;
+-	struct work_struct offchan_cac_abort_wk;
++	struct wireless_dev *background_radar_wdev;
++	struct cfg80211_chan_def background_radar_chandef;
++	struct delayed_work background_cac_done_wk;
++	struct work_struct background_cac_abort_wk;
+ 
+ 	/* netlink port which started critical protocol (0 means not started) */
+ 	u32 crit_proto_nlportid;
+@@ -497,15 +497,15 @@ cfg80211_chandef_dfs_cac_time(struct wip
+ void cfg80211_sched_dfs_chan_update(struct cfg80211_registered_device *rdev);
+ 
+ int
+-cfg80211_start_offchan_radar_detection(struct cfg80211_registered_device *rdev,
+-				       struct wireless_dev *wdev,
+-				       struct cfg80211_chan_def *chandef);
++cfg80211_start_background_radar_detection(struct cfg80211_registered_device *rdev,
++					  struct wireless_dev *wdev,
++					  struct cfg80211_chan_def *chandef);
+ 
+-void cfg80211_stop_offchan_radar_detection(struct wireless_dev *wdev);
++void cfg80211_stop_background_radar_detection(struct wireless_dev *wdev);
+ 
+-void cfg80211_offchan_cac_done_wk(struct work_struct *work);
++void cfg80211_background_cac_done_wk(struct work_struct *work);
+ 
+-void cfg80211_offchan_cac_abort_wk(struct work_struct *work);
++void cfg80211_background_cac_abort_wk(struct work_struct *work);
+ 
+ bool cfg80211_any_wiphy_oper_chan(struct wiphy *wiphy,
+ 				  struct ieee80211_channel *chan);
+--- a/net/wireless/mlme.c
++++ b/net/wireless/mlme.c
+@@ -920,7 +920,7 @@ void __cfg80211_radar_event(struct wiphy
+ 	cfg80211_set_dfs_state(wiphy, chandef, NL80211_DFS_UNAVAILABLE);
+ 
+ 	if (offchan)
+-		queue_work(cfg80211_wq, &rdev->offchan_cac_abort_wk);
++		queue_work(cfg80211_wq, &rdev->background_cac_abort_wk);
+ 
+ 	cfg80211_sched_dfs_chan_update(rdev);
+ 
+@@ -975,10 +975,10 @@ void cfg80211_cac_event(struct net_devic
+ EXPORT_SYMBOL(cfg80211_cac_event);
+ 
+ static void
+-__cfg80211_offchan_cac_event(struct cfg80211_registered_device *rdev,
+-			     struct wireless_dev *wdev,
+-			     const struct cfg80211_chan_def *chandef,
+-			     enum nl80211_radar_event event)
++__cfg80211_background_cac_event(struct cfg80211_registered_device *rdev,
++				struct wireless_dev *wdev,
++				const struct cfg80211_chan_def *chandef,
++				enum nl80211_radar_event event)
+ {
+ 	struct wiphy *wiphy = &rdev->wiphy;
+ 	struct net_device *netdev;
+@@ -988,7 +988,7 @@ __cfg80211_offchan_cac_event(struct cfg8
+ 	if (!cfg80211_chandef_valid(chandef))
+ 		return;
+ 
+-	if (!rdev->offchan_radar_wdev)
++	if (!rdev->background_radar_wdev)
+ 		return;
+ 
+ 	switch (event) {
+@@ -997,12 +997,12 @@ __cfg80211_offchan_cac_event(struct cfg8
+ 		memcpy(&rdev->cac_done_chandef, chandef, sizeof(*chandef));
+ 		queue_work(cfg80211_wq, &rdev->propagate_cac_done_wk);
+ 		cfg80211_sched_dfs_chan_update(rdev);
+-		wdev = rdev->offchan_radar_wdev;
++		wdev = rdev->background_radar_wdev;
+ 		break;
+ 	case NL80211_RADAR_CAC_ABORTED:
+-		if (!cancel_delayed_work(&rdev->offchan_cac_done_wk))
++		if (!cancel_delayed_work(&rdev->background_cac_done_wk))
+ 			return;
+-		wdev = rdev->offchan_radar_wdev;
++		wdev = rdev->background_radar_wdev;
+ 		break;
+ 	case NL80211_RADAR_CAC_STARTED:
+ 		break;
+@@ -1015,49 +1015,49 @@ __cfg80211_offchan_cac_event(struct cfg8
+ }
+ 
+ static void
+-cfg80211_offchan_cac_event(struct cfg80211_registered_device *rdev,
+-			   const struct cfg80211_chan_def *chandef,
+-			   enum nl80211_radar_event event)
++cfg80211_background_cac_event(struct cfg80211_registered_device *rdev,
++			      const struct cfg80211_chan_def *chandef,
++			      enum nl80211_radar_event event)
+ {
+ 	wiphy_lock(&rdev->wiphy);
+-	__cfg80211_offchan_cac_event(rdev, rdev->offchan_radar_wdev,
+-				     chandef, event);
++	__cfg80211_background_cac_event(rdev, rdev->background_radar_wdev,
++					chandef, event);
+ 	wiphy_unlock(&rdev->wiphy);
+ }
+ 
+-void cfg80211_offchan_cac_done_wk(struct work_struct *work)
++void cfg80211_background_cac_done_wk(struct work_struct *work)
+ {
+ 	struct delayed_work *delayed_work = to_delayed_work(work);
+ 	struct cfg80211_registered_device *rdev;
+ 
+ 	rdev = container_of(delayed_work, struct cfg80211_registered_device,
+-			    offchan_cac_done_wk);
+-	cfg80211_offchan_cac_event(rdev, &rdev->offchan_radar_chandef,
+-				   NL80211_RADAR_CAC_FINISHED);
++			    background_cac_done_wk);
++	cfg80211_background_cac_event(rdev, &rdev->background_radar_chandef,
++				      NL80211_RADAR_CAC_FINISHED);
+ }
+ 
+-void cfg80211_offchan_cac_abort_wk(struct work_struct *work)
++void cfg80211_background_cac_abort_wk(struct work_struct *work)
+ {
+ 	struct cfg80211_registered_device *rdev;
+ 
+ 	rdev = container_of(work, struct cfg80211_registered_device,
+-			    offchan_cac_abort_wk);
+-	cfg80211_offchan_cac_event(rdev, &rdev->offchan_radar_chandef,
+-				   NL80211_RADAR_CAC_ABORTED);
++			    background_cac_abort_wk);
++	cfg80211_background_cac_event(rdev, &rdev->background_radar_chandef,
++				      NL80211_RADAR_CAC_ABORTED);
+ }
+ 
+-void cfg80211_offchan_cac_abort(struct wiphy *wiphy)
++void cfg80211_background_cac_abort(struct wiphy *wiphy)
+ {
+ 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+ 
+-	queue_work(cfg80211_wq, &rdev->offchan_cac_abort_wk);
++	queue_work(cfg80211_wq, &rdev->background_cac_abort_wk);
+ }
+-EXPORT_SYMBOL(cfg80211_offchan_cac_abort);
++EXPORT_SYMBOL(cfg80211_background_cac_abort);
+ 
+ int
+-cfg80211_start_offchan_radar_detection(struct cfg80211_registered_device *rdev,
+-				       struct wireless_dev *wdev,
+-				       struct cfg80211_chan_def *chandef)
++cfg80211_start_background_radar_detection(struct cfg80211_registered_device *rdev,
++					  struct wireless_dev *wdev,
++					  struct cfg80211_chan_def *chandef)
+ {
+ 	unsigned int cac_time_ms;
+ 	int err;
+@@ -1065,19 +1065,19 @@ cfg80211_start_offchan_radar_detection(s
+ 	lockdep_assert_wiphy(&rdev->wiphy);
+ 
+ 	if (!wiphy_ext_feature_isset(&rdev->wiphy,
+-				     NL80211_EXT_FEATURE_RADAR_OFFCHAN))
++				     NL80211_EXT_FEATURE_RADAR_BACKGROUND))
+ 		return -EOPNOTSUPP;
+ 
+ 	/* Offchannel chain already locked by another wdev */
+-	if (rdev->offchan_radar_wdev && rdev->offchan_radar_wdev != wdev)
++	if (rdev->background_radar_wdev && rdev->background_radar_wdev != wdev)
+ 		return -EBUSY;
+ 
+ 	/* CAC already in progress on the offchannel chain */
+-	if (rdev->offchan_radar_wdev == wdev &&
+-	    delayed_work_pending(&rdev->offchan_cac_done_wk))
++	if (rdev->background_radar_wdev == wdev &&
++	    delayed_work_pending(&rdev->background_cac_done_wk))
+ 		return -EBUSY;
+ 
+-	err = rdev_set_radar_offchan(rdev, chandef);
++	err = rdev_set_radar_background(rdev, chandef);
+ 	if (err)
+ 		return err;
+ 
+@@ -1085,30 +1085,31 @@ cfg80211_start_offchan_radar_detection(s
+ 	if (!cac_time_ms)
+ 		cac_time_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;
+ 
+-	rdev->offchan_radar_chandef = *chandef;
+-	rdev->offchan_radar_wdev = wdev; /* Get offchain ownership */
++	rdev->background_radar_chandef = *chandef;
++	rdev->background_radar_wdev = wdev; /* Get offchain ownership */
+ 
+-	__cfg80211_offchan_cac_event(rdev, wdev, chandef,
+-				     NL80211_RADAR_CAC_STARTED);
+-	queue_delayed_work(cfg80211_wq, &rdev->offchan_cac_done_wk,
++	__cfg80211_background_cac_event(rdev, wdev, chandef,
++					NL80211_RADAR_CAC_STARTED);
++	queue_delayed_work(cfg80211_wq, &rdev->background_cac_done_wk,
+ 			   msecs_to_jiffies(cac_time_ms));
+ 
+ 	return 0;
+ }
+ 
+-void cfg80211_stop_offchan_radar_detection(struct wireless_dev *wdev)
++void cfg80211_stop_background_radar_detection(struct wireless_dev *wdev)
+ {
+ 	struct wiphy *wiphy = wdev->wiphy;
+ 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+ 
+ 	lockdep_assert_wiphy(wiphy);
+ 
+-	if (wdev != rdev->offchan_radar_wdev)
++	if (wdev != rdev->background_radar_wdev)
+ 		return;
+ 
+-	rdev_set_radar_offchan(rdev, NULL);
+-	rdev->offchan_radar_wdev = NULL; /* Release offchain ownership */
++	rdev_set_radar_background(rdev, NULL);
++	rdev->background_radar_wdev = NULL; /* Release offchain ownership */
+ 
+-	__cfg80211_offchan_cac_event(rdev, wdev, &rdev->offchan_radar_chandef,
+-				     NL80211_RADAR_CAC_ABORTED);
++	__cfg80211_background_cac_event(rdev, wdev,
++					&rdev->background_radar_chandef,
++					NL80211_RADAR_CAC_ABORTED);
+ }
+--- a/net/wireless/nl80211.c
++++ b/net/wireless/nl80211.c
+@@ -801,7 +801,7 @@ static const struct nla_policy nl80211_p
+ 	[NL80211_ATTR_MBSSID_CONFIG] =
+ 			NLA_POLICY_NESTED(nl80211_mbssid_config_policy),
+ 	[NL80211_ATTR_MBSSID_ELEMS] = { .type = NLA_NESTED },
+-	[NL80211_ATTR_RADAR_OFFCHAN] = { .type = NLA_FLAG },
++	[NL80211_ATTR_RADAR_BACKGROUND] = { .type = NLA_FLAG },
+ };
+ 
+ /* policy for the key attributes */
+@@ -9306,9 +9306,9 @@ static int nl80211_start_radar_detection
+ 		goto unlock;
+ 	}
+ 
+-	if (nla_get_flag(info->attrs[NL80211_ATTR_RADAR_OFFCHAN])) {
+-		err = cfg80211_start_offchan_radar_detection(rdev, wdev,
+-							     &chandef);
++	if (nla_get_flag(info->attrs[NL80211_ATTR_RADAR_BACKGROUND])) {
++		err = cfg80211_start_background_radar_detection(rdev, wdev,
++								&chandef);
+ 		goto unlock;
+ 	}
+ 
+--- a/net/wireless/rdev-ops.h
++++ b/net/wireless/rdev-ops.h
+@@ -1382,17 +1382,17 @@ static inline int rdev_color_change(stru
+ }
+ 
+ static inline int
+-rdev_set_radar_offchan(struct cfg80211_registered_device *rdev,
+-		       struct cfg80211_chan_def *chandef)
++rdev_set_radar_background(struct cfg80211_registered_device *rdev,
++			  struct cfg80211_chan_def *chandef)
+ {
+ 	struct wiphy *wiphy = &rdev->wiphy;
+ 	int ret;
+ 
+-	if (!rdev->ops->set_radar_offchan)
++	if (!rdev->ops->set_radar_background)
+ 		return -EOPNOTSUPP;
+ 
+-	trace_rdev_set_radar_offchan(wiphy, chandef);
+-	ret = rdev->ops->set_radar_offchan(wiphy, chandef);
++	trace_rdev_set_radar_background(wiphy, chandef);
++	ret = rdev->ops->set_radar_background(wiphy, chandef);
+ 	trace_rdev_return_int(wiphy, ret);
+ 
+ 	return ret;
+--- a/net/wireless/trace.h
++++ b/net/wireless/trace.h
+@@ -3646,7 +3646,7 @@ TRACE_EVENT(cfg80211_bss_color_notify,
+ 		  __entry->color_bitmap)
+ );
+ 
+-TRACE_EVENT(rdev_set_radar_offchan,
++TRACE_EVENT(rdev_set_radar_background,
+ 	TP_PROTO(struct wiphy *wiphy, struct cfg80211_chan_def *chandef),
+ 
+ 	TP_ARGS(wiphy, chandef),
diff --git a/package/kernel/mac80211/patches/subsys/323-mac80211-MBSSID-support-in-interface-handling.patch b/package/kernel/mac80211/patches/subsys/323-mac80211-MBSSID-support-in-interface-handling.patch
new file mode 100644
index 0000000000..a135e3d1b5
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/323-mac80211-MBSSID-support-in-interface-handling.patch
@@ -0,0 +1,144 @@
+From: John Crispin <john@phrozen.org>
+Date: Wed, 15 Sep 2021 19:54:35 -0700
+Subject: [PATCH] mac80211: MBSSID support in interface handling
+
+Configure multiple BSSID and enhanced multi-BSSID advertisement (EMA)
+parameters in mac80211 for AP mode.
+
+For each interface, 'mbssid_tx_vif' points to the transmitting interface of
+the MBSSID set. The pointer is set to NULL if MBSSID is disabled.
+
+Function ieee80211_stop() is modified to always bring down all the
+non-transmitting interfaces first and the transmitting interface last.
+
+Signed-off-by: John Crispin <john@phrozen.org>
+Co-developed-by: Aloka Dixit <alokad@codeaurora.org>
+Signed-off-by: Aloka Dixit <alokad@codeaurora.org>
+Link: https://lore.kernel.org/r/20210916025437.29138-3-alokad@codeaurora.org
+[slightly change logic to be more obvious]
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -1719,6 +1719,7 @@ enum ieee80211_offload_flags {
+  *	write-protected by sdata_lock and local->mtx so holding either is fine
+  *	for read access.
+  * @color_change_color: the bss color that will be used after the change.
++ * @mbssid_tx_vif: Pointer to the transmitting interface if MBSSID is enabled.
+  */
+ struct ieee80211_vif {
+ 	enum nl80211_iftype type;
+@@ -1750,6 +1751,8 @@ struct ieee80211_vif {
+ 	bool color_change_active;
+ 	u8 color_change_color;
+ 
++	struct ieee80211_vif *mbssid_tx_vif;
++
+ 	/* must be last */
+ 	u8 drv_priv[] __aligned(sizeof(void *));
+ };
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -112,6 +112,36 @@ static int ieee80211_set_mon_options(str
+ 	return 0;
+ }
+ 
++static int ieee80211_set_ap_mbssid_options(struct ieee80211_sub_if_data *sdata,
++					   struct cfg80211_mbssid_config params)
++{
++	struct ieee80211_sub_if_data *tx_sdata;
++
++	sdata->vif.mbssid_tx_vif = NULL;
++	sdata->vif.bss_conf.bssid_index = 0;
++	sdata->vif.bss_conf.nontransmitted = false;
++	sdata->vif.bss_conf.ema_ap = false;
++
++	if (sdata->vif.type != NL80211_IFTYPE_AP || !params.tx_wdev)
++		return -EINVAL;
++
++	tx_sdata = IEEE80211_WDEV_TO_SUB_IF(params.tx_wdev);
++	if (!tx_sdata)
++		return -EINVAL;
++
++	if (tx_sdata == sdata) {
++		sdata->vif.mbssid_tx_vif = &sdata->vif;
++	} else {
++		sdata->vif.mbssid_tx_vif = &tx_sdata->vif;
++		sdata->vif.bss_conf.nontransmitted = true;
++		sdata->vif.bss_conf.bssid_index = params.index;
++	}
++	if (params.ema)
++		sdata->vif.bss_conf.ema_ap = true;
++
++	return 0;
++}
++
+ static struct wireless_dev *ieee80211_add_iface(struct wiphy *wiphy,
+ 						const char *name,
+ 						unsigned char name_assign_type,
+@@ -1107,6 +1137,14 @@ static int ieee80211_start_ap(struct wip
+ 			changed |= BSS_CHANGED_HE_BSS_COLOR;
+ 	}
+ 
++	if (sdata->vif.type == NL80211_IFTYPE_AP &&
++	    params->mbssid_config.tx_wdev) {
++		err = ieee80211_set_ap_mbssid_options(sdata,
++						      params->mbssid_config);
++		if (err)
++			return err;
++	}
++
+ 	mutex_lock(&local->mtx);
+ 	err = ieee80211_vif_use_channel(sdata, &params->chandef,
+ 					IEEE80211_CHANCTX_SHARED);
+--- a/net/mac80211/iface.c
++++ b/net/mac80211/iface.c
+@@ -632,17 +632,46 @@ static void ieee80211_do_stop(struct iee
+ 		ieee80211_add_virtual_monitor(local);
+ }
+ 
++static void ieee80211_stop_mbssid(struct ieee80211_sub_if_data *sdata)
++{
++	struct ieee80211_sub_if_data *tx_sdata, *non_tx_sdata, *tmp_sdata;
++	struct ieee80211_vif *tx_vif = sdata->vif.mbssid_tx_vif;
++
++	if (!tx_vif)
++		return;
++
++	tx_sdata = vif_to_sdata(tx_vif);
++	sdata->vif.mbssid_tx_vif = NULL;
++
++	list_for_each_entry_safe(non_tx_sdata, tmp_sdata,
++				 &tx_sdata->local->interfaces, list) {
++		if (non_tx_sdata != sdata && non_tx_sdata != tx_sdata &&
++		    non_tx_sdata->vif.mbssid_tx_vif == tx_vif &&
++		    ieee80211_sdata_running(non_tx_sdata)) {
++			non_tx_sdata->vif.mbssid_tx_vif = NULL;
++			dev_close(non_tx_sdata->wdev.netdev);
++		}
++	}
++
++	if (sdata != tx_sdata && ieee80211_sdata_running(tx_sdata)) {
++		tx_sdata->vif.mbssid_tx_vif = NULL;
++		dev_close(tx_sdata->wdev.netdev);
++	}
++}
++
+ static int ieee80211_stop(struct net_device *dev)
+ {
+ 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+ 
+-	/* close all dependent VLAN interfaces before locking wiphy */
++	/* close dependent VLAN and MBSSID interfaces before locking wiphy */
+ 	if (sdata->vif.type == NL80211_IFTYPE_AP) {
+ 		struct ieee80211_sub_if_data *vlan, *tmpsdata;
+ 
+ 		list_for_each_entry_safe(vlan, tmpsdata, &sdata->u.ap.vlans,
+ 					 u.vlan.list)
+ 			dev_close(vlan->dev);
++
++		ieee80211_stop_mbssid(sdata);
+ 	}
+ 
+ 	wiphy_lock(sdata->local->hw.wiphy);
diff --git a/package/kernel/mac80211/patches/subsys/324-mac80211-MBSSID-beacon-handling-in-AP-mode.patch b/package/kernel/mac80211/patches/subsys/324-mac80211-MBSSID-beacon-handling-in-AP-mode.patch
new file mode 100644
index 0000000000..e2b05719db
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/324-mac80211-MBSSID-beacon-handling-in-AP-mode.patch
@@ -0,0 +1,326 @@
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Thu, 24 Feb 2022 12:54:58 +0100
+Subject: [PATCH] mac80211: MBSSID beacon handling in AP mode
+
+Add new fields in struct beacon_data to store all MBSSID elements.
+Generate a beacon template which includes all MBSSID elements.
+Move CSA offset to reflect the MBSSID element length.
+
+Co-developed-by: Aloka Dixit <alokad@codeaurora.org>
+Signed-off-by: Aloka Dixit <alokad@codeaurora.org>
+Co-developed-by: John Crispin <john@phrozen.org>
+Signed-off-by: John Crispin <john@phrozen.org>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Tested-by: Money Wang <money.wang@mediatek.com>
+Link: https://lore.kernel.org/r/5322db3c303f431adaf191ab31c45e151dde5465.1645702516.git.lorenzo@kernel.org
+[small cleanups]
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -4938,12 +4938,14 @@ void ieee80211_report_low_ack(struct iee
+  * @cntdwn_counter_offs: array of IEEE80211_MAX_CNTDWN_COUNTERS_NUM offsets
+  *	to countdown counters.  This array can contain zero values which
+  *	should be ignored.
++ * @mbssid_off: position of the multiple bssid element
+  */
+ struct ieee80211_mutable_offsets {
+ 	u16 tim_offset;
+ 	u16 tim_length;
+ 
+ 	u16 cntdwn_counter_offs[IEEE80211_MAX_CNTDWN_COUNTERS_NUM];
++	u16 mbssid_off;
+ };
+ 
+ /**
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -989,11 +989,29 @@ static int ieee80211_set_ftm_responder_p
+ 	return 0;
+ }
+ 
++static int
++ieee80211_copy_mbssid_beacon(u8 *pos, struct cfg80211_mbssid_elems *dst,
++			     struct cfg80211_mbssid_elems *src)
++{
++	int i, offset = 0;
++
++	for (i = 0; i < src->cnt; i++) {
++		memcpy(pos + offset, src->elem[i].data, src->elem[i].len);
++		dst->elem[i].len = src->elem[i].len;
++		dst->elem[i].data = pos + offset;
++		offset += dst->elem[i].len;
++	}
++	dst->cnt = src->cnt;
++
++	return offset;
++}
++
+ static int ieee80211_assign_beacon(struct ieee80211_sub_if_data *sdata,
+ 				   struct cfg80211_beacon_data *params,
+ 				   const struct ieee80211_csa_settings *csa,
+ 				   const struct ieee80211_color_change_settings *cca)
+ {
++	struct cfg80211_mbssid_elems *mbssid = NULL;
+ 	struct beacon_data *new, *old;
+ 	int new_head_len, new_tail_len;
+ 	int size, err;
+@@ -1021,6 +1039,17 @@ static int ieee80211_assign_beacon(struc
+ 
+ 	size = sizeof(*new) + new_head_len + new_tail_len;
+ 
++	/* new or old multiple BSSID elements? */
++	if (params->mbssid_ies) {
++		mbssid = params->mbssid_ies;
++		size += struct_size(new->mbssid_ies, elem, mbssid->cnt);
++		size += ieee80211_get_mbssid_beacon_len(mbssid);
++	} else if (old && old->mbssid_ies) {
++		mbssid = old->mbssid_ies;
++		size += struct_size(new->mbssid_ies, elem, mbssid->cnt);
++		size += ieee80211_get_mbssid_beacon_len(mbssid);
++	}
++
+ 	new = kzalloc(size, GFP_KERNEL);
+ 	if (!new)
+ 		return -ENOMEM;
+@@ -1029,12 +1058,20 @@ static int ieee80211_assign_beacon(struc
+ 
+ 	/*
+ 	 * pointers go into the block we allocated,
+-	 * memory is | beacon_data | head | tail |
++	 * memory is | beacon_data | head | tail | mbssid_ies
+ 	 */
+ 	new->head = ((u8 *) new) + sizeof(*new);
+ 	new->tail = new->head + new_head_len;
+ 	new->head_len = new_head_len;
+ 	new->tail_len = new_tail_len;
++	/* copy in optional mbssid_ies */
++	if (mbssid) {
++		u8 *pos = new->tail + new->tail_len;
++
++		new->mbssid_ies = (void *)pos;
++		pos += struct_size(new->mbssid_ies, elem, mbssid->cnt);
++		ieee80211_copy_mbssid_beacon(pos, new->mbssid_ies, mbssid);
++	}
+ 
+ 	if (csa) {
+ 		new->cntdwn_current_counter = csa->count;
+@@ -1332,8 +1369,11 @@ static int ieee80211_stop_ap(struct wiph
+ 
+ 	mutex_unlock(&local->mtx);
+ 
+-	kfree(sdata->u.ap.next_beacon);
+-	sdata->u.ap.next_beacon = NULL;
++	if (sdata->u.ap.next_beacon) {
++		kfree(sdata->u.ap.next_beacon->mbssid_ies);
++		kfree(sdata->u.ap.next_beacon);
++		sdata->u.ap.next_beacon = NULL;
++	}
+ 
+ 	/* turn off carrier for this interface and dependent VLANs */
+ 	list_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list)
+@@ -3126,12 +3166,24 @@ cfg80211_beacon_dup(struct cfg80211_beac
+ 
+ 	len = beacon->head_len + beacon->tail_len + beacon->beacon_ies_len +
+ 	      beacon->proberesp_ies_len + beacon->assocresp_ies_len +
+-	      beacon->probe_resp_len + beacon->lci_len + beacon->civicloc_len;
++	      beacon->probe_resp_len + beacon->lci_len + beacon->civicloc_len +
++	      ieee80211_get_mbssid_beacon_len(beacon->mbssid_ies);
+ 
+ 	new_beacon = kzalloc(sizeof(*new_beacon) + len, GFP_KERNEL);
+ 	if (!new_beacon)
+ 		return NULL;
+ 
++	if (beacon->mbssid_ies && beacon->mbssid_ies->cnt) {
++		new_beacon->mbssid_ies =
++			kzalloc(struct_size(new_beacon->mbssid_ies,
++					    elem, beacon->mbssid_ies->cnt),
++				GFP_KERNEL);
++		if (!new_beacon->mbssid_ies) {
++			kfree(new_beacon);
++			return NULL;
++		}
++	}
++
+ 	pos = (u8 *)(new_beacon + 1);
+ 	if (beacon->head_len) {
+ 		new_beacon->head_len = beacon->head_len;
+@@ -3169,6 +3221,10 @@ cfg80211_beacon_dup(struct cfg80211_beac
+ 		memcpy(pos, beacon->probe_resp, beacon->probe_resp_len);
+ 		pos += beacon->probe_resp_len;
+ 	}
++	if (beacon->mbssid_ies && beacon->mbssid_ies->cnt)
++		pos += ieee80211_copy_mbssid_beacon(pos,
++						    new_beacon->mbssid_ies,
++						    beacon->mbssid_ies);
+ 
+ 	/* might copy -1, meaning no changes requested */
+ 	new_beacon->ftm_responder = beacon->ftm_responder;
+@@ -3206,8 +3262,11 @@ static int ieee80211_set_after_csa_beaco
+ 	case NL80211_IFTYPE_AP:
+ 		err = ieee80211_assign_beacon(sdata, sdata->u.ap.next_beacon,
+ 					      NULL, NULL);
+-		kfree(sdata->u.ap.next_beacon);
+-		sdata->u.ap.next_beacon = NULL;
++		if (sdata->u.ap.next_beacon) {
++			kfree(sdata->u.ap.next_beacon->mbssid_ies);
++			kfree(sdata->u.ap.next_beacon);
++			sdata->u.ap.next_beacon = NULL;
++		}
+ 
+ 		if (err < 0)
+ 			return err;
+@@ -3362,8 +3421,12 @@ static int ieee80211_set_csa_beacon(stru
+ 		if ((params->n_counter_offsets_beacon >
+ 		     IEEE80211_MAX_CNTDWN_COUNTERS_NUM) ||
+ 		    (params->n_counter_offsets_presp >
+-		     IEEE80211_MAX_CNTDWN_COUNTERS_NUM))
++		     IEEE80211_MAX_CNTDWN_COUNTERS_NUM)) {
++			kfree(sdata->u.ap.next_beacon->mbssid_ies);
++			kfree(sdata->u.ap.next_beacon);
++			sdata->u.ap.next_beacon = NULL;
+ 			return -EINVAL;
++		}
+ 
+ 		csa.counter_offsets_beacon = params->counter_offsets_beacon;
+ 		csa.counter_offsets_presp = params->counter_offsets_presp;
+@@ -3373,7 +3436,9 @@ static int ieee80211_set_csa_beacon(stru
+ 
+ 		err = ieee80211_assign_beacon(sdata, &params->beacon_csa, &csa, NULL);
+ 		if (err < 0) {
++			kfree(sdata->u.ap.next_beacon->mbssid_ies);
+ 			kfree(sdata->u.ap.next_beacon);
++			sdata->u.ap.next_beacon = NULL;
+ 			return err;
+ 		}
+ 		*changed |= err;
+@@ -3463,8 +3528,11 @@ static int ieee80211_set_csa_beacon(stru
+ static void ieee80211_color_change_abort(struct ieee80211_sub_if_data  *sdata)
+ {
+ 	sdata->vif.color_change_active = false;
+-	kfree(sdata->u.ap.next_beacon);
+-	sdata->u.ap.next_beacon = NULL;
++	if (sdata->u.ap.next_beacon) {
++		kfree(sdata->u.ap.next_beacon->mbssid_ies);
++		kfree(sdata->u.ap.next_beacon);
++		sdata->u.ap.next_beacon = NULL;
++	}
+ 
+ 	cfg80211_color_change_aborted_notify(sdata->dev);
+ }
+@@ -4202,8 +4270,11 @@ ieee80211_set_after_color_change_beacon(
+ 
+ 		ret = ieee80211_assign_beacon(sdata, sdata->u.ap.next_beacon,
+ 					      NULL, NULL);
+-		kfree(sdata->u.ap.next_beacon);
+-		sdata->u.ap.next_beacon = NULL;
++		if (sdata->u.ap.next_beacon) {
++			kfree(sdata->u.ap.next_beacon->mbssid_ies);
++			kfree(sdata->u.ap.next_beacon);
++			sdata->u.ap.next_beacon = NULL;
++		}
+ 
+ 		if (ret < 0)
+ 			return ret;
+@@ -4246,7 +4317,11 @@ ieee80211_set_color_change_beacon(struct
+ 		err = ieee80211_assign_beacon(sdata, &params->beacon_color_change,
+ 					      NULL, &color_change);
+ 		if (err < 0) {
+-			kfree(sdata->u.ap.next_beacon);
++			if (sdata->u.ap.next_beacon) {
++				kfree(sdata->u.ap.next_beacon->mbssid_ies);
++				kfree(sdata->u.ap.next_beacon);
++				sdata->u.ap.next_beacon = NULL;
++			}
+ 			return err;
+ 		}
+ 		*changed |= err;
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -261,6 +261,7 @@ struct beacon_data {
+ 	struct ieee80211_meshconf_ie *meshconf;
+ 	u16 cntdwn_counter_offsets[IEEE80211_MAX_CNTDWN_COUNTERS_NUM];
+ 	u8 cntdwn_current_counter;
++	struct cfg80211_mbssid_elems *mbssid_ies;
+ 	struct rcu_head rcu_head;
+ };
+ 
+@@ -1082,6 +1083,20 @@ ieee80211_vif_get_shift(struct ieee80211
+ 	return shift;
+ }
+ 
++static inline int
++ieee80211_get_mbssid_beacon_len(struct cfg80211_mbssid_elems *elems)
++{
++	int i, len = 0;
++
++	if (!elems)
++		return 0;
++
++	for (i = 0; i < elems->cnt; i++)
++		len += elems->elem[i].len;
++
++	return len;
++}
++
+ enum {
+ 	IEEE80211_RX_MSG	= 1,
+ 	IEEE80211_TX_STATUS_MSG	= 2,
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -5041,6 +5041,19 @@ ieee80211_beacon_get_finish(struct ieee8
+ 		       IEEE80211_TX_CTL_FIRST_FRAGMENT;
+ }
+ 
++static void
++ieee80211_beacon_add_mbssid(struct sk_buff *skb, struct beacon_data *beacon)
++{
++	int i;
++
++	if (!beacon->mbssid_ies)
++		return;
++
++	for (i = 0; i < beacon->mbssid_ies->cnt; i++)
++		skb_put_data(skb, beacon->mbssid_ies->elem[i].data,
++			     beacon->mbssid_ies->elem[i].len);
++}
++
+ static struct sk_buff *
+ ieee80211_beacon_get_ap(struct ieee80211_hw *hw,
+ 			struct ieee80211_vif *vif,
+@@ -5054,6 +5067,7 @@ ieee80211_beacon_get_ap(struct ieee80211
+ 	struct ieee80211_if_ap *ap = &sdata->u.ap;
+ 	struct sk_buff *skb = NULL;
+ 	u16 csa_off_base = 0;
++	int mbssid_len;
+ 
+ 	if (beacon->cntdwn_counter_offsets[0]) {
+ 		if (!is_template)
+@@ -5063,11 +5077,12 @@ ieee80211_beacon_get_ap(struct ieee80211
+ 	}
+ 
+ 	/* headroom, head length,
+-	 * tail length and maximum TIM length
++	 * tail length, maximum TIM length and multiple BSSID length
+ 	 */
++	mbssid_len = ieee80211_get_mbssid_beacon_len(beacon->mbssid_ies);
+ 	skb = dev_alloc_skb(local->tx_headroom + beacon->head_len +
+ 			    beacon->tail_len + 256 +
+-			    local->hw.extra_beacon_tailroom);
++			    local->hw.extra_beacon_tailroom + mbssid_len);
+ 	if (!skb)
+ 		return NULL;
+ 
+@@ -5081,6 +5096,11 @@ ieee80211_beacon_get_ap(struct ieee80211
+ 		offs->tim_length = skb->len - beacon->head_len;
+ 		offs->cntdwn_counter_offs[0] = beacon->cntdwn_counter_offsets[0];
+ 
++		if (mbssid_len) {
++			ieee80211_beacon_add_mbssid(skb, beacon);
++			offs->mbssid_off = skb->len - mbssid_len;
++		}
++
+ 		/* for AP the csa offsets are from tail */
+ 		csa_off_base = skb->len;
+ 	}
diff --git a/package/kernel/mac80211/patches/subsys/325-mac80211-MBSSID-channel-switch.patch b/package/kernel/mac80211/patches/subsys/325-mac80211-MBSSID-channel-switch.patch
new file mode 100644
index 0000000000..38b0de180e
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/325-mac80211-MBSSID-channel-switch.patch
@@ -0,0 +1,52 @@
+From: John Crispin <john@phrozen.org>
+Date: Thu, 24 Feb 2022 12:54:59 +0100
+Subject: [PATCH] mac80211: MBSSID channel switch
+
+Trigger ieee80211_csa_finish() on the non-transmitting interfaces
+when channel switch concludes on the transmitting interface.
+
+Co-developed-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Co-developed-by: Aloka Dixit <alokad@codeaurora.org>
+Signed-off-by: Aloka Dixit <alokad@codeaurora.org>
+Signed-off-by: John Crispin <john@phrozen.org>
+Link: https://lore.kernel.org/r/6fde4d7f9fa387494f46a7aa4a584478dcda06f1.1645702516.git.lorenzo@kernel.org
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -3247,9 +3247,31 @@ cfg80211_beacon_dup(struct cfg80211_beac
+ void ieee80211_csa_finish(struct ieee80211_vif *vif)
+ {
+ 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
++	struct ieee80211_local *local = sdata->local;
+ 
+-	ieee80211_queue_work(&sdata->local->hw,
+-			     &sdata->csa_finalize_work);
++	rcu_read_lock();
++
++	if (vif->mbssid_tx_vif == vif) {
++		/* Trigger ieee80211_csa_finish() on the non-transmitting
++		 * interfaces when channel switch is received on
++		 * transmitting interface
++		 */
++		struct ieee80211_sub_if_data *iter;
++
++		list_for_each_entry_rcu(iter, &local->interfaces, list) {
++			if (!ieee80211_sdata_running(iter))
++				continue;
++
++			if (iter == sdata || iter->vif.mbssid_tx_vif != vif)
++				continue;
++
++			ieee80211_queue_work(&iter->local->hw,
++					     &iter->csa_finalize_work);
++		}
++	}
++	ieee80211_queue_work(&local->hw, &sdata->csa_finalize_work);
++
++	rcu_read_unlock();
+ }
+ EXPORT_SYMBOL(ieee80211_csa_finish);
+ 
diff --git a/package/kernel/mac80211/patches/subsys/326-mac80211-update-bssid_indicator-in-ieee80211_assign_.patch b/package/kernel/mac80211/patches/subsys/326-mac80211-update-bssid_indicator-in-ieee80211_assign_.patch
new file mode 100644
index 0000000000..1955568607
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/326-mac80211-update-bssid_indicator-in-ieee80211_assign_.patch
@@ -0,0 +1,25 @@
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Thu, 24 Feb 2022 12:55:00 +0100
+Subject: [PATCH] mac80211: update bssid_indicator in
+ ieee80211_assign_beacon
+
+Update bssid_indicator in ieee80211_bss_conf according to the
+number of bssid in the set.
+
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Link: https://lore.kernel.org/r/f92317e002fca9933f05a445fcefb4f53291d601.1645702516.git.lorenzo@kernel.org
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -1071,6 +1071,9 @@ static int ieee80211_assign_beacon(struc
+ 		new->mbssid_ies = (void *)pos;
+ 		pos += struct_size(new->mbssid_ies, elem, mbssid->cnt);
+ 		ieee80211_copy_mbssid_beacon(pos, new->mbssid_ies, mbssid);
++		/* update bssid_indicator */
++		sdata->vif.bss_conf.bssid_indicator =
++			ilog2(__roundup_pow_of_two(mbssid->cnt + 1));
+ 	}
+ 
+ 	if (csa) {
diff --git a/package/kernel/mac80211/patches/subsys/328-mac80211-do-not-wake-queues-on-a-vif-that-is-being-s.patch b/package/kernel/mac80211/patches/subsys/328-mac80211-do-not-wake-queues-on-a-vif-that-is-being-s.patch
new file mode 100644
index 0000000000..f0150ddef0
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/328-mac80211-do-not-wake-queues-on-a-vif-that-is-being-s.patch
@@ -0,0 +1,38 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 26 Mar 2022 23:58:35 +0100
+Subject: [PATCH] mac80211: do not wake queues on a vif that is being stopped
+
+When a vif is being removed and sdata->bss is cleared, __ieee80211_wake_txqs
+can still be called on it, which crashes as soon as sdata->bss is being
+dereferenced.
+To fix this properly, check for SDATA_STATE_RUNNING before waking queues,
+and take the fq lock when setting it (to ensure that __ieee80211_wake_txqs
+observes the change when running on a different CPU
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/iface.c
++++ b/net/mac80211/iface.c
+@@ -377,7 +377,9 @@ static void ieee80211_do_stop(struct iee
+ 	bool cancel_scan;
+ 	struct cfg80211_nan_func *func;
+ 
++	spin_lock_bh(&local->fq.lock);
+ 	clear_bit(SDATA_STATE_RUNNING, &sdata->state);
++	spin_unlock_bh(&local->fq.lock);
+ 
+ 	cancel_scan = rcu_access_pointer(local->scan_sdata) == sdata;
+ 	if (cancel_scan)
+--- a/net/mac80211/util.c
++++ b/net/mac80211/util.c
+@@ -301,6 +301,9 @@ static void __ieee80211_wake_txqs(struct
+ 	local_bh_disable();
+ 	spin_lock(&fq->lock);
+ 
++	if (!test_bit(SDATA_STATE_RUNNING, &sdata->state))
++		goto out;
++
+ 	if (sdata->vif.type == NL80211_IFTYPE_AP)
+ 		ps = &sdata->bss->ps;
+ 
diff --git a/package/kernel/mac80211/patches/subsys/330-mac80211-switch-airtime-fairness-back-to-deficit-rou.patch b/package/kernel/mac80211/patches/subsys/330-mac80211-switch-airtime-fairness-back-to-deficit-rou.patch
new file mode 100644
index 0000000000..e59036f5a2
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/330-mac80211-switch-airtime-fairness-back-to-deficit-rou.patch
@@ -0,0 +1,1249 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sun, 19 Jun 2022 23:13:05 +0200
+Subject: [PATCH] mac80211: switch airtime fairness back to deficit round-robin
+ scheduling
+
+This reverts commits 6a789ba679d652587532cec2a0e0274fda172f3b and
+2433647bc8d983a543e7d31b41ca2de1c7e2c198.
+
+The virtual time scheduler code has a number of issues:
+- queues slowed down by hardware/firmware powersave handling were not properly
+  handled.
+- on ath10k in push-pull mode, tx queues that the driver tries to pull from
+  were starved, causing excessive latency
+- delay between tx enqueue and reported airtime use were causing excessively
+  bursty tx behavior
+
+The bursty behavior may also be present on the round-robin scheduler, but there
+it is much easier to fix without introducing additional regressions
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -6666,6 +6666,9 @@ static inline void ieee80211_txq_schedul
+ {
+ }
+ 
++void __ieee80211_schedule_txq(struct ieee80211_hw *hw,
++			      struct ieee80211_txq *txq, bool force);
++
+ /**
+  * ieee80211_schedule_txq - schedule a TXQ for transmission
+  *
+@@ -6678,7 +6681,11 @@ static inline void ieee80211_txq_schedul
+  * The driver may call this function if it has buffered packets for
+  * this TXQ internally.
+  */
+-void ieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq);
++static inline void
++ieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq)
++{
++	__ieee80211_schedule_txq(hw, txq, true);
++}
+ 
+ /**
+  * ieee80211_return_txq - return a TXQ previously acquired by ieee80211_next_txq()
+@@ -6690,8 +6697,12 @@ void ieee80211_schedule_txq(struct ieee8
+  * The driver may set force=true if it has buffered packets for this TXQ
+  * internally.
+  */
+-void ieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq,
+-			  bool force);
++static inline void
++ieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq,
++		     bool force)
++{
++	__ieee80211_schedule_txq(hw, txq, force);
++}
+ 
+ /**
+  * ieee80211_txq_may_transmit - check whether TXQ is allowed to transmit
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -1554,38 +1554,6 @@ static void sta_apply_mesh_params(struct
+ #endif
+ }
+ 
+-static void sta_apply_airtime_params(struct ieee80211_local *local,
+-				     struct sta_info *sta,
+-				     struct station_parameters *params)
+-{
+-	u8 ac;
+-
+-	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+-		struct airtime_sched_info *air_sched = &local->airtime[ac];
+-		struct airtime_info *air_info = &sta->airtime[ac];
+-		struct txq_info *txqi;
+-		u8 tid;
+-
+-		spin_lock_bh(&air_sched->lock);
+-		for (tid = 0; tid < IEEE80211_NUM_TIDS + 1; tid++) {
+-			if (air_info->weight == params->airtime_weight ||
+-			    !sta->sta.txq[tid] ||
+-			    ac != ieee80211_ac_from_tid(tid))
+-				continue;
+-
+-			airtime_weight_set(air_info, params->airtime_weight);
+-
+-			txqi = to_txq_info(sta->sta.txq[tid]);
+-			if (RB_EMPTY_NODE(&txqi->schedule_order))
+-				continue;
+-
+-			ieee80211_update_airtime_weight(local, air_sched,
+-							0, true);
+-		}
+-		spin_unlock_bh(&air_sched->lock);
+-	}
+-}
+-
+ static int sta_apply_parameters(struct ieee80211_local *local,
+ 				struct sta_info *sta,
+ 				struct station_parameters *params)
+@@ -1773,8 +1741,7 @@ static int sta_apply_parameters(struct i
+ 		sta_apply_mesh_params(local, sta, params);
+ 
+ 	if (params->airtime_weight)
+-		sta_apply_airtime_params(local, sta, params);
+-
++		sta->airtime_weight = params->airtime_weight;
+ 
+ 	/* set the STA state after all sta info from usermode has been set */
+ 	if (test_sta_flag(sta, WLAN_STA_TDLS_PEER) ||
+--- a/net/mac80211/debugfs.c
++++ b/net/mac80211/debugfs.c
+@@ -216,14 +216,14 @@ static ssize_t aql_txq_limit_read(struct
+ 			"VI	%u		%u\n"
+ 			"BE	%u		%u\n"
+ 			"BK	%u		%u\n",
+-			local->airtime[IEEE80211_AC_VO].aql_txq_limit_low,
+-			local->airtime[IEEE80211_AC_VO].aql_txq_limit_high,
+-			local->airtime[IEEE80211_AC_VI].aql_txq_limit_low,
+-			local->airtime[IEEE80211_AC_VI].aql_txq_limit_high,
+-			local->airtime[IEEE80211_AC_BE].aql_txq_limit_low,
+-			local->airtime[IEEE80211_AC_BE].aql_txq_limit_high,
+-			local->airtime[IEEE80211_AC_BK].aql_txq_limit_low,
+-			local->airtime[IEEE80211_AC_BK].aql_txq_limit_high);
++			local->aql_txq_limit_low[IEEE80211_AC_VO],
++			local->aql_txq_limit_high[IEEE80211_AC_VO],
++			local->aql_txq_limit_low[IEEE80211_AC_VI],
++			local->aql_txq_limit_high[IEEE80211_AC_VI],
++			local->aql_txq_limit_low[IEEE80211_AC_BE],
++			local->aql_txq_limit_high[IEEE80211_AC_BE],
++			local->aql_txq_limit_low[IEEE80211_AC_BK],
++			local->aql_txq_limit_high[IEEE80211_AC_BK]);
+ 	return simple_read_from_buffer(user_buf, count, ppos,
+ 				       buf, len);
+ }
+@@ -255,11 +255,11 @@ static ssize_t aql_txq_limit_write(struc
+ 	if (ac >= IEEE80211_NUM_ACS)
+ 		return -EINVAL;
+ 
+-	q_limit_low_old = local->airtime[ac].aql_txq_limit_low;
+-	q_limit_high_old = local->airtime[ac].aql_txq_limit_high;
++	q_limit_low_old = local->aql_txq_limit_low[ac];
++	q_limit_high_old = local->aql_txq_limit_high[ac];
+ 
+-	local->airtime[ac].aql_txq_limit_low = q_limit_low;
+-	local->airtime[ac].aql_txq_limit_high = q_limit_high;
++	local->aql_txq_limit_low[ac] = q_limit_low;
++	local->aql_txq_limit_high[ac] = q_limit_high;
+ 
+ 	mutex_lock(&local->sta_mtx);
+ 	list_for_each_entry(sta, &local->sta_list, list) {
+@@ -382,46 +382,6 @@ static const struct file_operations forc
+ 	.llseek = default_llseek,
+ };
+ 
+-static ssize_t airtime_read(struct file *file,
+-			    char __user *user_buf,
+-			    size_t count,
+-			    loff_t *ppos)
+-{
+-	struct ieee80211_local *local = file->private_data;
+-	char buf[200];
+-	u64 v_t[IEEE80211_NUM_ACS];
+-	u64 wt[IEEE80211_NUM_ACS];
+-	int len = 0, ac;
+-
+-	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+-		spin_lock_bh(&local->airtime[ac].lock);
+-		v_t[ac] = local->airtime[ac].v_t;
+-		wt[ac] = local->airtime[ac].weight_sum;
+-		spin_unlock_bh(&local->airtime[ac].lock);
+-	}
+-	len = scnprintf(buf, sizeof(buf),
+-			"\tVO         VI         BE         BK\n"
+-			"Virt-t\t%-10llu %-10llu %-10llu %-10llu\n"
+-			"Weight\t%-10llu %-10llu %-10llu %-10llu\n",
+-			v_t[0],
+-			v_t[1],
+-			v_t[2],
+-			v_t[3],
+-			wt[0],
+-			wt[1],
+-			wt[2],
+-			wt[3]);
+-
+-	return simple_read_from_buffer(user_buf, count, ppos,
+-				       buf, len);
+-}
+-
+-static const struct file_operations airtime_ops = {
+-	.read = airtime_read,
+-	.open = simple_open,
+-	.llseek = default_llseek,
+-};
+-
+ #ifdef CONFIG_PM
+ static ssize_t reset_write(struct file *file, const char __user *user_buf,
+ 			   size_t count, loff_t *ppos)
+@@ -672,11 +632,7 @@ void debugfs_hw_add(struct ieee80211_loc
+ 	if (local->ops->wake_tx_queue)
+ 		DEBUGFS_ADD_MODE(aqm, 0600);
+ 
+-	if (wiphy_ext_feature_isset(local->hw.wiphy,
+-				    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS)) {
+-		DEBUGFS_ADD_MODE(airtime, 0600);
+-		DEBUGFS_ADD_MODE(airtime_flags, 0600);
+-	}
++	DEBUGFS_ADD_MODE(airtime_flags, 0600);
+ 
+ 	DEBUGFS_ADD(aql_txq_limit);
+ 	debugfs_create_u32("aql_threshold", 0600,
+--- a/net/mac80211/debugfs_netdev.c
++++ b/net/mac80211/debugfs_netdev.c
+@@ -512,34 +512,6 @@ static ssize_t ieee80211_if_fmt_aqm(
+ }
+ IEEE80211_IF_FILE_R(aqm);
+ 
+-static ssize_t ieee80211_if_fmt_airtime(
+-	const struct ieee80211_sub_if_data *sdata, char *buf, int buflen)
+-{
+-	struct ieee80211_local *local = sdata->local;
+-	struct ieee80211_txq *txq = sdata->vif.txq;
+-	struct airtime_info *air_info;
+-	int len;
+-
+-	if (!txq)
+-		return 0;
+-
+-	spin_lock_bh(&local->airtime[txq->ac].lock);
+-	air_info = to_airtime_info(txq);
+-	len = scnprintf(buf,
+-			buflen,
+-			"RX: %llu us\nTX: %llu us\nWeight: %u\n"
+-			"Virt-T: %lld us\n",
+-			air_info->rx_airtime,
+-			air_info->tx_airtime,
+-			air_info->weight,
+-			air_info->v_t);
+-	spin_unlock_bh(&local->airtime[txq->ac].lock);
+-
+-	return len;
+-}
+-
+-IEEE80211_IF_FILE_R(airtime);
+-
+ IEEE80211_IF_FILE(multicast_to_unicast, u.ap.multicast_to_unicast, HEX);
+ 
+ /* IBSS attributes */
+@@ -685,10 +657,8 @@ static void add_common_files(struct ieee
+ 
+ 	if (sdata->local->ops->wake_tx_queue &&
+ 	    sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE &&
+-	    sdata->vif.type != NL80211_IFTYPE_NAN) {
++	    sdata->vif.type != NL80211_IFTYPE_NAN)
+ 		DEBUGFS_ADD(aqm);
+-		DEBUGFS_ADD(airtime);
+-	}
+ }
+ 
+ static void add_sta_files(struct ieee80211_sub_if_data *sdata)
+--- a/net/mac80211/debugfs_sta.c
++++ b/net/mac80211/debugfs_sta.c
+@@ -202,7 +202,7 @@ static ssize_t sta_airtime_read(struct f
+ 	size_t bufsz = 400;
+ 	char *buf = kzalloc(bufsz, GFP_KERNEL), *p = buf;
+ 	u64 rx_airtime = 0, tx_airtime = 0;
+-	u64 v_t[IEEE80211_NUM_ACS];
++	s64 deficit[IEEE80211_NUM_ACS];
+ 	ssize_t rv;
+ 	int ac;
+ 
+@@ -210,18 +210,18 @@ static ssize_t sta_airtime_read(struct f
+ 		return -ENOMEM;
+ 
+ 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+-		spin_lock_bh(&local->airtime[ac].lock);
++		spin_lock_bh(&local->active_txq_lock[ac]);
+ 		rx_airtime += sta->airtime[ac].rx_airtime;
+ 		tx_airtime += sta->airtime[ac].tx_airtime;
+-		v_t[ac] = sta->airtime[ac].v_t;
+-		spin_unlock_bh(&local->airtime[ac].lock);
++		deficit[ac] = sta->airtime[ac].deficit;
++		spin_unlock_bh(&local->active_txq_lock[ac]);
+ 	}
+ 
+ 	p += scnprintf(p, bufsz + buf - p,
+ 		"RX: %llu us\nTX: %llu us\nWeight: %u\n"
+-		"Virt-T: VO: %lld us VI: %lld us BE: %lld us BK: %lld us\n",
+-		rx_airtime, tx_airtime, sta->airtime[0].weight,
+-		v_t[0], v_t[1], v_t[2], v_t[3]);
++		"Deficit: VO: %lld us VI: %lld us BE: %lld us BK: %lld us\n",
++		rx_airtime, tx_airtime, sta->airtime_weight,
++		deficit[0], deficit[1], deficit[2], deficit[3]);
+ 
+ 	rv = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);
+ 	kfree(buf);
+@@ -236,11 +236,11 @@ static ssize_t sta_airtime_write(struct
+ 	int ac;
+ 
+ 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+-		spin_lock_bh(&local->airtime[ac].lock);
++		spin_lock_bh(&local->active_txq_lock[ac]);
+ 		sta->airtime[ac].rx_airtime = 0;
+ 		sta->airtime[ac].tx_airtime = 0;
+-		sta->airtime[ac].v_t = 0;
+-		spin_unlock_bh(&local->airtime[ac].lock);
++		sta->airtime[ac].deficit = sta->airtime_weight;
++		spin_unlock_bh(&local->active_txq_lock[ac]);
+ 	}
+ 
+ 	return count;
+@@ -263,10 +263,10 @@ static ssize_t sta_aql_read(struct file
+ 		return -ENOMEM;
+ 
+ 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+-		spin_lock_bh(&local->airtime[ac].lock);
++		spin_lock_bh(&local->active_txq_lock[ac]);
+ 		q_limit_l[ac] = sta->airtime[ac].aql_limit_low;
+ 		q_limit_h[ac] = sta->airtime[ac].aql_limit_high;
+-		spin_unlock_bh(&local->airtime[ac].lock);
++		spin_unlock_bh(&local->active_txq_lock[ac]);
+ 		q_depth[ac] = atomic_read(&sta->airtime[ac].aql_tx_pending);
+ 	}
+ 
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -862,16 +862,20 @@ enum txq_info_flags {
+  * @def_flow: used as a fallback flow when a packet destined to @tin hashes to
+  *	a fq_flow which is already owned by a different tin
+  * @def_cvars: codel vars for @def_flow
+- * @schedule_order: used with ieee80211_local->active_txqs
+  * @frags: used to keep fragments created after dequeue
++ * @schedule_order: used with ieee80211_local->active_txqs
++ * @schedule_round: counter to prevent infinite loops on TXQ scheduling
+  */
+ struct txq_info {
+ 	struct fq_tin tin;
+ 	struct codel_vars def_cvars;
+ 	struct codel_stats cstats;
+-	struct rb_node schedule_order;
++
++	u16 schedule_round;
++	struct list_head schedule_order;
+ 
+ 	struct sk_buff_head frags;
++
+ 	unsigned long flags;
+ 
+ 	/* keep last! */
+@@ -948,8 +952,6 @@ struct ieee80211_sub_if_data {
+ 	struct ieee80211_tx_queue_params tx_conf[IEEE80211_NUM_ACS];
+ 	struct mac80211_qos_map __rcu *qos_map;
+ 
+-	struct airtime_info airtime[IEEE80211_NUM_ACS];
+-
+ 	struct work_struct csa_finalize_work;
+ 	bool csa_block_tx; /* write-protected by sdata_lock and local->mtx */
+ 	struct cfg80211_chan_def csa_chandef;
+@@ -1184,44 +1186,6 @@ enum mac80211_scan_state {
+ 	SCAN_ABORT,
+ };
+ 
+-/**
+- * struct airtime_sched_info - state used for airtime scheduling and AQL
+- *
+- * @lock: spinlock that protects all the fields in this struct
+- * @active_txqs: rbtree of currently backlogged queues, sorted by virtual time
+- * @schedule_pos: the current position maintained while a driver walks the tree
+- *                with ieee80211_next_txq()
+- * @active_list: list of struct airtime_info structs that were active within
+- *               the last AIRTIME_ACTIVE_DURATION (100 ms), used to compute
+- *               weight_sum
+- * @last_weight_update: used for rate limiting walking active_list
+- * @last_schedule_time: tracks the last time a transmission was scheduled; used
+- *                      for catching up v_t if no stations are eligible for
+- *                      transmission.
+- * @v_t: global virtual time; queues with v_t < this are eligible for
+- *       transmission
+- * @weight_sum: total sum of all active stations used for dividing airtime
+- * @weight_sum_reciprocal: reciprocal of weight_sum (to avoid divisions in fast
+- *                         path - see comment above
+- *                         IEEE80211_RECIPROCAL_DIVISOR_64)
+- * @aql_txq_limit_low: AQL limit when total outstanding airtime
+- *                     is < IEEE80211_AQL_THRESHOLD
+- * @aql_txq_limit_high: AQL limit when total outstanding airtime
+- *                      is > IEEE80211_AQL_THRESHOLD
+- */
+-struct airtime_sched_info {
+-	spinlock_t lock;
+-	struct rb_root_cached active_txqs;
+-	struct rb_node *schedule_pos;
+-	struct list_head active_list;
+-	u64 last_weight_update;
+-	u64 last_schedule_activity;
+-	u64 v_t;
+-	u64 weight_sum;
+-	u64 weight_sum_reciprocal;
+-	u32 aql_txq_limit_low;
+-	u32 aql_txq_limit_high;
+-};
+ DECLARE_STATIC_KEY_FALSE(aql_disable);
+ 
+ struct ieee80211_local {
+@@ -1235,8 +1199,13 @@ struct ieee80211_local {
+ 	struct codel_params cparams;
+ 
+ 	/* protects active_txqs and txqi->schedule_order */
+-	struct airtime_sched_info airtime[IEEE80211_NUM_ACS];
++	spinlock_t active_txq_lock[IEEE80211_NUM_ACS];
++	struct list_head active_txqs[IEEE80211_NUM_ACS];
++	u16 schedule_round[IEEE80211_NUM_ACS];
++
+ 	u16 airtime_flags;
++	u32 aql_txq_limit_low[IEEE80211_NUM_ACS];
++	u32 aql_txq_limit_high[IEEE80211_NUM_ACS];
+ 	u32 aql_threshold;
+ 	atomic_t aql_total_pending_airtime;
+ 
+@@ -1660,125 +1629,6 @@ static inline bool txq_has_queue(struct
+ 	return !(skb_queue_empty(&txqi->frags) && !txqi->tin.backlog_packets);
+ }
+ 
+-static inline struct airtime_info *to_airtime_info(struct ieee80211_txq *txq)
+-{
+-	struct ieee80211_sub_if_data *sdata;
+-	struct sta_info *sta;
+-
+-	if (txq->sta) {
+-		sta = container_of(txq->sta, struct sta_info, sta);
+-		return &sta->airtime[txq->ac];
+-	}
+-
+-	sdata = vif_to_sdata(txq->vif);
+-	return &sdata->airtime[txq->ac];
+-}
+-
+-/* To avoid divisions in the fast path, we keep pre-computed reciprocals for
+- * airtime weight calculations. There are two different weights to keep track
+- * of: The per-station weight and the sum of weights per phy.
+- *
+- * For the per-station weights (kept in airtime_info below), we use 32-bit
+- * reciprocals with a devisor of 2^19. This lets us keep the multiplications and
+- * divisions for the station weights as 32-bit operations at the cost of a bit
+- * of rounding error for high weights; but the choice of divisor keeps rounding
+- * errors <10% for weights <2^15, assuming no more than 8ms of airtime is
+- * reported at a time.
+- *
+- * For the per-phy sum of weights the values can get higher, so we use 64-bit
+- * operations for those with a 32-bit divisor, which should avoid any
+- * significant rounding errors.
+- */
+-#define IEEE80211_RECIPROCAL_DIVISOR_64 0x100000000ULL
+-#define IEEE80211_RECIPROCAL_SHIFT_64 32
+-#define IEEE80211_RECIPROCAL_DIVISOR_32 0x80000U
+-#define IEEE80211_RECIPROCAL_SHIFT_32 19
+-
+-static inline void airtime_weight_set(struct airtime_info *air_info, u16 weight)
+-{
+-	if (air_info->weight == weight)
+-		return;
+-
+-	air_info->weight = weight;
+-	if (weight) {
+-		air_info->weight_reciprocal =
+-			IEEE80211_RECIPROCAL_DIVISOR_32 / weight;
+-	} else {
+-		air_info->weight_reciprocal = 0;
+-	}
+-}
+-
+-static inline void airtime_weight_sum_set(struct airtime_sched_info *air_sched,
+-					  int weight_sum)
+-{
+-	if (air_sched->weight_sum == weight_sum)
+-		return;
+-
+-	air_sched->weight_sum = weight_sum;
+-	if (air_sched->weight_sum) {
+-		air_sched->weight_sum_reciprocal = IEEE80211_RECIPROCAL_DIVISOR_64;
+-		do_div(air_sched->weight_sum_reciprocal, air_sched->weight_sum);
+-	} else {
+-		air_sched->weight_sum_reciprocal = 0;
+-	}
+-}
+-
+-/* A problem when trying to enforce airtime fairness is that we want to divide
+- * the airtime between the currently *active* stations. However, basing this on
+- * the instantaneous queue state of stations doesn't work, as queues tend to
+- * oscillate very quickly between empty and occupied, leading to the scheduler
+- * thinking only a single station is active when deciding whether to allow
+- * transmission (and thus not throttling correctly).
+- *
+- * To fix this we use a timer-based notion of activity: a station is considered
+- * active if it has been scheduled within the last 100 ms; we keep a separate
+- * list of all the stations considered active in this manner, and lazily update
+- * the total weight of active stations from this list (filtering the stations in
+- * the list by their 'last active' time).
+- *
+- * We add one additional safeguard to guard against stations that manage to get
+- * scheduled every 100 ms but don't transmit a lot of data, and thus don't use
+- * up any airtime. Such stations would be able to get priority for an extended
+- * period of time if they do start transmitting at full capacity again, and so
+- * we add an explicit maximum for how far behind a station is allowed to fall in
+- * the virtual airtime domain. This limit is set to a relatively high value of
+- * 20 ms because the main mechanism for catching up idle stations is the active
+- * state as described above; i.e., the hard limit should only be hit in
+- * pathological cases.
+- */
+-#define AIRTIME_ACTIVE_DURATION (100 * NSEC_PER_MSEC)
+-#define AIRTIME_MAX_BEHIND 20000 /* 20 ms */
+-
+-static inline bool airtime_is_active(struct airtime_info *air_info, u64 now)
+-{
+-	return air_info->last_scheduled >= now - AIRTIME_ACTIVE_DURATION;
+-}
+-
+-static inline void airtime_set_active(struct airtime_sched_info *air_sched,
+-				      struct airtime_info *air_info, u64 now)
+-{
+-	air_info->last_scheduled = now;
+-	air_sched->last_schedule_activity = now;
+-	list_move_tail(&air_info->list, &air_sched->active_list);
+-}
+-
+-static inline bool airtime_catchup_v_t(struct airtime_sched_info *air_sched,
+-				       u64 v_t, u64 now)
+-{
+-	air_sched->v_t = v_t;
+-	return true;
+-}
+-
+-static inline void init_airtime_info(struct airtime_info *air_info,
+-				     struct airtime_sched_info *air_sched)
+-{
+-	atomic_set(&air_info->aql_tx_pending, 0);
+-	air_info->aql_limit_low = air_sched->aql_txq_limit_low;
+-	air_info->aql_limit_high = air_sched->aql_txq_limit_high;
+-	airtime_weight_set(air_info, IEEE80211_DEFAULT_AIRTIME_WEIGHT);
+-	INIT_LIST_HEAD(&air_info->list);
+-}
+-
+ static inline int ieee80211_bssid_match(const u8 *raddr, const u8 *addr)
+ {
+ 	return ether_addr_equal(raddr, addr) ||
+@@ -2024,14 +1874,6 @@ int ieee80211_tx_control_port(struct wip
+ 			      u64 *cookie);
+ int ieee80211_probe_mesh_link(struct wiphy *wiphy, struct net_device *dev,
+ 			      const u8 *buf, size_t len);
+-void ieee80211_resort_txq(struct ieee80211_hw *hw,
+-			  struct ieee80211_txq *txq);
+-void ieee80211_unschedule_txq(struct ieee80211_hw *hw,
+-			      struct ieee80211_txq *txq,
+-			      bool purge);
+-void ieee80211_update_airtime_weight(struct ieee80211_local *local,
+-				     struct airtime_sched_info *air_sched,
+-				     u64 now, bool force);
+ 
+ /* HT */
+ void ieee80211_apply_htcap_overrides(struct ieee80211_sub_if_data *sdata,
+--- a/net/mac80211/iface.c
++++ b/net/mac80211/iface.c
+@@ -2192,9 +2192,6 @@ int ieee80211_if_add(struct ieee80211_lo
+ 		}
+ 	}
+ 
+-	for (i = 0; i < IEEE80211_NUM_ACS; i++)
+-		init_airtime_info(&sdata->airtime[i], &local->airtime[i]);
+-
+ 	ieee80211_set_default_queues(sdata);
+ 
+ 	sdata->ap_power_level = IEEE80211_UNSET_POWER_LEVEL;
+--- a/net/mac80211/main.c
++++ b/net/mac80211/main.c
+@@ -707,13 +707,10 @@ struct ieee80211_hw *ieee80211_alloc_hw_
+ 	spin_lock_init(&local->queue_stop_reason_lock);
+ 
+ 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+-		struct airtime_sched_info *air_sched = &local->airtime[i];
+-
+-		air_sched->active_txqs = RB_ROOT_CACHED;
+-		INIT_LIST_HEAD(&air_sched->active_list);
+-		spin_lock_init(&air_sched->lock);
+-		air_sched->aql_txq_limit_low = IEEE80211_DEFAULT_AQL_TXQ_LIMIT_L;
+-		air_sched->aql_txq_limit_high =
++		INIT_LIST_HEAD(&local->active_txqs[i]);
++		spin_lock_init(&local->active_txq_lock[i]);
++		local->aql_txq_limit_low[i] = IEEE80211_DEFAULT_AQL_TXQ_LIMIT_L;
++		local->aql_txq_limit_high[i] =
+ 			IEEE80211_DEFAULT_AQL_TXQ_LIMIT_H;
+ 	}
+ 
+--- a/net/mac80211/rx.c
++++ b/net/mac80211/rx.c
+@@ -1583,8 +1583,12 @@ static void sta_ps_start(struct sta_info
+ 
+ 	for (tid = 0; tid < IEEE80211_NUM_TIDS; tid++) {
+ 		struct ieee80211_txq *txq = sta->sta.txq[tid];
++		struct txq_info *txqi = to_txq_info(txq);
+ 
+-		ieee80211_unschedule_txq(&local->hw, txq, false);
++		spin_lock(&local->active_txq_lock[txq->ac]);
++		if (!list_empty(&txqi->schedule_order))
++			list_del_init(&txqi->schedule_order);
++		spin_unlock(&local->active_txq_lock[txq->ac]);
+ 
+ 		if (txq_has_queue(txq))
+ 			set_bit(tid, &sta->txq_buffered_tids);
+--- a/net/mac80211/sta_info.c
++++ b/net/mac80211/sta_info.c
+@@ -426,11 +426,15 @@ struct sta_info *sta_info_alloc(struct i
+ 	if (sta_prepare_rate_control(local, sta, gfp))
+ 		goto free_txq;
+ 
++	sta->airtime_weight = IEEE80211_DEFAULT_AIRTIME_WEIGHT;
+ 
+ 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+ 		skb_queue_head_init(&sta->ps_tx_buf[i]);
+ 		skb_queue_head_init(&sta->tx_filtered[i]);
+-		init_airtime_info(&sta->airtime[i], &local->airtime[i]);
++		sta->airtime[i].deficit = sta->airtime_weight;
++		atomic_set(&sta->airtime[i].aql_tx_pending, 0);
++		sta->airtime[i].aql_limit_low = local->aql_txq_limit_low[i];
++		sta->airtime[i].aql_limit_high = local->aql_txq_limit_high[i];
+ 	}
+ 
+ 	for (i = 0; i < IEEE80211_NUM_TIDS; i++)
+@@ -1889,59 +1893,24 @@ void ieee80211_sta_set_buffered(struct i
+ }
+ EXPORT_SYMBOL(ieee80211_sta_set_buffered);
+ 
+-void ieee80211_register_airtime(struct ieee80211_txq *txq,
+-				u32 tx_airtime, u32 rx_airtime)
++void ieee80211_sta_register_airtime(struct ieee80211_sta *pubsta, u8 tid,
++				    u32 tx_airtime, u32 rx_airtime)
+ {
+-	struct ieee80211_sub_if_data *sdata = vif_to_sdata(txq->vif);
+-	struct ieee80211_local *local = sdata->local;
+-	u64 weight_sum, weight_sum_reciprocal;
+-	struct airtime_sched_info *air_sched;
+-	struct airtime_info *air_info;
++	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
++	struct ieee80211_local *local = sta->sdata->local;
++	u8 ac = ieee80211_ac_from_tid(tid);
+ 	u32 airtime = 0;
+ 
+-	air_sched = &local->airtime[txq->ac];
+-	air_info = to_airtime_info(txq);
+-
+-	if (local->airtime_flags & AIRTIME_USE_TX)
++	if (sta->local->airtime_flags & AIRTIME_USE_TX)
+ 		airtime += tx_airtime;
+-	if (local->airtime_flags & AIRTIME_USE_RX)
++	if (sta->local->airtime_flags & AIRTIME_USE_RX)
+ 		airtime += rx_airtime;
+ 
+-	/* Weights scale so the unit weight is 256 */
+-	airtime <<= 8;
+-
+-	spin_lock_bh(&air_sched->lock);
+-
+-	air_info->tx_airtime += tx_airtime;
+-	air_info->rx_airtime += rx_airtime;
+-
+-	if (air_sched->weight_sum) {
+-		weight_sum = air_sched->weight_sum;
+-		weight_sum_reciprocal = air_sched->weight_sum_reciprocal;
+-	} else {
+-		weight_sum = air_info->weight;
+-		weight_sum_reciprocal = air_info->weight_reciprocal;
+-	}
+-
+-	/* Round the calculation of global vt */
+-	air_sched->v_t += (u64)((airtime + (weight_sum >> 1)) *
+-				weight_sum_reciprocal) >> IEEE80211_RECIPROCAL_SHIFT_64;
+-	air_info->v_t += (u32)((airtime + (air_info->weight >> 1)) *
+-			       air_info->weight_reciprocal) >> IEEE80211_RECIPROCAL_SHIFT_32;
+-	ieee80211_resort_txq(&local->hw, txq);
+-
+-	spin_unlock_bh(&air_sched->lock);
+-}
+-
+-void ieee80211_sta_register_airtime(struct ieee80211_sta *pubsta, u8 tid,
+-				    u32 tx_airtime, u32 rx_airtime)
+-{
+-	struct ieee80211_txq *txq = pubsta->txq[tid];
+-
+-	if (!txq)
+-		return;
+-
+-	ieee80211_register_airtime(txq, tx_airtime, rx_airtime);
++	spin_lock_bh(&local->active_txq_lock[ac]);
++	sta->airtime[ac].tx_airtime += tx_airtime;
++	sta->airtime[ac].rx_airtime += rx_airtime;
++	sta->airtime[ac].deficit -= airtime;
++	spin_unlock_bh(&local->active_txq_lock[ac]);
+ }
+ EXPORT_SYMBOL(ieee80211_sta_register_airtime);
+ 
+@@ -2385,7 +2354,7 @@ void sta_set_sinfo(struct sta_info *sta,
+ 	}
+ 
+ 	if (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_AIRTIME_WEIGHT))) {
+-		sinfo->airtime_weight = sta->airtime[0].weight;
++		sinfo->airtime_weight = sta->airtime_weight;
+ 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_AIRTIME_WEIGHT);
+ 	}
+ 
+--- a/net/mac80211/sta_info.h
++++ b/net/mac80211/sta_info.h
+@@ -135,25 +135,18 @@ enum ieee80211_agg_stop_reason {
+ #define AIRTIME_USE_TX		BIT(0)
+ #define AIRTIME_USE_RX		BIT(1)
+ 
+-
+ struct airtime_info {
+ 	u64 rx_airtime;
+ 	u64 tx_airtime;
+-	u64 v_t;
+-	u64 last_scheduled;
+-	struct list_head list;
++	s64 deficit;
+ 	atomic_t aql_tx_pending; /* Estimated airtime for frames pending */
+ 	u32 aql_limit_low;
+ 	u32 aql_limit_high;
+-	u32 weight_reciprocal;
+-	u16 weight;
+ };
+ 
+ void ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,
+ 					  struct sta_info *sta, u8 ac,
+ 					  u16 tx_airtime, bool tx_completed);
+-void ieee80211_register_airtime(struct ieee80211_txq *txq,
+-				u32 tx_airtime, u32 rx_airtime);
+ 
+ struct sta_info;
+ 
+@@ -523,6 +516,7 @@ struct ieee80211_fragment_cache {
+  * @tid_seq: per-TID sequence numbers for sending to this STA
+  * @airtime: per-AC struct airtime_info describing airtime statistics for this
+  *	station
++ * @airtime_weight: station weight for airtime fairness calculation purposes
+  * @ampdu_mlme: A-MPDU state machine state
+  * @mesh: mesh STA information
+  * @debugfs_dir: debug filesystem directory dentry
+@@ -653,6 +647,7 @@ struct sta_info {
+ 	u16 tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1];
+ 
+ 	struct airtime_info airtime[IEEE80211_NUM_ACS];
++	u16 airtime_weight;
+ 
+ 	/*
+ 	 * Aggregation information, locked with lock.
+--- a/net/mac80211/status.c
++++ b/net/mac80211/status.c
+@@ -983,25 +983,6 @@ static void __ieee80211_tx_status(struct
+ 		if (!(info->flags & IEEE80211_TX_CTL_INJECTED) && acked)
+ 			ieee80211_frame_acked(sta, skb);
+ 
+-	} else if (wiphy_ext_feature_isset(local->hw.wiphy,
+-					   NL80211_EXT_FEATURE_AIRTIME_FAIRNESS)) {
+-		struct ieee80211_sub_if_data *sdata;
+-		struct ieee80211_txq *txq;
+-		u32 airtime;
+-
+-		/* Account airtime to multicast queue */
+-		sdata = ieee80211_sdata_from_skb(local, skb);
+-
+-		if (sdata && (txq = sdata->vif.txq)) {
+-			airtime = info->status.tx_time ?:
+-				ieee80211_calc_expected_tx_airtime(hw,
+-								   &sdata->vif,
+-								   NULL,
+-								   skb->len,
+-								   false);
+-
+-			ieee80211_register_airtime(txq, airtime, 0);
+-		}
+ 	}
+ 
+ 	/* SNMP counters
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -18,7 +18,6 @@
+ #include <linux/bitmap.h>
+ #include <linux/rcupdate.h>
+ #include <linux/export.h>
+-#include <linux/timekeeping.h>
+ #include <net/net_namespace.h>
+ #include <net/ieee80211_radiotap.h>
+ #include <net/cfg80211.h>
+@@ -1480,7 +1479,7 @@ void ieee80211_txq_init(struct ieee80211
+ 	codel_vars_init(&txqi->def_cvars);
+ 	codel_stats_init(&txqi->cstats);
+ 	__skb_queue_head_init(&txqi->frags);
+-	RB_CLEAR_NODE(&txqi->schedule_order);
++	INIT_LIST_HEAD(&txqi->schedule_order);
+ 
+ 	txqi->txq.vif = &sdata->vif;
+ 
+@@ -1524,7 +1523,9 @@ void ieee80211_txq_purge(struct ieee8021
+ 	ieee80211_purge_tx_queue(&local->hw, &txqi->frags);
+ 	spin_unlock_bh(&fq->lock);
+ 
+-	ieee80211_unschedule_txq(&local->hw, &txqi->txq, true);
++	spin_lock_bh(&local->active_txq_lock[txqi->txq.ac]);
++	list_del_init(&txqi->schedule_order);
++	spin_unlock_bh(&local->active_txq_lock[txqi->txq.ac]);
+ }
+ 
+ void ieee80211_txq_set_params(struct ieee80211_local *local)
+@@ -3819,259 +3820,102 @@ EXPORT_SYMBOL(ieee80211_tx_dequeue);
+ struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
+ {
+ 	struct ieee80211_local *local = hw_to_local(hw);
+-	struct airtime_sched_info *air_sched;
+-	u64 now = ktime_get_coarse_boottime_ns();
+ 	struct ieee80211_txq *ret = NULL;
+-	struct airtime_info *air_info;
+-	struct txq_info *txqi = NULL;
+-	struct rb_node *node;
+-	bool first = false;
++	struct txq_info *txqi = NULL, *head = NULL;
++	bool found_eligible_txq = false;
+ 
+-	air_sched = &local->airtime[ac];
+-	spin_lock_bh(&air_sched->lock);
++	spin_lock_bh(&local->active_txq_lock[ac]);
+ 
+-	node = air_sched->schedule_pos;
+-
+-begin:
+-	if (!node) {
+-		node = rb_first_cached(&air_sched->active_txqs);
+-		first = true;
+-	} else {
+-		node = rb_next(node);
+-	}
+-
+-	if (!node)
+-		goto out;
+-
+-	txqi = container_of(node, struct txq_info, schedule_order);
+-	air_info = to_airtime_info(&txqi->txq);
+-
+-	if (air_info->v_t > air_sched->v_t &&
+-	    (!first || !airtime_catchup_v_t(air_sched, air_info->v_t, now)))
++ begin:
++	txqi = list_first_entry_or_null(&local->active_txqs[ac],
++					struct txq_info,
++					schedule_order);
++	if (!txqi)
+ 		goto out;
+ 
+-	if (!ieee80211_txq_airtime_check(hw, &txqi->txq)) {
+-		first = false;
+-		goto begin;
+-	}
+-
+-	air_sched->schedule_pos = node;
+-	air_sched->last_schedule_activity = now;
+-	ret = &txqi->txq;
+-out:
+-	spin_unlock_bh(&air_sched->lock);
+-	return ret;
+-}
+-EXPORT_SYMBOL(ieee80211_next_txq);
+-
+-static void __ieee80211_insert_txq(struct rb_root_cached *root,
+-				   struct txq_info *txqi)
+-{
+-	struct rb_node **new = &root->rb_root.rb_node;
+-	struct airtime_info *old_air, *new_air;
+-	struct rb_node *parent = NULL;
+-	struct txq_info *__txqi;
+-	bool leftmost = true;
+-
+-	while (*new) {
+-		parent = *new;
+-		__txqi = rb_entry(parent, struct txq_info, schedule_order);
+-		old_air = to_airtime_info(&__txqi->txq);
+-		new_air = to_airtime_info(&txqi->txq);
+-
+-		if (new_air->v_t <= old_air->v_t) {
+-			new = &parent->rb_left;
+-		} else {
+-			new = &parent->rb_right;
+-			leftmost = false;
+-		}
++	if (txqi == head) {
++		if (!found_eligible_txq)
++			goto out;
++		else
++			found_eligible_txq = false;
+ 	}
+ 
+-	rb_link_node(&txqi->schedule_order, parent, new);
+-	rb_insert_color_cached(&txqi->schedule_order, root, leftmost);
+-}
+-
+-void ieee80211_resort_txq(struct ieee80211_hw *hw,
+-			  struct ieee80211_txq *txq)
+-{
+-	struct airtime_info *air_info = to_airtime_info(txq);
+-	struct ieee80211_local *local = hw_to_local(hw);
+-	struct txq_info *txqi = to_txq_info(txq);
+-	struct airtime_sched_info *air_sched;
+-
+-	air_sched = &local->airtime[txq->ac];
++	if (!head)
++		head = txqi;
+ 
+-	lockdep_assert_held(&air_sched->lock);
+-
+-	if (!RB_EMPTY_NODE(&txqi->schedule_order)) {
+-		struct airtime_info *a_prev = NULL, *a_next = NULL;
+-		struct txq_info *t_prev, *t_next;
+-		struct rb_node *n_prev, *n_next;
++	if (txqi->txq.sta) {
++		struct sta_info *sta = container_of(txqi->txq.sta,
++						    struct sta_info, sta);
++		bool aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);
++		s64 deficit = sta->airtime[txqi->txq.ac].deficit;
+ 
+-		/* Erasing a node can cause an expensive rebalancing operation,
+-		 * so we check the previous and next nodes first and only remove
+-		 * and re-insert if the current node is not already in the
+-		 * correct position.
+-		 */
+-		if ((n_prev = rb_prev(&txqi->schedule_order)) != NULL) {
+-			t_prev = container_of(n_prev, struct txq_info,
+-					      schedule_order);
+-			a_prev = to_airtime_info(&t_prev->txq);
+-		}
++		if (aql_check)
++			found_eligible_txq = true;
+ 
+-		if ((n_next = rb_next(&txqi->schedule_order)) != NULL) {
+-			t_next = container_of(n_next, struct txq_info,
+-					      schedule_order);
+-			a_next = to_airtime_info(&t_next->txq);
++		if (deficit < 0)
++			sta->airtime[txqi->txq.ac].deficit +=
++				sta->airtime_weight;
++
++		if (deficit < 0 || !aql_check) {
++			list_move_tail(&txqi->schedule_order,
++				       &local->active_txqs[txqi->txq.ac]);
++			goto begin;
+ 		}
+-
+-		if ((!a_prev || a_prev->v_t <= air_info->v_t) &&
+-		    (!a_next || a_next->v_t > air_info->v_t))
+-			return;
+-
+-		if (air_sched->schedule_pos == &txqi->schedule_order)
+-			air_sched->schedule_pos = n_prev;
+-
+-		rb_erase_cached(&txqi->schedule_order,
+-				&air_sched->active_txqs);
+-		RB_CLEAR_NODE(&txqi->schedule_order);
+-		__ieee80211_insert_txq(&air_sched->active_txqs, txqi);
+ 	}
+-}
+-
+-void ieee80211_update_airtime_weight(struct ieee80211_local *local,
+-				     struct airtime_sched_info *air_sched,
+-				     u64 now, bool force)
+-{
+-	struct airtime_info *air_info, *tmp;
+-	u64 weight_sum = 0;
+-
+-	if (unlikely(!now))
+-		now = ktime_get_coarse_boottime_ns();
+-
+-	lockdep_assert_held(&air_sched->lock);
+-
+-	if (!force && (air_sched->last_weight_update <
+-		       now - AIRTIME_ACTIVE_DURATION))
+-		return;
+-
+-	list_for_each_entry_safe(air_info, tmp,
+-				 &air_sched->active_list, list) {
+-		if (airtime_is_active(air_info, now))
+-			weight_sum += air_info->weight;
+-		else
+-			list_del_init(&air_info->list);
+-	}
+-	airtime_weight_sum_set(air_sched, weight_sum);
+-	air_sched->last_weight_update = now;
+-}
+ 
+-void ieee80211_schedule_txq(struct ieee80211_hw *hw,
+-			    struct ieee80211_txq *txq)
+-	__acquires(txq_lock) __releases(txq_lock)
+-{
+-	struct ieee80211_local *local = hw_to_local(hw);
+-	struct txq_info *txqi = to_txq_info(txq);
+-	struct airtime_sched_info *air_sched;
+-	u64 now = ktime_get_coarse_boottime_ns();
+-	struct airtime_info *air_info;
+-	u8 ac = txq->ac;
+-	bool was_active;
+ 
+-	air_sched = &local->airtime[ac];
+-	air_info = to_airtime_info(txq);
+-
+-	spin_lock_bh(&air_sched->lock);
+-	was_active = airtime_is_active(air_info, now);
+-	airtime_set_active(air_sched, air_info, now);
+-
+-	if (!RB_EMPTY_NODE(&txqi->schedule_order))
++	if (txqi->schedule_round == local->schedule_round[ac])
+ 		goto out;
+ 
+-	/* If the station has been inactive for a while, catch up its v_t so it
+-	 * doesn't get indefinite priority; see comment above the definition of
+-	 * AIRTIME_MAX_BEHIND.
+-	 */
+-	if ((!was_active && air_info->v_t < air_sched->v_t) ||
+-	    air_info->v_t < air_sched->v_t - AIRTIME_MAX_BEHIND)
+-		air_info->v_t = air_sched->v_t;
+-
+-	ieee80211_update_airtime_weight(local, air_sched, now, !was_active);
+-	__ieee80211_insert_txq(&air_sched->active_txqs, txqi);
++	list_del_init(&txqi->schedule_order);
++	txqi->schedule_round = local->schedule_round[ac];
++	ret = &txqi->txq;
+ 
+ out:
+-	spin_unlock_bh(&air_sched->lock);
+-}
+-EXPORT_SYMBOL(ieee80211_schedule_txq);
+-
+-static void __ieee80211_unschedule_txq(struct ieee80211_hw *hw,
+-				       struct ieee80211_txq *txq,
+-				       bool purge)
+-{
+-	struct ieee80211_local *local = hw_to_local(hw);
+-	struct txq_info *txqi = to_txq_info(txq);
+-	struct airtime_sched_info *air_sched;
+-	struct airtime_info *air_info;
+-
+-	air_sched = &local->airtime[txq->ac];
+-	air_info = to_airtime_info(&txqi->txq);
+-
+-	lockdep_assert_held(&air_sched->lock);
+-
+-	if (purge) {
+-		list_del_init(&air_info->list);
+-		ieee80211_update_airtime_weight(local, air_sched, 0, true);
+-	}
+-
+-	if (RB_EMPTY_NODE(&txqi->schedule_order))
+-		return;
+-
+-	if (air_sched->schedule_pos == &txqi->schedule_order)
+-		air_sched->schedule_pos = rb_prev(&txqi->schedule_order);
+-
+-	if (!purge)
+-		airtime_set_active(air_sched, air_info,
+-				   ktime_get_coarse_boottime_ns());
+-
+-	rb_erase_cached(&txqi->schedule_order,
+-			&air_sched->active_txqs);
+-	RB_CLEAR_NODE(&txqi->schedule_order);
++	spin_unlock_bh(&local->active_txq_lock[ac]);
++	return ret;
+ }
++EXPORT_SYMBOL(ieee80211_next_txq);
+ 
+-void ieee80211_unschedule_txq(struct ieee80211_hw *hw,
++void __ieee80211_schedule_txq(struct ieee80211_hw *hw,
+ 			      struct ieee80211_txq *txq,
+-			      bool purge)
+-	__acquires(txq_lock) __releases(txq_lock)
+-{
+-	struct ieee80211_local *local = hw_to_local(hw);
+-
+-	spin_lock_bh(&local->airtime[txq->ac].lock);
+-	__ieee80211_unschedule_txq(hw, txq, purge);
+-	spin_unlock_bh(&local->airtime[txq->ac].lock);
+-}
+-
+-void ieee80211_return_txq(struct ieee80211_hw *hw,
+-			  struct ieee80211_txq *txq, bool force)
++			      bool force)
+ {
+ 	struct ieee80211_local *local = hw_to_local(hw);
+ 	struct txq_info *txqi = to_txq_info(txq);
+ 
+-	spin_lock_bh(&local->airtime[txq->ac].lock);
++	spin_lock_bh(&local->active_txq_lock[txq->ac]);
+ 
+-	if (!RB_EMPTY_NODE(&txqi->schedule_order) && !force &&
+-	    !txq_has_queue(txq))
+-		__ieee80211_unschedule_txq(hw, txq, false);
++	if (list_empty(&txqi->schedule_order) &&
++	    (force || !skb_queue_empty(&txqi->frags) ||
++	     txqi->tin.backlog_packets)) {
++		/* If airtime accounting is active, always enqueue STAs at the
++		 * head of the list to ensure that they only get moved to the
++		 * back by the airtime DRR scheduler once they have a negative
++		 * deficit. A station that already has a negative deficit will
++		 * get immediately moved to the back of the list on the next
++		 * call to ieee80211_next_txq().
++		 */
++		if (txqi->txq.sta && local->airtime_flags &&
++		    wiphy_ext_feature_isset(local->hw.wiphy,
++					    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
++			list_add(&txqi->schedule_order,
++				 &local->active_txqs[txq->ac]);
++		else
++			list_add_tail(&txqi->schedule_order,
++				      &local->active_txqs[txq->ac]);
++	}
+ 
+-	spin_unlock_bh(&local->airtime[txq->ac].lock);
++	spin_unlock_bh(&local->active_txq_lock[txq->ac]);
+ }
+-EXPORT_SYMBOL(ieee80211_return_txq);
++EXPORT_SYMBOL(__ieee80211_schedule_txq);
+ 
+ DEFINE_STATIC_KEY_FALSE(aql_disable);
+ 
+ bool ieee80211_txq_airtime_check(struct ieee80211_hw *hw,
+ 				 struct ieee80211_txq *txq)
+ {
+-	struct airtime_info *air_info = to_airtime_info(txq);
++	struct sta_info *sta;
+ 	struct ieee80211_local *local = hw_to_local(hw);
+ 
+ 	if (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))
+@@ -4086,12 +3930,15 @@ bool ieee80211_txq_airtime_check(struct
+ 	if (unlikely(txq->tid == IEEE80211_NUM_TIDS))
+ 		return true;
+ 
+-	if (atomic_read(&air_info->aql_tx_pending) < air_info->aql_limit_low)
++	sta = container_of(txq->sta, struct sta_info, sta);
++	if (atomic_read(&sta->airtime[txq->ac].aql_tx_pending) <
++	    sta->airtime[txq->ac].aql_limit_low)
+ 		return true;
+ 
+ 	if (atomic_read(&local->aql_total_pending_airtime) <
+ 	    local->aql_threshold &&
+-	    atomic_read(&air_info->aql_tx_pending) < air_info->aql_limit_high)
++	    atomic_read(&sta->airtime[txq->ac].aql_tx_pending) <
++	    sta->airtime[txq->ac].aql_limit_high)
+ 		return true;
+ 
+ 	return false;
+@@ -4101,59 +3948,60 @@ EXPORT_SYMBOL(ieee80211_txq_airtime_chec
+ bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
+ 				struct ieee80211_txq *txq)
+ {
+-	struct txq_info *first_txqi = NULL, *txqi = to_txq_info(txq);
+ 	struct ieee80211_local *local = hw_to_local(hw);
+-	struct airtime_sched_info *air_sched;
+-	struct airtime_info *air_info;
+-	struct rb_node *node = NULL;
+-	bool ret = false;
+-	u64 now;
+-
++	struct txq_info *iter, *tmp, *txqi = to_txq_info(txq);
++	struct sta_info *sta;
++	u8 ac = txq->ac;
+ 
+-	if (!ieee80211_txq_airtime_check(hw, txq))
+-		return false;
++	spin_lock_bh(&local->active_txq_lock[ac]);
+ 
+-	air_sched = &local->airtime[txq->ac];
+-	spin_lock_bh(&air_sched->lock);
++	if (!txqi->txq.sta)
++		goto out;
+ 
+-	if (RB_EMPTY_NODE(&txqi->schedule_order))
++	if (list_empty(&txqi->schedule_order))
+ 		goto out;
+ 
+-	now = ktime_get_coarse_boottime_ns();
++	list_for_each_entry_safe(iter, tmp, &local->active_txqs[ac],
++				 schedule_order) {
++		if (iter == txqi)
++			break;
+ 
+-	/* Like in ieee80211_next_txq(), make sure the first station in the
+-	 * scheduling order is eligible for transmission to avoid starvation.
+-	 */
+-	node = rb_first_cached(&air_sched->active_txqs);
+-	if (node) {
+-		first_txqi = container_of(node, struct txq_info,
+-					  schedule_order);
+-		air_info = to_airtime_info(&first_txqi->txq);
+-
+-		if (air_sched->v_t < air_info->v_t)
+-			airtime_catchup_v_t(air_sched, air_info->v_t, now);
++		if (!iter->txq.sta) {
++			list_move_tail(&iter->schedule_order,
++				       &local->active_txqs[ac]);
++			continue;
++		}
++		sta = container_of(iter->txq.sta, struct sta_info, sta);
++		if (sta->airtime[ac].deficit < 0)
++			sta->airtime[ac].deficit += sta->airtime_weight;
++		list_move_tail(&iter->schedule_order, &local->active_txqs[ac]);
+ 	}
+ 
+-	air_info = to_airtime_info(&txqi->txq);
+-	if (air_info->v_t <= air_sched->v_t) {
+-		air_sched->last_schedule_activity = now;
+-		ret = true;
+-	}
++	sta = container_of(txqi->txq.sta, struct sta_info, sta);
++	if (sta->airtime[ac].deficit >= 0)
++		goto out;
++
++	sta->airtime[ac].deficit += sta->airtime_weight;
++	list_move_tail(&txqi->schedule_order, &local->active_txqs[ac]);
++	spin_unlock_bh(&local->active_txq_lock[ac]);
+ 
++	return false;
+ out:
+-	spin_unlock_bh(&air_sched->lock);
+-	return ret;
++	if (!list_empty(&txqi->schedule_order))
++		list_del_init(&txqi->schedule_order);
++	spin_unlock_bh(&local->active_txq_lock[ac]);
++
++	return true;
+ }
+ EXPORT_SYMBOL(ieee80211_txq_may_transmit);
+ 
+ void ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac)
+ {
+ 	struct ieee80211_local *local = hw_to_local(hw);
+-	struct airtime_sched_info *air_sched = &local->airtime[ac];
+ 
+-	spin_lock_bh(&air_sched->lock);
+-	air_sched->schedule_pos = NULL;
+-	spin_unlock_bh(&air_sched->lock);
++	spin_lock_bh(&local->active_txq_lock[ac]);
++	local->schedule_round[ac]++;
++	spin_unlock_bh(&local->active_txq_lock[ac]);
+ }
+ EXPORT_SYMBOL(ieee80211_txq_schedule_start);
+ 
diff --git a/package/kernel/mac80211/patches/subsys/331-mac80211-make-sta-airtime-deficit-field-s32-instead-.patch b/package/kernel/mac80211/patches/subsys/331-mac80211-make-sta-airtime-deficit-field-s32-instead-.patch
new file mode 100644
index 0000000000..c006d3762a
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/331-mac80211-make-sta-airtime-deficit-field-s32-instead-.patch
@@ -0,0 +1,52 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 20 Jun 2022 14:53:04 +0200
+Subject: [PATCH] mac80211: make sta airtime deficit field s32 instead of
+ s64
+
+32 bit is more than enough range for the airtime deficit
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/debugfs_sta.c
++++ b/net/mac80211/debugfs_sta.c
+@@ -202,7 +202,7 @@ static ssize_t sta_airtime_read(struct f
+ 	size_t bufsz = 400;
+ 	char *buf = kzalloc(bufsz, GFP_KERNEL), *p = buf;
+ 	u64 rx_airtime = 0, tx_airtime = 0;
+-	s64 deficit[IEEE80211_NUM_ACS];
++	s32 deficit[IEEE80211_NUM_ACS];
+ 	ssize_t rv;
+ 	int ac;
+ 
+@@ -219,7 +219,7 @@ static ssize_t sta_airtime_read(struct f
+ 
+ 	p += scnprintf(p, bufsz + buf - p,
+ 		"RX: %llu us\nTX: %llu us\nWeight: %u\n"
+-		"Deficit: VO: %lld us VI: %lld us BE: %lld us BK: %lld us\n",
++		"Deficit: VO: %d us VI: %d us BE: %d us BK: %d us\n",
+ 		rx_airtime, tx_airtime, sta->airtime_weight,
+ 		deficit[0], deficit[1], deficit[2], deficit[3]);
+ 
+--- a/net/mac80211/sta_info.h
++++ b/net/mac80211/sta_info.h
+@@ -138,7 +138,7 @@ enum ieee80211_agg_stop_reason {
+ struct airtime_info {
+ 	u64 rx_airtime;
+ 	u64 tx_airtime;
+-	s64 deficit;
++	s32 deficit;
+ 	atomic_t aql_tx_pending; /* Estimated airtime for frames pending */
+ 	u32 aql_limit_low;
+ 	u32 aql_limit_high;
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -3847,7 +3847,7 @@ struct ieee80211_txq *ieee80211_next_txq
+ 		struct sta_info *sta = container_of(txqi->txq.sta,
+ 						    struct sta_info, sta);
+ 		bool aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);
+-		s64 deficit = sta->airtime[txqi->txq.ac].deficit;
++		s32 deficit = sta->airtime[txqi->txq.ac].deficit;
+ 
+ 		if (aql_check)
+ 			found_eligible_txq = true;
diff --git a/package/kernel/mac80211/patches/subsys/332-mac80211-consider-aql_tx_pending-when-checking-airti.patch b/package/kernel/mac80211/patches/subsys/332-mac80211-consider-aql_tx_pending-when-checking-airti.patch
new file mode 100644
index 0000000000..c214294603
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/332-mac80211-consider-aql_tx_pending-when-checking-airti.patch
@@ -0,0 +1,48 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 20 Jun 2022 14:59:09 +0200
+Subject: [PATCH] mac80211: consider aql_tx_pending when checking airtime
+ deficit
+
+When queueing packets for a station, deficit only gets added once the packets
+have been transmitted, which could be much later. During that time, a lot of
+temporary unfairness could happen, which could lead to bursty behavior.
+Fix this by subtracting the aql_tx_pending when checking the deficit in tx
+scheduling.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -3817,6 +3817,13 @@ out:
+ }
+ EXPORT_SYMBOL(ieee80211_tx_dequeue);
+ 
++static inline s32 ieee80211_sta_deficit(struct sta_info *sta, u8 ac)
++{
++	struct airtime_info *air_info = &sta->airtime[ac];
++
++	return air_info->deficit - atomic_read(&air_info->aql_tx_pending);
++}
++
+ struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
+ {
+ 	struct ieee80211_local *local = hw_to_local(hw);
+@@ -3847,7 +3854,7 @@ struct ieee80211_txq *ieee80211_next_txq
+ 		struct sta_info *sta = container_of(txqi->txq.sta,
+ 						    struct sta_info, sta);
+ 		bool aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);
+-		s32 deficit = sta->airtime[txqi->txq.ac].deficit;
++		s32 deficit = ieee80211_sta_deficit(sta, txqi->txq.ac);
+ 
+ 		if (aql_check)
+ 			found_eligible_txq = true;
+@@ -3972,7 +3979,7 @@ bool ieee80211_txq_may_transmit(struct i
+ 			continue;
+ 		}
+ 		sta = container_of(iter->txq.sta, struct sta_info, sta);
+-		if (sta->airtime[ac].deficit < 0)
++		if (ieee80211_sta_deficit(sta, ac) < 0)
+ 			sta->airtime[ac].deficit += sta->airtime_weight;
+ 		list_move_tail(&iter->schedule_order, &local->active_txqs[ac]);
+ 	}
diff --git a/package/kernel/mac80211/patches/subsys/333-mac80211-keep-recently-active-tx-queues-in-schedulin.patch b/package/kernel/mac80211/patches/subsys/333-mac80211-keep-recently-active-tx-queues-in-schedulin.patch
new file mode 100644
index 0000000000..317e4f0653
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/333-mac80211-keep-recently-active-tx-queues-in-schedulin.patch
@@ -0,0 +1,118 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 20 Jun 2022 20:52:50 +0200
+Subject: [PATCH] mac80211: keep recently active tx queues in scheduling
+ list
+
+This allows proper deficit accounting to ensure that they don't carry their
+deficit until the next time they become active
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -83,6 +83,13 @@ extern const u8 ieee80211_ac_to_qos_mask
+ 
+ #define IEEE80211_MAX_NAN_INSTANCE_ID 255
+ 
++
++/*
++ * Keep a station's queues on the active list for deficit accounting purposes
++ * if it was active or queued during the last 100ms
++ */
++#define AIRTIME_ACTIVE_DURATION (HZ / 10)
++
+ struct ieee80211_bss {
+ 	u32 device_ts_beacon, device_ts_presp;
+ 
+--- a/net/mac80211/sta_info.h
++++ b/net/mac80211/sta_info.h
+@@ -138,6 +138,7 @@ enum ieee80211_agg_stop_reason {
+ struct airtime_info {
+ 	u64 rx_airtime;
+ 	u64 tx_airtime;
++	u32 last_active;
+ 	s32 deficit;
+ 	atomic_t aql_tx_pending; /* Estimated airtime for frames pending */
+ 	u32 aql_limit_low;
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -3824,6 +3824,36 @@ static inline s32 ieee80211_sta_deficit(
+ 	return air_info->deficit - atomic_read(&air_info->aql_tx_pending);
+ }
+ 
++static void
++ieee80211_txq_set_active(struct txq_info *txqi)
++{
++	struct sta_info *sta;
++
++	if (!txqi->txq.sta)
++		return;
++
++	sta = container_of(txqi->txq.sta, struct sta_info, sta);
++	sta->airtime[txqi->txq.ac].last_active = (u32)jiffies;
++}
++
++static bool
++ieee80211_txq_keep_active(struct txq_info *txqi)
++{
++	struct sta_info *sta;
++	u32 diff;
++
++	if (!txqi->txq.sta)
++		return false;
++
++	sta = container_of(txqi->txq.sta, struct sta_info, sta);
++	if (ieee80211_sta_deficit(sta, txqi->txq.ac) >= 0)
++		return false;
++
++	diff = (u32)jiffies - sta->airtime[txqi->txq.ac].last_active;
++
++	return diff <= AIRTIME_ACTIVE_DURATION;
++}
++
+ struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
+ {
+ 	struct ieee80211_local *local = hw_to_local(hw);
+@@ -3870,7 +3900,6 @@ struct ieee80211_txq *ieee80211_next_txq
+ 		}
+ 	}
+ 
+-
+ 	if (txqi->schedule_round == local->schedule_round[ac])
+ 		goto out;
+ 
+@@ -3890,12 +3919,13 @@ void __ieee80211_schedule_txq(struct iee
+ {
+ 	struct ieee80211_local *local = hw_to_local(hw);
+ 	struct txq_info *txqi = to_txq_info(txq);
++	bool has_queue;
+ 
+ 	spin_lock_bh(&local->active_txq_lock[txq->ac]);
+ 
++	has_queue = force || txq_has_queue(txq);
+ 	if (list_empty(&txqi->schedule_order) &&
+-	    (force || !skb_queue_empty(&txqi->frags) ||
+-	     txqi->tin.backlog_packets)) {
++	    (has_queue || ieee80211_txq_keep_active(txqi))) {
+ 		/* If airtime accounting is active, always enqueue STAs at the
+ 		 * head of the list to ensure that they only get moved to the
+ 		 * back by the airtime DRR scheduler once they have a negative
+@@ -3903,7 +3933,7 @@ void __ieee80211_schedule_txq(struct iee
+ 		 * get immediately moved to the back of the list on the next
+ 		 * call to ieee80211_next_txq().
+ 		 */
+-		if (txqi->txq.sta && local->airtime_flags &&
++		if (txqi->txq.sta && local->airtime_flags && has_queue &&
+ 		    wiphy_ext_feature_isset(local->hw.wiphy,
+ 					    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
+ 			list_add(&txqi->schedule_order,
+@@ -3911,6 +3941,8 @@ void __ieee80211_schedule_txq(struct iee
+ 		else
+ 			list_add_tail(&txqi->schedule_order,
+ 				      &local->active_txqs[txq->ac]);
++		if (has_queue)
++			ieee80211_txq_set_active(txqi);
+ 	}
+ 
+ 	spin_unlock_bh(&local->active_txq_lock[txq->ac]);
diff --git a/package/kernel/mac80211/patches/subsys/334-mac80211-add-a-per-PHY-AQL-limit-to-improve-fairness.patch b/package/kernel/mac80211/patches/subsys/334-mac80211-add-a-per-PHY-AQL-limit-to-improve-fairness.patch
new file mode 100644
index 0000000000..fb6fd6eac6
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/334-mac80211-add-a-per-PHY-AQL-limit-to-improve-fairness.patch
@@ -0,0 +1,131 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 20 Jun 2022 21:26:34 +0200
+Subject: [PATCH] mac80211: add a per-PHY AQL limit to improve fairness
+
+In order to maintain fairness, the amount of queueing needs to be limited
+beyond the simple per-station AQL budget, otherwise the driver can simply
+repeatedly do scheduling rounds until all queues that have not used their
+AQL budget become eligble.
+
+To be conservative, use the high AQL limit for the first txq and add half
+of the low AQL for each subsequent queue.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -1215,6 +1215,7 @@ struct ieee80211_local {
+ 	u32 aql_txq_limit_high[IEEE80211_NUM_ACS];
+ 	u32 aql_threshold;
+ 	atomic_t aql_total_pending_airtime;
++	atomic_t aql_ac_pending_airtime[IEEE80211_NUM_ACS];
+ 
+ 	const struct ieee80211_ops *ops;
+ 
+--- a/net/mac80211/main.c
++++ b/net/mac80211/main.c
+@@ -712,6 +712,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
+ 		local->aql_txq_limit_low[i] = IEEE80211_DEFAULT_AQL_TXQ_LIMIT_L;
+ 		local->aql_txq_limit_high[i] =
+ 			IEEE80211_DEFAULT_AQL_TXQ_LIMIT_H;
++		atomic_set(&local->aql_ac_pending_airtime[i], 0);
+ 	}
+ 
+ 	local->airtime_flags = AIRTIME_USE_TX | AIRTIME_USE_RX;
+--- a/net/mac80211/sta_info.c
++++ b/net/mac80211/sta_info.c
+@@ -1929,6 +1929,7 @@ void ieee80211_sta_update_pending_airtim
+ 				   &sta->airtime[ac].aql_tx_pending);
+ 
+ 		atomic_add(tx_airtime, &local->aql_total_pending_airtime);
++		atomic_add(tx_airtime, &local->aql_ac_pending_airtime[ac]);
+ 		return;
+ 	}
+ 
+@@ -1940,14 +1941,17 @@ void ieee80211_sta_update_pending_airtim
+ 				       tx_pending, 0);
+ 	}
+ 
++	atomic_sub(tx_airtime, &local->aql_total_pending_airtime);
+ 	tx_pending = atomic_sub_return(tx_airtime,
+-				       &local->aql_total_pending_airtime);
++				       &local->aql_ac_pending_airtime[ac]);
+ 	if (WARN_ONCE(tx_pending < 0,
+ 		      "Device %s AC %d pending airtime underflow: %u, %u",
+ 		      wiphy_name(local->hw.wiphy), ac, tx_pending,
+-		      tx_airtime))
+-		atomic_cmpxchg(&local->aql_total_pending_airtime,
++		      tx_airtime)) {
++		atomic_cmpxchg(&local->aql_ac_pending_airtime[ac],
+ 			       tx_pending, 0);
++		atomic_sub(tx_pending, &local->aql_total_pending_airtime);
++	}
+ }
+ 
+ int sta_info_move_state(struct sta_info *sta,
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -3863,6 +3863,9 @@ struct ieee80211_txq *ieee80211_next_txq
+ 
+ 	spin_lock_bh(&local->active_txq_lock[ac]);
+ 
++	if (!local->schedule_round[ac])
++		goto out;
++
+  begin:
+ 	txqi = list_first_entry_or_null(&local->active_txqs[ac],
+ 					struct txq_info,
+@@ -3984,6 +3987,25 @@ bool ieee80211_txq_airtime_check(struct
+ }
+ EXPORT_SYMBOL(ieee80211_txq_airtime_check);
+ 
++static bool
++ieee80211_txq_schedule_airtime_check(struct ieee80211_local *local, u8 ac)
++{
++	unsigned int num_txq = 0;
++	struct txq_info *txq;
++	u32 aql_limit;
++
++	if (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))
++		return true;
++
++	list_for_each_entry(txq, &local->active_txqs[ac], schedule_order)
++		num_txq++;
++
++	aql_limit = (num_txq - 1) * local->aql_txq_limit_low[ac] / 2 +
++		    local->aql_txq_limit_high[ac];
++
++	return atomic_read(&local->aql_ac_pending_airtime[ac]) < aql_limit;
++}
++
+ bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
+ 				struct ieee80211_txq *txq)
+ {
+@@ -4000,6 +4022,9 @@ bool ieee80211_txq_may_transmit(struct i
+ 	if (list_empty(&txqi->schedule_order))
+ 		goto out;
+ 
++	if (!ieee80211_txq_schedule_airtime_check(local, ac))
++		goto out;
++
+ 	list_for_each_entry_safe(iter, tmp, &local->active_txqs[ac],
+ 				 schedule_order) {
+ 		if (iter == txqi)
+@@ -4039,7 +4064,15 @@ void ieee80211_txq_schedule_start(struct
+ 	struct ieee80211_local *local = hw_to_local(hw);
+ 
+ 	spin_lock_bh(&local->active_txq_lock[ac]);
+-	local->schedule_round[ac]++;
++
++	if (ieee80211_txq_schedule_airtime_check(local, ac)) {
++		local->schedule_round[ac]++;
++		if (!local->schedule_round[ac])
++			local->schedule_round[ac]++;
++	} else {
++		local->schedule_round[ac] = 0;
++	}
++
+ 	spin_unlock_bh(&local->active_txq_lock[ac]);
+ }
+ EXPORT_SYMBOL(ieee80211_txq_schedule_start);
diff --git a/package/kernel/mac80211/patches/subsys/335-mac80211-add-debugfs-file-to-display-per-phy-AQL-pen.patch b/package/kernel/mac80211/patches/subsys/335-mac80211-add-debugfs-file-to-display-per-phy-AQL-pen.patch
new file mode 100644
index 0000000000..df45a520fa
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/335-mac80211-add-debugfs-file-to-display-per-phy-AQL-pen.patch
@@ -0,0 +1,58 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 25 Jun 2022 21:25:40 +0200
+Subject: [PATCH] mac80211: add debugfs file to display per-phy AQL pending
+ airtime
+
+Now that the global pending airtime is more relevant for airtime fairness,
+it makes sense to make it accessible via debugfs for debugging
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/debugfs.c
++++ b/net/mac80211/debugfs.c
+@@ -201,6 +201,36 @@ static const struct file_operations airt
+ 	.llseek = default_llseek,
+ };
+ 
++static ssize_t aql_pending_read(struct file *file,
++				char __user *user_buf,
++				size_t count, loff_t *ppos)
++{
++	struct ieee80211_local *local = file->private_data;
++	char buf[400];
++	int len = 0;
++
++	len = scnprintf(buf, sizeof(buf),
++			"AC     AQL pending\n"
++			"VO     %u us\n"
++			"VI     %u us\n"
++			"BE     %u us\n"
++			"BK     %u us\n"
++			"total  %u us\n",
++			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_VO]),
++			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_VI]),
++			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_BE]),
++			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_BK]),
++			atomic_read(&local->aql_total_pending_airtime));
++	return simple_read_from_buffer(user_buf, count, ppos,
++				       buf, len);
++}
++
++static const struct file_operations aql_pending_ops = {
++	.read = aql_pending_read,
++	.open = simple_open,
++	.llseek = default_llseek,
++};
++
+ static ssize_t aql_txq_limit_read(struct file *file,
+ 				  char __user *user_buf,
+ 				  size_t count,
+@@ -628,6 +658,7 @@ void debugfs_hw_add(struct ieee80211_loc
+ 	DEBUGFS_ADD(hw_conf);
+ 	DEBUGFS_ADD_MODE(force_tx_status, 0600);
+ 	DEBUGFS_ADD_MODE(aql_enable, 0600);
++	DEBUGFS_ADD(aql_pending);
+ 
+ 	if (local->ops->wake_tx_queue)
+ 		DEBUGFS_ADD_MODE(aqm, 0600);
diff --git a/package/kernel/mac80211/patches/subsys/336-mac80211-only-accumulate-airtime-deficit-for-active-.patch b/package/kernel/mac80211/patches/subsys/336-mac80211-only-accumulate-airtime-deficit-for-active-.patch
new file mode 100644
index 0000000000..35f07c1a97
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/336-mac80211-only-accumulate-airtime-deficit-for-active-.patch
@@ -0,0 +1,36 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 25 Jun 2022 23:10:19 +0200
+Subject: [PATCH] mac80211: only accumulate airtime deficit for active
+ clients
+
+When a client does not generate any local tx activity, accumulating airtime
+deficit for the round-robin scheduler can be harmful. If this goes on for too
+long, the deficit could grow quite large, which might cause unreasonable
+initial latency once the client becomes active
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/sta_info.c
++++ b/net/mac80211/sta_info.c
+@@ -1900,6 +1900,7 @@ void ieee80211_sta_register_airtime(stru
+ 	struct ieee80211_local *local = sta->sdata->local;
+ 	u8 ac = ieee80211_ac_from_tid(tid);
+ 	u32 airtime = 0;
++	u32 diff;
+ 
+ 	if (sta->local->airtime_flags & AIRTIME_USE_TX)
+ 		airtime += tx_airtime;
+@@ -1909,7 +1910,11 @@ void ieee80211_sta_register_airtime(stru
+ 	spin_lock_bh(&local->active_txq_lock[ac]);
+ 	sta->airtime[ac].tx_airtime += tx_airtime;
+ 	sta->airtime[ac].rx_airtime += rx_airtime;
+-	sta->airtime[ac].deficit -= airtime;
++
++	diff = (u32)jiffies - sta->airtime[ac].last_active;
++	if (diff <= AIRTIME_ACTIVE_DURATION)
++		sta->airtime[ac].deficit -= airtime;
++
+ 	spin_unlock_bh(&local->active_txq_lock[ac]);
+ }
+ EXPORT_SYMBOL(ieee80211_sta_register_airtime);
diff --git a/package/kernel/mac80211/patches/subsys/337-mac80211-increase-quantum-for-airtime-scheduler.patch b/package/kernel/mac80211/patches/subsys/337-mac80211-increase-quantum-for-airtime-scheduler.patch
new file mode 100644
index 0000000000..74e857679e
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/337-mac80211-increase-quantum-for-airtime-scheduler.patch
@@ -0,0 +1,53 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sun, 26 Jun 2022 11:43:25 +0200
+Subject: [PATCH] mac80211: increase quantum for airtime scheduler
+
+Given the typical AQL budget and queue length, a quantum of 256 with the
+default station weight often requires iterating over all queues frequently,
+until one of them becomes eligible.
+Improve performance by using 8 times station weight as scheduler quantum
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -90,6 +90,8 @@ extern const u8 ieee80211_ac_to_qos_mask
+  */
+ #define AIRTIME_ACTIVE_DURATION (HZ / 10)
+ 
++#define AIRTIME_QUANTUM_SHIFT	3
++
+ struct ieee80211_bss {
+ 	u32 device_ts_beacon, device_ts_presp;
+ 
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -3894,7 +3894,7 @@ struct ieee80211_txq *ieee80211_next_txq
+ 
+ 		if (deficit < 0)
+ 			sta->airtime[txqi->txq.ac].deficit +=
+-				sta->airtime_weight;
++				sta->airtime_weight << AIRTIME_QUANTUM_SHIFT;
+ 
+ 		if (deficit < 0 || !aql_check) {
+ 			list_move_tail(&txqi->schedule_order,
+@@ -4037,7 +4037,8 @@ bool ieee80211_txq_may_transmit(struct i
+ 		}
+ 		sta = container_of(iter->txq.sta, struct sta_info, sta);
+ 		if (ieee80211_sta_deficit(sta, ac) < 0)
+-			sta->airtime[ac].deficit += sta->airtime_weight;
++			sta->airtime[ac].deficit += sta->airtime_weight <<
++						    AIRTIME_QUANTUM_SHIFT;
+ 		list_move_tail(&iter->schedule_order, &local->active_txqs[ac]);
+ 	}
+ 
+@@ -4045,7 +4046,7 @@ bool ieee80211_txq_may_transmit(struct i
+ 	if (sta->airtime[ac].deficit >= 0)
+ 		goto out;
+ 
+-	sta->airtime[ac].deficit += sta->airtime_weight;
++	sta->airtime[ac].deficit += sta->airtime_weight << AIRTIME_QUANTUM_SHIFT;
+ 	list_move_tail(&txqi->schedule_order, &local->active_txqs[ac]);
+ 	spin_unlock_bh(&local->active_txq_lock[ac]);
+ 
diff --git a/package/kernel/mac80211/patches/subsys/337-mac80211-minstrel_ht-clean-up-CCK-code.patch b/package/kernel/mac80211/patches/subsys/337-mac80211-minstrel_ht-clean-up-CCK-code.patch
deleted file mode 100644
index f667d2c94e..0000000000
--- a/package/kernel/mac80211/patches/subsys/337-mac80211-minstrel_ht-clean-up-CCK-code.patch
+++ /dev/null
@@ -1,166 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 25 Dec 2020 16:22:52 +0100
-Subject: [PATCH] mac80211: minstrel_ht: clean up CCK code
-
-- move ack overhead out of rate duration table
-- remove cck_supported, cck_supported_short
-
-Preparation for adding OFDM legacy rates support
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -136,20 +136,16 @@
- 	__VHT_GROUP(_streams, _sgi, _bw,				\
- 		    VHT_GROUP_SHIFT(_streams, _sgi, _bw))
- 
--#define CCK_DURATION(_bitrate, _short, _len)		\
-+#define CCK_DURATION(_bitrate, _short)			\
- 	(1000 * (10 /* SIFS */ +			\
- 	 (_short ? 72 + 24 : 144 + 48) +		\
--	 (8 * (_len + 4) * 10) / (_bitrate)))
--
--#define CCK_ACK_DURATION(_bitrate, _short)			\
--	(CCK_DURATION((_bitrate > 10 ? 20 : 10), false, 60) +	\
--	 CCK_DURATION(_bitrate, _short, AVG_PKT_SIZE))
-+	 (8 * (AVG_PKT_SIZE + 4) * 10) / (_bitrate)))
- 
- #define CCK_DURATION_LIST(_short, _s)			\
--	CCK_ACK_DURATION(10, _short) >> _s,		\
--	CCK_ACK_DURATION(20, _short) >> _s,		\
--	CCK_ACK_DURATION(55, _short) >> _s,		\
--	CCK_ACK_DURATION(110, _short) >> _s
-+	CCK_DURATION(10, _short) >> _s,			\
-+	CCK_DURATION(20, _short) >> _s,			\
-+	CCK_DURATION(55, _short) >> _s,			\
-+	CCK_DURATION(110, _short) >> _s
- 
- #define __CCK_GROUP(_s)					\
- 	[MINSTREL_CCK_GROUP] = {			\
-@@ -163,7 +159,7 @@
- 	}
- 
- #define CCK_GROUP_SHIFT					\
--	GROUP_SHIFT(CCK_ACK_DURATION(10, false))
-+	GROUP_SHIFT(CCK_DURATION(10, false))
- 
- #define CCK_GROUP __CCK_GROUP(CCK_GROUP_SHIFT)
- 
-@@ -349,15 +345,19 @@ int
- minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
- 		       int prob_avg)
- {
--	unsigned int nsecs = 0;
-+	unsigned int nsecs = 0, overhead = mi->overhead;
-+	unsigned int ampdu_len = 1;
- 
- 	/* do not account throughput if sucess prob is below 10% */
- 	if (prob_avg < MINSTREL_FRAC(10, 100))
- 		return 0;
- 
--	if (group != MINSTREL_CCK_GROUP)
--		nsecs = 1000 * mi->overhead / minstrel_ht_avg_ampdu_len(mi);
-+	if (group == MINSTREL_CCK_GROUP)
-+		overhead = mi->overhead_legacy;
-+	else
-+		ampdu_len = minstrel_ht_avg_ampdu_len(mi);
- 
-+	nsecs = 1000 * overhead / ampdu_len;
- 	nsecs += minstrel_mcs_groups[group].duration[rate] <<
- 		 minstrel_mcs_groups[group].shift;
- 
-@@ -1031,7 +1031,10 @@ minstrel_calc_retransmit(struct minstrel
- 	ctime += (t_slot * cw) >> 1;
- 	cw = min((cw << 1) | 1, mp->cw_max);
- 
--	if (index / MCS_GROUP_RATES != MINSTREL_CCK_GROUP) {
-+	if (index / MCS_GROUP_RATES == MINSTREL_CCK_GROUP) {
-+		overhead = mi->overhead_legacy;
-+		overhead_rtscts = mi->overhead_legacy_rtscts;
-+	} else {
- 		overhead = mi->overhead;
- 		overhead_rtscts = mi->overhead_rtscts;
- 	}
-@@ -1369,18 +1372,14 @@ minstrel_ht_update_cck(struct minstrel_p
- 	if (!ieee80211_hw_check(mp->hw, SUPPORTS_HT_CCK_RATES))
- 		return;
- 
--	mi->cck_supported = 0;
--	mi->cck_supported_short = 0;
- 	for (i = 0; i < 4; i++) {
- 		if (!rate_supported(sta, sband->band, mp->cck_rates[i]))
- 			continue;
- 
--		mi->cck_supported |= BIT(i);
-+		mi->supported[MINSTREL_CCK_GROUP] |= BIT(i);
- 		if (sband->bitrates[i].flags & IEEE80211_RATE_SHORT_PREAMBLE)
--			mi->cck_supported_short |= BIT(i);
-+			mi->supported[MINSTREL_CCK_GROUP] |= BIT(i + 4);
- 	}
--
--	mi->supported[MINSTREL_CCK_GROUP] = mi->cck_supported;
- }
- 
- static void
-@@ -1394,12 +1393,13 @@ minstrel_ht_update_caps(void *priv, stru
- 	struct ieee80211_mcs_info *mcs = &sta->ht_cap.mcs;
- 	u16 ht_cap = sta->ht_cap.cap;
- 	struct ieee80211_sta_vht_cap *vht_cap = &sta->vht_cap;
-+	const struct ieee80211_rate *ctl_rate;
-+	bool ldpc, erp;
- 	int use_vht;
- 	int n_supported = 0;
- 	int ack_dur;
- 	int stbc;
- 	int i;
--	bool ldpc;
- 
- 	/* fall back to the old minstrel for legacy stations */
- 	if (!sta->ht_cap.ht_supported)
-@@ -1423,6 +1423,14 @@ minstrel_ht_update_caps(void *priv, stru
- 	mi->overhead += ack_dur;
- 	mi->overhead_rtscts = mi->overhead + 2 * ack_dur;
- 
-+	ctl_rate = &sband->bitrates[rate_lowest_index(sband, sta)];
-+	erp = ctl_rate->flags & IEEE80211_RATE_ERP_G;
-+	ack_dur = ieee80211_frame_duration(sband->band, 10,
-+					   ctl_rate->bitrate, erp, 1,
-+					   ieee80211_chandef_get_shift(chandef));
-+	mi->overhead_legacy = ack_dur;
-+	mi->overhead_legacy_rtscts = mi->overhead_legacy + 2 * ack_dur;
-+
- 	mi->avg_ampdu_len = MINSTREL_FRAC(1, 1);
- 
- 	/* When using MRR, sample more on the first attempt, without delay */
-@@ -1523,8 +1531,6 @@ minstrel_ht_update_caps(void *priv, stru
- 	if (!n_supported)
- 		goto use_legacy;
- 
--	mi->supported[MINSTREL_CCK_GROUP] |= mi->cck_supported_short << 4;
--
- 	/* create an initial rate table with the lowest supported rates */
- 	minstrel_ht_update_stats(mp, mi, true);
- 	minstrel_ht_update_rates(mp, mi);
---- a/net/mac80211/rc80211_minstrel_ht.h
-+++ b/net/mac80211/rc80211_minstrel_ht.h
-@@ -77,6 +77,8 @@ struct minstrel_ht_sta {
- 	/* overhead time in usec for each frame */
- 	unsigned int overhead;
- 	unsigned int overhead_rtscts;
-+	unsigned int overhead_legacy;
-+	unsigned int overhead_legacy_rtscts;
- 
- 	unsigned int total_packets_last;
- 	unsigned int total_packets_cur;
-@@ -97,9 +99,6 @@ struct minstrel_ht_sta {
- 	/* current MCS group to be sampled */
- 	u8 sample_group;
- 
--	u8 cck_supported;
--	u8 cck_supported_short;
--
- 	/* Bitfield of supported MCS rates of all groups */
- 	u16 supported[MINSTREL_GROUPS_NB];
- 
diff --git a/package/kernel/mac80211/patches/subsys/338-mac80211-minstrel_ht-add-support-for-OFDM-rates-on-n.patch b/package/kernel/mac80211/patches/subsys/338-mac80211-minstrel_ht-add-support-for-OFDM-rates-on-n.patch
deleted file mode 100644
index abefde7109..0000000000
--- a/package/kernel/mac80211/patches/subsys/338-mac80211-minstrel_ht-add-support-for-OFDM-rates-on-n.patch
+++ /dev/null
@@ -1,762 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 26 Dec 2020 13:56:42 +0100
-Subject: [PATCH] mac80211: minstrel_ht: add support for OFDM rates on
- non-HT clients
-
-The legacy minstrel code is essentially unmaintained and receives only very
-little testing. In order to bring the significant algorithm improvements from
-minstrel_ht to legacy clients, this patch adds support for OFDM rates to
-minstrel_ht and removes the fallback to the legacy codepath.
-This also makes it work much better on hardware with rate selection constraints,
-e.g. mt76.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel.h
-+++ b/net/mac80211/rc80211_minstrel.h
-@@ -152,6 +152,7 @@ struct minstrel_priv {
- 	unsigned int lookaround_rate_mrr;
- 
- 	u8 cck_rates[4];
-+	u8 ofdm_rates[NUM_NL80211_BANDS][8];
- 
- #ifdef CPTCFG_MAC80211_DEBUGFS
- 	/*
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -163,6 +163,38 @@
- 
- #define CCK_GROUP __CCK_GROUP(CCK_GROUP_SHIFT)
- 
-+#define OFDM_DURATION(_bitrate)				\
-+	(1000 * (16 /* SIFS + signal ext */ +		\
-+	 16 /* T_PREAMBLE */ +				\
-+	 4 /* T_SIGNAL */ +				\
-+	 4 * (((16 + 80 * (AVG_PKT_SIZE + 4) + 6) /	\
-+	      ((_bitrate) * 4)))))
-+
-+#define OFDM_DURATION_LIST(_s)				\
-+	OFDM_DURATION(60) >> _s,			\
-+	OFDM_DURATION(90) >> _s,			\
-+	OFDM_DURATION(120) >> _s,			\
-+	OFDM_DURATION(180) >> _s,			\
-+	OFDM_DURATION(240) >> _s,			\
-+	OFDM_DURATION(360) >> _s,			\
-+	OFDM_DURATION(480) >> _s,			\
-+	OFDM_DURATION(540) >> _s
-+
-+#define __OFDM_GROUP(_s)				\
-+	[MINSTREL_OFDM_GROUP] = {			\
-+		.streams = 1,				\
-+		.flags = 0,				\
-+		.shift = _s,				\
-+		.duration = {				\
-+			OFDM_DURATION_LIST(_s),		\
-+		}					\
-+	}
-+
-+#define OFDM_GROUP_SHIFT				\
-+	GROUP_SHIFT(OFDM_DURATION(60))
-+
-+#define OFDM_GROUP __OFDM_GROUP(OFDM_GROUP_SHIFT)
-+
- 
- static bool minstrel_vht_only = true;
- module_param(minstrel_vht_only, bool, 0644);
-@@ -199,6 +231,7 @@ const struct mcs_group minstrel_mcs_grou
- 	MCS_GROUP(4, 1, BW_40),
- 
- 	CCK_GROUP,
-+	OFDM_GROUP,
- 
- 	VHT_GROUP(1, 0, BW_20),
- 	VHT_GROUP(2, 0, BW_20),
-@@ -231,6 +264,8 @@ const struct mcs_group minstrel_mcs_grou
- 	VHT_GROUP(4, 1, BW_80),
- };
- 
-+const s16 minstrel_cck_bitrates[4] = { 10, 20, 55, 110 };
-+const s16 minstrel_ofdm_bitrates[8] = { 60, 90, 120, 180, 240, 360, 480, 540 };
- static u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES] __read_mostly;
- 
- static void
-@@ -275,6 +310,13 @@ minstrel_get_valid_vht_rates(int bw, int
- 	return 0x3ff & ~mask;
- }
- 
-+static bool
-+minstrel_ht_is_legacy_group(int group)
-+{
-+	return group == MINSTREL_CCK_GROUP ||
-+	       group == MINSTREL_OFDM_GROUP;
-+}
-+
- /*
-  * Look up an MCS group index based on mac80211 rate information
-  */
-@@ -304,21 +346,34 @@ minstrel_ht_get_stats(struct minstrel_pr
- 	if (rate->flags & IEEE80211_TX_RC_MCS) {
- 		group = minstrel_ht_get_group_idx(rate);
- 		idx = rate->idx % 8;
--	} else if (rate->flags & IEEE80211_TX_RC_VHT_MCS) {
-+		goto out;
-+	}
-+
-+	if (rate->flags & IEEE80211_TX_RC_VHT_MCS) {
- 		group = minstrel_vht_get_group_idx(rate);
- 		idx = ieee80211_rate_get_vht_mcs(rate);
--	} else {
--		group = MINSTREL_CCK_GROUP;
-+		goto out;
-+	}
- 
--		for (idx = 0; idx < ARRAY_SIZE(mp->cck_rates); idx++)
--			if (rate->idx == mp->cck_rates[idx])
--				break;
-+	group = MINSTREL_CCK_GROUP;
-+	for (idx = 0; idx < ARRAY_SIZE(mp->cck_rates); idx++) {
-+		if (rate->idx != mp->cck_rates[idx])
-+			continue;
- 
- 		/* short preamble */
- 		if ((mi->supported[group] & BIT(idx + 4)) &&
- 		    (rate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE))
--			idx += 4;
-+				idx += 4;
-+		goto out;
- 	}
-+
-+	group = MINSTREL_OFDM_GROUP;
-+	for (idx = 0; idx < ARRAY_SIZE(mp->ofdm_rates[0]); idx++)
-+		if (rate->idx == mp->ofdm_rates[mi->band][idx])
-+			goto out;
-+
-+	idx = 0;
-+out:
- 	return &mi->groups[group].rates[idx];
- }
- 
-@@ -352,7 +407,7 @@ minstrel_ht_get_tp_avg(struct minstrel_h
- 	if (prob_avg < MINSTREL_FRAC(10, 100))
- 		return 0;
- 
--	if (group == MINSTREL_CCK_GROUP)
-+	if (minstrel_ht_is_legacy_group(group))
- 		overhead = mi->overhead_legacy;
- 	else
- 		ampdu_len = minstrel_ht_avg_ampdu_len(mi);
-@@ -439,8 +494,8 @@ minstrel_ht_set_best_prob_rate(struct mi
- 	/* if max_tp_rate[0] is from MCS_GROUP max_prob_rate get selected from
- 	 * MCS_GROUP as well as CCK_GROUP rates do not allow aggregation */
- 	max_tp_group = mi->max_tp_rate[0] / MCS_GROUP_RATES;
--	if((index / MCS_GROUP_RATES == MINSTREL_CCK_GROUP) &&
--	    (max_tp_group != MINSTREL_CCK_GROUP))
-+	if (minstrel_ht_is_legacy_group(index / MCS_GROUP_RATES) &&
-+	    !minstrel_ht_is_legacy_group(max_tp_group))
- 		return;
- 
- 	max_gpr_group = mg->max_group_prob_rate / MCS_GROUP_RATES;
-@@ -476,13 +531,13 @@ minstrel_ht_set_best_prob_rate(struct mi
- static void
- minstrel_ht_assign_best_tp_rates(struct minstrel_ht_sta *mi,
- 				 u16 tmp_mcs_tp_rate[MAX_THR_RATES],
--				 u16 tmp_cck_tp_rate[MAX_THR_RATES])
-+				 u16 tmp_legacy_tp_rate[MAX_THR_RATES])
- {
- 	unsigned int tmp_group, tmp_idx, tmp_cck_tp, tmp_mcs_tp, tmp_prob;
- 	int i;
- 
--	tmp_group = tmp_cck_tp_rate[0] / MCS_GROUP_RATES;
--	tmp_idx = tmp_cck_tp_rate[0] % MCS_GROUP_RATES;
-+	tmp_group = tmp_legacy_tp_rate[0] / MCS_GROUP_RATES;
-+	tmp_idx = tmp_legacy_tp_rate[0] % MCS_GROUP_RATES;
- 	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
- 	tmp_cck_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);
- 
-@@ -493,7 +548,7 @@ minstrel_ht_assign_best_tp_rates(struct
- 
- 	if (tmp_cck_tp > tmp_mcs_tp) {
- 		for(i = 0; i < MAX_THR_RATES; i++) {
--			minstrel_ht_sort_best_tp_rates(mi, tmp_cck_tp_rate[i],
-+			minstrel_ht_sort_best_tp_rates(mi, tmp_legacy_tp_rate[i],
- 						       tmp_mcs_tp_rate);
- 		}
- 	}
-@@ -511,6 +566,9 @@ minstrel_ht_prob_rate_reduce_streams(str
- 	int tmp_max_streams, group, tmp_idx, tmp_prob;
- 	int tmp_tp = 0;
- 
-+	if (!mi->sta->ht_cap.ht_supported)
-+		return;
-+
- 	tmp_max_streams = minstrel_mcs_groups[mi->max_tp_rate[0] /
- 			  MCS_GROUP_RATES].streams;
- 	for (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {
-@@ -675,7 +733,8 @@ minstrel_ht_update_stats(struct minstrel
- 	struct minstrel_rate_stats *mrs;
- 	int group, i, j, cur_prob;
- 	u16 tmp_mcs_tp_rate[MAX_THR_RATES], tmp_group_tp_rate[MAX_THR_RATES];
--	u16 tmp_cck_tp_rate[MAX_THR_RATES], index;
-+	u16 tmp_legacy_tp_rate[MAX_THR_RATES], index;
-+	bool ht_supported = mi->sta->ht_cap.ht_supported;
- 
- 	mi->sample_mode = MINSTREL_SAMPLE_IDLE;
- 
-@@ -704,21 +763,29 @@ minstrel_ht_update_stats(struct minstrel
- 	mi->sample_count = 0;
- 
- 	memset(tmp_mcs_tp_rate, 0, sizeof(tmp_mcs_tp_rate));
--	memset(tmp_cck_tp_rate, 0, sizeof(tmp_cck_tp_rate));
-+	memset(tmp_legacy_tp_rate, 0, sizeof(tmp_legacy_tp_rate));
- 	if (mi->supported[MINSTREL_CCK_GROUP])
--		for (j = 0; j < ARRAY_SIZE(tmp_cck_tp_rate); j++)
--			tmp_cck_tp_rate[j] = MINSTREL_CCK_GROUP * MCS_GROUP_RATES;
-+		for (j = 0; j < ARRAY_SIZE(tmp_legacy_tp_rate); j++)
-+			tmp_legacy_tp_rate[j] = MINSTREL_CCK_GROUP * MCS_GROUP_RATES;
-+	else if (mi->supported[MINSTREL_OFDM_GROUP])
-+		for (j = 0; j < ARRAY_SIZE(tmp_legacy_tp_rate); j++)
-+			tmp_legacy_tp_rate[j] = MINSTREL_OFDM_GROUP * MCS_GROUP_RATES;
- 
- 	if (mi->supported[MINSTREL_VHT_GROUP_0])
- 		index = MINSTREL_VHT_GROUP_0 * MCS_GROUP_RATES;
--	else
-+	else if (ht_supported)
- 		index = MINSTREL_HT_GROUP_0 * MCS_GROUP_RATES;
-+	else if (mi->supported[MINSTREL_CCK_GROUP])
-+		index = MINSTREL_CCK_GROUP * MCS_GROUP_RATES;
-+	else
-+		index = MINSTREL_OFDM_GROUP * MCS_GROUP_RATES;
- 
- 	for (j = 0; j < ARRAY_SIZE(tmp_mcs_tp_rate); j++)
- 		tmp_mcs_tp_rate[j] = index;
- 
- 	/* Find best rate sets within all MCS groups*/
- 	for (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {
-+		u16 *tp_rate = tmp_mcs_tp_rate;
- 
- 		mg = &mi->groups[group];
- 		if (!mi->supported[group])
-@@ -730,6 +797,9 @@ minstrel_ht_update_stats(struct minstrel
- 		for(j = 0; j < MAX_THR_RATES; j++)
- 			tmp_group_tp_rate[j] = MCS_GROUP_RATES * group;
- 
-+		if (group == MINSTREL_CCK_GROUP && ht_supported)
-+			tp_rate = tmp_legacy_tp_rate;
-+
- 		for (i = 0; i < MCS_GROUP_RATES; i++) {
- 			if (!(mi->supported[group] & BIT(i)))
- 				continue;
-@@ -745,13 +815,7 @@ minstrel_ht_update_stats(struct minstrel
- 				continue;
- 
- 			/* Find max throughput rate set */
--			if (group != MINSTREL_CCK_GROUP) {
--				minstrel_ht_sort_best_tp_rates(mi, index,
--							       tmp_mcs_tp_rate);
--			} else if (group == MINSTREL_CCK_GROUP) {
--				minstrel_ht_sort_best_tp_rates(mi, index,
--							       tmp_cck_tp_rate);
--			}
-+			minstrel_ht_sort_best_tp_rates(mi, index, tp_rate);
- 
- 			/* Find max throughput rate set within a group */
- 			minstrel_ht_sort_best_tp_rates(mi, index,
-@@ -766,7 +830,8 @@ minstrel_ht_update_stats(struct minstrel
- 	}
- 
- 	/* Assign new rate set per sta */
--	minstrel_ht_assign_best_tp_rates(mi, tmp_mcs_tp_rate, tmp_cck_tp_rate);
-+	minstrel_ht_assign_best_tp_rates(mi, tmp_mcs_tp_rate,
-+					 tmp_legacy_tp_rate);
- 	memcpy(mi->max_tp_rate, tmp_mcs_tp_rate, sizeof(mi->max_tp_rate));
- 
- 	/* Try to increase robustness of max_prob_rate*/
-@@ -795,8 +860,11 @@ minstrel_ht_update_stats(struct minstrel
- }
- 
- static bool
--minstrel_ht_txstat_valid(struct minstrel_priv *mp, struct ieee80211_tx_rate *rate)
-+minstrel_ht_txstat_valid(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-+			 struct ieee80211_tx_rate *rate)
- {
-+	int i;
-+
- 	if (rate->idx < 0)
- 		return false;
- 
-@@ -807,10 +875,15 @@ minstrel_ht_txstat_valid(struct minstrel
- 	    rate->flags & IEEE80211_TX_RC_VHT_MCS)
- 		return true;
- 
--	return rate->idx == mp->cck_rates[0] ||
--	       rate->idx == mp->cck_rates[1] ||
--	       rate->idx == mp->cck_rates[2] ||
--	       rate->idx == mp->cck_rates[3];
-+	for (i = 0; i < ARRAY_SIZE(mp->cck_rates); i++)
-+		if (rate->idx == mp->cck_rates[i])
-+			return true;
-+
-+	for (i = 0; i < ARRAY_SIZE(mp->ofdm_rates[0]); i++)
-+		if (rate->idx == mp->ofdm_rates[mi->band][i])
-+			return true;
-+
-+	return false;
- }
- 
- static void
-@@ -897,11 +970,6 @@ minstrel_ht_tx_status(void *priv, struct
- 	bool sample_status = false;
- 	int i;
- 
--	if (!msp->is_ht)
--		return mac80211_minstrel.tx_status_ext(priv, sband,
--						       &msp->legacy, st);
--
--
- 	/* This packet was aggregated but doesn't carry status info */
- 	if ((info->flags & IEEE80211_TX_CTL_AMPDU) &&
- 	    !(info->flags & IEEE80211_TX_STAT_AMPDU))
-@@ -930,10 +998,10 @@ minstrel_ht_tx_status(void *priv, struct
- 	if (mi->sample_mode != MINSTREL_SAMPLE_IDLE)
- 		rate_sample = minstrel_get_ratestats(mi, mi->sample_rate);
- 
--	last = !minstrel_ht_txstat_valid(mp, &ar[0]);
-+	last = !minstrel_ht_txstat_valid(mp, mi, &ar[0]);
- 	for (i = 0; !last; i++) {
- 		last = (i == IEEE80211_TX_MAX_RATES - 1) ||
--		       !minstrel_ht_txstat_valid(mp, &ar[i + 1]);
-+		       !minstrel_ht_txstat_valid(mp, mi, &ar[i + 1]);
- 
- 		rate = minstrel_ht_get_stats(mp, mi, &ar[i]);
- 		if (rate == rate_sample)
-@@ -1031,7 +1099,7 @@ minstrel_calc_retransmit(struct minstrel
- 	ctime += (t_slot * cw) >> 1;
- 	cw = min((cw << 1) | 1, mp->cw_max);
- 
--	if (index / MCS_GROUP_RATES == MINSTREL_CCK_GROUP) {
-+	if (minstrel_ht_is_legacy_group(index / MCS_GROUP_RATES)) {
- 		overhead = mi->overhead_legacy;
- 		overhead_rtscts = mi->overhead_legacy_rtscts;
- 	} else {
-@@ -1064,7 +1132,8 @@ static void
- minstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-                      struct ieee80211_sta_rates *ratetbl, int offset, int index)
- {
--	const struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];
-+	int group_idx = index / MCS_GROUP_RATES;
-+	const struct mcs_group *group = &minstrel_mcs_groups[group_idx];
- 	struct minstrel_rate_stats *mrs;
- 	u8 idx;
- 	u16 flags = group->flags;
-@@ -1083,13 +1152,17 @@ minstrel_ht_set_rate(struct minstrel_pri
- 		ratetbl->rate[offset].count_rts = mrs->retry_count_rtscts;
- 	}
- 
--	if (index / MCS_GROUP_RATES == MINSTREL_CCK_GROUP)
-+	index %= MCS_GROUP_RATES;
-+	if (group_idx == MINSTREL_CCK_GROUP)
- 		idx = mp->cck_rates[index % ARRAY_SIZE(mp->cck_rates)];
-+	else if (group_idx == MINSTREL_OFDM_GROUP)
-+		idx = mp->ofdm_rates[mi->band][index %
-+					       ARRAY_SIZE(mp->ofdm_rates[0])];
- 	else if (flags & IEEE80211_TX_RC_VHT_MCS)
- 		idx = ((group->streams - 1) << 4) |
--		      ((index % MCS_GROUP_RATES) & 0xF);
-+		      (index & 0xF);
- 	else
--		idx = index % MCS_GROUP_RATES + (group->streams - 1) * 8;
-+		idx = index + (group->streams - 1) * 8;
- 
- 	/* enable RTS/CTS if needed:
- 	 *  - if station is in dynamic SMPS (and streams > 1)
-@@ -1304,11 +1377,8 @@ minstrel_ht_get_rate(void *priv, struct
- 	struct minstrel_priv *mp = priv;
- 	int sample_idx;
- 
--	if (!msp->is_ht)
--		return mac80211_minstrel.get_rate(priv, sta, &msp->legacy, txrc);
--
- 	if (!(info->flags & IEEE80211_TX_CTL_AMPDU) &&
--	    mi->max_prob_rate / MCS_GROUP_RATES != MINSTREL_CCK_GROUP)
-+	    !minstrel_ht_is_legacy_group(mi->max_prob_rate / MCS_GROUP_RATES))
- 		minstrel_aggr_check(sta, txrc->skb);
- 
- 	info->flags |= mi->tx_flags;
-@@ -1349,6 +1419,9 @@ minstrel_ht_get_rate(void *priv, struct
- 	if (sample_group == &minstrel_mcs_groups[MINSTREL_CCK_GROUP]) {
- 		int idx = sample_idx % ARRAY_SIZE(mp->cck_rates);
- 		rate->idx = mp->cck_rates[idx];
-+	} else if (sample_group == &minstrel_mcs_groups[MINSTREL_OFDM_GROUP]) {
-+		int idx = sample_idx % ARRAY_SIZE(mp->ofdm_rates[0]);
-+		rate->idx = mp->ofdm_rates[mi->band][idx];
- 	} else if (sample_group->flags & IEEE80211_TX_RC_VHT_MCS) {
- 		ieee80211_rate_set_vht(rate, sample_idx % MCS_GROUP_RATES,
- 				       sample_group->streams);
-@@ -1369,11 +1442,13 @@ minstrel_ht_update_cck(struct minstrel_p
- 	if (sband->band != NL80211_BAND_2GHZ)
- 		return;
- 
--	if (!ieee80211_hw_check(mp->hw, SUPPORTS_HT_CCK_RATES))
-+	if (sta->ht_cap.ht_supported &&
-+	    !ieee80211_hw_check(mp->hw, SUPPORTS_HT_CCK_RATES))
- 		return;
- 
- 	for (i = 0; i < 4; i++) {
--		if (!rate_supported(sta, sband->band, mp->cck_rates[i]))
-+		if (mp->cck_rates[i] == 0xff ||
-+		    !rate_supported(sta, sband->band, mp->cck_rates[i]))
- 			continue;
- 
- 		mi->supported[MINSTREL_CCK_GROUP] |= BIT(i);
-@@ -1383,9 +1458,30 @@ minstrel_ht_update_cck(struct minstrel_p
- }
- 
- static void
-+minstrel_ht_update_ofdm(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-+			struct ieee80211_supported_band *sband,
-+			struct ieee80211_sta *sta)
-+{
-+	const u8 *rates;
-+	int i;
-+
-+	if (sta->ht_cap.ht_supported)
-+		return;
-+
-+	rates = mp->ofdm_rates[sband->band];
-+	for (i = 0; i < ARRAY_SIZE(mp->ofdm_rates[0]); i++) {
-+		if (rates[i] == 0xff ||
-+		    !rate_supported(sta, sband->band, rates[i]))
-+			continue;
-+
-+		mi->supported[MINSTREL_OFDM_GROUP] |= BIT(i);
-+	}
-+}
-+
-+static void
- minstrel_ht_update_caps(void *priv, struct ieee80211_supported_band *sband,
- 			struct cfg80211_chan_def *chandef,
--                        struct ieee80211_sta *sta, void *priv_sta)
-+			struct ieee80211_sta *sta, void *priv_sta)
- {
- 	struct minstrel_priv *mp = priv;
- 	struct minstrel_ht_sta_priv *msp = priv_sta;
-@@ -1401,10 +1497,6 @@ minstrel_ht_update_caps(void *priv, stru
- 	int stbc;
- 	int i;
- 
--	/* fall back to the old minstrel for legacy stations */
--	if (!sta->ht_cap.ht_supported)
--		goto use_legacy;
--
- 	BUILD_BUG_ON(ARRAY_SIZE(minstrel_mcs_groups) != MINSTREL_GROUPS_NB);
- 
- 	if (vht_cap->vht_supported)
-@@ -1412,10 +1504,10 @@ minstrel_ht_update_caps(void *priv, stru
- 	else
- 		use_vht = 0;
- 
--	msp->is_ht = true;
- 	memset(mi, 0, sizeof(*mi));
- 
- 	mi->sta = sta;
-+	mi->band = sband->band;
- 	mi->last_stats_update = jiffies;
- 
- 	ack_dur = ieee80211_frame_duration(sband->band, 10, 60, 1, 1, 0);
-@@ -1464,10 +1556,8 @@ minstrel_ht_update_caps(void *priv, stru
- 		int bw, nss;
- 
- 		mi->supported[i] = 0;
--		if (i == MINSTREL_CCK_GROUP) {
--			minstrel_ht_update_cck(mp, mi, sband, sta);
-+		if (minstrel_ht_is_legacy_group(i))
- 			continue;
--		}
- 
- 		if (gflags & IEEE80211_TX_RC_SHORT_GI) {
- 			if (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH) {
-@@ -1528,22 +1618,12 @@ minstrel_ht_update_caps(void *priv, stru
- 			n_supported++;
- 	}
- 
--	if (!n_supported)
--		goto use_legacy;
-+	minstrel_ht_update_cck(mp, mi, sband, sta);
-+	minstrel_ht_update_ofdm(mp, mi, sband, sta);
- 
- 	/* create an initial rate table with the lowest supported rates */
- 	minstrel_ht_update_stats(mp, mi, true);
- 	minstrel_ht_update_rates(mp, mi);
--
--	return;
--
--use_legacy:
--	msp->is_ht = false;
--	memset(&msp->legacy, 0, sizeof(msp->legacy));
--	msp->legacy.r = msp->ratelist;
--	msp->legacy.sample_table = msp->sample_table;
--	return mac80211_minstrel.rate_init(priv, sband, chandef, sta,
--					   &msp->legacy);
- }
- 
- static void
-@@ -1611,40 +1691,70 @@ minstrel_ht_free_sta(void *priv, struct
- }
- 
- static void
--minstrel_ht_init_cck_rates(struct minstrel_priv *mp)
-+minstrel_ht_fill_rate_array(u8 *dest, struct ieee80211_supported_band *sband,
-+			    const s16 *bitrates, int n_rates, u32 rate_flags)
- {
--	static const int bitrates[4] = { 10, 20, 55, 110 };
--	struct ieee80211_supported_band *sband;
--	u32 rate_flags = ieee80211_chandef_rate_flags(&mp->hw->conf.chandef);
- 	int i, j;
- 
--	sband = mp->hw->wiphy->bands[NL80211_BAND_2GHZ];
--	if (!sband)
--		return;
--
- 	for (i = 0; i < sband->n_bitrates; i++) {
- 		struct ieee80211_rate *rate = &sband->bitrates[i];
- 
--		if (rate->flags & IEEE80211_RATE_ERP_G)
--			continue;
--
- 		if ((rate_flags & sband->bitrates[i].flags) != rate_flags)
- 			continue;
- 
--		for (j = 0; j < ARRAY_SIZE(bitrates); j++) {
-+		for (j = 0; j < n_rates; j++) {
- 			if (rate->bitrate != bitrates[j])
- 				continue;
- 
--			mp->cck_rates[j] = i;
-+			dest[j] = i;
- 			break;
- 		}
- 	}
- }
- 
-+static void
-+minstrel_ht_init_cck_rates(struct minstrel_priv *mp)
-+{
-+	static const s16 bitrates[4] = { 10, 20, 55, 110 };
-+	struct ieee80211_supported_band *sband;
-+	u32 rate_flags = ieee80211_chandef_rate_flags(&mp->hw->conf.chandef);
-+
-+	memset(mp->cck_rates, 0xff, sizeof(mp->cck_rates));
-+	sband = mp->hw->wiphy->bands[NL80211_BAND_2GHZ];
-+	if (!sband)
-+		return;
-+
-+	BUILD_BUG_ON(ARRAY_SIZE(mp->cck_rates) != ARRAY_SIZE(bitrates));
-+	minstrel_ht_fill_rate_array(mp->cck_rates, sband,
-+				    minstrel_cck_bitrates,
-+				    ARRAY_SIZE(minstrel_cck_bitrates),
-+				    rate_flags);
-+}
-+
-+static void
-+minstrel_ht_init_ofdm_rates(struct minstrel_priv *mp, enum nl80211_band band)
-+{
-+	static const s16 bitrates[8] = { 60, 90, 120, 180, 240, 360, 480, 540 };
-+	struct ieee80211_supported_band *sband;
-+	u32 rate_flags = ieee80211_chandef_rate_flags(&mp->hw->conf.chandef);
-+
-+	memset(mp->ofdm_rates[band], 0xff, sizeof(mp->ofdm_rates[band]));
-+	sband = mp->hw->wiphy->bands[band];
-+	if (!sband)
-+		return;
-+
-+	BUILD_BUG_ON(ARRAY_SIZE(mp->ofdm_rates[band]) != ARRAY_SIZE(bitrates));
-+	minstrel_ht_fill_rate_array(mp->ofdm_rates[band], sband,
-+				    minstrel_ofdm_bitrates,
-+				    ARRAY_SIZE(minstrel_ofdm_bitrates),
-+				    rate_flags);
-+}
-+
- static void *
- minstrel_ht_alloc(struct ieee80211_hw *hw)
- {
- 	struct minstrel_priv *mp;
-+	int i;
- 
- 	mp = kzalloc(sizeof(struct minstrel_priv), GFP_ATOMIC);
- 	if (!mp)
-@@ -1681,6 +1791,8 @@ minstrel_ht_alloc(struct ieee80211_hw *h
- 	mp->new_avg = true;
- 
- 	minstrel_ht_init_cck_rates(mp);
-+	for (i = 0; i < ARRAY_SIZE(mp->hw->wiphy->bands); i++)
-+	    minstrel_ht_init_ofdm_rates(mp, i);
- 
- 	return mp;
- }
-@@ -1713,9 +1825,6 @@ static u32 minstrel_ht_get_expected_thro
- 	struct minstrel_ht_sta *mi = &msp->ht;
- 	int i, j, prob, tp_avg;
- 
--	if (!msp->is_ht)
--		return mac80211_minstrel.get_expected_throughput(priv_sta);
--
- 	i = mi->max_tp_rate[0] / MCS_GROUP_RATES;
- 	j = mi->max_tp_rate[0] % MCS_GROUP_RATES;
- 	prob = mi->groups[i].rates[j].prob_avg;
---- a/net/mac80211/rc80211_minstrel_ht.h
-+++ b/net/mac80211/rc80211_minstrel_ht.h
-@@ -18,14 +18,15 @@
- 				 MINSTREL_HT_STREAM_GROUPS)
- #define MINSTREL_VHT_GROUPS_NB	(MINSTREL_MAX_STREAMS *		\
- 				 MINSTREL_VHT_STREAM_GROUPS)
--#define MINSTREL_CCK_GROUPS_NB	1
-+#define MINSTREL_LEGACY_GROUPS_NB	2
- #define MINSTREL_GROUPS_NB	(MINSTREL_HT_GROUPS_NB +	\
- 				 MINSTREL_VHT_GROUPS_NB +	\
--				 MINSTREL_CCK_GROUPS_NB)
-+				 MINSTREL_LEGACY_GROUPS_NB)
- 
- #define MINSTREL_HT_GROUP_0	0
- #define MINSTREL_CCK_GROUP	(MINSTREL_HT_GROUP_0 + MINSTREL_HT_GROUPS_NB)
--#define MINSTREL_VHT_GROUP_0	(MINSTREL_CCK_GROUP + 1)
-+#define MINSTREL_OFDM_GROUP	(MINSTREL_CCK_GROUP + 1)
-+#define MINSTREL_VHT_GROUP_0	(MINSTREL_OFDM_GROUP + 1)
- 
- #define MCS_GROUP_RATES		10
- 
-@@ -37,6 +38,8 @@ struct mcs_group {
- 	u16 duration[MCS_GROUP_RATES];
- };
- 
-+extern const s16 minstrel_cck_bitrates[4];
-+extern const s16 minstrel_ofdm_bitrates[8];
- extern const struct mcs_group minstrel_mcs_groups[];
- 
- struct minstrel_mcs_group_data {
-@@ -99,6 +102,8 @@ struct minstrel_ht_sta {
- 	/* current MCS group to be sampled */
- 	u8 sample_group;
- 
-+	u8 band;
-+
- 	/* Bitfield of supported MCS rates of all groups */
- 	u16 supported[MINSTREL_GROUPS_NB];
- 
-@@ -107,13 +112,9 @@ struct minstrel_ht_sta {
- };
- 
- struct minstrel_ht_sta_priv {
--	union {
--		struct minstrel_ht_sta ht;
--		struct minstrel_sta_info legacy;
--	};
-+	struct minstrel_ht_sta ht;
- 	void *ratelist;
- 	void *sample_table;
--	bool is_ht;
- };
- 
- void minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
---- a/net/mac80211/rc80211_minstrel_ht_debugfs.c
-+++ b/net/mac80211/rc80211_minstrel_ht_debugfs.c
-@@ -52,7 +52,6 @@ minstrel_ht_stats_dump(struct minstrel_h
- 
- 	for (j = 0; j < MCS_GROUP_RATES; j++) {
- 		struct minstrel_rate_stats *mrs = &mi->groups[i].rates[j];
--		static const int bitrates[4] = { 10, 20, 55, 110 };
- 		int idx = i * MCS_GROUP_RATES + j;
- 		unsigned int duration;
- 
-@@ -67,6 +66,9 @@ minstrel_ht_stats_dump(struct minstrel_h
- 			p += sprintf(p, "VHT%c0 ", htmode);
- 			p += sprintf(p, "%cGI ", gimode);
- 			p += sprintf(p, "%d  ", mg->streams);
-+		} else if (i == MINSTREL_OFDM_GROUP) {
-+			p += sprintf(p, "OFDM       ");
-+			p += sprintf(p, "1 ");
- 		} else {
- 			p += sprintf(p, "CCK    ");
- 			p += sprintf(p, "%cP  ", j < 4 ? 'L' : 'S');
-@@ -84,7 +86,12 @@ minstrel_ht_stats_dump(struct minstrel_h
- 		} else if (gflags & IEEE80211_TX_RC_VHT_MCS) {
- 			p += sprintf(p, "  MCS%-1u/%1u", j, mg->streams);
- 		} else {
--			int r = bitrates[j % 4];
-+			int r;
-+
-+			if (i == MINSTREL_OFDM_GROUP)
-+				r = minstrel_ofdm_bitrates[j % 8];
-+			else
-+				r = minstrel_cck_bitrates[j % 4];
- 
- 			p += sprintf(p, "   %2u.%1uM", r / 10, r % 10);
- 		}
-@@ -124,16 +131,8 @@ minstrel_ht_stats_open(struct inode *ino
- 	struct minstrel_ht_sta *mi = &msp->ht;
- 	struct minstrel_debugfs_info *ms;
- 	unsigned int i;
--	int ret;
- 	char *p;
- 
--	if (!msp->is_ht) {
--		inode->i_private = &msp->legacy;
--		ret = minstrel_stats_open(inode, file);
--		inode->i_private = msp;
--		return ret;
--	}
--
- 	ms = kmalloc(32768, GFP_KERNEL);
- 	if (!ms)
- 		return -ENOMEM;
-@@ -199,7 +198,6 @@ minstrel_ht_stats_csv_dump(struct minstr
- 
- 	for (j = 0; j < MCS_GROUP_RATES; j++) {
- 		struct minstrel_rate_stats *mrs = &mi->groups[i].rates[j];
--		static const int bitrates[4] = { 10, 20, 55, 110 };
- 		int idx = i * MCS_GROUP_RATES + j;
- 		unsigned int duration;
- 
-@@ -214,6 +212,8 @@ minstrel_ht_stats_csv_dump(struct minstr
- 			p += sprintf(p, "VHT%c0,", htmode);
- 			p += sprintf(p, "%cGI,", gimode);
- 			p += sprintf(p, "%d,", mg->streams);
-+		} else if (i == MINSTREL_OFDM_GROUP) {
-+			p += sprintf(p, "OFDM,,1,");
- 		} else {
- 			p += sprintf(p, "CCK,");
- 			p += sprintf(p, "%cP,", j < 4 ? 'L' : 'S');
-@@ -231,7 +231,13 @@ minstrel_ht_stats_csv_dump(struct minstr
- 		} else if (gflags & IEEE80211_TX_RC_VHT_MCS) {
- 			p += sprintf(p, ",MCS%-1u/%1u,", j, mg->streams);
- 		} else {
--			int r = bitrates[j % 4];
-+			int r;
-+
-+			if (i == MINSTREL_OFDM_GROUP)
-+				r = minstrel_ofdm_bitrates[j % 8];
-+			else
-+				r = minstrel_cck_bitrates[j % 4];
-+
- 			p += sprintf(p, ",%2u.%1uM,", r / 10, r % 10);
- 		}
- 
-@@ -274,18 +280,9 @@ minstrel_ht_stats_csv_open(struct inode
- 	struct minstrel_ht_sta *mi = &msp->ht;
- 	struct minstrel_debugfs_info *ms;
- 	unsigned int i;
--	int ret;
- 	char *p;
- 
--	if (!msp->is_ht) {
--		inode->i_private = &msp->legacy;
--		ret = minstrel_stats_csv_open(inode, file);
--		inode->i_private = msp;
--		return ret;
--	}
--
- 	ms = kmalloc(32768, GFP_KERNEL);
--
- 	if (!ms)
- 		return -ENOMEM;
- 
diff --git a/package/kernel/mac80211/patches/subsys/339-mac80211-exclude-multicast-packets-from-AQL-pending-.patch b/package/kernel/mac80211/patches/subsys/339-mac80211-exclude-multicast-packets-from-AQL-pending-.patch
new file mode 100644
index 0000000000..43c3e75d65
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/339-mac80211-exclude-multicast-packets-from-AQL-pending-.patch
@@ -0,0 +1,30 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Wed, 13 Jul 2022 07:32:26 +0200
+Subject: [PATCH] mac80211: exclude multicast packets from AQL pending airtime
+
+In AP mode, multicast traffic is handled very differently from normal traffic,
+especially if at least one client is in powersave mode.
+This means that multicast packets can be buffered a lot longer than normal
+unicast packets, and can eat up the AQL budget very quickly because of the low
+data rate.
+Along with the recent change to maintain a global PHY AQL limit, this can lead
+to significant latency spikes for unicast traffic.
+
+Since queueing multicast to hardware is currently not constrained by AQL limits
+anyway, let's just exclude it from the AQL pending airtime calculation entirely.
+
+Fixes: 8e4bac067105 ("wifi: mac80211: add a per-PHY AQL limit to improve fairness")
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -3792,7 +3792,7 @@ begin:
+ encap_out:
+ 	IEEE80211_SKB_CB(skb)->control.vif = vif;
+ 
+-	if (vif &&
++	if (tx.sta &&
+ 	    wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL)) {
+ 		bool ampdu = txq->ac != IEEE80211_AC_VO;
+ 		u32 airtime;
diff --git a/package/kernel/mac80211/patches/subsys/339-mac80211-remove-legacy-minstrel-rate-control.patch b/package/kernel/mac80211/patches/subsys/339-mac80211-remove-legacy-minstrel-rate-control.patch
deleted file mode 100644
index 96ee595ac1..0000000000
--- a/package/kernel/mac80211/patches/subsys/339-mac80211-remove-legacy-minstrel-rate-control.patch
+++ /dev/null
@@ -1,1328 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 26 Dec 2020 14:23:47 +0100
-Subject: [PATCH] mac80211: remove legacy minstrel rate control
-
-Now that minstrel_ht supports legacy rates, it is no longer needed
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- delete mode 100644 net/mac80211/rc80211_minstrel.c
- delete mode 100644 net/mac80211/rc80211_minstrel.h
- delete mode 100644 net/mac80211/rc80211_minstrel_debugfs.c
-
---- a/net/mac80211/Makefile
-+++ b/net/mac80211/Makefile
-@@ -55,11 +55,9 @@ mac80211-$(CONFIG_PM) += pm.o
- CFLAGS_trace.o := -I$(src)
- 
- rc80211_minstrel-y := \
--	rc80211_minstrel.o \
- 	rc80211_minstrel_ht.o
- 
- rc80211_minstrel-$(CPTCFG_MAC80211_DEBUGFS) += \
--	rc80211_minstrel_debugfs.o \
- 	rc80211_minstrel_ht_debugfs.o
- 
- mac80211-$(CPTCFG_MAC80211_RC_MINSTREL) += $(rc80211_minstrel-y)
---- a/net/mac80211/rc80211_minstrel.c
-+++ /dev/null
-@@ -1,574 +0,0 @@
--/*
-- * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
-- *
-- * This program is free software; you can redistribute it and/or modify
-- * it under the terms of the GNU General Public License version 2 as
-- * published by the Free Software Foundation.
-- *
-- * Based on minstrel.c:
-- *   Copyright (C) 2005-2007 Derek Smithies <derek@indranet.co.nz>
-- *   Sponsored by Indranet Technologies Ltd
-- *
-- * Based on sample.c:
-- *   Copyright (c) 2005 John Bicket
-- *   All rights reserved.
-- *
-- *   Redistribution and use in source and binary forms, with or without
-- *   modification, are permitted provided that the following conditions
-- *   are met:
-- *   1. Redistributions of source code must retain the above copyright
-- *      notice, this list of conditions and the following disclaimer,
-- *      without modification.
-- *   2. Redistributions in binary form must reproduce at minimum a disclaimer
-- *      similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any
-- *      redistribution must be conditioned upon including a substantially
-- *      similar Disclaimer requirement for further binary redistribution.
-- *   3. Neither the names of the above-listed copyright holders nor the names
-- *      of any contributors may be used to endorse or promote products derived
-- *      from this software without specific prior written permission.
-- *
-- *   Alternatively, this software may be distributed under the terms of the
-- *   GNU General Public License ("GPL") version 2 as published by the Free
-- *   Software Foundation.
-- *
-- *   NO WARRANTY
-- *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-- *   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-- *   LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY
-- *   AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
-- *   THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,
-- *   OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-- *   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-- *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
-- *   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-- *   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-- *   THE POSSIBILITY OF SUCH DAMAGES.
-- */
--#include <linux/netdevice.h>
--#include <linux/types.h>
--#include <linux/skbuff.h>
--#include <linux/debugfs.h>
--#include <linux/random.h>
--#include <linux/ieee80211.h>
--#include <linux/slab.h>
--#include <net/mac80211.h>
--#include "rate.h"
--#include "rc80211_minstrel.h"
--
--#define SAMPLE_TBL(_mi, _idx, _col) \
--		_mi->sample_table[(_idx * SAMPLE_COLUMNS) + _col]
--
--/* convert mac80211 rate index to local array index */
--static inline int
--rix_to_ndx(struct minstrel_sta_info *mi, int rix)
--{
--	int i = rix;
--	for (i = rix; i >= 0; i--)
--		if (mi->r[i].rix == rix)
--			break;
--	return i;
--}
--
--/* return current EMWA throughput */
--int minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_avg)
--{
--	int usecs;
--
--	usecs = mr->perfect_tx_time;
--	if (!usecs)
--		usecs = 1000000;
--
--	/* reset thr. below 10% success */
--	if (mr->stats.prob_avg < MINSTREL_FRAC(10, 100))
--		return 0;
--
--	if (prob_avg > MINSTREL_FRAC(90, 100))
--		return MINSTREL_TRUNC(100000 * (MINSTREL_FRAC(90, 100) / usecs));
--	else
--		return MINSTREL_TRUNC(100000 * (prob_avg / usecs));
--}
--
--/* find & sort topmost throughput rates */
--static inline void
--minstrel_sort_best_tp_rates(struct minstrel_sta_info *mi, int i, u8 *tp_list)
--{
--	int j;
--	struct minstrel_rate_stats *tmp_mrs;
--	struct minstrel_rate_stats *cur_mrs = &mi->r[i].stats;
--
--	for (j = MAX_THR_RATES; j > 0; --j) {
--		tmp_mrs = &mi->r[tp_list[j - 1]].stats;
--		if (minstrel_get_tp_avg(&mi->r[i], cur_mrs->prob_avg) <=
--		    minstrel_get_tp_avg(&mi->r[tp_list[j - 1]], tmp_mrs->prob_avg))
--			break;
--	}
--
--	if (j < MAX_THR_RATES - 1)
--		memmove(&tp_list[j + 1], &tp_list[j], MAX_THR_RATES - (j + 1));
--	if (j < MAX_THR_RATES)
--		tp_list[j] = i;
--}
--
--static void
--minstrel_set_rate(struct minstrel_sta_info *mi, struct ieee80211_sta_rates *ratetbl,
--		  int offset, int idx)
--{
--	struct minstrel_rate *r = &mi->r[idx];
--
--	ratetbl->rate[offset].idx = r->rix;
--	ratetbl->rate[offset].count = r->adjusted_retry_count;
--	ratetbl->rate[offset].count_cts = r->retry_count_cts;
--	ratetbl->rate[offset].count_rts = r->stats.retry_count_rtscts;
--}
--
--static void
--minstrel_update_rates(struct minstrel_priv *mp, struct minstrel_sta_info *mi)
--{
--	struct ieee80211_sta_rates *ratetbl;
--	int i = 0;
--
--	ratetbl = kzalloc(sizeof(*ratetbl), GFP_ATOMIC);
--	if (!ratetbl)
--		return;
--
--	/* Start with max_tp_rate */
--	minstrel_set_rate(mi, ratetbl, i++, mi->max_tp_rate[0]);
--
--	if (mp->hw->max_rates >= 3) {
--		/* At least 3 tx rates supported, use max_tp_rate2 next */
--		minstrel_set_rate(mi, ratetbl, i++, mi->max_tp_rate[1]);
--	}
--
--	if (mp->hw->max_rates >= 2) {
--		/* At least 2 tx rates supported, use max_prob_rate next */
--		minstrel_set_rate(mi, ratetbl, i++, mi->max_prob_rate);
--	}
--
--	/* Use lowest rate last */
--	ratetbl->rate[i].idx = mi->lowest_rix;
--	ratetbl->rate[i].count = mp->max_retry;
--	ratetbl->rate[i].count_cts = mp->max_retry;
--	ratetbl->rate[i].count_rts = mp->max_retry;
--
--	rate_control_set_rates(mp->hw, mi->sta, ratetbl);
--}
--
--/*
--* Recalculate statistics and counters of a given rate
--*/
--void
--minstrel_calc_rate_stats(struct minstrel_priv *mp,
--			 struct minstrel_rate_stats *mrs)
--{
--	unsigned int cur_prob;
--
--	if (unlikely(mrs->attempts > 0)) {
--		mrs->sample_skipped = 0;
--		cur_prob = MINSTREL_FRAC(mrs->success, mrs->attempts);
--		if (mp->new_avg) {
--			minstrel_filter_avg_add(&mrs->prob_avg,
--						&mrs->prob_avg_1, cur_prob);
--		} else if (unlikely(!mrs->att_hist)) {
--			mrs->prob_avg = cur_prob;
--		} else {
--			/*update exponential weighted moving avarage */
--			mrs->prob_avg = minstrel_ewma(mrs->prob_avg,
--						      cur_prob,
--						      EWMA_LEVEL);
--		}
--		mrs->att_hist += mrs->attempts;
--		mrs->succ_hist += mrs->success;
--	} else {
--		mrs->sample_skipped++;
--	}
--
--	mrs->last_success = mrs->success;
--	mrs->last_attempts = mrs->attempts;
--	mrs->success = 0;
--	mrs->attempts = 0;
--}
--
--static void
--minstrel_update_stats(struct minstrel_priv *mp, struct minstrel_sta_info *mi)
--{
--	u8 tmp_tp_rate[MAX_THR_RATES];
--	u8 tmp_prob_rate = 0;
--	int i, tmp_cur_tp, tmp_prob_tp;
--
--	for (i = 0; i < MAX_THR_RATES; i++)
--	    tmp_tp_rate[i] = 0;
--
--	for (i = 0; i < mi->n_rates; i++) {
--		struct minstrel_rate *mr = &mi->r[i];
--		struct minstrel_rate_stats *mrs = &mi->r[i].stats;
--		struct minstrel_rate_stats *tmp_mrs = &mi->r[tmp_prob_rate].stats;
--
--		/* Update statistics of success probability per rate */
--		minstrel_calc_rate_stats(mp, mrs);
--
--		/* Sample less often below the 10% chance of success.
--		 * Sample less often above the 95% chance of success. */
--		if (mrs->prob_avg > MINSTREL_FRAC(95, 100) ||
--		    mrs->prob_avg < MINSTREL_FRAC(10, 100)) {
--			mr->adjusted_retry_count = mrs->retry_count >> 1;
--			if (mr->adjusted_retry_count > 2)
--				mr->adjusted_retry_count = 2;
--			mr->sample_limit = 4;
--		} else {
--			mr->sample_limit = -1;
--			mr->adjusted_retry_count = mrs->retry_count;
--		}
--		if (!mr->adjusted_retry_count)
--			mr->adjusted_retry_count = 2;
--
--		minstrel_sort_best_tp_rates(mi, i, tmp_tp_rate);
--
--		/* To determine the most robust rate (max_prob_rate) used at
--		 * 3rd mmr stage we distinct between two cases:
--		 * (1) if any success probabilitiy >= 95%, out of those rates
--		 * choose the maximum throughput rate as max_prob_rate
--		 * (2) if all success probabilities < 95%, the rate with
--		 * highest success probability is chosen as max_prob_rate */
--		if (mrs->prob_avg >= MINSTREL_FRAC(95, 100)) {
--			tmp_cur_tp = minstrel_get_tp_avg(mr, mrs->prob_avg);
--			tmp_prob_tp = minstrel_get_tp_avg(&mi->r[tmp_prob_rate],
--							  tmp_mrs->prob_avg);
--			if (tmp_cur_tp >= tmp_prob_tp)
--				tmp_prob_rate = i;
--		} else {
--			if (mrs->prob_avg >= tmp_mrs->prob_avg)
--				tmp_prob_rate = i;
--		}
--	}
--
--	/* Assign the new rate set */
--	memcpy(mi->max_tp_rate, tmp_tp_rate, sizeof(mi->max_tp_rate));
--	mi->max_prob_rate = tmp_prob_rate;
--
--#ifdef CPTCFG_MAC80211_DEBUGFS
--	/* use fixed index if set */
--	if (mp->fixed_rate_idx != -1) {
--		mi->max_tp_rate[0] = mp->fixed_rate_idx;
--		mi->max_tp_rate[1] = mp->fixed_rate_idx;
--		mi->max_prob_rate = mp->fixed_rate_idx;
--	}
--#endif
--
--	/* Reset update timer */
--	mi->last_stats_update = jiffies;
--
--	minstrel_update_rates(mp, mi);
--}
--
--static void
--minstrel_tx_status(void *priv, struct ieee80211_supported_band *sband,
--		   void *priv_sta, struct ieee80211_tx_status *st)
--{
--	struct ieee80211_tx_info *info = st->info;
--	struct minstrel_priv *mp = priv;
--	struct minstrel_sta_info *mi = priv_sta;
--	struct ieee80211_tx_rate *ar = info->status.rates;
--	int i, ndx;
--	int success;
--
--	success = !!(info->flags & IEEE80211_TX_STAT_ACK);
--
--	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {
--		if (ar[i].idx < 0 || !ar[i].count)
--			break;
--
--		ndx = rix_to_ndx(mi, ar[i].idx);
--		if (ndx < 0)
--			continue;
--
--		mi->r[ndx].stats.attempts += ar[i].count;
--
--		if ((i != IEEE80211_TX_MAX_RATES - 1) && (ar[i + 1].idx < 0))
--			mi->r[ndx].stats.success += success;
--	}
--
--	if (time_after(jiffies, mi->last_stats_update +
--				mp->update_interval / (mp->new_avg ? 2 : 1)))
--		minstrel_update_stats(mp, mi);
--}
--
--
--static inline unsigned int
--minstrel_get_retry_count(struct minstrel_rate *mr,
--			 struct ieee80211_tx_info *info)
--{
--	u8 retry = mr->adjusted_retry_count;
--
--	if (info->control.use_rts)
--		retry = max_t(u8, 2, min(mr->stats.retry_count_rtscts, retry));
--	else if (info->control.use_cts_prot)
--		retry = max_t(u8, 2, min(mr->retry_count_cts, retry));
--	return retry;
--}
--
--
--static int
--minstrel_get_next_sample(struct minstrel_sta_info *mi)
--{
--	unsigned int sample_ndx;
--	sample_ndx = SAMPLE_TBL(mi, mi->sample_row, mi->sample_column);
--	mi->sample_row++;
--	if ((int) mi->sample_row >= mi->n_rates) {
--		mi->sample_row = 0;
--		mi->sample_column++;
--		if (mi->sample_column >= SAMPLE_COLUMNS)
--			mi->sample_column = 0;
--	}
--	return sample_ndx;
--}
--
--static void
--minstrel_get_rate(void *priv, struct ieee80211_sta *sta,
--		  void *priv_sta, struct ieee80211_tx_rate_control *txrc)
--{
--	struct sk_buff *skb = txrc->skb;
--	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
--	struct minstrel_sta_info *mi = priv_sta;
--	struct minstrel_priv *mp = priv;
--	struct ieee80211_tx_rate *rate = &info->control.rates[0];
--	struct minstrel_rate *msr, *mr;
--	unsigned int ndx;
--	bool mrr_capable;
--	bool prev_sample;
--	int delta;
--	int sampling_ratio;
--
--	/* check multi-rate-retry capabilities & adjust lookaround_rate */
--	mrr_capable = mp->has_mrr &&
--		      !txrc->rts &&
--		      !txrc->bss_conf->use_cts_prot;
--	if (mrr_capable)
--		sampling_ratio = mp->lookaround_rate_mrr;
--	else
--		sampling_ratio = mp->lookaround_rate;
--
--	/* increase sum packet counter */
--	mi->total_packets++;
--
--#ifdef CPTCFG_MAC80211_DEBUGFS
--	if (mp->fixed_rate_idx != -1)
--		return;
--#endif
--
--	/* Don't use EAPOL frames for sampling on non-mrr hw */
--	if (mp->hw->max_rates == 1 &&
--	    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
--		return;
--
--	delta = (mi->total_packets * sampling_ratio / 100) -
--			mi->sample_packets;
--
--	/* delta < 0: no sampling required */
--	prev_sample = mi->prev_sample;
--	mi->prev_sample = false;
--	if (delta < 0 || (!mrr_capable && prev_sample))
--		return;
--
--	if (mi->total_packets >= 10000) {
--		mi->sample_packets = 0;
--		mi->total_packets = 0;
--	} else if (delta > mi->n_rates * 2) {
--		/* With multi-rate retry, not every planned sample
--		 * attempt actually gets used, due to the way the retry
--		 * chain is set up - [max_tp,sample,prob,lowest] for
--		 * sample_rate < max_tp.
--		 *
--		 * If there's too much sampling backlog and the link
--		 * starts getting worse, minstrel would start bursting
--		 * out lots of sampling frames, which would result
--		 * in a large throughput loss. */
--		mi->sample_packets += (delta - mi->n_rates * 2);
--	}
--
--	/* get next random rate sample */
--	ndx = minstrel_get_next_sample(mi);
--	msr = &mi->r[ndx];
--	mr = &mi->r[mi->max_tp_rate[0]];
--
--	/* Decide if direct ( 1st mrr stage) or indirect (2nd mrr stage)
--	 * rate sampling method should be used.
--	 * Respect such rates that are not sampled for 20 interations.
--	 */
--	if (msr->perfect_tx_time < mr->perfect_tx_time ||
--	    msr->stats.sample_skipped >= 20) {
--		if (!msr->sample_limit)
--			return;
--
--		mi->sample_packets++;
--		if (msr->sample_limit > 0)
--			msr->sample_limit--;
--	}
--
--	/* If we're not using MRR and the sampling rate already
--	 * has a probability of >95%, we shouldn't be attempting
--	 * to use it, as this only wastes precious airtime */
--	if (!mrr_capable &&
--	   (mi->r[ndx].stats.prob_avg > MINSTREL_FRAC(95, 100)))
--		return;
--
--	mi->prev_sample = true;
--
--	rate->idx = mi->r[ndx].rix;
--	rate->count = minstrel_get_retry_count(&mi->r[ndx], info);
--	info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
--}
--
--
--static void
--calc_rate_durations(enum nl80211_band band,
--		    struct minstrel_rate *d,
--		    struct ieee80211_rate *rate,
--		    struct cfg80211_chan_def *chandef)
--{
--	int erp = !!(rate->flags & IEEE80211_RATE_ERP_G);
--	int shift = ieee80211_chandef_get_shift(chandef);
--
--	d->perfect_tx_time = ieee80211_frame_duration(band, 1200,
--			DIV_ROUND_UP(rate->bitrate, 1 << shift), erp, 1,
--			shift);
--	d->ack_time = ieee80211_frame_duration(band, 10,
--			DIV_ROUND_UP(rate->bitrate, 1 << shift), erp, 1,
--			shift);
--}
--
--static void
--init_sample_table(struct minstrel_sta_info *mi)
--{
--	unsigned int i, col, new_idx;
--	u8 rnd[8];
--
--	mi->sample_column = 0;
--	mi->sample_row = 0;
--	memset(mi->sample_table, 0xff, SAMPLE_COLUMNS * mi->n_rates);
--
--	for (col = 0; col < SAMPLE_COLUMNS; col++) {
--		prandom_bytes(rnd, sizeof(rnd));
--		for (i = 0; i < mi->n_rates; i++) {
--			new_idx = (i + rnd[i & 7]) % mi->n_rates;
--			while (SAMPLE_TBL(mi, new_idx, col) != 0xff)
--				new_idx = (new_idx + 1) % mi->n_rates;
--
--			SAMPLE_TBL(mi, new_idx, col) = i;
--		}
--	}
--}
--
--static void
--minstrel_rate_init(void *priv, struct ieee80211_supported_band *sband,
--		   struct cfg80211_chan_def *chandef,
--		   struct ieee80211_sta *sta, void *priv_sta)
--{
--	struct minstrel_sta_info *mi = priv_sta;
--	struct minstrel_priv *mp = priv;
--	struct ieee80211_rate *ctl_rate;
--	unsigned int i, n = 0;
--	unsigned int t_slot = 9; /* FIXME: get real slot time */
--	u32 rate_flags;
--
--	mi->sta = sta;
--	mi->lowest_rix = rate_lowest_index(sband, sta);
--	ctl_rate = &sband->bitrates[mi->lowest_rix];
--	mi->sp_ack_dur = ieee80211_frame_duration(sband->band, 10,
--				ctl_rate->bitrate,
--				!!(ctl_rate->flags & IEEE80211_RATE_ERP_G), 1,
--				ieee80211_chandef_get_shift(chandef));
--
--	rate_flags = ieee80211_chandef_rate_flags(&mp->hw->conf.chandef);
--	memset(mi->max_tp_rate, 0, sizeof(mi->max_tp_rate));
--	mi->max_prob_rate = 0;
--
--	for (i = 0; i < sband->n_bitrates; i++) {
--		struct minstrel_rate *mr = &mi->r[n];
--		struct minstrel_rate_stats *mrs = &mi->r[n].stats;
--		unsigned int tx_time = 0, tx_time_cts = 0, tx_time_rtscts = 0;
--		unsigned int tx_time_single;
--		unsigned int cw = mp->cw_min;
--		int shift;
--
--		if (!rate_supported(sta, sband->band, i))
--			continue;
--		if ((rate_flags & sband->bitrates[i].flags) != rate_flags)
--			continue;
--
--		n++;
--		memset(mr, 0, sizeof(*mr));
--		memset(mrs, 0, sizeof(*mrs));
--
--		mr->rix = i;
--		shift = ieee80211_chandef_get_shift(chandef);
--		mr->bitrate = DIV_ROUND_UP(sband->bitrates[i].bitrate,
--					   (1 << shift) * 5);
--		calc_rate_durations(sband->band, mr, &sband->bitrates[i],
--				    chandef);
--
--		/* calculate maximum number of retransmissions before
--		 * fallback (based on maximum segment size) */
--		mr->sample_limit = -1;
--		mrs->retry_count = 1;
--		mr->retry_count_cts = 1;
--		mrs->retry_count_rtscts = 1;
--		tx_time = mr->perfect_tx_time + mi->sp_ack_dur;
--		do {
--			/* add one retransmission */
--			tx_time_single = mr->ack_time + mr->perfect_tx_time;
--
--			/* contention window */
--			tx_time_single += (t_slot * cw) >> 1;
--			cw = min((cw << 1) | 1, mp->cw_max);
--
--			tx_time += tx_time_single;
--			tx_time_cts += tx_time_single + mi->sp_ack_dur;
--			tx_time_rtscts += tx_time_single + 2 * mi->sp_ack_dur;
--			if ((tx_time_cts < mp->segment_size) &&
--				(mr->retry_count_cts < mp->max_retry))
--				mr->retry_count_cts++;
--			if ((tx_time_rtscts < mp->segment_size) &&
--				(mrs->retry_count_rtscts < mp->max_retry))
--				mrs->retry_count_rtscts++;
--		} while ((tx_time < mp->segment_size) &&
--				(++mr->stats.retry_count < mp->max_retry));
--		mr->adjusted_retry_count = mrs->retry_count;
--		if (!(sband->bitrates[i].flags & IEEE80211_RATE_ERP_G))
--			mr->retry_count_cts = mrs->retry_count;
--	}
--
--	for (i = n; i < sband->n_bitrates; i++) {
--		struct minstrel_rate *mr = &mi->r[i];
--		mr->rix = -1;
--	}
--
--	mi->n_rates = n;
--	mi->last_stats_update = jiffies;
--
--	init_sample_table(mi);
--	minstrel_update_rates(mp, mi);
--}
--
--static u32 minstrel_get_expected_throughput(void *priv_sta)
--{
--	struct minstrel_sta_info *mi = priv_sta;
--	struct minstrel_rate_stats *tmp_mrs;
--	int idx = mi->max_tp_rate[0];
--	int tmp_cur_tp;
--
--	/* convert pkt per sec in kbps (1200 is the average pkt size used for
--	 * computing cur_tp
--	 */
--	tmp_mrs = &mi->r[idx].stats;
--	tmp_cur_tp = minstrel_get_tp_avg(&mi->r[idx], tmp_mrs->prob_avg) * 10;
--	tmp_cur_tp = tmp_cur_tp * 1200 * 8 / 1024;
--
--	return tmp_cur_tp;
--}
--
--const struct rate_control_ops mac80211_minstrel = {
--	.tx_status_ext = minstrel_tx_status,
--	.get_rate = minstrel_get_rate,
--	.rate_init = minstrel_rate_init,
--	.get_expected_throughput = minstrel_get_expected_throughput,
--};
---- a/net/mac80211/rc80211_minstrel.h
-+++ /dev/null
-@@ -1,185 +0,0 @@
--/* SPDX-License-Identifier: GPL-2.0-only */
--/*
-- * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
-- */
--
--#ifndef __RC_MINSTREL_H
--#define __RC_MINSTREL_H
--
--#define EWMA_LEVEL	96	/* ewma weighting factor [/EWMA_DIV] */
--#define EWMA_DIV	128
--#define SAMPLE_COLUMNS	10	/* number of columns in sample table */
--
--/* scaled fraction values */
--#define MINSTREL_SCALE  12
--#define MINSTREL_FRAC(val, div) (((val) << MINSTREL_SCALE) / div)
--#define MINSTREL_TRUNC(val) ((val) >> MINSTREL_SCALE)
--
--/* number of highest throughput rates to consider*/
--#define MAX_THR_RATES 4
--
--/*
-- * Coefficients for moving average with noise filter (period=16),
-- * scaled by 10 bits
-- *
-- * a1 = exp(-pi * sqrt(2) / period)
-- * coeff2 = 2 * a1 * cos(sqrt(2) * 2 * pi / period)
-- * coeff3 = -sqr(a1)
-- * coeff1 = 1 - coeff2 - coeff3
-- */
--#define MINSTREL_AVG_COEFF1		(MINSTREL_FRAC(1, 1) - \
--					 MINSTREL_AVG_COEFF2 - \
--					 MINSTREL_AVG_COEFF3)
--#define MINSTREL_AVG_COEFF2		0x00001499
--#define MINSTREL_AVG_COEFF3		-0x0000092e
--
--/*
-- * Perform EWMA (Exponentially Weighted Moving Average) calculation
-- */
--static inline int
--minstrel_ewma(int old, int new, int weight)
--{
--	int diff, incr;
--
--	diff = new - old;
--	incr = (EWMA_DIV - weight) * diff / EWMA_DIV;
--
--	return old + incr;
--}
--
--static inline int minstrel_filter_avg_add(u16 *prev_1, u16 *prev_2, s32 in)
--{
--	s32 out_1 = *prev_1;
--	s32 out_2 = *prev_2;
--	s32 val;
--
--	if (!in)
--		in += 1;
--
--	if (!out_1) {
--		val = out_1 = in;
--		goto out;
--	}
--
--	val = MINSTREL_AVG_COEFF1 * in;
--	val += MINSTREL_AVG_COEFF2 * out_1;
--	val += MINSTREL_AVG_COEFF3 * out_2;
--	val >>= MINSTREL_SCALE;
--
--	if (val > 1 << MINSTREL_SCALE)
--		val = 1 << MINSTREL_SCALE;
--	if (val < 0)
--		val = 1;
--
--out:
--	*prev_2 = out_1;
--	*prev_1 = val;
--
--	return val;
--}
--
--struct minstrel_rate_stats {
--	/* current / last sampling period attempts/success counters */
--	u16 attempts, last_attempts;
--	u16 success, last_success;
--
--	/* total attempts/success counters */
--	u32 att_hist, succ_hist;
--
--	/* prob_avg - moving average of prob */
--	u16 prob_avg;
--	u16 prob_avg_1;
--
--	/* maximum retry counts */
--	u8 retry_count;
--	u8 retry_count_rtscts;
--
--	u8 sample_skipped;
--	bool retry_updated;
--};
--
--struct minstrel_rate {
--	int bitrate;
--
--	s8 rix;
--	u8 retry_count_cts;
--	u8 adjusted_retry_count;
--
--	unsigned int perfect_tx_time;
--	unsigned int ack_time;
--
--	int sample_limit;
--
--	struct minstrel_rate_stats stats;
--};
--
--struct minstrel_sta_info {
--	struct ieee80211_sta *sta;
--
--	unsigned long last_stats_update;
--	unsigned int sp_ack_dur;
--	unsigned int rate_avg;
--
--	unsigned int lowest_rix;
--
--	u8 max_tp_rate[MAX_THR_RATES];
--	u8 max_prob_rate;
--	unsigned int total_packets;
--	unsigned int sample_packets;
--
--	unsigned int sample_row;
--	unsigned int sample_column;
--
--	int n_rates;
--	struct minstrel_rate *r;
--	bool prev_sample;
--
--	/* sampling table */
--	u8 *sample_table;
--};
--
--struct minstrel_priv {
--	struct ieee80211_hw *hw;
--	bool has_mrr;
--	bool new_avg;
--	u32 sample_switch;
--	unsigned int cw_min;
--	unsigned int cw_max;
--	unsigned int max_retry;
--	unsigned int segment_size;
--	unsigned int update_interval;
--	unsigned int lookaround_rate;
--	unsigned int lookaround_rate_mrr;
--
--	u8 cck_rates[4];
--	u8 ofdm_rates[NUM_NL80211_BANDS][8];
--
--#ifdef CPTCFG_MAC80211_DEBUGFS
--	/*
--	 * enable fixed rate processing per RC
--	 *   - write static index to debugfs:ieee80211/phyX/rc/fixed_rate_idx
--	 *   - write -1 to enable RC processing again
--	 *   - setting will be applied on next update
--	 */
--	u32 fixed_rate_idx;
--#endif
--};
--
--struct minstrel_debugfs_info {
--	size_t len;
--	char buf[];
--};
--
--extern const struct rate_control_ops mac80211_minstrel;
--void minstrel_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
--
--/* Recalculate success probabilities and counters for a given rate using EWMA */
--void minstrel_calc_rate_stats(struct minstrel_priv *mp,
--			      struct minstrel_rate_stats *mrs);
--int minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_avg);
--
--/* debugfs */
--int minstrel_stats_open(struct inode *inode, struct file *file);
--int minstrel_stats_csv_open(struct inode *inode, struct file *file);
--
--#endif
---- a/net/mac80211/rc80211_minstrel_debugfs.c
-+++ /dev/null
-@@ -1,172 +0,0 @@
--/*
-- * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
-- *
-- * This program is free software; you can redistribute it and/or modify
-- * it under the terms of the GNU General Public License version 2 as
-- * published by the Free Software Foundation.
-- *
-- * Based on minstrel.c:
-- *   Copyright (C) 2005-2007 Derek Smithies <derek@indranet.co.nz>
-- *   Sponsored by Indranet Technologies Ltd
-- *
-- * Based on sample.c:
-- *   Copyright (c) 2005 John Bicket
-- *   All rights reserved.
-- *
-- *   Redistribution and use in source and binary forms, with or without
-- *   modification, are permitted provided that the following conditions
-- *   are met:
-- *   1. Redistributions of source code must retain the above copyright
-- *      notice, this list of conditions and the following disclaimer,
-- *      without modification.
-- *   2. Redistributions in binary form must reproduce at minimum a disclaimer
-- *      similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any
-- *      redistribution must be conditioned upon including a substantially
-- *      similar Disclaimer requirement for further binary redistribution.
-- *   3. Neither the names of the above-listed copyright holders nor the names
-- *      of any contributors may be used to endorse or promote products derived
-- *      from this software without specific prior written permission.
-- *
-- *   Alternatively, this software may be distributed under the terms of the
-- *   GNU General Public License ("GPL") version 2 as published by the Free
-- *   Software Foundation.
-- *
-- *   NO WARRANTY
-- *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-- *   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-- *   LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY
-- *   AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
-- *   THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,
-- *   OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-- *   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-- *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
-- *   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-- *   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-- *   THE POSSIBILITY OF SUCH DAMAGES.
-- */
--#include <linux/netdevice.h>
--#include <linux/types.h>
--#include <linux/skbuff.h>
--#include <linux/debugfs.h>
--#include <linux/ieee80211.h>
--#include <linux/slab.h>
--#include <linux/export.h>
--#include <net/mac80211.h>
--#include "rc80211_minstrel.h"
--
--int
--minstrel_stats_open(struct inode *inode, struct file *file)
--{
--	struct minstrel_sta_info *mi = inode->i_private;
--	struct minstrel_debugfs_info *ms;
--	unsigned int i, tp_max, tp_avg, eprob;
--	char *p;
--
--	ms = kmalloc(2048, GFP_KERNEL);
--	if (!ms)
--		return -ENOMEM;
--
--	file->private_data = ms;
--	p = ms->buf;
--	p += sprintf(p, "\n");
--	p += sprintf(p,
--		     "best   __________rate_________    ____statistics___    ____last_____    ______sum-of________\n");
--	p += sprintf(p,
--		     "rate  [name idx airtime max_tp]  [avg(tp) avg(prob)]  [retry|suc|att]  [#success | #attempts]\n");
--
--	for (i = 0; i < mi->n_rates; i++) {
--		struct minstrel_rate *mr = &mi->r[i];
--		struct minstrel_rate_stats *mrs = &mi->r[i].stats;
--
--		*(p++) = (i == mi->max_tp_rate[0]) ? 'A' : ' ';
--		*(p++) = (i == mi->max_tp_rate[1]) ? 'B' : ' ';
--		*(p++) = (i == mi->max_tp_rate[2]) ? 'C' : ' ';
--		*(p++) = (i == mi->max_tp_rate[3]) ? 'D' : ' ';
--		*(p++) = (i == mi->max_prob_rate) ? 'P' : ' ';
--
--		p += sprintf(p, " %3u%s ", mr->bitrate / 2,
--				(mr->bitrate & 1 ? ".5" : "  "));
--		p += sprintf(p, "%3u  ", i);
--		p += sprintf(p, "%6u ", mr->perfect_tx_time);
--
--		tp_max = minstrel_get_tp_avg(mr, MINSTREL_FRAC(100,100));
--		tp_avg = minstrel_get_tp_avg(mr, mrs->prob_avg);
--		eprob = MINSTREL_TRUNC(mrs->prob_avg * 1000);
--
--		p += sprintf(p, "%4u.%1u    %4u.%1u     %3u.%1u"
--				"     %3u   %3u %-3u   "
--				"%9llu   %-9llu\n",
--				tp_max / 10, tp_max % 10,
--				tp_avg / 10, tp_avg % 10,
--				eprob / 10, eprob % 10,
--				mrs->retry_count,
--				mrs->last_success,
--				mrs->last_attempts,
--				(unsigned long long)mrs->succ_hist,
--				(unsigned long long)mrs->att_hist);
--	}
--	p += sprintf(p, "\nTotal packet count::    ideal %d      "
--			"lookaround %d\n\n",
--			mi->total_packets - mi->sample_packets,
--			mi->sample_packets);
--	ms->len = p - ms->buf;
--
--	WARN_ON(ms->len + sizeof(*ms) > 2048);
--
--	return 0;
--}
--
--int
--minstrel_stats_csv_open(struct inode *inode, struct file *file)
--{
--	struct minstrel_sta_info *mi = inode->i_private;
--	struct minstrel_debugfs_info *ms;
--	unsigned int i, tp_max, tp_avg, eprob;
--	char *p;
--
--	ms = kmalloc(2048, GFP_KERNEL);
--	if (!ms)
--		return -ENOMEM;
--
--	file->private_data = ms;
--	p = ms->buf;
--
--	for (i = 0; i < mi->n_rates; i++) {
--		struct minstrel_rate *mr = &mi->r[i];
--		struct minstrel_rate_stats *mrs = &mi->r[i].stats;
--
--		p += sprintf(p, "%s" ,((i == mi->max_tp_rate[0]) ? "A" : ""));
--		p += sprintf(p, "%s" ,((i == mi->max_tp_rate[1]) ? "B" : ""));
--		p += sprintf(p, "%s" ,((i == mi->max_tp_rate[2]) ? "C" : ""));
--		p += sprintf(p, "%s" ,((i == mi->max_tp_rate[3]) ? "D" : ""));
--		p += sprintf(p, "%s" ,((i == mi->max_prob_rate) ? "P" : ""));
--
--		p += sprintf(p, ",%u%s", mr->bitrate / 2,
--				(mr->bitrate & 1 ? ".5," : ","));
--		p += sprintf(p, "%u,", i);
--		p += sprintf(p, "%u,",mr->perfect_tx_time);
--
--		tp_max = minstrel_get_tp_avg(mr, MINSTREL_FRAC(100,100));
--		tp_avg = minstrel_get_tp_avg(mr, mrs->prob_avg);
--		eprob = MINSTREL_TRUNC(mrs->prob_avg * 1000);
--
--		p += sprintf(p, "%u.%u,%u.%u,%u.%u,%u,%u,%u,"
--				"%llu,%llu,%d,%d\n",
--				tp_max / 10, tp_max % 10,
--				tp_avg / 10, tp_avg % 10,
--				eprob / 10, eprob % 10,
--				mrs->retry_count,
--				mrs->last_success,
--				mrs->last_attempts,
--				(unsigned long long)mrs->succ_hist,
--				(unsigned long long)mrs->att_hist,
--				mi->total_packets - mi->sample_packets,
--				mi->sample_packets);
--
--	}
--	ms->len = p - ms->buf;
--
--	WARN_ON(ms->len + sizeof(*ms) > 2048);
--
--	return 0;
--}
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -13,7 +13,6 @@
- #include <net/mac80211.h>
- #include "rate.h"
- #include "sta_info.h"
--#include "rc80211_minstrel.h"
- #include "rc80211_minstrel_ht.h"
- 
- #define AVG_AMPDU_SIZE	16
-@@ -716,6 +715,83 @@ out:
- 	mi->sample_mode = MINSTREL_SAMPLE_ACTIVE;
- }
- 
-+static inline int
-+minstrel_ewma(int old, int new, int weight)
-+{
-+	int diff, incr;
-+
-+	diff = new - old;
-+	incr = (EWMA_DIV - weight) * diff / EWMA_DIV;
-+
-+	return old + incr;
-+}
-+
-+static inline int minstrel_filter_avg_add(u16 *prev_1, u16 *prev_2, s32 in)
-+{
-+	s32 out_1 = *prev_1;
-+	s32 out_2 = *prev_2;
-+	s32 val;
-+
-+	if (!in)
-+		in += 1;
-+
-+	if (!out_1) {
-+		val = out_1 = in;
-+		goto out;
-+	}
-+
-+	val = MINSTREL_AVG_COEFF1 * in;
-+	val += MINSTREL_AVG_COEFF2 * out_1;
-+	val += MINSTREL_AVG_COEFF3 * out_2;
-+	val >>= MINSTREL_SCALE;
-+
-+	if (val > 1 << MINSTREL_SCALE)
-+		val = 1 << MINSTREL_SCALE;
-+	if (val < 0)
-+		val = 1;
-+
-+out:
-+	*prev_2 = out_1;
-+	*prev_1 = val;
-+
-+	return val;
-+}
-+
-+/*
-+* Recalculate statistics and counters of a given rate
-+*/
-+static void
-+minstrel_ht_calc_rate_stats(struct minstrel_priv *mp,
-+			    struct minstrel_rate_stats *mrs)
-+{
-+	unsigned int cur_prob;
-+
-+	if (unlikely(mrs->attempts > 0)) {
-+		mrs->sample_skipped = 0;
-+		cur_prob = MINSTREL_FRAC(mrs->success, mrs->attempts);
-+		if (mp->new_avg) {
-+			minstrel_filter_avg_add(&mrs->prob_avg,
-+						&mrs->prob_avg_1, cur_prob);
-+		} else if (unlikely(!mrs->att_hist)) {
-+			mrs->prob_avg = cur_prob;
-+		} else {
-+			/*update exponential weighted moving avarage */
-+			mrs->prob_avg = minstrel_ewma(mrs->prob_avg,
-+						      cur_prob,
-+						      EWMA_LEVEL);
-+		}
-+		mrs->att_hist += mrs->attempts;
-+		mrs->succ_hist += mrs->success;
-+	} else {
-+		mrs->sample_skipped++;
-+	}
-+
-+	mrs->last_success = mrs->success;
-+	mrs->last_attempts = mrs->attempts;
-+	mrs->success = 0;
-+	mrs->attempts = 0;
-+}
-+
- /*
-  * Update rate statistics and select new primary rates
-  *
-@@ -808,7 +884,7 @@ minstrel_ht_update_stats(struct minstrel
- 
- 			mrs = &mg->rates[i];
- 			mrs->retry_updated = false;
--			minstrel_calc_rate_stats(mp, mrs);
-+			minstrel_ht_calc_rate_stats(mp, mrs);
- 			cur_prob = mrs->prob_avg;
- 
- 			if (minstrel_ht_get_tp_avg(mi, group, i, cur_prob) == 0)
-@@ -960,8 +1036,7 @@ minstrel_ht_tx_status(void *priv, struct
-                       void *priv_sta, struct ieee80211_tx_status *st)
- {
- 	struct ieee80211_tx_info *info = st->info;
--	struct minstrel_ht_sta_priv *msp = priv_sta;
--	struct minstrel_ht_sta *mi = &msp->ht;
-+	struct minstrel_ht_sta *mi = priv_sta;
- 	struct ieee80211_tx_rate *ar = info->status.rates;
- 	struct minstrel_rate_stats *rate, *rate2, *rate_sample = NULL;
- 	struct minstrel_priv *mp = priv;
-@@ -1372,8 +1447,7 @@ minstrel_ht_get_rate(void *priv, struct
- 	const struct mcs_group *sample_group;
- 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(txrc->skb);
- 	struct ieee80211_tx_rate *rate = &info->status.rates[0];
--	struct minstrel_ht_sta_priv *msp = priv_sta;
--	struct minstrel_ht_sta *mi = &msp->ht;
-+	struct minstrel_ht_sta *mi = priv_sta;
- 	struct minstrel_priv *mp = priv;
- 	int sample_idx;
- 
-@@ -1484,8 +1558,7 @@ minstrel_ht_update_caps(void *priv, stru
- 			struct ieee80211_sta *sta, void *priv_sta)
- {
- 	struct minstrel_priv *mp = priv;
--	struct minstrel_ht_sta_priv *msp = priv_sta;
--	struct minstrel_ht_sta *mi = &msp->ht;
-+	struct minstrel_ht_sta *mi = priv_sta;
- 	struct ieee80211_mcs_info *mcs = &sta->ht_cap.mcs;
- 	u16 ht_cap = sta->ht_cap.cap;
- 	struct ieee80211_sta_vht_cap *vht_cap = &sta->vht_cap;
-@@ -1647,7 +1720,7 @@ static void *
- minstrel_ht_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)
- {
- 	struct ieee80211_supported_band *sband;
--	struct minstrel_ht_sta_priv *msp;
-+	struct minstrel_ht_sta *mi;
- 	struct minstrel_priv *mp = priv;
- 	struct ieee80211_hw *hw = mp->hw;
- 	int max_rates = 0;
-@@ -1659,35 +1732,13 @@ minstrel_ht_alloc_sta(void *priv, struct
- 			max_rates = sband->n_bitrates;
- 	}
- 
--	msp = kzalloc(sizeof(*msp), gfp);
--	if (!msp)
--		return NULL;
--
--	msp->ratelist = kcalloc(max_rates, sizeof(struct minstrel_rate), gfp);
--	if (!msp->ratelist)
--		goto error;
--
--	msp->sample_table = kmalloc_array(max_rates, SAMPLE_COLUMNS, gfp);
--	if (!msp->sample_table)
--		goto error1;
--
--	return msp;
--
--error1:
--	kfree(msp->ratelist);
--error:
--	kfree(msp);
--	return NULL;
-+	return kzalloc(sizeof(*mi), gfp);
- }
- 
- static void
- minstrel_ht_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)
- {
--	struct minstrel_ht_sta_priv *msp = priv_sta;
--
--	kfree(msp->sample_table);
--	kfree(msp->ratelist);
--	kfree(msp);
-+	kfree(priv_sta);
- }
- 
- static void
-@@ -1768,12 +1819,6 @@ minstrel_ht_alloc(struct ieee80211_hw *h
- 	mp->cw_min = 15;
- 	mp->cw_max = 1023;
- 
--	/* number of packets (in %) to use for sampling other rates
--	 * sample less often for non-mrr packets, because the overhead
--	 * is much higher than with mrr */
--	mp->lookaround_rate = 5;
--	mp->lookaround_rate_mrr = 10;
--
- 	/* maximum time that the hw is allowed to stay in one MRR segment */
- 	mp->segment_size = 6000;
- 
-@@ -1821,8 +1866,7 @@ minstrel_ht_free(void *priv)
- 
- static u32 minstrel_ht_get_expected_throughput(void *priv_sta)
- {
--	struct minstrel_ht_sta_priv *msp = priv_sta;
--	struct minstrel_ht_sta *mi = &msp->ht;
-+	struct minstrel_ht_sta *mi = priv_sta;
- 	int i, j, prob, tp_avg;
- 
- 	i = mi->max_tp_rate[0] / MCS_GROUP_RATES;
---- a/net/mac80211/rc80211_minstrel_ht.h
-+++ b/net/mac80211/rc80211_minstrel_ht.h
-@@ -6,6 +6,33 @@
- #ifndef __RC_MINSTREL_HT_H
- #define __RC_MINSTREL_HT_H
- 
-+/* number of highest throughput rates to consider*/
-+#define MAX_THR_RATES 4
-+#define SAMPLE_COLUMNS	10	/* number of columns in sample table */
-+
-+/* scaled fraction values */
-+#define MINSTREL_SCALE  12
-+#define MINSTREL_FRAC(val, div) (((val) << MINSTREL_SCALE) / div)
-+#define MINSTREL_TRUNC(val) ((val) >> MINSTREL_SCALE)
-+
-+#define EWMA_LEVEL	96	/* ewma weighting factor [/EWMA_DIV] */
-+#define EWMA_DIV	128
-+
-+/*
-+ * Coefficients for moving average with noise filter (period=16),
-+ * scaled by 10 bits
-+ *
-+ * a1 = exp(-pi * sqrt(2) / period)
-+ * coeff2 = 2 * a1 * cos(sqrt(2) * 2 * pi / period)
-+ * coeff3 = -sqr(a1)
-+ * coeff1 = 1 - coeff2 - coeff3
-+ */
-+#define MINSTREL_AVG_COEFF1		(MINSTREL_FRAC(1, 1) - \
-+					 MINSTREL_AVG_COEFF2 - \
-+					 MINSTREL_AVG_COEFF3)
-+#define MINSTREL_AVG_COEFF2		0x00001499
-+#define MINSTREL_AVG_COEFF3		-0x0000092e
-+
- /*
-  * The number of streams can be changed to 2 to reduce code
-  * size and memory footprint.
-@@ -30,6 +57,32 @@
- 
- #define MCS_GROUP_RATES		10
- 
-+struct minstrel_priv {
-+	struct ieee80211_hw *hw;
-+	bool has_mrr;
-+	bool new_avg;
-+	u32 sample_switch;
-+	unsigned int cw_min;
-+	unsigned int cw_max;
-+	unsigned int max_retry;
-+	unsigned int segment_size;
-+	unsigned int update_interval;
-+
-+	u8 cck_rates[4];
-+	u8 ofdm_rates[NUM_NL80211_BANDS][8];
-+
-+#ifdef CPTCFG_MAC80211_DEBUGFS
-+	/*
-+	 * enable fixed rate processing per RC
-+	 *   - write static index to debugfs:ieee80211/phyX/rc/fixed_rate_idx
-+	 *   - write -1 to enable RC processing again
-+	 *   - setting will be applied on next update
-+	 */
-+	u32 fixed_rate_idx;
-+#endif
-+};
-+
-+
- struct mcs_group {
- 	u16 flags;
- 	u8 streams;
-@@ -42,6 +95,26 @@ extern const s16 minstrel_cck_bitrates[4
- extern const s16 minstrel_ofdm_bitrates[8];
- extern const struct mcs_group minstrel_mcs_groups[];
- 
-+struct minstrel_rate_stats {
-+	/* current / last sampling period attempts/success counters */
-+	u16 attempts, last_attempts;
-+	u16 success, last_success;
-+
-+	/* total attempts/success counters */
-+	u32 att_hist, succ_hist;
-+
-+	/* prob_avg - moving average of prob */
-+	u16 prob_avg;
-+	u16 prob_avg_1;
-+
-+	/* maximum retry counts */
-+	u8 retry_count;
-+	u8 retry_count_rtscts;
-+
-+	u8 sample_skipped;
-+	bool retry_updated;
-+};
-+
- struct minstrel_mcs_group_data {
- 	u8 index;
- 	u8 column;
-@@ -111,12 +184,6 @@ struct minstrel_ht_sta {
- 	struct minstrel_mcs_group_data groups[MINSTREL_GROUPS_NB];
- };
- 
--struct minstrel_ht_sta_priv {
--	struct minstrel_ht_sta ht;
--	void *ratelist;
--	void *sample_table;
--};
--
- void minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
- int minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
- 			   int prob_avg);
---- a/net/mac80211/rc80211_minstrel_ht_debugfs.c
-+++ b/net/mac80211/rc80211_minstrel_ht_debugfs.c
-@@ -9,9 +9,13 @@
- #include <linux/ieee80211.h>
- #include <linux/export.h>
- #include <net/mac80211.h>
--#include "rc80211_minstrel.h"
- #include "rc80211_minstrel_ht.h"
- 
-+struct minstrel_debugfs_info {
-+	size_t len;
-+	char buf[];
-+};
-+
- static ssize_t
- minstrel_stats_read(struct file *file, char __user *buf, size_t len, loff_t *ppos)
- {
-@@ -127,8 +131,7 @@ minstrel_ht_stats_dump(struct minstrel_h
- static int
- minstrel_ht_stats_open(struct inode *inode, struct file *file)
- {
--	struct minstrel_ht_sta_priv *msp = inode->i_private;
--	struct minstrel_ht_sta *mi = &msp->ht;
-+	struct minstrel_ht_sta *mi = inode->i_private;
- 	struct minstrel_debugfs_info *ms;
- 	unsigned int i;
- 	char *p;
-@@ -276,8 +279,7 @@ minstrel_ht_stats_csv_dump(struct minstr
- static int
- minstrel_ht_stats_csv_open(struct inode *inode, struct file *file)
- {
--	struct minstrel_ht_sta_priv *msp = inode->i_private;
--	struct minstrel_ht_sta *mi = &msp->ht;
-+	struct minstrel_ht_sta *mi = inode->i_private;
- 	struct minstrel_debugfs_info *ms;
- 	unsigned int i;
- 	char *p;
-@@ -313,10 +315,8 @@ static const struct file_operations mins
- void
- minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir)
- {
--	struct minstrel_ht_sta_priv *msp = priv_sta;
--
--	debugfs_create_file("rc_stats", 0444, dir, msp,
-+	debugfs_create_file("rc_stats", 0444, dir, priv_sta,
- 			    &minstrel_ht_stat_fops);
--	debugfs_create_file("rc_stats_csv", 0444, dir, msp,
-+	debugfs_create_file("rc_stats_csv", 0444, dir, priv_sta,
- 			    &minstrel_ht_stat_csv_fops);
- }
diff --git a/package/kernel/mac80211/patches/subsys/340-mac80211-minstrel_ht-remove-old-ewma-based-rate-aver.patch b/package/kernel/mac80211/patches/subsys/340-mac80211-minstrel_ht-remove-old-ewma-based-rate-aver.patch
deleted file mode 100644
index 9b6a614aa8..0000000000
--- a/package/kernel/mac80211/patches/subsys/340-mac80211-minstrel_ht-remove-old-ewma-based-rate-aver.patch
+++ /dev/null
@@ -1,96 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 26 Dec 2020 14:34:30 +0100
-Subject: [PATCH] mac80211: minstrel_ht: remove old ewma based rate average
- code
-
-The new noise filter has been the default for a while now with no reported
-downside and significant improvement compared to the old code.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -769,17 +769,8 @@ minstrel_ht_calc_rate_stats(struct minst
- 	if (unlikely(mrs->attempts > 0)) {
- 		mrs->sample_skipped = 0;
- 		cur_prob = MINSTREL_FRAC(mrs->success, mrs->attempts);
--		if (mp->new_avg) {
--			minstrel_filter_avg_add(&mrs->prob_avg,
--						&mrs->prob_avg_1, cur_prob);
--		} else if (unlikely(!mrs->att_hist)) {
--			mrs->prob_avg = cur_prob;
--		} else {
--			/*update exponential weighted moving avarage */
--			mrs->prob_avg = minstrel_ewma(mrs->prob_avg,
--						      cur_prob,
--						      EWMA_LEVEL);
--		}
-+		minstrel_filter_avg_add(&mrs->prob_avg,
-+					&mrs->prob_avg_1, cur_prob);
- 		mrs->att_hist += mrs->attempts;
- 		mrs->succ_hist += mrs->success;
- 	} else {
-@@ -913,10 +904,8 @@ minstrel_ht_update_stats(struct minstrel
- 	/* Try to increase robustness of max_prob_rate*/
- 	minstrel_ht_prob_rate_reduce_streams(mi);
- 
--	/* try to sample all available rates during each interval */
--	mi->sample_count *= 8;
--	if (mp->new_avg)
--		mi->sample_count /= 2;
-+	/* try to sample half of all available rates during each interval */
-+	mi->sample_count *= 4;
- 
- 	if (sample)
- 		minstrel_ht_rate_sample_switch(mp, mi);
-@@ -1040,7 +1029,7 @@ minstrel_ht_tx_status(void *priv, struct
- 	struct ieee80211_tx_rate *ar = info->status.rates;
- 	struct minstrel_rate_stats *rate, *rate2, *rate_sample = NULL;
- 	struct minstrel_priv *mp = priv;
--	u32 update_interval = mp->update_interval / 2;
-+	u32 update_interval = mp->update_interval;
- 	bool last, update = false;
- 	bool sample_status = false;
- 	int i;
-@@ -1090,9 +1079,8 @@ minstrel_ht_tx_status(void *priv, struct
- 
- 	switch (mi->sample_mode) {
- 	case MINSTREL_SAMPLE_IDLE:
--		if (mp->new_avg &&
--		    (mp->hw->max_rates > 1 ||
--		     mi->total_packets_cur < SAMPLE_SWITCH_THR))
-+		if (mp->hw->max_rates > 1 ||
-+		     mi->total_packets_cur < SAMPLE_SWITCH_THR)
- 			update_interval /= 2;
- 		break;
- 
-@@ -1832,8 +1820,7 @@ minstrel_ht_alloc(struct ieee80211_hw *h
- 		mp->has_mrr = true;
- 
- 	mp->hw = hw;
--	mp->update_interval = HZ / 10;
--	mp->new_avg = true;
-+	mp->update_interval = HZ / 20;
- 
- 	minstrel_ht_init_cck_rates(mp);
- 	for (i = 0; i < ARRAY_SIZE(mp->hw->wiphy->bands); i++)
-@@ -1853,8 +1840,6 @@ static void minstrel_ht_add_debugfs(stru
- 			   &mp->fixed_rate_idx);
- 	debugfs_create_u32("sample_switch", S_IRUGO | S_IWUSR, debugfsdir,
- 			   &mp->sample_switch);
--	debugfs_create_bool("new_avg", S_IRUGO | S_IWUSR, debugfsdir,
--			   &mp->new_avg);
- }
- #endif
- 
---- a/net/mac80211/rc80211_minstrel_ht.h
-+++ b/net/mac80211/rc80211_minstrel_ht.h
-@@ -60,7 +60,6 @@
- struct minstrel_priv {
- 	struct ieee80211_hw *hw;
- 	bool has_mrr;
--	bool new_avg;
- 	u32 sample_switch;
- 	unsigned int cw_min;
- 	unsigned int cw_max;
diff --git a/package/kernel/mac80211/patches/subsys/340-wifi-mac80211-do-not-abuse-fq.lock-in-ieee80211_do_s.patch b/package/kernel/mac80211/patches/subsys/340-wifi-mac80211-do-not-abuse-fq.lock-in-ieee80211_do_s.patch
new file mode 100644
index 0000000000..82243f1d98
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/340-wifi-mac80211-do-not-abuse-fq.lock-in-ieee80211_do_s.patch
@@ -0,0 +1,46 @@
+From aa40d5a43526cca9439a2b45fcfdcd016594dece Mon Sep 17 00:00:00 2001
+From: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
+Date: Sun, 17 Jul 2022 21:21:52 +0900
+Subject: [PATCH] wifi: mac80211: do not abuse fq.lock in ieee80211_do_stop()
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+lockdep complains use of uninitialized spinlock at ieee80211_do_stop() [1],
+for commit f856373e2f31ffd3 ("wifi: mac80211: do not wake queues on a vif
+that is being stopped") guards clear_bit() using fq.lock even before
+fq_init() from ieee80211_txq_setup_flows() initializes this spinlock.
+
+According to discussion [2], Toke was not happy with expanding usage of
+fq.lock. Since __ieee80211_wake_txqs() is called under RCU read lock, we
+can instead use synchronize_rcu() for flushing ieee80211_wake_txqs().
+
+Link: https://syzkaller.appspot.com/bug?extid=eceab52db7c4b961e9d6 [1]
+Link: https://lkml.kernel.org/r/874k0zowh2.fsf@toke.dk [2]
+Reported-by: syzbot <syzbot+eceab52db7c4b961e9d6@syzkaller.appspotmail.com>
+Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
+Fixes: f856373e2f31ffd3 ("wifi: mac80211: do not wake queues on a vif that is being stopped")
+Tested-by: syzbot <syzbot+eceab52db7c4b961e9d6@syzkaller.appspotmail.com>
+Acked-by: Toke Høiland-Jørgensen <toke@kernel.org>
+Signed-off-by: Kalle Valo <kvalo@kernel.org>
+Link: https://lore.kernel.org/r/9cc9b81d-75a3-3925-b612-9d0ad3cab82b@I-love.SAKURA.ne.jp
+[ pick up commit 3598cb6e1862 ("wifi: mac80211: do not abuse fq.lock in ieee80211_do_stop()") from -next]
+Link: https://lore.kernel.org/all/87o7xcq6qt.fsf@kernel.org/
+Signed-off-by: Jakub Kicinski <kuba@kernel.org>
+---
+ net/mac80211/iface.c | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+--- a/net/mac80211/iface.c
++++ b/net/mac80211/iface.c
+@@ -377,9 +377,8 @@ static void ieee80211_do_stop(struct iee
+ 	bool cancel_scan;
+ 	struct cfg80211_nan_func *func;
+ 
+-	spin_lock_bh(&local->fq.lock);
+ 	clear_bit(SDATA_STATE_RUNNING, &sdata->state);
+-	spin_unlock_bh(&local->fq.lock);
++	synchronize_rcu(); /* flush _ieee80211_wake_txqs() */
+ 
+ 	cancel_scan = rcu_access_pointer(local->scan_sdata) == sdata;
+ 	if (cancel_scan)
diff --git a/package/kernel/mac80211/patches/subsys/341-mac80211-Fix-deadlock-Don-t-start-TX-while-holding-f.patch b/package/kernel/mac80211/patches/subsys/341-mac80211-Fix-deadlock-Don-t-start-TX-while-holding-f.patch
new file mode 100644
index 0000000000..8c56acbf88
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/341-mac80211-Fix-deadlock-Don-t-start-TX-while-holding-f.patch
@@ -0,0 +1,40 @@
+From: Alexander Wetzel <alexander@wetzel-home.de>
+Date: Thu, 15 Sep 2022 14:41:20 +0200
+Subject: [PATCH] mac80211: Fix deadlock: Don't start TX while holding
+ fq->lock
+
+ieee80211_txq_purge() calls fq_tin_reset() and
+ieee80211_purge_tx_queue(); Both are then calling
+ieee80211_free_txskb(). Which can decide to TX the skb again.
+
+There are at least two ways to get a deadlock:
+
+1) When we have a TDLS teardown packet queued in either tin or frags
+   ieee80211_tdls_td_tx_handle() will call ieee80211_subif_start_xmit()
+   while we still hold fq->lock. ieee80211_txq_enqueue() will thus
+   deadlock.
+
+2) A variant of the above happens if aggregation is up and running:
+   In that case ieee80211_iface_work() will deadlock with the original
+   task: The original tasks already holds fq->lock and tries to get
+   sta->lock after kicking off ieee80211_iface_work(). But the worker
+   can get sta->lock prior to the original task and will then spin for
+   fq->lock.
+
+Avoid these deadlocks by not sending out any skbs when called via
+ieee80211_free_txskb().
+
+Signed-off-by: Alexander Wetzel <alexander@wetzel-home.de>
+---
+
+--- a/net/mac80211/status.c
++++ b/net/mac80211/status.c
+@@ -698,7 +698,7 @@ static void ieee80211_report_used_skb(st
+ 
+ 		if (!sdata) {
+ 			skb->dev = NULL;
+-		} else {
++		} else if (!dropped) {
+ 			unsigned int hdr_size =
+ 				ieee80211_hdrlen(hdr->frame_control);
+ 
diff --git a/package/kernel/mac80211/patches/subsys/341-mac80211-minstrel_ht-improve-ampdu-length-estimation.patch b/package/kernel/mac80211/patches/subsys/341-mac80211-minstrel_ht-improve-ampdu-length-estimation.patch
deleted file mode 100644
index a8e6e89954..0000000000
--- a/package/kernel/mac80211/patches/subsys/341-mac80211-minstrel_ht-improve-ampdu-length-estimation.patch
+++ /dev/null
@@ -1,67 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 26 Dec 2020 19:08:19 +0100
-Subject: [PATCH] mac80211: minstrel_ht: improve ampdu length estimation
-
-If the driver does not report A-MPDU length, estimate it based on the rate.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -382,13 +382,37 @@ minstrel_get_ratestats(struct minstrel_h
- 	return &mi->groups[index / MCS_GROUP_RATES].rates[index % MCS_GROUP_RATES];
- }
- 
-+static inline int
-+minstrel_get_duration(int index)
-+{
-+	const struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];
-+	unsigned int duration = group->duration[index % MCS_GROUP_RATES];
-+	return duration << group->shift;
-+}
-+
- static unsigned int
- minstrel_ht_avg_ampdu_len(struct minstrel_ht_sta *mi)
- {
--	if (!mi->avg_ampdu_len)
--		return AVG_AMPDU_SIZE;
-+	int duration;
-+
-+	if (mi->avg_ampdu_len)
-+		return MINSTREL_TRUNC(mi->avg_ampdu_len);
-+
-+	if (minstrel_ht_is_legacy_group(mi->max_tp_rate[0] / MCS_GROUP_RATES))
-+		return 1;
-+
-+	duration = minstrel_get_duration(mi->max_tp_rate[0]);
- 
--	return MINSTREL_TRUNC(mi->avg_ampdu_len);
-+	if (duration > 400 * 1000)
-+		return 2;
-+
-+	if (duration > 250 * 1000)
-+		return 4;
-+
-+	if (duration > 150 * 1000)
-+		return 8;
-+
-+	return 16;
- }
- 
- /*
-@@ -588,14 +612,6 @@ minstrel_ht_prob_rate_reduce_streams(str
- 	}
- }
- 
--static inline int
--minstrel_get_duration(int index)
--{
--	const struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];
--	unsigned int duration = group->duration[index % MCS_GROUP_RATES];
--	return duration << group->shift;
--}
--
- static bool
- minstrel_ht_probe_group(struct minstrel_ht_sta *mi, const struct mcs_group *tp_group,
- 						int tp_idx, const struct mcs_group *group)
diff --git a/package/kernel/mac80211/patches/subsys/342-mac80211-Ensure-vif-queues-are-operational-after-sta.patch b/package/kernel/mac80211/patches/subsys/342-mac80211-Ensure-vif-queues-are-operational-after-sta.patch
new file mode 100644
index 0000000000..4310329319
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/342-mac80211-Ensure-vif-queues-are-operational-after-sta.patch
@@ -0,0 +1,47 @@
+From: Alexander Wetzel <alexander@wetzel-home.de>
+Date: Thu, 15 Sep 2022 15:09:46 +0200
+Subject: [PATCH] mac80211: Ensure vif queues are operational after start
+
+Make sure local->queue_stop_reasons and vif.txqs_stopped stay in sync.
+
+When a new vif is created the queues may end up in an inconsistent state
+and be inoperable:
+Communication not using iTXQ will work, allowing to e.g. complete the
+association. But the 4-way handshake will time out. The sta will not
+send out any skbs queued in iTXQs.
+
+All normal attempts to start the queues will fail when reaching this
+state.
+local->queue_stop_reasons will have marked all queues as operational but
+vif.txqs_stopped will still be set, creating an inconsistent internal
+state.
+
+In reality this seems to be race between the mac80211 function
+ieee80211_do_open() setting SDATA_STATE_RUNNING and the wake_txqs_tasklet:
+Depending on the driver and the timing the queues may end up to be
+operational or not.
+
+Cc: stable@vger.kernel.org
+Fixes: f856373e2f31 ("wifi: mac80211: do not wake queues on a vif that is being stopped")
+Signed-off-by: Alexander Wetzel <alexander@wetzel-home.de>
+---
+
+--- a/net/mac80211/util.c
++++ b/net/mac80211/util.c
+@@ -301,14 +301,14 @@ static void __ieee80211_wake_txqs(struct
+ 	local_bh_disable();
+ 	spin_lock(&fq->lock);
+ 
++	sdata->vif.txqs_stopped[ac] = false;
++
+ 	if (!test_bit(SDATA_STATE_RUNNING, &sdata->state))
+ 		goto out;
+ 
+ 	if (sdata->vif.type == NL80211_IFTYPE_AP)
+ 		ps = &sdata->bss->ps;
+ 
+-	sdata->vif.txqs_stopped[ac] = false;
+-
+ 	list_for_each_entry_rcu(sta, &local->sta_list, list) {
+ 		if (sdata != sta->sdata)
+ 			continue;
diff --git a/package/kernel/mac80211/patches/subsys/342-mac80211-minstrel_ht-improve-sample-rate-selection.patch b/package/kernel/mac80211/patches/subsys/342-mac80211-minstrel_ht-improve-sample-rate-selection.patch
deleted file mode 100644
index e084525235..0000000000
--- a/package/kernel/mac80211/patches/subsys/342-mac80211-minstrel_ht-improve-sample-rate-selection.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 26 Dec 2020 19:12:22 +0100
-Subject: [PATCH] mac80211: minstrel_ht: improve sample rate selection
-
-Always allow sampling of rates faster than the primary max throughput rate.
-When the second max_tp_rate is higher than the first one, sample attempts were
-previously skipped, potentially causing rate control to get stuck at a slightly
-lower rate
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -1379,13 +1379,13 @@ minstrel_get_sample_rate(struct minstrel
- 	mrs = &mg->rates[sample_idx];
- 	sample_idx += sample_group * MCS_GROUP_RATES;
- 
--	/* Set tp_rate1, tp_rate2 to the highest / second highest max_tp_rate */
-+	tp_rate1 = mi->max_tp_rate[0];
-+
-+	/* Set tp_rate2 to the second highest max_tp_rate */
- 	if (minstrel_get_duration(mi->max_tp_rate[0]) >
- 	    minstrel_get_duration(mi->max_tp_rate[1])) {
--		tp_rate1 = mi->max_tp_rate[1];
- 		tp_rate2 = mi->max_tp_rate[0];
- 	} else {
--		tp_rate1 = mi->max_tp_rate[0];
- 		tp_rate2 = mi->max_tp_rate[1];
- 	}
- 
diff --git a/package/kernel/mac80211/patches/subsys/343-mac80211-minstrel_ht-fix-max-probability-rate-select.patch b/package/kernel/mac80211/patches/subsys/343-mac80211-minstrel_ht-fix-max-probability-rate-select.patch
deleted file mode 100644
index 0dbfa9d4fb..0000000000
--- a/package/kernel/mac80211/patches/subsys/343-mac80211-minstrel_ht-fix-max-probability-rate-select.patch
+++ /dev/null
@@ -1,124 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 26 Dec 2020 19:09:08 +0100
-Subject: [PATCH] mac80211: minstrel_ht: fix max probability rate selection
-
-- do not select rates faster than the max throughput rate if probability is lower
-- reset previous rate before sorting again
-
-This ensures that the max prob rate gets set to a more reliable rate
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -495,12 +495,13 @@ minstrel_ht_sort_best_tp_rates(struct mi
-  * Find and set the topmost probability rate per sta and per group
-  */
- static void
--minstrel_ht_set_best_prob_rate(struct minstrel_ht_sta *mi, u16 index)
-+minstrel_ht_set_best_prob_rate(struct minstrel_ht_sta *mi, u16 *dest, u16 index)
- {
- 	struct minstrel_mcs_group_data *mg;
- 	struct minstrel_rate_stats *mrs;
- 	int tmp_group, tmp_idx, tmp_tp_avg, tmp_prob;
--	int max_tp_group, cur_tp_avg, cur_group, cur_idx;
-+	int max_tp_group, max_tp_idx, max_tp_prob;
-+	int cur_tp_avg, cur_group, cur_idx;
- 	int max_gpr_group, max_gpr_idx;
- 	int max_gpr_tp_avg, max_gpr_prob;
- 
-@@ -509,18 +510,26 @@ minstrel_ht_set_best_prob_rate(struct mi
- 	mg = &mi->groups[index / MCS_GROUP_RATES];
- 	mrs = &mg->rates[index % MCS_GROUP_RATES];
- 
--	tmp_group = mi->max_prob_rate / MCS_GROUP_RATES;
--	tmp_idx = mi->max_prob_rate % MCS_GROUP_RATES;
-+	tmp_group = *dest / MCS_GROUP_RATES;
-+	tmp_idx = *dest % MCS_GROUP_RATES;
- 	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
- 	tmp_tp_avg = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);
- 
- 	/* if max_tp_rate[0] is from MCS_GROUP max_prob_rate get selected from
- 	 * MCS_GROUP as well as CCK_GROUP rates do not allow aggregation */
- 	max_tp_group = mi->max_tp_rate[0] / MCS_GROUP_RATES;
-+	max_tp_idx = mi->max_tp_rate[0] % MCS_GROUP_RATES;
-+	max_tp_prob = mi->groups[max_tp_group].rates[max_tp_idx].prob_avg;
-+
- 	if (minstrel_ht_is_legacy_group(index / MCS_GROUP_RATES) &&
- 	    !minstrel_ht_is_legacy_group(max_tp_group))
- 		return;
- 
-+	/* skip rates faster than max tp rate with lower prob */
-+	if (minstrel_get_duration(mi->max_tp_rate[0]) > minstrel_get_duration(index) &&
-+	    mrs->prob_avg < max_tp_prob)
-+		return;
-+
- 	max_gpr_group = mg->max_group_prob_rate / MCS_GROUP_RATES;
- 	max_gpr_idx = mg->max_group_prob_rate % MCS_GROUP_RATES;
- 	max_gpr_prob = mi->groups[max_gpr_group].rates[max_gpr_idx].prob_avg;
-@@ -538,7 +547,7 @@ minstrel_ht_set_best_prob_rate(struct mi
- 			mg->max_group_prob_rate = index;
- 	} else {
- 		if (mrs->prob_avg > tmp_prob)
--			mi->max_prob_rate = index;
-+			*dest = index;
- 		if (mrs->prob_avg > max_gpr_prob)
- 			mg->max_group_prob_rate = index;
- 	}
-@@ -816,7 +825,8 @@ minstrel_ht_update_stats(struct minstrel
- 	struct minstrel_rate_stats *mrs;
- 	int group, i, j, cur_prob;
- 	u16 tmp_mcs_tp_rate[MAX_THR_RATES], tmp_group_tp_rate[MAX_THR_RATES];
--	u16 tmp_legacy_tp_rate[MAX_THR_RATES], index;
-+	u16 tmp_legacy_tp_rate[MAX_THR_RATES], tmp_max_prob_rate;
-+	u16 index;
- 	bool ht_supported = mi->sta->ht_cap.ht_supported;
- 
- 	mi->sample_mode = MINSTREL_SAMPLE_IDLE;
-@@ -863,6 +873,7 @@ minstrel_ht_update_stats(struct minstrel
- 	else
- 		index = MINSTREL_OFDM_GROUP * MCS_GROUP_RATES;
- 
-+	tmp_max_prob_rate = index;
- 	for (j = 0; j < ARRAY_SIZE(tmp_mcs_tp_rate); j++)
- 		tmp_mcs_tp_rate[j] = index;
- 
-@@ -903,9 +914,6 @@ minstrel_ht_update_stats(struct minstrel
- 			/* Find max throughput rate set within a group */
- 			minstrel_ht_sort_best_tp_rates(mi, index,
- 						       tmp_group_tp_rate);
--
--			/* Find max probability rate per group and global */
--			minstrel_ht_set_best_prob_rate(mi, index);
- 		}
- 
- 		memcpy(mg->max_group_tp_rate, tmp_group_tp_rate,
-@@ -917,6 +925,27 @@ minstrel_ht_update_stats(struct minstrel
- 					 tmp_legacy_tp_rate);
- 	memcpy(mi->max_tp_rate, tmp_mcs_tp_rate, sizeof(mi->max_tp_rate));
- 
-+	for (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {
-+		if (!mi->supported[group])
-+			continue;
-+
-+		mg = &mi->groups[group];
-+		mg->max_group_prob_rate = MCS_GROUP_RATES * group;
-+
-+		for (i = 0; i < MCS_GROUP_RATES; i++) {
-+			if (!(mi->supported[group] & BIT(i)))
-+				continue;
-+
-+			index = MCS_GROUP_RATES * group + i;
-+
-+			/* Find max probability rate per group and global */
-+			minstrel_ht_set_best_prob_rate(mi, &tmp_max_prob_rate,
-+						       index);
-+		}
-+	}
-+
-+	mi->max_prob_rate = tmp_max_prob_rate;
-+
- 	/* Try to increase robustness of max_prob_rate*/
- 	minstrel_ht_prob_rate_reduce_streams(mi);
- 
diff --git a/package/kernel/mac80211/patches/subsys/344-mac80211-minstrel_ht-increase-stats-update-interval.patch b/package/kernel/mac80211/patches/subsys/344-mac80211-minstrel_ht-increase-stats-update-interval.patch
deleted file mode 100644
index 9972a9414e..0000000000
--- a/package/kernel/mac80211/patches/subsys/344-mac80211-minstrel_ht-increase-stats-update-interval.patch
+++ /dev/null
@@ -1,20 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 26 Dec 2020 19:14:58 +0100
-Subject: [PATCH] mac80211: minstrel_ht: increase stats update interval
-
-The shorter interval was leading to too many frames being used for probing
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -1865,7 +1865,7 @@ minstrel_ht_alloc(struct ieee80211_hw *h
- 		mp->has_mrr = true;
- 
- 	mp->hw = hw;
--	mp->update_interval = HZ / 20;
-+	mp->update_interval = HZ / 10;
- 
- 	minstrel_ht_init_cck_rates(mp);
- 	for (i = 0; i < ARRAY_SIZE(mp->hw->wiphy->bands); i++)
diff --git a/package/kernel/mac80211/patches/subsys/345-mac80211-minstrel_ht-fix-rounding-error-in-throughpu.patch b/package/kernel/mac80211/patches/subsys/345-mac80211-minstrel_ht-fix-rounding-error-in-throughpu.patch
deleted file mode 100644
index 1df5dec039..0000000000
--- a/package/kernel/mac80211/patches/subsys/345-mac80211-minstrel_ht-fix-rounding-error-in-throughpu.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 15 Jan 2021 12:15:06 +0100
-Subject: [PATCH] mac80211: minstrel_ht: fix rounding error in throughput
- calculation
-
-On lower data rates, the throughput calculation has a significant rounding
-error, causing rates like 48M and 54M OFDM to share the same throughput
-value with >= 90% success probablity.
-
-This is because the result of the division (prob_avg * 1000) / nsecs
-is really small (8 in this example).
-
-Improve accuracy by moving over some zeroes, making better use of the full
-range of u32 before the division.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -445,10 +445,9 @@ minstrel_ht_get_tp_avg(struct minstrel_h
- 	 * (prob is scaled - see MINSTREL_FRAC above)
- 	 */
- 	if (prob_avg > MINSTREL_FRAC(90, 100))
--		return MINSTREL_TRUNC(100000 * ((MINSTREL_FRAC(90, 100) * 1000)
--								      / nsecs));
--	else
--		return MINSTREL_TRUNC(100000 * ((prob_avg * 1000) / nsecs));
-+		prob_avg = MINSTREL_FRAC(90, 100);
-+
-+	return MINSTREL_TRUNC(100 * ((prob_avg * 1000000) / nsecs));
- }
- 
- /*
diff --git a/package/kernel/mac80211/patches/subsys/346-mac80211-minstrel_ht-use-bitfields-to-encode-rate-in.patch b/package/kernel/mac80211/patches/subsys/346-mac80211-minstrel_ht-use-bitfields-to-encode-rate-in.patch
deleted file mode 100644
index 6aa6f0ed93..0000000000
--- a/package/kernel/mac80211/patches/subsys/346-mac80211-minstrel_ht-use-bitfields-to-encode-rate-in.patch
+++ /dev/null
@@ -1,412 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 21 Jan 2021 18:29:30 +0100
-Subject: [PATCH] mac80211: minstrel_ht: use bitfields to encode rate
- indexes
-
-Get rid of a lot of divisions and modulo operations
-Reduces code size and improves performance
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -379,14 +379,14 @@ out:
- static inline struct minstrel_rate_stats *
- minstrel_get_ratestats(struct minstrel_ht_sta *mi, int index)
- {
--	return &mi->groups[index / MCS_GROUP_RATES].rates[index % MCS_GROUP_RATES];
-+	return &mi->groups[MI_RATE_GROUP(index)].rates[MI_RATE_IDX(index)];
- }
- 
--static inline int
--minstrel_get_duration(int index)
-+static inline int minstrel_get_duration(int index)
- {
--	const struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];
--	unsigned int duration = group->duration[index % MCS_GROUP_RATES];
-+	const struct mcs_group *group = &minstrel_mcs_groups[MI_RATE_GROUP(index)];
-+	unsigned int duration = group->duration[MI_RATE_IDX(index)];
-+
- 	return duration << group->shift;
- }
- 
-@@ -398,7 +398,7 @@ minstrel_ht_avg_ampdu_len(struct minstre
- 	if (mi->avg_ampdu_len)
- 		return MINSTREL_TRUNC(mi->avg_ampdu_len);
- 
--	if (minstrel_ht_is_legacy_group(mi->max_tp_rate[0] / MCS_GROUP_RATES))
-+	if (minstrel_ht_is_legacy_group(MI_RATE_GROUP(mi->max_tp_rate[0])))
- 		return 1;
- 
- 	duration = minstrel_get_duration(mi->max_tp_rate[0]);
-@@ -465,14 +465,14 @@ minstrel_ht_sort_best_tp_rates(struct mi
- 	int tmp_group, tmp_idx, tmp_tp_avg, tmp_prob;
- 	int j = MAX_THR_RATES;
- 
--	cur_group = index / MCS_GROUP_RATES;
--	cur_idx = index  % MCS_GROUP_RATES;
-+	cur_group = MI_RATE_GROUP(index);
-+	cur_idx = MI_RATE_IDX(index);
- 	cur_prob = mi->groups[cur_group].rates[cur_idx].prob_avg;
- 	cur_tp_avg = minstrel_ht_get_tp_avg(mi, cur_group, cur_idx, cur_prob);
- 
- 	do {
--		tmp_group = tp_list[j - 1] / MCS_GROUP_RATES;
--		tmp_idx = tp_list[j - 1] % MCS_GROUP_RATES;
-+		tmp_group = MI_RATE_GROUP(tp_list[j - 1]);
-+		tmp_idx = MI_RATE_IDX(tp_list[j - 1]);
- 		tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
- 		tmp_tp_avg = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx,
- 						    tmp_prob);
-@@ -504,23 +504,23 @@ minstrel_ht_set_best_prob_rate(struct mi
- 	int max_gpr_group, max_gpr_idx;
- 	int max_gpr_tp_avg, max_gpr_prob;
- 
--	cur_group = index / MCS_GROUP_RATES;
--	cur_idx = index % MCS_GROUP_RATES;
--	mg = &mi->groups[index / MCS_GROUP_RATES];
--	mrs = &mg->rates[index % MCS_GROUP_RATES];
-+	cur_group = MI_RATE_GROUP(index);
-+	cur_idx = MI_RATE_IDX(index);
-+	mg = &mi->groups[cur_group];
-+	mrs = &mg->rates[cur_idx];
- 
--	tmp_group = *dest / MCS_GROUP_RATES;
--	tmp_idx = *dest % MCS_GROUP_RATES;
-+	tmp_group = MI_RATE_GROUP(*dest);
-+	tmp_idx = MI_RATE_IDX(*dest);
- 	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
- 	tmp_tp_avg = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);
- 
- 	/* if max_tp_rate[0] is from MCS_GROUP max_prob_rate get selected from
- 	 * MCS_GROUP as well as CCK_GROUP rates do not allow aggregation */
--	max_tp_group = mi->max_tp_rate[0] / MCS_GROUP_RATES;
--	max_tp_idx = mi->max_tp_rate[0] % MCS_GROUP_RATES;
-+	max_tp_group = MI_RATE_GROUP(mi->max_tp_rate[0]);
-+	max_tp_idx = MI_RATE_IDX(mi->max_tp_rate[0]);
- 	max_tp_prob = mi->groups[max_tp_group].rates[max_tp_idx].prob_avg;
- 
--	if (minstrel_ht_is_legacy_group(index / MCS_GROUP_RATES) &&
-+	if (minstrel_ht_is_legacy_group(MI_RATE_GROUP(index)) &&
- 	    !minstrel_ht_is_legacy_group(max_tp_group))
- 		return;
- 
-@@ -529,8 +529,8 @@ minstrel_ht_set_best_prob_rate(struct mi
- 	    mrs->prob_avg < max_tp_prob)
- 		return;
- 
--	max_gpr_group = mg->max_group_prob_rate / MCS_GROUP_RATES;
--	max_gpr_idx = mg->max_group_prob_rate % MCS_GROUP_RATES;
-+	max_gpr_group = MI_RATE_GROUP(mg->max_group_prob_rate);
-+	max_gpr_idx = MI_RATE_IDX(mg->max_group_prob_rate);
- 	max_gpr_prob = mi->groups[max_gpr_group].rates[max_gpr_idx].prob_avg;
- 
- 	if (mrs->prob_avg > MINSTREL_FRAC(75, 100)) {
-@@ -567,13 +567,13 @@ minstrel_ht_assign_best_tp_rates(struct
- 	unsigned int tmp_group, tmp_idx, tmp_cck_tp, tmp_mcs_tp, tmp_prob;
- 	int i;
- 
--	tmp_group = tmp_legacy_tp_rate[0] / MCS_GROUP_RATES;
--	tmp_idx = tmp_legacy_tp_rate[0] % MCS_GROUP_RATES;
-+	tmp_group = MI_RATE_GROUP(tmp_legacy_tp_rate[0]);
-+	tmp_idx = MI_RATE_IDX(tmp_legacy_tp_rate[0]);
- 	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
- 	tmp_cck_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);
- 
--	tmp_group = tmp_mcs_tp_rate[0] / MCS_GROUP_RATES;
--	tmp_idx = tmp_mcs_tp_rate[0] % MCS_GROUP_RATES;
-+	tmp_group = MI_RATE_GROUP(tmp_mcs_tp_rate[0]);
-+	tmp_idx = MI_RATE_IDX(tmp_mcs_tp_rate[0]);
- 	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
- 	tmp_mcs_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);
- 
-@@ -600,14 +600,14 @@ minstrel_ht_prob_rate_reduce_streams(str
- 	if (!mi->sta->ht_cap.ht_supported)
- 		return;
- 
--	tmp_max_streams = minstrel_mcs_groups[mi->max_tp_rate[0] /
--			  MCS_GROUP_RATES].streams;
-+	group = MI_RATE_GROUP(mi->max_tp_rate[0]);
-+	tmp_max_streams = minstrel_mcs_groups[group].streams;
- 	for (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {
- 		mg = &mi->groups[group];
- 		if (!mi->supported[group] || group == MINSTREL_CCK_GROUP)
- 			continue;
- 
--		tmp_idx = mg->max_group_prob_rate % MCS_GROUP_RATES;
-+		tmp_idx = MI_RATE_IDX(mg->max_group_prob_rate);
- 		tmp_prob = mi->groups[group].rates[tmp_idx].prob_avg;
- 
- 		if (tmp_tp < minstrel_ht_get_tp_avg(mi, group, tmp_idx, tmp_prob) &&
-@@ -644,8 +644,8 @@ minstrel_ht_find_probe_rates(struct mins
- 	int i, g, max_dur;
- 	int tp_idx;
- 
--	tp_group = &minstrel_mcs_groups[mi->max_tp_rate[0] / MCS_GROUP_RATES];
--	tp_idx = mi->max_tp_rate[0] % MCS_GROUP_RATES;
-+	tp_group = &minstrel_mcs_groups[MI_RATE_GROUP(mi->max_tp_rate[0])];
-+	tp_idx = MI_RATE_IDX(mi->max_tp_rate[0]);
- 
- 	max_dur = minstrel_get_duration(mi->max_tp_rate[0]);
- 	if (faster_rate)
-@@ -670,7 +670,7 @@ minstrel_ht_find_probe_rates(struct mins
- 			if ((group->duration[i] << group->shift) > max_dur)
- 				continue;
- 
--			idx = g * MCS_GROUP_RATES + i;
-+			idx = MI_RATE(g, i);
- 			if (idx == mi->max_tp_rate[0])
- 				continue;
- 
-@@ -712,10 +712,10 @@ minstrel_ht_rate_sample_switch(struct mi
- 
- 	/* If no suitable rate was found, try to pick the next one in the group */
- 	if (!n_rates) {
--		int g_idx = mi->max_tp_rate[0] / MCS_GROUP_RATES;
-+		int g_idx = MI_RATE_GROUP(mi->max_tp_rate[0]);
- 		u16 supported = mi->supported[g_idx];
- 
--		supported >>= mi->max_tp_rate[0] % MCS_GROUP_RATES;
-+		supported >>= MI_RATE_IDX(mi->max_tp_rate[0]);
- 		for (i = 0; supported; supported >>= 1, i++) {
- 			if (!(supported & 1))
- 				continue;
-@@ -854,24 +854,27 @@ minstrel_ht_update_stats(struct minstrel
- 	mi->sample_slow = 0;
- 	mi->sample_count = 0;
- 
--	memset(tmp_mcs_tp_rate, 0, sizeof(tmp_mcs_tp_rate));
--	memset(tmp_legacy_tp_rate, 0, sizeof(tmp_legacy_tp_rate));
- 	if (mi->supported[MINSTREL_CCK_GROUP])
--		for (j = 0; j < ARRAY_SIZE(tmp_legacy_tp_rate); j++)
--			tmp_legacy_tp_rate[j] = MINSTREL_CCK_GROUP * MCS_GROUP_RATES;
-+		group = MINSTREL_CCK_GROUP;
- 	else if (mi->supported[MINSTREL_OFDM_GROUP])
--		for (j = 0; j < ARRAY_SIZE(tmp_legacy_tp_rate); j++)
--			tmp_legacy_tp_rate[j] = MINSTREL_OFDM_GROUP * MCS_GROUP_RATES;
-+		group = MINSTREL_OFDM_GROUP;
-+	else
-+		group = 0;
-+
-+	index = MI_RATE(group, 0);
-+	for (j = 0; j < ARRAY_SIZE(tmp_legacy_tp_rate); j++)
-+		tmp_legacy_tp_rate[j] = index;
- 
- 	if (mi->supported[MINSTREL_VHT_GROUP_0])
--		index = MINSTREL_VHT_GROUP_0 * MCS_GROUP_RATES;
-+		group = MINSTREL_VHT_GROUP_0;
- 	else if (ht_supported)
--		index = MINSTREL_HT_GROUP_0 * MCS_GROUP_RATES;
-+		group = MINSTREL_HT_GROUP_0;
- 	else if (mi->supported[MINSTREL_CCK_GROUP])
--		index = MINSTREL_CCK_GROUP * MCS_GROUP_RATES;
-+		group = MINSTREL_CCK_GROUP;
- 	else
--		index = MINSTREL_OFDM_GROUP * MCS_GROUP_RATES;
-+		group = MINSTREL_OFDM_GROUP;
- 
-+	index = MI_RATE(group, 0);
- 	tmp_max_prob_rate = index;
- 	for (j = 0; j < ARRAY_SIZE(tmp_mcs_tp_rate); j++)
- 		tmp_mcs_tp_rate[j] = index;
-@@ -888,7 +891,7 @@ minstrel_ht_update_stats(struct minstrel
- 
- 		/* (re)Initialize group rate indexes */
- 		for(j = 0; j < MAX_THR_RATES; j++)
--			tmp_group_tp_rate[j] = MCS_GROUP_RATES * group;
-+			tmp_group_tp_rate[j] = MI_RATE(group, 0);
- 
- 		if (group == MINSTREL_CCK_GROUP && ht_supported)
- 			tp_rate = tmp_legacy_tp_rate;
-@@ -897,7 +900,7 @@ minstrel_ht_update_stats(struct minstrel
- 			if (!(mi->supported[group] & BIT(i)))
- 				continue;
- 
--			index = MCS_GROUP_RATES * group + i;
-+			index = MI_RATE(group, i);
- 
- 			mrs = &mg->rates[i];
- 			mrs->retry_updated = false;
-@@ -929,13 +932,13 @@ minstrel_ht_update_stats(struct minstrel
- 			continue;
- 
- 		mg = &mi->groups[group];
--		mg->max_group_prob_rate = MCS_GROUP_RATES * group;
-+		mg->max_group_prob_rate = MI_RATE(group, 0);
- 
- 		for (i = 0; i < MCS_GROUP_RATES; i++) {
- 			if (!(mi->supported[group] & BIT(i)))
- 				continue;
- 
--			index = MCS_GROUP_RATES * group + i;
-+			index = MI_RATE(group, i);
- 
- 			/* Find max probability rate per group and global */
- 			minstrel_ht_set_best_prob_rate(mi, &tmp_max_prob_rate,
-@@ -1022,7 +1025,7 @@ minstrel_downgrade_rate(struct minstrel_
- {
- 	int group, orig_group;
- 
--	orig_group = group = *idx / MCS_GROUP_RATES;
-+	orig_group = group = MI_RATE_GROUP(*idx);
- 	while (group > 0) {
- 		group--;
- 
-@@ -1206,7 +1209,7 @@ minstrel_calc_retransmit(struct minstrel
- 	ctime += (t_slot * cw) >> 1;
- 	cw = min((cw << 1) | 1, mp->cw_max);
- 
--	if (minstrel_ht_is_legacy_group(index / MCS_GROUP_RATES)) {
-+	if (minstrel_ht_is_legacy_group(MI_RATE_GROUP(index))) {
- 		overhead = mi->overhead_legacy;
- 		overhead_rtscts = mi->overhead_legacy_rtscts;
- 	} else {
-@@ -1239,7 +1242,7 @@ static void
- minstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-                      struct ieee80211_sta_rates *ratetbl, int offset, int index)
- {
--	int group_idx = index / MCS_GROUP_RATES;
-+	int group_idx = MI_RATE_GROUP(index);
- 	const struct mcs_group *group = &minstrel_mcs_groups[group_idx];
- 	struct minstrel_rate_stats *mrs;
- 	u8 idx;
-@@ -1259,7 +1262,7 @@ minstrel_ht_set_rate(struct minstrel_pri
- 		ratetbl->rate[offset].count_rts = mrs->retry_count_rtscts;
- 	}
- 
--	index %= MCS_GROUP_RATES;
-+	index = MI_RATE_IDX(index);
- 	if (group_idx == MINSTREL_CCK_GROUP)
- 		idx = mp->cck_rates[index % ARRAY_SIZE(mp->cck_rates)];
- 	else if (group_idx == MINSTREL_OFDM_GROUP)
-@@ -1289,17 +1292,17 @@ minstrel_ht_set_rate(struct minstrel_pri
- static inline int
- minstrel_ht_get_prob_avg(struct minstrel_ht_sta *mi, int rate)
- {
--	int group = rate / MCS_GROUP_RATES;
--	rate %= MCS_GROUP_RATES;
-+	int group = MI_RATE_GROUP(rate);
-+	rate = MI_RATE_IDX(rate);
- 	return mi->groups[group].rates[rate].prob_avg;
- }
- 
- static int
- minstrel_ht_get_max_amsdu_len(struct minstrel_ht_sta *mi)
- {
--	int group = mi->max_prob_rate / MCS_GROUP_RATES;
-+	int group = MI_RATE_GROUP(mi->max_prob_rate);
- 	const struct mcs_group *g = &minstrel_mcs_groups[group];
--	int rate = mi->max_prob_rate % MCS_GROUP_RATES;
-+	int rate = MI_RATE_IDX(mi->max_prob_rate);
- 	unsigned int duration;
- 
- 	/* Disable A-MSDU if max_prob_rate is bad */
-@@ -1405,7 +1408,7 @@ minstrel_get_sample_rate(struct minstrel
- 		return -1;
- 
- 	mrs = &mg->rates[sample_idx];
--	sample_idx += sample_group * MCS_GROUP_RATES;
-+	sample_idx += MI_RATE(sample_group, 0);
- 
- 	tp_rate1 = mi->max_tp_rate[0];
- 
-@@ -1455,8 +1458,7 @@ minstrel_get_sample_rate(struct minstrel
- 	 * if the link is working perfectly.
- 	 */
- 
--	cur_max_tp_streams = minstrel_mcs_groups[tp_rate1 /
--		MCS_GROUP_RATES].streams;
-+	cur_max_tp_streams = minstrel_mcs_groups[MI_RATE_GROUP(tp_rate1)].streams;
- 	if (sample_dur >= minstrel_get_duration(tp_rate2) &&
- 	    (cur_max_tp_streams - 1 <
- 	     minstrel_mcs_groups[sample_group].streams ||
-@@ -1484,7 +1486,7 @@ minstrel_ht_get_rate(void *priv, struct
- 	int sample_idx;
- 
- 	if (!(info->flags & IEEE80211_TX_CTL_AMPDU) &&
--	    !minstrel_ht_is_legacy_group(mi->max_prob_rate / MCS_GROUP_RATES))
-+	    !minstrel_ht_is_legacy_group(MI_RATE_GROUP(mi->max_prob_rate)))
- 		minstrel_aggr_check(sta, txrc->skb);
- 
- 	info->flags |= mi->tx_flags;
-@@ -1512,8 +1514,8 @@ minstrel_ht_get_rate(void *priv, struct
- 	if (sample_idx < 0)
- 		return;
- 
--	sample_group = &minstrel_mcs_groups[sample_idx / MCS_GROUP_RATES];
--	sample_idx %= MCS_GROUP_RATES;
-+	sample_group = &minstrel_mcs_groups[MI_RATE_GROUP(sample_idx)];
-+	sample_idx = MI_RATE_IDX(sample_idx);
- 
- 	if (sample_group == &minstrel_mcs_groups[MINSTREL_CCK_GROUP] &&
- 	    (sample_idx >= 4) != txrc->short_preamble)
-@@ -1529,7 +1531,7 @@ minstrel_ht_get_rate(void *priv, struct
- 		int idx = sample_idx % ARRAY_SIZE(mp->ofdm_rates[0]);
- 		rate->idx = mp->ofdm_rates[mi->band][idx];
- 	} else if (sample_group->flags & IEEE80211_TX_RC_VHT_MCS) {
--		ieee80211_rate_set_vht(rate, sample_idx % MCS_GROUP_RATES,
-+		ieee80211_rate_set_vht(rate, MI_RATE_IDX(sample_idx),
- 				       sample_group->streams);
- 	} else {
- 		rate->idx = sample_idx + (sample_group->streams - 1) * 8;
-@@ -1898,8 +1900,8 @@ static u32 minstrel_ht_get_expected_thro
- 	struct minstrel_ht_sta *mi = priv_sta;
- 	int i, j, prob, tp_avg;
- 
--	i = mi->max_tp_rate[0] / MCS_GROUP_RATES;
--	j = mi->max_tp_rate[0] % MCS_GROUP_RATES;
-+	i = MI_RATE_GROUP(mi->max_tp_rate[0]);
-+	j = MI_RATE_IDX(mi->max_tp_rate[0]);
- 	prob = mi->groups[i].rates[j].prob_avg;
- 
- 	/* convert tp_avg from pkt per second in kbps */
---- a/net/mac80211/rc80211_minstrel_ht.h
-+++ b/net/mac80211/rc80211_minstrel_ht.h
-@@ -6,6 +6,8 @@
- #ifndef __RC_MINSTREL_HT_H
- #define __RC_MINSTREL_HT_H
- 
-+#include <linux/bitfield.h>
-+
- /* number of highest throughput rates to consider*/
- #define MAX_THR_RATES 4
- #define SAMPLE_COLUMNS	10	/* number of columns in sample table */
-@@ -57,6 +59,17 @@
- 
- #define MCS_GROUP_RATES		10
- 
-+#define MI_RATE_IDX_MASK	GENMASK(3, 0)
-+#define MI_RATE_GROUP_MASK	GENMASK(15, 4)
-+
-+#define MI_RATE(_group, _idx)				\
-+	(FIELD_PREP(MI_RATE_GROUP_MASK, _group) |	\
-+	 FIELD_PREP(MI_RATE_IDX_MASK, _idx))
-+
-+#define MI_RATE_IDX(_rate) FIELD_GET(MI_RATE_IDX_MASK, _rate)
-+#define MI_RATE_GROUP(_rate) FIELD_GET(MI_RATE_GROUP_MASK, _rate)
-+
-+
- struct minstrel_priv {
- 	struct ieee80211_hw *hw;
- 	bool has_mrr;
---- a/net/mac80211/rc80211_minstrel_ht_debugfs.c
-+++ b/net/mac80211/rc80211_minstrel_ht_debugfs.c
-@@ -56,7 +56,7 @@ minstrel_ht_stats_dump(struct minstrel_h
- 
- 	for (j = 0; j < MCS_GROUP_RATES; j++) {
- 		struct minstrel_rate_stats *mrs = &mi->groups[i].rates[j];
--		int idx = i * MCS_GROUP_RATES + j;
-+		int idx = MI_RATE(i, j);
- 		unsigned int duration;
- 
- 		if (!(mi->supported[i] & BIT(j)))
-@@ -201,7 +201,7 @@ minstrel_ht_stats_csv_dump(struct minstr
- 
- 	for (j = 0; j < MCS_GROUP_RATES; j++) {
- 		struct minstrel_rate_stats *mrs = &mi->groups[i].rates[j];
--		int idx = i * MCS_GROUP_RATES + j;
-+		int idx = MI_RATE(i, j);
- 		unsigned int duration;
- 
- 		if (!(mi->supported[i] & BIT(j)))
diff --git a/package/kernel/mac80211/patches/subsys/347-mac80211-minstrel_ht-update-total-packets-counter-in.patch b/package/kernel/mac80211/patches/subsys/347-mac80211-minstrel_ht-update-total-packets-counter-in.patch
deleted file mode 100644
index dce8104934..0000000000
--- a/package/kernel/mac80211/patches/subsys/347-mac80211-minstrel_ht-update-total-packets-counter-in.patch
+++ /dev/null
@@ -1,54 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 22 Jan 2021 18:21:13 +0100
-Subject: [PATCH] mac80211: minstrel_ht: update total packets counter in tx
- status path
-
-Keep the update in one place and prepare for further rework
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -1092,6 +1092,16 @@ minstrel_ht_tx_status(void *priv, struct
- 		info->status.ampdu_len = 1;
- 	}
- 
-+	/* wraparound */
-+	if (mi->total_packets >= ~0 - info->status.ampdu_len) {
-+		mi->total_packets = 0;
-+		mi->sample_packets = 0;
-+	}
-+
-+	mi->total_packets += info->status.ampdu_len;
-+	if (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)
-+		mi->sample_packets += info->status.ampdu_len;
-+
- 	mi->ampdu_packets++;
- 	mi->ampdu_len += info->status.ampdu_len;
- 
-@@ -1103,9 +1113,6 @@ minstrel_ht_tx_status(void *priv, struct
- 		mi->sample_count--;
- 	}
- 
--	if (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)
--		mi->sample_packets += info->status.ampdu_len;
--
- 	if (mi->sample_mode != MINSTREL_SAMPLE_IDLE)
- 		rate_sample = minstrel_get_ratestats(mi, mi->sample_rate);
- 
-@@ -1503,14 +1510,6 @@ minstrel_ht_get_rate(void *priv, struct
- 	else
- 		sample_idx = minstrel_get_sample_rate(mp, mi);
- 
--	mi->total_packets++;
--
--	/* wraparound */
--	if (mi->total_packets == ~0) {
--		mi->total_packets = 0;
--		mi->sample_packets = 0;
--	}
--
- 	if (sample_idx < 0)
- 		return;
- 
diff --git a/package/kernel/mac80211/patches/subsys/348-mac80211-minstrel_ht-reduce-the-need-to-sample-slowe.patch b/package/kernel/mac80211/patches/subsys/348-mac80211-minstrel_ht-reduce-the-need-to-sample-slowe.patch
deleted file mode 100644
index dc6f11e4b9..0000000000
--- a/package/kernel/mac80211/patches/subsys/348-mac80211-minstrel_ht-reduce-the-need-to-sample-slowe.patch
+++ /dev/null
@@ -1,102 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 22 Jan 2021 19:24:59 +0100
-Subject: [PATCH] mac80211: minstrel_ht: reduce the need to sample slower
- rates
-
-In order to more gracefully be able to fall back to lower rates without too
-much throughput fluctuations, initialize all untested rates below tested ones
-to the maximum probabilty of higher rates.
-Usually this leads to untested lower rates getting initialized with a
-probability value of 100%, making them better candidates for fallback without
-having to rely on random probing
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -791,14 +791,11 @@ minstrel_ht_calc_rate_stats(struct minst
- 	unsigned int cur_prob;
- 
- 	if (unlikely(mrs->attempts > 0)) {
--		mrs->sample_skipped = 0;
- 		cur_prob = MINSTREL_FRAC(mrs->success, mrs->attempts);
- 		minstrel_filter_avg_add(&mrs->prob_avg,
- 					&mrs->prob_avg_1, cur_prob);
- 		mrs->att_hist += mrs->attempts;
- 		mrs->succ_hist += mrs->success;
--	} else {
--		mrs->sample_skipped++;
- 	}
- 
- 	mrs->last_success = mrs->success;
-@@ -851,7 +848,6 @@ minstrel_ht_update_stats(struct minstrel
- 		mi->ampdu_packets = 0;
- 	}
- 
--	mi->sample_slow = 0;
- 	mi->sample_count = 0;
- 
- 	if (mi->supported[MINSTREL_CCK_GROUP])
-@@ -882,6 +878,7 @@ minstrel_ht_update_stats(struct minstrel
- 	/* Find best rate sets within all MCS groups*/
- 	for (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {
- 		u16 *tp_rate = tmp_mcs_tp_rate;
-+		u16 last_prob = 0;
- 
- 		mg = &mi->groups[group];
- 		if (!mi->supported[group])
-@@ -896,7 +893,7 @@ minstrel_ht_update_stats(struct minstrel
- 		if (group == MINSTREL_CCK_GROUP && ht_supported)
- 			tp_rate = tmp_legacy_tp_rate;
- 
--		for (i = 0; i < MCS_GROUP_RATES; i++) {
-+		for (i = MCS_GROUP_RATES - 1; i >= 0; i--) {
- 			if (!(mi->supported[group] & BIT(i)))
- 				continue;
- 
-@@ -905,6 +902,11 @@ minstrel_ht_update_stats(struct minstrel
- 			mrs = &mg->rates[i];
- 			mrs->retry_updated = false;
- 			minstrel_ht_calc_rate_stats(mp, mrs);
-+
-+			if (mrs->att_hist)
-+				last_prob = max(last_prob, mrs->prob_avg);
-+			else
-+				mrs->prob_avg = max(last_prob, mrs->prob_avg);
- 			cur_prob = mrs->prob_avg;
- 
- 			if (minstrel_ht_get_tp_avg(mi, group, i, cur_prob) == 0)
-@@ -1469,13 +1471,9 @@ minstrel_get_sample_rate(struct minstrel
- 	if (sample_dur >= minstrel_get_duration(tp_rate2) &&
- 	    (cur_max_tp_streams - 1 <
- 	     minstrel_mcs_groups[sample_group].streams ||
--	     sample_dur >= minstrel_get_duration(mi->max_prob_rate))) {
--		if (mrs->sample_skipped < 20)
-+	     sample_dur >= minstrel_get_duration(mi->max_prob_rate)))
- 			return -1;
- 
--		if (mi->sample_slow++ > 2)
--			return -1;
--	}
- 	mi->sample_tries--;
- 
- 	return sample_idx;
---- a/net/mac80211/rc80211_minstrel_ht.h
-+++ b/net/mac80211/rc80211_minstrel_ht.h
-@@ -123,7 +123,6 @@ struct minstrel_rate_stats {
- 	u8 retry_count;
- 	u8 retry_count_rtscts;
- 
--	u8 sample_skipped;
- 	bool retry_updated;
- };
- 
-@@ -179,7 +178,6 @@ struct minstrel_ht_sta {
- 	u8 sample_wait;
- 	u8 sample_tries;
- 	u8 sample_count;
--	u8 sample_slow;
- 
- 	enum minstrel_sample_mode sample_mode;
- 	u16 sample_rate;
diff --git a/package/kernel/mac80211/patches/subsys/349-mac80211-minstrel_ht-significantly-redesign-the-rate.patch b/package/kernel/mac80211/patches/subsys/349-mac80211-minstrel_ht-significantly-redesign-the-rate.patch
deleted file mode 100644
index 09f6fd2214..0000000000
--- a/package/kernel/mac80211/patches/subsys/349-mac80211-minstrel_ht-significantly-redesign-the-rate.patch
+++ /dev/null
@@ -1,767 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 22 Jan 2021 23:57:50 +0100
-Subject: [PATCH] mac80211: minstrel_ht: significantly redesign the rate
- probing strategy
-
-The biggest flaw in current minstrel_ht is the fact that it needs way too
-many probing packets to be able to quickly find the best rate.
-Depending on the wifi hardware and operating mode, this can significantly
-reduce throughput when not operating at the highest available data rate.
-
-In order to be able to significantly reduce the amount of rate sampling,
-we need a much smarter selection of probing rates.
-
-The new approach introduced by this patch maintains a limited set of
-available rates to be tested during a statistics window.
-
-They are split into distinct categories:
-- MINSTREL_SAMPLE_TYPE_INC - incremental rate upgrade:
-  Pick the next rate group and find the first rate that is faster than
-  the current max. throughput rate
-- MINSTREL_SAMPLE_TYPE_JUMP - random testing of higher rates:
-  Pick a random rate from the next group that is faster than the current
-  max throughput rate. This allows faster adaptation when the link changes
-  significantly
-- MINSTREL_SAMPLE_TYPE_SLOW - test a rate between max_prob, max_tp2 and
-  max_tp in order to reduce the gap between them
-
-In order to prioritize sampling, every 6 attempts are split into 3x INC,
-2x JUMP, 1x SLOW.
-
-Available rates are checked and refilled on every stats window update.
-
-With this approach, we finally get a very small delta in throughput when
-comparing setting the optimal data rate as a fixed rate vs normal rate
-control operation.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -266,6 +266,14 @@ const struct mcs_group minstrel_mcs_grou
- const s16 minstrel_cck_bitrates[4] = { 10, 20, 55, 110 };
- const s16 minstrel_ofdm_bitrates[8] = { 60, 90, 120, 180, 240, 360, 480, 540 };
- static u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES] __read_mostly;
-+static const u8 minstrel_sample_seq[] = {
-+	MINSTREL_SAMPLE_TYPE_INC,
-+	MINSTREL_SAMPLE_TYPE_JUMP,
-+	MINSTREL_SAMPLE_TYPE_INC,
-+	MINSTREL_SAMPLE_TYPE_JUMP,
-+	MINSTREL_SAMPLE_TYPE_INC,
-+	MINSTREL_SAMPLE_TYPE_SLOW,
-+};
- 
- static void
- minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
-@@ -620,77 +628,31 @@ minstrel_ht_prob_rate_reduce_streams(str
- 	}
- }
- 
--static bool
--minstrel_ht_probe_group(struct minstrel_ht_sta *mi, const struct mcs_group *tp_group,
--						int tp_idx, const struct mcs_group *group)
--{
--	if (group->bw < tp_group->bw)
--		return false;
--
--	if (group->streams == tp_group->streams)
--		return true;
--
--	if (tp_idx < 4 && group->streams == tp_group->streams - 1)
--		return true;
--
--	return group->streams == tp_group->streams + 1;
--}
--
--static void
--minstrel_ht_find_probe_rates(struct minstrel_ht_sta *mi, u16 *rates, int *n_rates,
--			     bool faster_rate)
-+static u16
-+__minstrel_ht_get_sample_rate(struct minstrel_ht_sta *mi,
-+			      enum minstrel_sample_type type)
- {
--	const struct mcs_group *group, *tp_group;
--	int i, g, max_dur;
--	int tp_idx;
--
--	tp_group = &minstrel_mcs_groups[MI_RATE_GROUP(mi->max_tp_rate[0])];
--	tp_idx = MI_RATE_IDX(mi->max_tp_rate[0]);
--
--	max_dur = minstrel_get_duration(mi->max_tp_rate[0]);
--	if (faster_rate)
--		max_dur -= max_dur / 16;
--
--	for (g = 0; g < MINSTREL_GROUPS_NB; g++) {
--		u16 supported = mi->supported[g];
--
--		if (!supported)
--			continue;
-+	u16 *rates = mi->sample[type].sample_rates;
-+	u16 cur;
-+	int i;
- 
--		group = &minstrel_mcs_groups[g];
--		if (!minstrel_ht_probe_group(mi, tp_group, tp_idx, group))
-+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++) {
-+		if (!rates[i])
- 			continue;
- 
--		for (i = 0; supported; supported >>= 1, i++) {
--			int idx;
--
--			if (!(supported & 1))
--				continue;
--
--			if ((group->duration[i] << group->shift) > max_dur)
--				continue;
--
--			idx = MI_RATE(g, i);
--			if (idx == mi->max_tp_rate[0])
--				continue;
--
--			rates[(*n_rates)++] = idx;
--			break;
--		}
-+		cur = rates[i];
-+		rates[i] = 0;
-+		return cur;
- 	}
-+
-+	return 0;
- }
- 
- static void
- minstrel_ht_rate_sample_switch(struct minstrel_priv *mp,
- 			       struct minstrel_ht_sta *mi)
- {
--	struct minstrel_rate_stats *mrs;
--	u16 rates[MINSTREL_GROUPS_NB];
--	int n_rates = 0;
--	int probe_rate = 0;
--	bool faster_rate;
--	int i;
--	u8 random;
-+	u16 rate;
- 
- 	/*
- 	 * Use rate switching instead of probing packets for devices with
-@@ -699,43 +661,11 @@ minstrel_ht_rate_sample_switch(struct mi
- 	if (mp->hw->max_rates > 1)
- 		return;
- 
--	/*
--	 * If the current EWMA prob is >75%, look for a rate that's 6.25%
--	 * faster than the max tp rate.
--	 * If that fails, look again for a rate that is at least as fast
--	 */
--	mrs = minstrel_get_ratestats(mi, mi->max_tp_rate[0]);
--	faster_rate = mrs->prob_avg > MINSTREL_FRAC(75, 100);
--	minstrel_ht_find_probe_rates(mi, rates, &n_rates, faster_rate);
--	if (!n_rates && faster_rate)
--		minstrel_ht_find_probe_rates(mi, rates, &n_rates, false);
--
--	/* If no suitable rate was found, try to pick the next one in the group */
--	if (!n_rates) {
--		int g_idx = MI_RATE_GROUP(mi->max_tp_rate[0]);
--		u16 supported = mi->supported[g_idx];
--
--		supported >>= MI_RATE_IDX(mi->max_tp_rate[0]);
--		for (i = 0; supported; supported >>= 1, i++) {
--			if (!(supported & 1))
--				continue;
--
--			probe_rate = mi->max_tp_rate[0] + i;
--			goto out;
--		}
--
-+	rate = __minstrel_ht_get_sample_rate(mi, MINSTREL_SAMPLE_TYPE_INC);
-+	if (!rate)
- 		return;
--	}
--
--	i = 0;
--	if (n_rates > 1) {
--		random = prandom_u32();
--		i = random % n_rates;
--	}
--	probe_rate = rates[i];
- 
--out:
--	mi->sample_rate = probe_rate;
-+	mi->sample_rate = rate;
- 	mi->sample_mode = MINSTREL_SAMPLE_ACTIVE;
- }
- 
-@@ -804,6 +734,274 @@ minstrel_ht_calc_rate_stats(struct minst
- 	mrs->attempts = 0;
- }
- 
-+static bool
-+minstrel_ht_find_sample_rate(struct minstrel_ht_sta *mi, int type, int idx)
-+{
-+	int i;
-+
-+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++) {
-+		u16 cur = mi->sample[type].sample_rates[i];
-+
-+		if (cur == idx)
-+			return true;
-+
-+		if (!cur)
-+			break;
-+	}
-+
-+	return false;
-+}
-+
-+static int
-+minstrel_ht_move_sample_rates(struct minstrel_ht_sta *mi, int type,
-+			      u32 fast_rate_dur, u32 slow_rate_dur)
-+{
-+	u16 *rates = mi->sample[type].sample_rates;
-+	int i, j;
-+
-+	for (i = 0, j = 0; i < MINSTREL_SAMPLE_RATES; i++) {
-+		u32 duration;
-+		bool valid = false;
-+		u16 cur;
-+
-+		cur = rates[i];
-+		if (!cur)
-+			continue;
-+
-+		duration = minstrel_get_duration(cur);
-+		switch (type) {
-+		case MINSTREL_SAMPLE_TYPE_SLOW:
-+			valid = duration > fast_rate_dur &&
-+				duration < slow_rate_dur;
-+			break;
-+		case MINSTREL_SAMPLE_TYPE_INC:
-+		case MINSTREL_SAMPLE_TYPE_JUMP:
-+			valid = duration < fast_rate_dur;
-+			break;
-+		default:
-+			valid = false;
-+			break;
-+		}
-+
-+		if (!valid) {
-+			rates[i] = 0;
-+			continue;
-+		}
-+
-+		if (i == j)
-+			continue;
-+
-+		rates[j++] = cur;
-+		rates[i] = 0;
-+	}
-+
-+	return j;
-+}
-+
-+static int
-+minstrel_ht_group_min_rate_offset(struct minstrel_ht_sta *mi, int group,
-+				  u32 max_duration)
-+{
-+	u16 supported = mi->supported[group];
-+	int i;
-+
-+	for (i = 0; i < MCS_GROUP_RATES && supported; i++, supported >>= 1) {
-+		if (!(supported & BIT(0)))
-+			continue;
-+
-+		if (minstrel_get_duration(MI_RATE(group, i)) >= max_duration)
-+			continue;
-+
-+		return i;
-+	}
-+
-+	return -1;
-+}
-+
-+/*
-+ * Incremental update rates:
-+ * Flip through groups and pick the first group rate that is faster than the
-+ * highest currently selected rate
-+ */
-+static u16
-+minstrel_ht_next_inc_rate(struct minstrel_ht_sta *mi, u32 fast_rate_dur)
-+{
-+	struct minstrel_mcs_group_data *mg;
-+	u8 type = MINSTREL_SAMPLE_TYPE_INC;
-+	int i, index = 0;
-+	u8 group;
-+
-+	group = mi->sample[type].sample_group;
-+	for (i = 0; i < ARRAY_SIZE(minstrel_mcs_groups); i++) {
-+		group = (group + 1) % ARRAY_SIZE(minstrel_mcs_groups);
-+		mg = &mi->groups[group];
-+
-+		index = minstrel_ht_group_min_rate_offset(mi, group,
-+							  fast_rate_dur);
-+		if (index < 0)
-+			continue;
-+
-+		index = MI_RATE(group, index & 0xf);
-+		if (!minstrel_ht_find_sample_rate(mi, type, index))
-+			goto out;
-+	}
-+	index = 0;
-+
-+out:
-+	mi->sample[type].sample_group = group;
-+
-+	return index;
-+}
-+
-+static int
-+minstrel_ht_next_group_sample_rate(struct minstrel_ht_sta *mi, int group,
-+				   u16 supported, int offset)
-+{
-+	struct minstrel_mcs_group_data *mg = &mi->groups[group];
-+	u16 idx;
-+	int i;
-+
-+	for (i = 0; i < MCS_GROUP_RATES; i++) {
-+		idx = sample_table[mg->column][mg->index];
-+		if (++mg->index >= MCS_GROUP_RATES) {
-+			mg->index = 0;
-+			if (++mg->column >= ARRAY_SIZE(sample_table))
-+				mg->column = 0;
-+		}
-+
-+		if (idx < offset)
-+			continue;
-+
-+		if (!(supported & BIT(idx)))
-+			continue;
-+
-+		return MI_RATE(group, idx);
-+	}
-+
-+	return -1;
-+}
-+
-+/*
-+ * Jump rates:
-+ * Sample random rates, use those that are faster than the highest
-+ * currently selected rate. Rates between the fastest and the slowest
-+ * get sorted into the slow sample bucket, but only if it has room
-+ */
-+static u16
-+minstrel_ht_next_jump_rate(struct minstrel_ht_sta *mi, u32 fast_rate_dur,
-+			   u32 slow_rate_dur, int *slow_rate_ofs)
-+{
-+	struct minstrel_mcs_group_data *mg;
-+	struct minstrel_rate_stats *mrs;
-+	u32 max_duration = slow_rate_dur;
-+	int i, index, offset;
-+	u16 *slow_rates;
-+	u16 supported;
-+	u32 duration;
-+	u8 group;
-+
-+	if (*slow_rate_ofs >= MINSTREL_SAMPLE_RATES)
-+		max_duration = fast_rate_dur;
-+
-+	slow_rates = mi->sample[MINSTREL_SAMPLE_TYPE_SLOW].sample_rates;
-+	group = mi->sample[MINSTREL_SAMPLE_TYPE_JUMP].sample_group;
-+	for (i = 0; i < ARRAY_SIZE(minstrel_mcs_groups); i++) {
-+		u8 type;
-+
-+		group = (group + 1) % ARRAY_SIZE(minstrel_mcs_groups);
-+		mg = &mi->groups[group];
-+
-+		supported = mi->supported[group];
-+		if (!supported)
-+			continue;
-+
-+		offset = minstrel_ht_group_min_rate_offset(mi, group,
-+							   max_duration);
-+		if (offset < 0)
-+			continue;
-+
-+		index = minstrel_ht_next_group_sample_rate(mi, group, supported,
-+							   offset);
-+		if (index < 0)
-+			continue;
-+
-+		duration = minstrel_get_duration(index);
-+		if (duration < fast_rate_dur)
-+			type = MINSTREL_SAMPLE_TYPE_JUMP;
-+		else
-+			type = MINSTREL_SAMPLE_TYPE_SLOW;
-+
-+		if (minstrel_ht_find_sample_rate(mi, type, index))
-+			continue;
-+
-+		if (type == MINSTREL_SAMPLE_TYPE_JUMP)
-+			goto found;
-+
-+		if (*slow_rate_ofs >= MINSTREL_SAMPLE_RATES)
-+			continue;
-+
-+		if (duration >= slow_rate_dur)
-+			continue;
-+
-+		/* skip slow rates with high success probability */
-+		mrs = minstrel_get_ratestats(mi, index);
-+		if (mrs->prob_avg > MINSTREL_FRAC(95, 100))
-+			continue;
-+
-+		slow_rates[(*slow_rate_ofs)++] = index;
-+		if (*slow_rate_ofs >= MINSTREL_SAMPLE_RATES)
-+			max_duration = fast_rate_dur;
-+	}
-+	index = 0;
-+
-+found:
-+	mi->sample[MINSTREL_SAMPLE_TYPE_JUMP].sample_group = group;
-+
-+	return index;
-+}
-+
-+static void
-+minstrel_ht_refill_sample_rates(struct minstrel_ht_sta *mi)
-+{
-+	u32 prob_dur = minstrel_get_duration(mi->max_prob_rate);
-+	u32 tp_dur = minstrel_get_duration(mi->max_tp_rate[0]);
-+	u32 tp2_dur = minstrel_get_duration(mi->max_tp_rate[1]);
-+	u32 fast_rate_dur = min(min(tp_dur, tp2_dur), prob_dur);
-+	u32 slow_rate_dur = max(max(tp_dur, tp2_dur), prob_dur);
-+	u16 *rates;
-+	int i, j;
-+
-+	rates = mi->sample[MINSTREL_SAMPLE_TYPE_INC].sample_rates;
-+	i = minstrel_ht_move_sample_rates(mi, MINSTREL_SAMPLE_TYPE_INC,
-+					  fast_rate_dur, slow_rate_dur);
-+	while (i < MINSTREL_SAMPLE_RATES) {
-+		rates[i] = minstrel_ht_next_inc_rate(mi, tp_dur);
-+		if (!rates[i])
-+			break;
-+
-+		i++;
-+	}
-+
-+	rates = mi->sample[MINSTREL_SAMPLE_TYPE_JUMP].sample_rates;
-+	i = minstrel_ht_move_sample_rates(mi, MINSTREL_SAMPLE_TYPE_JUMP,
-+					  fast_rate_dur, slow_rate_dur);
-+	j = minstrel_ht_move_sample_rates(mi, MINSTREL_SAMPLE_TYPE_SLOW,
-+					  fast_rate_dur, slow_rate_dur);
-+	while (i < MINSTREL_SAMPLE_RATES) {
-+		rates[i] = minstrel_ht_next_jump_rate(mi, fast_rate_dur,
-+						      slow_rate_dur, &j);
-+		if (!rates[i])
-+			break;
-+
-+		i++;
-+	}
-+
-+	for (i = 0; i < ARRAY_SIZE(mi->sample); i++)
-+		memcpy(mi->sample[i].cur_sample_rates, mi->sample[i].sample_rates,
-+		       sizeof(mi->sample[i].cur_sample_rates));
-+}
-+
-+
- /*
-  * Update rate statistics and select new primary rates
-  *
-@@ -848,8 +1046,6 @@ minstrel_ht_update_stats(struct minstrel
- 		mi->ampdu_packets = 0;
- 	}
- 
--	mi->sample_count = 0;
--
- 	if (mi->supported[MINSTREL_CCK_GROUP])
- 		group = MINSTREL_CCK_GROUP;
- 	else if (mi->supported[MINSTREL_OFDM_GROUP])
-@@ -884,8 +1080,6 @@ minstrel_ht_update_stats(struct minstrel
- 		if (!mi->supported[group])
- 			continue;
- 
--		mi->sample_count++;
--
- 		/* (re)Initialize group rate indexes */
- 		for(j = 0; j < MAX_THR_RATES; j++)
- 			tmp_group_tp_rate[j] = MI_RATE(group, 0);
-@@ -952,9 +1146,7 @@ minstrel_ht_update_stats(struct minstrel
- 
- 	/* Try to increase robustness of max_prob_rate*/
- 	minstrel_ht_prob_rate_reduce_streams(mi);
--
--	/* try to sample half of all available rates during each interval */
--	mi->sample_count *= 4;
-+	minstrel_ht_refill_sample_rates(mi);
- 
- 	if (sample)
- 		minstrel_ht_rate_sample_switch(mp, mi);
-@@ -971,6 +1163,7 @@ minstrel_ht_update_stats(struct minstrel
- 
- 	/* Reset update timer */
- 	mi->last_stats_update = jiffies;
-+	mi->sample_time = jiffies;
- }
- 
- static bool
-@@ -1001,28 +1194,6 @@ minstrel_ht_txstat_valid(struct minstrel
- }
- 
- static void
--minstrel_set_next_sample_idx(struct minstrel_ht_sta *mi)
--{
--	struct minstrel_mcs_group_data *mg;
--
--	for (;;) {
--		mi->sample_group++;
--		mi->sample_group %= ARRAY_SIZE(minstrel_mcs_groups);
--		mg = &mi->groups[mi->sample_group];
--
--		if (!mi->supported[mi->sample_group])
--			continue;
--
--		if (++mg->index >= MCS_GROUP_RATES) {
--			mg->index = 0;
--			if (++mg->column >= ARRAY_SIZE(sample_table))
--				mg->column = 0;
--		}
--		break;
--	}
--}
--
--static void
- minstrel_downgrade_rate(struct minstrel_ht_sta *mi, u16 *idx, bool primary)
- {
- 	int group, orig_group;
-@@ -1107,14 +1278,6 @@ minstrel_ht_tx_status(void *priv, struct
- 	mi->ampdu_packets++;
- 	mi->ampdu_len += info->status.ampdu_len;
- 
--	if (!mi->sample_wait && !mi->sample_tries && mi->sample_count > 0) {
--		int avg_ampdu_len = minstrel_ht_avg_ampdu_len(mi);
--
--		mi->sample_wait = 16 + 2 * avg_ampdu_len;
--		mi->sample_tries = 1;
--		mi->sample_count--;
--	}
--
- 	if (mi->sample_mode != MINSTREL_SAMPLE_IDLE)
- 		rate_sample = minstrel_get_ratestats(mi, mi->sample_rate);
- 
-@@ -1386,97 +1549,20 @@ minstrel_ht_update_rates(struct minstrel
- 	rate_control_set_rates(mp->hw, mi->sta, rates);
- }
- 
--static int
--minstrel_get_sample_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
-+static u16
-+minstrel_ht_get_sample_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
- {
--	struct minstrel_rate_stats *mrs;
--	struct minstrel_mcs_group_data *mg;
--	unsigned int sample_dur, sample_group, cur_max_tp_streams;
--	int tp_rate1, tp_rate2;
--	int sample_idx = 0;
--
--	if (mp->hw->max_rates == 1 && mp->sample_switch &&
--	    (mi->total_packets_cur >= SAMPLE_SWITCH_THR ||
--	     mp->sample_switch == 1))
--		return -1;
--
--	if (mi->sample_wait > 0) {
--		mi->sample_wait--;
--		return -1;
--	}
--
--	if (!mi->sample_tries)
--		return -1;
--
--	sample_group = mi->sample_group;
--	mg = &mi->groups[sample_group];
--	sample_idx = sample_table[mg->column][mg->index];
--	minstrel_set_next_sample_idx(mi);
--
--	if (!(mi->supported[sample_group] & BIT(sample_idx)))
--		return -1;
-+	u8 seq;
- 
--	mrs = &mg->rates[sample_idx];
--	sample_idx += MI_RATE(sample_group, 0);
--
--	tp_rate1 = mi->max_tp_rate[0];
--
--	/* Set tp_rate2 to the second highest max_tp_rate */
--	if (minstrel_get_duration(mi->max_tp_rate[0]) >
--	    minstrel_get_duration(mi->max_tp_rate[1])) {
--		tp_rate2 = mi->max_tp_rate[0];
-+	if (mp->hw->max_rates > 1) {
-+		seq = mi->sample_seq;
-+		mi->sample_seq = (seq + 1) % ARRAY_SIZE(minstrel_sample_seq);
-+		seq = minstrel_sample_seq[seq];
- 	} else {
--		tp_rate2 = mi->max_tp_rate[1];
-+		seq = MINSTREL_SAMPLE_TYPE_INC;
- 	}
- 
--	/*
--	 * Sampling might add some overhead (RTS, no aggregation)
--	 * to the frame. Hence, don't use sampling for the highest currently
--	 * used highest throughput or probability rate.
--	 */
--	if (sample_idx == mi->max_tp_rate[0] || sample_idx == mi->max_prob_rate)
--		return -1;
--
--	/*
--	 * Do not sample if the probability is already higher than 95%,
--	 * or if the rate is 3 times slower than the current max probability
--	 * rate, to avoid wasting airtime.
--	 */
--	sample_dur = minstrel_get_duration(sample_idx);
--	if (mrs->prob_avg > MINSTREL_FRAC(95, 100) ||
--	    minstrel_get_duration(mi->max_prob_rate) * 3 < sample_dur)
--		return -1;
--
--
--	/*
--	 * For devices with no configurable multi-rate retry, skip sampling
--	 * below the per-group max throughput rate, and only use one sampling
--	 * attempt per rate
--	 */
--	if (mp->hw->max_rates == 1 &&
--	    (minstrel_get_duration(mg->max_group_tp_rate[0]) < sample_dur ||
--	     mrs->attempts))
--		return -1;
--
--	/* Skip already sampled slow rates */
--	if (sample_dur >= minstrel_get_duration(tp_rate1) && mrs->attempts)
--		return -1;
--
--	/*
--	 * Make sure that lower rates get sampled only occasionally,
--	 * if the link is working perfectly.
--	 */
--
--	cur_max_tp_streams = minstrel_mcs_groups[MI_RATE_GROUP(tp_rate1)].streams;
--	if (sample_dur >= minstrel_get_duration(tp_rate2) &&
--	    (cur_max_tp_streams - 1 <
--	     minstrel_mcs_groups[sample_group].streams ||
--	     sample_dur >= minstrel_get_duration(mi->max_prob_rate)))
--			return -1;
--
--	mi->sample_tries--;
--
--	return sample_idx;
-+	return __minstrel_ht_get_sample_rate(mi, seq);
- }
- 
- static void
-@@ -1488,7 +1574,7 @@ minstrel_ht_get_rate(void *priv, struct
- 	struct ieee80211_tx_rate *rate = &info->status.rates[0];
- 	struct minstrel_ht_sta *mi = priv_sta;
- 	struct minstrel_priv *mp = priv;
--	int sample_idx;
-+	u16 sample_idx;
- 
- 	if (!(info->flags & IEEE80211_TX_CTL_AMPDU) &&
- 	    !minstrel_ht_is_legacy_group(MI_RATE_GROUP(mi->max_prob_rate)))
-@@ -1504,11 +1590,19 @@ minstrel_ht_get_rate(void *priv, struct
- 	/* Don't use EAPOL frames for sampling on non-mrr hw */
- 	if (mp->hw->max_rates == 1 &&
- 	    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
--		sample_idx = -1;
--	else
--		sample_idx = minstrel_get_sample_rate(mp, mi);
-+		return;
-+
-+	if (mp->hw->max_rates == 1 && mp->sample_switch &&
-+	    (mi->total_packets_cur >= SAMPLE_SWITCH_THR ||
-+	     mp->sample_switch == 1))
-+		return;
-+
-+	if (time_is_before_jiffies(mi->sample_time))
-+		return;
- 
--	if (sample_idx < 0)
-+	mi->sample_time = jiffies + MINSTREL_SAMPLE_INTERVAL;
-+	sample_idx = minstrel_ht_get_sample_rate(mp, mi);
-+	if (!sample_idx)
- 		return;
- 
- 	sample_group = &minstrel_mcs_groups[MI_RATE_GROUP(sample_idx)];
-@@ -1629,16 +1723,6 @@ minstrel_ht_update_caps(void *priv, stru
- 
- 	mi->avg_ampdu_len = MINSTREL_FRAC(1, 1);
- 
--	/* When using MRR, sample more on the first attempt, without delay */
--	if (mp->has_mrr) {
--		mi->sample_count = 16;
--		mi->sample_wait = 0;
--	} else {
--		mi->sample_count = 8;
--		mi->sample_wait = 8;
--	}
--	mi->sample_tries = 4;
--
- 	if (!use_vht) {
- 		stbc = (ht_cap & IEEE80211_HT_CAP_RX_STBC) >>
- 			IEEE80211_HT_CAP_RX_STBC_SHIFT;
---- a/net/mac80211/rc80211_minstrel_ht.h
-+++ b/net/mac80211/rc80211_minstrel_ht.h
-@@ -69,6 +69,8 @@
- #define MI_RATE_IDX(_rate) FIELD_GET(MI_RATE_IDX_MASK, _rate)
- #define MI_RATE_GROUP(_rate) FIELD_GET(MI_RATE_GROUP_MASK, _rate)
- 
-+#define MINSTREL_SAMPLE_RATES		5 /* rates per sample type */
-+#define MINSTREL_SAMPLE_INTERVAL	(HZ / 50)
- 
- struct minstrel_priv {
- 	struct ieee80211_hw *hw;
-@@ -126,6 +128,13 @@ struct minstrel_rate_stats {
- 	bool retry_updated;
- };
- 
-+enum minstrel_sample_type {
-+	MINSTREL_SAMPLE_TYPE_INC,
-+	MINSTREL_SAMPLE_TYPE_JUMP,
-+	MINSTREL_SAMPLE_TYPE_SLOW,
-+	__MINSTREL_SAMPLE_TYPE_MAX
-+};
-+
- struct minstrel_mcs_group_data {
- 	u8 index;
- 	u8 column;
-@@ -144,6 +153,12 @@ enum minstrel_sample_mode {
- 	MINSTREL_SAMPLE_PENDING,
- };
- 
-+struct minstrel_sample_category {
-+	u8 sample_group;
-+	u16 sample_rates[MINSTREL_SAMPLE_RATES];
-+	u16 cur_sample_rates[MINSTREL_SAMPLE_RATES];
-+};
-+
- struct minstrel_ht_sta {
- 	struct ieee80211_sta *sta;
- 
-@@ -175,16 +190,14 @@ struct minstrel_ht_sta {
- 	/* tx flags to add for frames for this sta */
- 	u32 tx_flags;
- 
--	u8 sample_wait;
--	u8 sample_tries;
--	u8 sample_count;
-+	unsigned long sample_time;
-+	struct minstrel_sample_category sample[__MINSTREL_SAMPLE_TYPE_MAX];
-+
-+	u8 sample_seq;
- 
- 	enum minstrel_sample_mode sample_mode;
- 	u16 sample_rate;
- 
--	/* current MCS group to be sampled */
--	u8 sample_group;
--
- 	u8 band;
- 
- 	/* Bitfield of supported MCS rates of all groups */
diff --git a/package/kernel/mac80211/patches/subsys/350-mac80211-minstrel_ht-show-sampling-rates-in-debugfs.patch b/package/kernel/mac80211/patches/subsys/350-mac80211-minstrel_ht-show-sampling-rates-in-debugfs.patch
deleted file mode 100644
index 041ba31a37..0000000000
--- a/package/kernel/mac80211/patches/subsys/350-mac80211-minstrel_ht-show-sampling-rates-in-debugfs.patch
+++ /dev/null
@@ -1,58 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 23 Jan 2021 00:10:34 +0100
-Subject: [PATCH] mac80211: minstrel_ht: show sampling rates in debugfs
-
-This makes it easier to see what rates are going to be tested next
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht_debugfs.c
-+++ b/net/mac80211/rc80211_minstrel_ht_debugfs.c
-@@ -32,6 +32,18 @@ minstrel_stats_release(struct inode *ino
- 	return 0;
- }
- 
-+static bool
-+minstrel_ht_is_sample_rate(struct minstrel_ht_sta *mi, int idx)
-+{
-+	int type, i;
-+
-+	for (type = 0; type < ARRAY_SIZE(mi->sample); type++)
-+		for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
-+			if (mi->sample[type].cur_sample_rates[i] == idx)
-+				return true;
-+	return false;
-+}
-+
- static char *
- minstrel_ht_stats_dump(struct minstrel_ht_sta *mi, int i, char *p)
- {
-@@ -84,6 +96,7 @@ minstrel_ht_stats_dump(struct minstrel_h
- 		*(p++) = (idx == mi->max_tp_rate[2]) ? 'C' : ' ';
- 		*(p++) = (idx == mi->max_tp_rate[3]) ? 'D' : ' ';
- 		*(p++) = (idx == mi->max_prob_rate) ? 'P' : ' ';
-+		*(p++) = minstrel_ht_is_sample_rate(mi, idx) ? 'S' : ' ';
- 
- 		if (gflags & IEEE80211_TX_RC_MCS) {
- 			p += sprintf(p, "  MCS%-2u", (mg->streams - 1) * 8 + j);
-@@ -145,9 +158,9 @@ minstrel_ht_stats_open(struct inode *ino
- 
- 	p += sprintf(p, "\n");
- 	p += sprintf(p,
--		     "              best   ____________rate__________    ____statistics___    _____last____    ______sum-of________\n");
-+		     "              best    ____________rate__________    ____statistics___    _____last____    ______sum-of________\n");
- 	p += sprintf(p,
--		     "mode guard #  rate  [name   idx airtime  max_tp]  [avg(tp) avg(prob)]  [retry|suc|att]  [#success | #attempts]\n");
-+		     "mode guard #  rate   [name   idx airtime  max_tp]  [avg(tp) avg(prob)]  [retry|suc|att]  [#success | #attempts]\n");
- 
- 	p = minstrel_ht_stats_dump(mi, MINSTREL_CCK_GROUP, p);
- 	for (i = 0; i < MINSTREL_CCK_GROUP; i++)
-@@ -228,6 +241,7 @@ minstrel_ht_stats_csv_dump(struct minstr
- 		p += sprintf(p, "%s" ,((idx == mi->max_tp_rate[2]) ? "C" : ""));
- 		p += sprintf(p, "%s" ,((idx == mi->max_tp_rate[3]) ? "D" : ""));
- 		p += sprintf(p, "%s" ,((idx == mi->max_prob_rate) ? "P" : ""));
-+		p += sprintf(p, "%s", (minstrel_ht_is_sample_rate(mi, idx) ? "S" : ""));
- 
- 		if (gflags & IEEE80211_TX_RC_MCS) {
- 			p += sprintf(p, ",MCS%-2u,", (mg->streams - 1) * 8 + j);
diff --git a/package/kernel/mac80211/patches/subsys/351-mac80211-minstrel_ht-remove-sample-rate-switching-co.patch b/package/kernel/mac80211/patches/subsys/351-mac80211-minstrel_ht-remove-sample-rate-switching-co.patch
deleted file mode 100644
index 8170ff85f8..0000000000
--- a/package/kernel/mac80211/patches/subsys/351-mac80211-minstrel_ht-remove-sample-rate-switching-co.patch
+++ /dev/null
@@ -1,279 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 23 Jan 2021 07:18:26 +0100
-Subject: [PATCH] mac80211: minstrel_ht: remove sample rate switching code for
- constrained devices
-
-This was added to mitigate the effects of too much sampling on devices that
-use a static global fallback table instead of configurable multi-rate retry.
-Now that the sampling algorithm is improved, this code path no longer performs
-any better than the standard probing on affected devices.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -648,27 +648,6 @@ __minstrel_ht_get_sample_rate(struct min
- 	return 0;
- }
- 
--static void
--minstrel_ht_rate_sample_switch(struct minstrel_priv *mp,
--			       struct minstrel_ht_sta *mi)
--{
--	u16 rate;
--
--	/*
--	 * Use rate switching instead of probing packets for devices with
--	 * little control over retry fallback behavior
--	 */
--	if (mp->hw->max_rates > 1)
--		return;
--
--	rate = __minstrel_ht_get_sample_rate(mi, MINSTREL_SAMPLE_TYPE_INC);
--	if (!rate)
--		return;
--
--	mi->sample_rate = rate;
--	mi->sample_mode = MINSTREL_SAMPLE_ACTIVE;
--}
--
- static inline int
- minstrel_ewma(int old, int new, int weight)
- {
-@@ -1012,8 +991,7 @@ minstrel_ht_refill_sample_rates(struct m
-  *    higher throughput rates, even if the probablity is a bit lower
-  */
- static void
--minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
--			 bool sample)
-+minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
- {
- 	struct minstrel_mcs_group_data *mg;
- 	struct minstrel_rate_stats *mrs;
-@@ -1023,18 +1001,6 @@ minstrel_ht_update_stats(struct minstrel
- 	u16 index;
- 	bool ht_supported = mi->sta->ht_cap.ht_supported;
- 
--	mi->sample_mode = MINSTREL_SAMPLE_IDLE;
--
--	if (sample) {
--		mi->total_packets_cur = mi->total_packets -
--					mi->total_packets_last;
--		mi->total_packets_last = mi->total_packets;
--	}
--	if (!mp->sample_switch)
--		sample = false;
--	if (mi->total_packets_cur < SAMPLE_SWITCH_THR && mp->sample_switch != 1)
--	    sample = false;
--
- 	if (mi->ampdu_packets > 0) {
- 		if (!ieee80211_hw_check(mp->hw, TX_STATUS_NO_AMPDU_LEN))
- 			mi->avg_ampdu_len = minstrel_ewma(mi->avg_ampdu_len,
-@@ -1148,16 +1114,12 @@ minstrel_ht_update_stats(struct minstrel
- 	minstrel_ht_prob_rate_reduce_streams(mi);
- 	minstrel_ht_refill_sample_rates(mi);
- 
--	if (sample)
--		minstrel_ht_rate_sample_switch(mp, mi);
--
- #ifdef CPTCFG_MAC80211_DEBUGFS
- 	/* use fixed index if set */
- 	if (mp->fixed_rate_idx != -1) {
- 		for (i = 0; i < 4; i++)
- 			mi->max_tp_rate[i] = mp->fixed_rate_idx;
- 		mi->max_prob_rate = mp->fixed_rate_idx;
--		mi->sample_mode = MINSTREL_SAMPLE_IDLE;
- 	}
- #endif
- 
-@@ -1247,11 +1209,10 @@ minstrel_ht_tx_status(void *priv, struct
- 	struct ieee80211_tx_info *info = st->info;
- 	struct minstrel_ht_sta *mi = priv_sta;
- 	struct ieee80211_tx_rate *ar = info->status.rates;
--	struct minstrel_rate_stats *rate, *rate2, *rate_sample = NULL;
-+	struct minstrel_rate_stats *rate, *rate2;
- 	struct minstrel_priv *mp = priv;
- 	u32 update_interval = mp->update_interval;
- 	bool last, update = false;
--	bool sample_status = false;
- 	int i;
- 
- 	/* This packet was aggregated but doesn't carry status info */
-@@ -1278,49 +1239,18 @@ minstrel_ht_tx_status(void *priv, struct
- 	mi->ampdu_packets++;
- 	mi->ampdu_len += info->status.ampdu_len;
- 
--	if (mi->sample_mode != MINSTREL_SAMPLE_IDLE)
--		rate_sample = minstrel_get_ratestats(mi, mi->sample_rate);
--
- 	last = !minstrel_ht_txstat_valid(mp, mi, &ar[0]);
- 	for (i = 0; !last; i++) {
- 		last = (i == IEEE80211_TX_MAX_RATES - 1) ||
- 		       !minstrel_ht_txstat_valid(mp, mi, &ar[i + 1]);
- 
- 		rate = minstrel_ht_get_stats(mp, mi, &ar[i]);
--		if (rate == rate_sample)
--			sample_status = true;
--
- 		if (last)
- 			rate->success += info->status.ampdu_ack_len;
- 
- 		rate->attempts += ar[i].count * info->status.ampdu_len;
- 	}
- 
--	switch (mi->sample_mode) {
--	case MINSTREL_SAMPLE_IDLE:
--		if (mp->hw->max_rates > 1 ||
--		     mi->total_packets_cur < SAMPLE_SWITCH_THR)
--			update_interval /= 2;
--		break;
--
--	case MINSTREL_SAMPLE_ACTIVE:
--		if (!sample_status)
--			break;
--
--		mi->sample_mode = MINSTREL_SAMPLE_PENDING;
--		update = true;
--		break;
--
--	case MINSTREL_SAMPLE_PENDING:
--		if (sample_status)
--			break;
--
--		update = true;
--		minstrel_ht_update_stats(mp, mi, false);
--		break;
--	}
--
--
- 	if (mp->hw->max_rates > 1) {
- 		/*
- 		 * check for sudden death of spatial multiplexing,
-@@ -1343,7 +1273,7 @@ minstrel_ht_tx_status(void *priv, struct
- 
- 	if (time_after(jiffies, mi->last_stats_update + update_interval)) {
- 		update = true;
--		minstrel_ht_update_stats(mp, mi, true);
-+		minstrel_ht_update_stats(mp, mi);
- 	}
- 
- 	if (update)
-@@ -1522,18 +1452,14 @@ static void
- minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
- {
- 	struct ieee80211_sta_rates *rates;
--	u16 first_rate = mi->max_tp_rate[0];
- 	int i = 0;
- 
--	if (mi->sample_mode == MINSTREL_SAMPLE_ACTIVE)
--		first_rate = mi->sample_rate;
--
- 	rates = kzalloc(sizeof(*rates), GFP_ATOMIC);
- 	if (!rates)
- 		return;
- 
- 	/* Start with max_tp_rate[0] */
--	minstrel_ht_set_rate(mp, mi, rates, i++, first_rate);
-+	minstrel_ht_set_rate(mp, mi, rates, i++, mi->max_tp_rate[0]);
- 
- 	if (mp->hw->max_rates >= 3) {
- 		/* At least 3 tx rates supported, use max_tp_rate[1] next */
-@@ -1592,11 +1518,6 @@ minstrel_ht_get_rate(void *priv, struct
- 	    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
- 		return;
- 
--	if (mp->hw->max_rates == 1 && mp->sample_switch &&
--	    (mi->total_packets_cur >= SAMPLE_SWITCH_THR ||
--	     mp->sample_switch == 1))
--		return;
--
- 	if (time_is_before_jiffies(mi->sample_time))
- 		return;
- 
-@@ -1810,7 +1731,7 @@ minstrel_ht_update_caps(void *priv, stru
- 	minstrel_ht_update_ofdm(mp, mi, sband, sta);
- 
- 	/* create an initial rate table with the lowest supported rates */
--	minstrel_ht_update_stats(mp, mi, true);
-+	minstrel_ht_update_stats(mp, mi);
- 	minstrel_ht_update_rates(mp, mi);
- }
- 
-@@ -1926,8 +1847,6 @@ minstrel_ht_alloc(struct ieee80211_hw *h
- 	if (!mp)
- 		return NULL;
- 
--	mp->sample_switch = -1;
--
- 	/* contention window settings
- 	 * Just an approximation. Using the per-queue values would complicate
- 	 * the calculations and is probably unnecessary */
-@@ -1947,7 +1866,7 @@ minstrel_ht_alloc(struct ieee80211_hw *h
- 		mp->has_mrr = true;
- 
- 	mp->hw = hw;
--	mp->update_interval = HZ / 10;
-+	mp->update_interval = HZ / 20;
- 
- 	minstrel_ht_init_cck_rates(mp);
- 	for (i = 0; i < ARRAY_SIZE(mp->hw->wiphy->bands); i++)
-@@ -1965,8 +1884,6 @@ static void minstrel_ht_add_debugfs(stru
- 	mp->fixed_rate_idx = (u32) -1;
- 	debugfs_create_u32("fixed_rate_idx", S_IRUGO | S_IWUGO, debugfsdir,
- 			   &mp->fixed_rate_idx);
--	debugfs_create_u32("sample_switch", S_IRUGO | S_IWUSR, debugfsdir,
--			   &mp->sample_switch);
- }
- #endif
- 
---- a/net/mac80211/rc80211_minstrel_ht.h
-+++ b/net/mac80211/rc80211_minstrel_ht.h
-@@ -75,7 +75,6 @@
- struct minstrel_priv {
- 	struct ieee80211_hw *hw;
- 	bool has_mrr;
--	u32 sample_switch;
- 	unsigned int cw_min;
- 	unsigned int cw_max;
- 	unsigned int max_retry;
-@@ -147,12 +146,6 @@ struct minstrel_mcs_group_data {
- 	struct minstrel_rate_stats rates[MCS_GROUP_RATES];
- };
- 
--enum minstrel_sample_mode {
--	MINSTREL_SAMPLE_IDLE,
--	MINSTREL_SAMPLE_ACTIVE,
--	MINSTREL_SAMPLE_PENDING,
--};
--
- struct minstrel_sample_category {
- 	u8 sample_group;
- 	u16 sample_rates[MINSTREL_SAMPLE_RATES];
-@@ -182,23 +175,19 @@ struct minstrel_ht_sta {
- 	unsigned int overhead_legacy;
- 	unsigned int overhead_legacy_rtscts;
- 
--	unsigned int total_packets_last;
--	unsigned int total_packets_cur;
- 	unsigned int total_packets;
- 	unsigned int sample_packets;
- 
- 	/* tx flags to add for frames for this sta */
- 	u32 tx_flags;
- 
--	unsigned long sample_time;
--	struct minstrel_sample_category sample[__MINSTREL_SAMPLE_TYPE_MAX];
-+	u8 band;
- 
- 	u8 sample_seq;
--
--	enum minstrel_sample_mode sample_mode;
- 	u16 sample_rate;
- 
--	u8 band;
-+	unsigned long sample_time;
-+	struct minstrel_sample_category sample[__MINSTREL_SAMPLE_TYPE_MAX];
- 
- 	/* Bitfield of supported MCS rates of all groups */
- 	u16 supported[MINSTREL_GROUPS_NB];
diff --git a/package/kernel/mac80211/patches/subsys/352-mac80211-minstrel_ht-fix-regression-in-the-max_prob_.patch b/package/kernel/mac80211/patches/subsys/352-mac80211-minstrel_ht-fix-regression-in-the-max_prob_.patch
deleted file mode 100644
index a366a921d4..0000000000
--- a/package/kernel/mac80211/patches/subsys/352-mac80211-minstrel_ht-fix-regression-in-the-max_prob_.patch
+++ /dev/null
@@ -1,23 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Tue, 26 Jan 2021 16:40:52 +0100
-Subject: [PATCH] mac80211: minstrel_ht: fix regression in the max_prob_rate
- fix
-
-Since mi->max_prob_rate is overwritten after the loop that calls
-minstrel_ht_set_best_prob_rate, the new best rate needs to be written to *dest
-
-Fixes: a7fca4e4037f ("mac80211: minstrel_ht: fix max probability rate selection")
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -545,7 +545,7 @@ minstrel_ht_set_best_prob_rate(struct mi
- 		cur_tp_avg = minstrel_ht_get_tp_avg(mi, cur_group, cur_idx,
- 						    mrs->prob_avg);
- 		if (cur_tp_avg > tmp_tp_avg)
--			mi->max_prob_rate = index;
-+			*dest = index;
- 
- 		max_gpr_tp_avg = minstrel_ht_get_tp_avg(mi, max_gpr_group,
- 							max_gpr_idx,
diff --git a/package/kernel/mac80211/patches/subsys/371-mac80211-don-t-apply-flow-control-on-management-fram.patch b/package/kernel/mac80211/patches/subsys/371-mac80211-don-t-apply-flow-control-on-management-fram.patch
deleted file mode 100644
index 0d3b42f3b9..0000000000
--- a/package/kernel/mac80211/patches/subsys/371-mac80211-don-t-apply-flow-control-on-management-fram.patch
+++ /dev/null
@@ -1,60 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Fri, 19 Mar 2021 23:28:01 +0100
-Subject: [PATCH] mac80211: don't apply flow control on management frames
-
-In some cases (depending on the driver, but it's true e.g. for
-iwlwifi) we're using an internal TXQ for management packets,
-mostly to simplify the code and to have a place to queue them.
-However, it appears that in certain cases we can confuse the
-code and management frames are dropped, which is certainly not
-what we want.
-
-Short-circuit the processing of management frames. To keep the
-impact minimal, only put them on the frags queue and check the
-tid == management only for doing that and to skip the airtime
-fairness checks, if applicable.
-
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -5,7 +5,7 @@
-  * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
-  * Copyright 2007	Johannes Berg <johannes@sipsolutions.net>
-  * Copyright 2013-2014  Intel Mobile Communications GmbH
-- * Copyright (C) 2018-2020 Intel Corporation
-+ * Copyright (C) 2018-2021 Intel Corporation
-  *
-  * Transmit and frame generation functions.
-  */
-@@ -1401,8 +1401,17 @@ static void ieee80211_txq_enqueue(struct
- 	ieee80211_set_skb_enqueue_time(skb);
- 
- 	spin_lock_bh(&fq->lock);
--	fq_tin_enqueue(fq, tin, flow_idx, skb,
--		       fq_skb_free_func);
-+	/*
-+	 * For management frames, don't really apply codel etc.,
-+	 * we don't want to apply any shaping or anything we just
-+	 * want to simplify the driver API by having them on the
-+	 * txqi.
-+	 */
-+	if (unlikely(txqi->txq.tid == IEEE80211_NUM_TIDS))
-+		__skb_queue_tail(&txqi->frags, skb);
-+	else
-+		fq_tin_enqueue(fq, tin, flow_idx, skb,
-+			       fq_skb_free_func);
- 	spin_unlock_bh(&fq->lock);
- }
- 
-@@ -3878,6 +3887,9 @@ bool ieee80211_txq_airtime_check(struct
- 	if (!txq->sta)
- 		return true;
- 
-+	if (unlikely(txq->tid == IEEE80211_NUM_TIDS))
-+		return true;
-+
- 	sta = container_of(txq->sta, struct sta_info, sta);
- 	if (atomic_read(&sta->airtime[txq->ac].aql_tx_pending) <
- 	    sta->airtime[txq->ac].aql_limit_low)
diff --git a/package/kernel/mac80211/patches/subsys/372-mac80211-set-sk_pacing_shift-for-802.3-txpath.patch b/package/kernel/mac80211/patches/subsys/372-mac80211-set-sk_pacing_shift-for-802.3-txpath.patch
deleted file mode 100644
index 9e57d01e0b..0000000000
--- a/package/kernel/mac80211/patches/subsys/372-mac80211-set-sk_pacing_shift-for-802.3-txpath.patch
+++ /dev/null
@@ -1,21 +0,0 @@
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Mon, 8 Mar 2021 23:01:49 +0100
-Subject: [PATCH] mac80211: set sk_pacing_shift for 802.3 txpath
-
-Similar to 802.11 txpath, set socket sk_pacing_shift for 802.3 tx path.
-
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
----
-
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -4205,6 +4205,9 @@ static bool ieee80211_tx_8023(struct iee
- 	unsigned long flags;
- 	int q = info->hw_queue;
- 
-+	if (sta)
-+		sk_pacing_shift_update(skb->sk, local->hw.tx_sk_pacing_shift);
-+
- 	if (ieee80211_queue_skb(local, sdata, sta, skb))
- 		return true;
- 
diff --git a/package/kernel/mac80211/patches/subsys/373-mac80211-support-Rx-timestamp-calculation-for-all-pr.patch b/package/kernel/mac80211/patches/subsys/373-mac80211-support-Rx-timestamp-calculation-for-all-pr.patch
deleted file mode 100644
index 34933abdaf..0000000000
--- a/package/kernel/mac80211/patches/subsys/373-mac80211-support-Rx-timestamp-calculation-for-all-pr.patch
+++ /dev/null
@@ -1,134 +0,0 @@
-From: Avraham Stern <avraham.stern@intel.com>
-Date: Sun, 6 Dec 2020 14:54:45 +0200
-Subject: [PATCH] mac80211: support Rx timestamp calculation for all preamble
- types
-
-Add support for calculating the Rx timestamp for HE frames.
-Since now all frame types are supported, allow setting the Rx
-timestamp regardless of the frame type.
-
-Signed-off-by: Avraham Stern <avraham.stern@intel.com>
-Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
-Link: https://lore.kernel.org/r/iwlwifi.20201206145305.4786559af475.Ia54486bb0a12e5351f9d5c60ef6fcda7c9e7141c@changeid
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -1592,13 +1592,8 @@ ieee80211_have_rx_timestamp(struct ieee8
- {
- 	WARN_ON_ONCE(status->flag & RX_FLAG_MACTIME_START &&
- 		     status->flag & RX_FLAG_MACTIME_END);
--	if (status->flag & (RX_FLAG_MACTIME_START | RX_FLAG_MACTIME_END))
--		return true;
--	/* can't handle non-legacy preamble yet */
--	if (status->flag & RX_FLAG_MACTIME_PLCP_START &&
--	    status->encoding == RX_ENC_LEGACY)
--		return true;
--	return false;
-+	return !!(status->flag & (RX_FLAG_MACTIME_START | RX_FLAG_MACTIME_END |
-+				  RX_FLAG_MACTIME_PLCP_START));
- }
- 
- void ieee80211_vif_inc_num_mcast(struct ieee80211_sub_if_data *sdata);
---- a/net/mac80211/util.c
-+++ b/net/mac80211/util.c
-@@ -3673,6 +3673,7 @@ u64 ieee80211_calculate_rx_timestamp(str
- 	u64 ts = status->mactime;
- 	struct rate_info ri;
- 	u16 rate;
-+	u8 n_ltf;
- 
- 	if (WARN_ON(!ieee80211_have_rx_timestamp(status)))
- 		return 0;
-@@ -3683,11 +3684,58 @@ u64 ieee80211_calculate_rx_timestamp(str
- 
- 	/* Fill cfg80211 rate info */
- 	switch (status->encoding) {
-+	case RX_ENC_HE:
-+		ri.flags |= RATE_INFO_FLAGS_HE_MCS;
-+		ri.mcs = status->rate_idx;
-+		ri.nss = status->nss;
-+		ri.he_ru_alloc = status->he_ru;
-+		if (status->enc_flags & RX_ENC_FLAG_SHORT_GI)
-+			ri.flags |= RATE_INFO_FLAGS_SHORT_GI;
-+
-+		/*
-+		 * See P802.11ax_D6.0, section 27.3.4 for
-+		 * VHT PPDU format.
-+		 */
-+		if (status->flag & RX_FLAG_MACTIME_PLCP_START) {
-+			mpdu_offset += 2;
-+			ts += 36;
-+
-+			/*
-+			 * TODO:
-+			 * For HE MU PPDU, add the HE-SIG-B.
-+			 * For HE ER PPDU, add 8us for the HE-SIG-A.
-+			 * For HE TB PPDU, add 4us for the HE-STF.
-+			 * Add the HE-LTF durations - variable.
-+			 */
-+		}
-+
-+		break;
- 	case RX_ENC_HT:
- 		ri.mcs = status->rate_idx;
- 		ri.flags |= RATE_INFO_FLAGS_MCS;
- 		if (status->enc_flags & RX_ENC_FLAG_SHORT_GI)
- 			ri.flags |= RATE_INFO_FLAGS_SHORT_GI;
-+
-+		/*
-+		 * See P802.11REVmd_D3.0, section 19.3.2 for
-+		 * HT PPDU format.
-+		 */
-+		if (status->flag & RX_FLAG_MACTIME_PLCP_START) {
-+			mpdu_offset += 2;
-+			if (status->enc_flags & RX_ENC_FLAG_HT_GF)
-+				ts += 24;
-+			else
-+				ts += 32;
-+
-+			/*
-+			 * Add Data HT-LTFs per streams
-+			 * TODO: add Extension HT-LTFs, 4us per LTF
-+			 */
-+			n_ltf = ((ri.mcs >> 3) & 3) + 1;
-+			n_ltf = n_ltf == 3 ? 4 : n_ltf;
-+			ts += n_ltf * 4;
-+		}
-+
- 		break;
- 	case RX_ENC_VHT:
- 		ri.flags |= RATE_INFO_FLAGS_VHT_MCS;
-@@ -3695,6 +3743,23 @@ u64 ieee80211_calculate_rx_timestamp(str
- 		ri.nss = status->nss;
- 		if (status->enc_flags & RX_ENC_FLAG_SHORT_GI)
- 			ri.flags |= RATE_INFO_FLAGS_SHORT_GI;
-+
-+		/*
-+		 * See P802.11REVmd_D3.0, section 21.3.2 for
-+		 * VHT PPDU format.
-+		 */
-+		if (status->flag & RX_FLAG_MACTIME_PLCP_START) {
-+			mpdu_offset += 2;
-+			ts += 36;
-+
-+			/*
-+			 * Add VHT-LTFs per streams
-+			 */
-+			n_ltf = (ri.nss != 1) && (ri.nss % 2) ?
-+				ri.nss + 1 : ri.nss;
-+			ts += 4 * n_ltf;
-+		}
-+
- 		break;
- 	default:
- 		WARN_ON(1);
-@@ -3718,7 +3783,6 @@ u64 ieee80211_calculate_rx_timestamp(str
- 		ri.legacy = DIV_ROUND_UP(bitrate, (1 << shift));
- 
- 		if (status->flag & RX_FLAG_MACTIME_PLCP_START) {
--			/* TODO: handle HT/VHT preambles */
- 			if (status->band == NL80211_BAND_5GHZ) {
- 				ts += 20 << shift;
- 				mpdu_offset += 2;
diff --git a/package/kernel/mac80211/patches/subsys/374-mac80211-move-A-MPDU-session-check-from-minstrel_ht-.patch b/package/kernel/mac80211/patches/subsys/374-mac80211-move-A-MPDU-session-check-from-minstrel_ht-.patch
deleted file mode 100644
index bab8917ff9..0000000000
--- a/package/kernel/mac80211/patches/subsys/374-mac80211-move-A-MPDU-session-check-from-minstrel_ht-.patch
+++ /dev/null
@@ -1,126 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 17 Jun 2021 17:56:54 +0200
-Subject: [PATCH] mac80211: move A-MPDU session check from minstrel_ht to
- mac80211
-
-This avoids calling back into tx handlers from within the rate control module.
-Preparation for deferring rate control until tx dequeue
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -6160,6 +6160,11 @@ enum rate_control_capabilities {
- 	 * otherwise the NSS difference doesn't bother us.
- 	 */
- 	RATE_CTRL_CAPA_VHT_EXT_NSS_BW = BIT(0),
-+	/**
-+	 * @RATE_CTRL_CAPA_AMPDU_TRIGGER:
-+	 * mac80211 should start A-MPDU sessions on tx
-+	 */
-+	RATE_CTRL_CAPA_AMPDU_TRIGGER = BIT(1),
- };
- 
- struct rate_control_ops {
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -1144,29 +1144,6 @@ minstrel_downgrade_prob_rate(struct mins
- }
- 
- static void
--minstrel_aggr_check(struct ieee80211_sta *pubsta, struct sk_buff *skb)
--{
--	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
--	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
--	u16 tid;
--
--	if (skb_get_queue_mapping(skb) == IEEE80211_AC_VO)
--		return;
--
--	if (unlikely(!ieee80211_is_data_qos(hdr->frame_control)))
--		return;
--
--	if (unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE)))
--		return;
--
--	tid = ieee80211_get_tid(hdr);
--	if (likely(sta->ampdu_mlme.tid_tx[tid]))
--		return;
--
--	ieee80211_start_tx_ba_session(pubsta, tid, 0);
--}
--
--static void
- minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
-                       void *priv_sta, struct ieee80211_tx_status *st)
- {
-@@ -1461,10 +1438,6 @@ minstrel_ht_get_rate(void *priv, struct
- 	struct minstrel_priv *mp = priv;
- 	u16 sample_idx;
- 
--	if (!(info->flags & IEEE80211_TX_CTL_AMPDU) &&
--	    !minstrel_ht_is_legacy_group(MI_RATE_GROUP(mi->max_prob_rate)))
--		minstrel_aggr_check(sta, txrc->skb);
--
- 	info->flags |= mi->tx_flags;
- 
- #ifdef CPTCFG_MAC80211_DEBUGFS
-@@ -1870,6 +1843,7 @@ static u32 minstrel_ht_get_expected_thro
- 
- static const struct rate_control_ops mac80211_minstrel_ht = {
- 	.name = "minstrel_ht",
-+	.capa = RATE_CTRL_CAPA_AMPDU_TRIGGER,
- 	.tx_status_ext = minstrel_ht_tx_status,
- 	.get_rate = minstrel_ht_get_rate,
- 	.rate_init = minstrel_ht_rate_init,
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -3965,6 +3965,29 @@ void ieee80211_txq_schedule_start(struct
- }
- EXPORT_SYMBOL(ieee80211_txq_schedule_start);
- 
-+static void
-+ieee80211_aggr_check(struct ieee80211_sub_if_data *sdata,
-+		     struct sta_info *sta,
-+		     struct sk_buff *skb)
-+{
-+	struct rate_control_ref *ref = sdata->local->rate_ctrl;
-+	u16 tid;
-+
-+	if (!ref || !(ref->ops->capa & RATE_CTRL_CAPA_AMPDU_TRIGGER))
-+		return;
-+
-+	if (!sta || !sta->sta.ht_cap.ht_supported ||
-+	    !sta->sta.wme || skb_get_queue_mapping(skb) == IEEE80211_AC_VO ||
-+	    skb->protocol == sdata->control_port_protocol)
-+		return;
-+
-+	tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;
-+	if (likely(sta->ampdu_mlme.tid_tx[tid]))
-+		return;
-+
-+	ieee80211_start_tx_ba_session(&sta->sta, tid, 0);
-+}
-+
- void __ieee80211_subif_start_xmit(struct sk_buff *skb,
- 				  struct net_device *dev,
- 				  u32 info_flags,
-@@ -3995,6 +4018,8 @@ void __ieee80211_subif_start_xmit(struct
- 		skb_get_hash(skb);
- 	}
- 
-+	ieee80211_aggr_check(sdata, sta, skb);
-+
- 	if (sta) {
- 		struct ieee80211_fast_tx *fast_tx;
- 
-@@ -4258,6 +4283,8 @@ static void ieee80211_8023_xmit(struct i
- 
- 	memset(info, 0, sizeof(*info));
- 
-+	ieee80211_aggr_check(sdata, sta, skb);
-+
- 	tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;
- 	tid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);
- 	if (tid_tx) {
diff --git a/package/kernel/mac80211/patches/subsys/375-mac80211-call-ieee80211_tx_h_rate_ctrl-when-dequeue.patch b/package/kernel/mac80211/patches/subsys/375-mac80211-call-ieee80211_tx_h_rate_ctrl-when-dequeue.patch
deleted file mode 100644
index 36c46c2f83..0000000000
--- a/package/kernel/mac80211/patches/subsys/375-mac80211-call-ieee80211_tx_h_rate_ctrl-when-dequeue.patch
+++ /dev/null
@@ -1,114 +0,0 @@
-From: Ryder Lee <ryder.lee@mediatek.com>
-Date: Fri, 28 May 2021 14:05:41 +0800
-Subject: [PATCH] mac80211: call ieee80211_tx_h_rate_ctrl() when dequeue
-
-Make ieee80211_tx_h_rate_ctrl() get called on dequeue to improve
-performance since it reduces the turnaround time for rate control.
-
-Signed-off-by: Ryder Lee <ryder.lee@mediatek.com>
----
-
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -1778,8 +1778,6 @@ static int invoke_tx_handlers_early(stru
- 	CALL_TXH(ieee80211_tx_h_ps_buf);
- 	CALL_TXH(ieee80211_tx_h_check_control_port_protocol);
- 	CALL_TXH(ieee80211_tx_h_select_key);
--	if (!ieee80211_hw_check(&tx->local->hw, HAS_RATE_CONTROL))
--		CALL_TXH(ieee80211_tx_h_rate_ctrl);
- 
-  txh_done:
- 	if (unlikely(res == TX_DROP)) {
-@@ -1812,6 +1810,9 @@ static int invoke_tx_handlers_late(struc
- 		goto txh_done;
- 	}
- 
-+	if (!ieee80211_hw_check(&tx->local->hw, HAS_RATE_CONTROL))
-+		CALL_TXH(ieee80211_tx_h_rate_ctrl);
-+
- 	CALL_TXH(ieee80211_tx_h_michael_mic_add);
- 	CALL_TXH(ieee80211_tx_h_sequence);
- 	CALL_TXH(ieee80211_tx_h_fragment);
-@@ -3416,15 +3417,21 @@ out:
-  * Can be called while the sta lock is held. Anything that can cause packets to
-  * be generated will cause deadlock!
-  */
--static void ieee80211_xmit_fast_finish(struct ieee80211_sub_if_data *sdata,
--				       struct sta_info *sta, u8 pn_offs,
--				       struct ieee80211_key *key,
--				       struct sk_buff *skb)
-+static ieee80211_tx_result
-+ieee80211_xmit_fast_finish(struct ieee80211_sub_if_data *sdata,
-+			   struct sta_info *sta, u8 pn_offs,
-+			   struct ieee80211_key *key,
-+			   struct ieee80211_tx_data *tx)
- {
-+	struct sk_buff *skb = tx->skb;
- 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
- 	struct ieee80211_hdr *hdr = (void *)skb->data;
- 	u8 tid = IEEE80211_NUM_TIDS;
- 
-+	if (!ieee80211_hw_check(&tx->local->hw, HAS_RATE_CONTROL) &&
-+	    ieee80211_tx_h_rate_ctrl(tx) != TX_CONTINUE)
-+		return TX_DROP;
-+
- 	if (key)
- 		info->control.hw_key = &key->conf;
- 
-@@ -3473,6 +3480,8 @@ static void ieee80211_xmit_fast_finish(s
- 			break;
- 		}
- 	}
-+
-+	return TX_CONTINUE;
- }
- 
- static bool ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,
-@@ -3576,24 +3585,17 @@ static bool ieee80211_xmit_fast(struct i
- 	tx.sta = sta;
- 	tx.key = fast_tx->key;
- 
--	if (!ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL)) {
--		tx.skb = skb;
--		r = ieee80211_tx_h_rate_ctrl(&tx);
--		skb = tx.skb;
--		tx.skb = NULL;
--
--		if (r != TX_CONTINUE) {
--			if (r != TX_QUEUED)
--				kfree_skb(skb);
--			return true;
--		}
--	}
--
- 	if (ieee80211_queue_skb(local, sdata, sta, skb))
- 		return true;
- 
--	ieee80211_xmit_fast_finish(sdata, sta, fast_tx->pn_offs,
--				   fast_tx->key, skb);
-+	tx.skb = skb;
-+	r = ieee80211_xmit_fast_finish(sdata, sta, fast_tx->pn_offs,
-+				       fast_tx->key, &tx);
-+	tx.skb = NULL;
-+	if (r == TX_DROP) {
-+		kfree_skb(skb);
-+		return true;
-+	}
- 
- 	if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
- 		sdata = container_of(sdata->bss,
-@@ -3704,8 +3706,12 @@ begin:
- 		    (tx.key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV))
- 			pn_offs = ieee80211_hdrlen(hdr->frame_control);
- 
--		ieee80211_xmit_fast_finish(sta->sdata, sta, pn_offs,
--					   tx.key, skb);
-+		r = ieee80211_xmit_fast_finish(sta->sdata, sta, pn_offs,
-+					       tx.key, &tx);
-+		if (r != TX_CONTINUE) {
-+			ieee80211_free_txskb(&local->hw, skb);
-+			goto begin;
-+		}
- 	} else {
- 		if (invoke_tx_handlers_late(&tx))
- 			goto begin;
diff --git a/package/kernel/mac80211/patches/subsys/376-mac80211-add-rate-control-support-for-encap-offload.patch b/package/kernel/mac80211/patches/subsys/376-mac80211-add-rate-control-support-for-encap-offload.patch
deleted file mode 100644
index 11890ae3f9..0000000000
--- a/package/kernel/mac80211/patches/subsys/376-mac80211-add-rate-control-support-for-encap-offload.patch
+++ /dev/null
@@ -1,126 +0,0 @@
-From: Ryder Lee <ryder.lee@mediatek.com>
-Date: Fri, 28 May 2021 14:05:43 +0800
-Subject: [PATCH] mac80211: add rate control support for encap offload
-
-The software rate control cannot deal with encap offload, so fix it.
-
-Signed-off-by: Ryder Lee <ryder.lee@mediatek.com>
----
-
---- a/net/mac80211/rate.c
-+++ b/net/mac80211/rate.c
-@@ -297,15 +297,11 @@ void ieee80211_check_rate_mask(struct ie
- static bool rc_no_data_or_no_ack_use_min(struct ieee80211_tx_rate_control *txrc)
- {
- 	struct sk_buff *skb = txrc->skb;
--	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
- 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
--	__le16 fc;
--
--	fc = hdr->frame_control;
- 
- 	return (info->flags & (IEEE80211_TX_CTL_NO_ACK |
- 			       IEEE80211_TX_CTL_USE_MINRATE)) ||
--		!ieee80211_is_data(fc);
-+		!ieee80211_is_tx_data(skb);
- }
- 
- static void rc_send_low_basicrate(struct ieee80211_tx_rate *rate,
-@@ -870,7 +866,6 @@ void ieee80211_get_tx_rates(struct ieee8
- 			    int max_rates)
- {
- 	struct ieee80211_sub_if_data *sdata;
--	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
- 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
- 	struct ieee80211_supported_band *sband;
- 
-@@ -882,7 +877,7 @@ void ieee80211_get_tx_rates(struct ieee8
- 	sdata = vif_to_sdata(vif);
- 	sband = sdata->local->hw.wiphy->bands[info->band];
- 
--	if (ieee80211_is_data(hdr->frame_control))
-+	if (ieee80211_is_tx_data(skb))
- 		rate_control_apply_mask(sdata, sta, sband, dest, max_rates);
- 
- 	if (dest[0].idx < 0)
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -679,6 +679,7 @@ ieee80211_tx_h_rate_ctrl(struct ieee8021
- 	u32 len;
- 	struct ieee80211_tx_rate_control txrc;
- 	struct ieee80211_sta_rates *ratetbl = NULL;
-+	bool encap = info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP;
- 	bool assoc = false;
- 
- 	memset(&txrc, 0, sizeof(txrc));
-@@ -720,7 +721,7 @@ ieee80211_tx_h_rate_ctrl(struct ieee8021
- 	 * just wants a probe response.
- 	 */
- 	if (tx->sdata->vif.bss_conf.use_short_preamble &&
--	    (ieee80211_is_data(hdr->frame_control) ||
-+	    (ieee80211_is_tx_data(tx->skb) ||
- 	     (tx->sta && test_sta_flag(tx->sta, WLAN_STA_SHORT_PREAMBLE))))
- 		txrc.short_preamble = true;
- 
-@@ -742,7 +743,8 @@ ieee80211_tx_h_rate_ctrl(struct ieee8021
- 		 "%s: Dropped data frame as no usable bitrate found while "
- 		 "scanning and associated. Target station: "
- 		 "%pM on %d GHz band\n",
--		 tx->sdata->name, hdr->addr1,
-+		 tx->sdata->name,
-+		 encap ? ((struct ethhdr *)hdr)->h_dest : hdr->addr1,
- 		 info->band ? 5 : 2))
- 		return TX_DROP;
- 
-@@ -776,7 +778,7 @@ ieee80211_tx_h_rate_ctrl(struct ieee8021
- 
- 	if (txrc.reported_rate.idx < 0) {
- 		txrc.reported_rate = tx->rate;
--		if (tx->sta && ieee80211_is_data(hdr->frame_control))
-+		if (tx->sta && ieee80211_is_tx_data(tx->skb))
- 			tx->sta->tx_stats.last_rate = txrc.reported_rate;
- 	} else if (tx->sta)
- 		tx->sta->tx_stats.last_rate = txrc.reported_rate;
-@@ -3694,8 +3696,16 @@ begin:
- 	else
- 		info->flags &= ~IEEE80211_TX_CTL_AMPDU;
- 
--	if (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)
-+	if (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) {
-+		if (!ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL)) {
-+			r = ieee80211_tx_h_rate_ctrl(&tx);
-+			if (r != TX_CONTINUE) {
-+				ieee80211_free_txskb(&local->hw, skb);
-+				goto begin;
-+			}
-+		}
- 		goto encap_out;
-+	}
- 
- 	if (info->control.flags & IEEE80211_TX_CTRL_FAST_XMIT) {
- 		struct sta_info *sta = container_of(txq->sta, struct sta_info,
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -6733,4 +6733,22 @@ struct sk_buff *ieee80211_get_fils_disco
- struct sk_buff *
- ieee80211_get_unsol_bcast_probe_resp_tmpl(struct ieee80211_hw *hw,
- 					  struct ieee80211_vif *vif);
-+
-+/**
-+ * ieee80211_is_tx_data - check if frame is a data frame
-+ *
-+ * The function is used to check if a frame is a data frame. Frames with
-+ * hardware encapsulation enabled are data frames.
-+ *
-+ * @skb: the frame to be transmitted.
-+ */
-+static inline bool ieee80211_is_tx_data(struct sk_buff *skb)
-+{
-+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-+	struct ieee80211_hdr *hdr = (void *) skb->data;
-+
-+	return info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP ||
-+	       ieee80211_is_data(hdr->frame_control);
-+}
-+
- #endif /* MAC80211_H */
diff --git a/package/kernel/mac80211/patches/subsys/377-mac80211-minstrel_ht-fix-sample-time-check.patch b/package/kernel/mac80211/patches/subsys/377-mac80211-minstrel_ht-fix-sample-time-check.patch
deleted file mode 100644
index 054662f3ef..0000000000
--- a/package/kernel/mac80211/patches/subsys/377-mac80211-minstrel_ht-fix-sample-time-check.patch
+++ /dev/null
@@ -1,23 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 17 Jun 2021 12:05:54 +0200
-Subject: [PATCH] mac80211: minstrel_ht: fix sample time check
-
-We need to skip sampling if the next sample time is after jiffies, not before.
-This patch fixes an issue where in some cases only very little sampling (or none
-at all) is performed, leading to really bad data rates
-
-Fixes: 80d55154b2f8 ("mac80211: minstrel_ht: significantly redesign the rate probing strategy")
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -1450,7 +1450,7 @@ minstrel_ht_get_rate(void *priv, struct
- 	    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
- 		return;
- 
--	if (time_is_before_jiffies(mi->sample_time))
-+	if (time_is_after_jiffies(mi->sample_time))
- 		return;
- 
- 	mi->sample_time = jiffies + MINSTREL_SAMPLE_INTERVAL;
diff --git a/package/kernel/mac80211/patches/subsys/379-mac80211-fix-starting-aggregation-sessions-on-mesh-i.patch b/package/kernel/mac80211/patches/subsys/379-mac80211-fix-starting-aggregation-sessions-on-mesh-i.patch
deleted file mode 100644
index a684b59382..0000000000
--- a/package/kernel/mac80211/patches/subsys/379-mac80211-fix-starting-aggregation-sessions-on-mesh-i.patch
+++ /dev/null
@@ -1,112 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Tue, 29 Jun 2021 13:25:09 +0200
-Subject: [PATCH] mac80211: fix starting aggregation sessions on mesh
- interfaces
-
-The logic for starting aggregation sessions was recently moved from minstrel_ht
-to mac80211, into the subif tx handler just after the sta lookup.
-Unfortunately this didn't work for mesh interfaces, since the sta lookup is
-deferred until a much later point in time on those.
-Fix this by also calling the aggregation check right after the deferred sta
-lookup.
-
-Fixes: 08a46c642001 ("mac80211: move A-MPDU session check from minstrel_ht to mac80211")
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -1159,6 +1159,29 @@ static bool ieee80211_tx_prep_agg(struct
- 	return queued;
- }
- 
-+static void
-+ieee80211_aggr_check(struct ieee80211_sub_if_data *sdata,
-+		     struct sta_info *sta,
-+		     struct sk_buff *skb)
-+{
-+	struct rate_control_ref *ref = sdata->local->rate_ctrl;
-+	u16 tid;
-+
-+	if (!ref || !(ref->ops->capa & RATE_CTRL_CAPA_AMPDU_TRIGGER))
-+		return;
-+
-+	if (!sta || !sta->sta.ht_cap.ht_supported ||
-+	    !sta->sta.wme || skb_get_queue_mapping(skb) == IEEE80211_AC_VO ||
-+	    skb->protocol == sdata->control_port_protocol)
-+		return;
-+
-+	tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;
-+	if (likely(sta->ampdu_mlme.tid_tx[tid]))
-+		return;
-+
-+	ieee80211_start_tx_ba_session(&sta->sta, tid, 0);
-+}
-+
- /*
-  * initialises @tx
-  * pass %NULL for the station if unknown, a valid pointer if known
-@@ -1172,6 +1195,7 @@ ieee80211_tx_prepare(struct ieee80211_su
- 	struct ieee80211_local *local = sdata->local;
- 	struct ieee80211_hdr *hdr;
- 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-+	bool aggr_check = false;
- 	int tid;
- 
- 	memset(tx, 0, sizeof(*tx));
-@@ -1200,8 +1224,10 @@ ieee80211_tx_prepare(struct ieee80211_su
- 		} else if (tx->sdata->control_port_protocol == tx->skb->protocol) {
- 			tx->sta = sta_info_get_bss(sdata, hdr->addr1);
- 		}
--		if (!tx->sta && !is_multicast_ether_addr(hdr->addr1))
-+		if (!tx->sta && !is_multicast_ether_addr(hdr->addr1)) {
- 			tx->sta = sta_info_get(sdata, hdr->addr1);
-+			aggr_check = true;
-+		}
- 	}
- 
- 	if (tx->sta && ieee80211_is_data_qos(hdr->frame_control) &&
-@@ -1211,8 +1237,12 @@ ieee80211_tx_prepare(struct ieee80211_su
- 		struct tid_ampdu_tx *tid_tx;
- 
- 		tid = ieee80211_get_tid(hdr);
--
- 		tid_tx = rcu_dereference(tx->sta->ampdu_mlme.tid_tx[tid]);
-+		if (!tid_tx && aggr_check) {
-+			ieee80211_aggr_check(sdata, tx->sta, skb);
-+			tid_tx = rcu_dereference(tx->sta->ampdu_mlme.tid_tx[tid]);
-+		}
-+
- 		if (tid_tx) {
- 			bool queued;
- 
-@@ -3981,29 +4011,6 @@ void ieee80211_txq_schedule_start(struct
- }
- EXPORT_SYMBOL(ieee80211_txq_schedule_start);
- 
--static void
--ieee80211_aggr_check(struct ieee80211_sub_if_data *sdata,
--		     struct sta_info *sta,
--		     struct sk_buff *skb)
--{
--	struct rate_control_ref *ref = sdata->local->rate_ctrl;
--	u16 tid;
--
--	if (!ref || !(ref->ops->capa & RATE_CTRL_CAPA_AMPDU_TRIGGER))
--		return;
--
--	if (!sta || !sta->sta.ht_cap.ht_supported ||
--	    !sta->sta.wme || skb_get_queue_mapping(skb) == IEEE80211_AC_VO ||
--	    skb->protocol == sdata->control_port_protocol)
--		return;
--
--	tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;
--	if (likely(sta->ampdu_mlme.tid_tx[tid]))
--		return;
--
--	ieee80211_start_tx_ba_session(&sta->sta, tid, 0);
--}
--
- void __ieee80211_subif_start_xmit(struct sk_buff *skb,
- 				  struct net_device *dev,
- 				  u32 info_flags,
diff --git a/package/kernel/mac80211/patches/subsys/380-mac80211-introduce-aql_enable-node-in-debugfs.patch b/package/kernel/mac80211/patches/subsys/380-mac80211-introduce-aql_enable-node-in-debugfs.patch
deleted file mode 100644
index a7ef62af80..0000000000
--- a/package/kernel/mac80211/patches/subsys/380-mac80211-introduce-aql_enable-node-in-debugfs.patch
+++ /dev/null
@@ -1,111 +0,0 @@
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Sat, 9 Jan 2021 18:57:51 +0100
-Subject: [PATCH] mac80211: introduce aql_enable node in debugfs
-
-Introduce aql_enable node in debugfs in order to enable/disable aql.
-This is useful for debugging purpose.
-
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Link: https://lore.kernel.org/r/e7a934d5d84e4796c4f97ea5de4e66c824296b07.1610214851.git.lorenzo@kernel.org
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/net/mac80211/debugfs.c
-+++ b/net/mac80211/debugfs.c
-@@ -281,6 +281,56 @@ static const struct file_operations aql_
- 	.llseek = default_llseek,
- };
- 
-+static ssize_t aql_enable_read(struct file *file, char __user *user_buf,
-+			       size_t count, loff_t *ppos)
-+{
-+	char buf[3];
-+	int len;
-+
-+	len = scnprintf(buf, sizeof(buf), "%d\n",
-+			!static_key_false(&aql_disable.key));
-+
-+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-+}
-+
-+static ssize_t aql_enable_write(struct file *file, const char __user *user_buf,
-+				size_t count, loff_t *ppos)
-+{
-+	bool aql_disabled = static_key_false(&aql_disable.key);
-+	char buf[3];
-+	size_t len;
-+
-+	if (count > sizeof(buf))
-+		return -EINVAL;
-+
-+	if (copy_from_user(buf, user_buf, count))
-+		return -EFAULT;
-+
-+	buf[sizeof(buf) - 1] = '\0';
-+	len = strlen(buf);
-+	if (len > 0 && buf[len - 1] == '\n')
-+		buf[len - 1] = 0;
-+
-+	if (buf[0] == '0' && buf[1] == '\0') {
-+		if (!aql_disabled)
-+			static_branch_inc(&aql_disable);
-+	} else if (buf[0] == '1' && buf[1] == '\0') {
-+		if (aql_disabled)
-+			static_branch_dec(&aql_disable);
-+	} else {
-+		return -EINVAL;
-+	}
-+
-+	return count;
-+}
-+
-+static const struct file_operations aql_enable_ops = {
-+	.write = aql_enable_write,
-+	.read = aql_enable_read,
-+	.open = simple_open,
-+	.llseek = default_llseek,
-+};
-+
- static ssize_t force_tx_status_read(struct file *file,
- 				    char __user *user_buf,
- 				    size_t count,
-@@ -569,6 +619,7 @@ void debugfs_hw_add(struct ieee80211_loc
- 	DEBUGFS_ADD(power);
- 	DEBUGFS_ADD(hw_conf);
- 	DEBUGFS_ADD_MODE(force_tx_status, 0600);
-+	DEBUGFS_ADD_MODE(aql_enable, 0600);
- 
- 	if (local->ops->wake_tx_queue)
- 		DEBUGFS_ADD_MODE(aqm, 0600);
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -1145,6 +1145,8 @@ enum mac80211_scan_state {
- 	SCAN_ABORT,
- };
- 
-+DECLARE_STATIC_KEY_FALSE(aql_disable);
-+
- struct ieee80211_local {
- 	/* embed the driver visible part.
- 	 * don't cast (use the static inlines below), but we keep
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -3921,6 +3921,8 @@ void __ieee80211_schedule_txq(struct iee
- }
- EXPORT_SYMBOL(__ieee80211_schedule_txq);
- 
-+DEFINE_STATIC_KEY_FALSE(aql_disable);
-+
- bool ieee80211_txq_airtime_check(struct ieee80211_hw *hw,
- 				 struct ieee80211_txq *txq)
- {
-@@ -3930,6 +3932,9 @@ bool ieee80211_txq_airtime_check(struct
- 	if (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))
- 		return true;
- 
-+	if (static_branch_unlikely(&aql_disable))
-+		return true;
-+
- 	if (!txq->sta)
- 		return true;
- 
diff --git a/package/kernel/mac80211/patches/subsys/381-mac80211-rearrange-struct-txq_info-for-fewer-holes.patch b/package/kernel/mac80211/patches/subsys/381-mac80211-rearrange-struct-txq_info-for-fewer-holes.patch
deleted file mode 100644
index 708ad6f460..0000000000
--- a/package/kernel/mac80211/patches/subsys/381-mac80211-rearrange-struct-txq_info-for-fewer-holes.patch
+++ /dev/null
@@ -1,39 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Fri, 18 Jun 2021 13:41:44 +0300
-Subject: [PATCH] mac80211: rearrange struct txq_info for fewer holes
-
-We can slightly decrease the size of struct txq_info by
-rearranging some fields for fewer holes, so do that.
-
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
-Link: https://lore.kernel.org/r/iwlwifi.20210618133832.1bf019a1fe2e.Ib54622b8d6dc1a9a7dc484e573c073119450538b@changeid
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -5,7 +5,7 @@
-  * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
-  * Copyright 2007-2010	Johannes Berg <johannes@sipsolutions.net>
-  * Copyright 2013-2015  Intel Mobile Communications GmbH
-- * Copyright (C) 2018-2020 Intel Corporation
-+ * Copyright (C) 2018-2021 Intel Corporation
-  */
- 
- #ifndef IEEE80211_I_H
-@@ -848,9 +848,12 @@ struct txq_info {
- 	struct fq_tin tin;
- 	struct codel_vars def_cvars;
- 	struct codel_stats cstats;
--	struct sk_buff_head frags;
--	struct list_head schedule_order;
-+
- 	u16 schedule_round;
-+	struct list_head schedule_order;
-+
-+	struct sk_buff_head frags;
-+
- 	unsigned long flags;
- 
- 	/* keep last! */
diff --git a/package/kernel/mac80211/patches/subsys/382-mac80211-Switch-to-a-virtual-time-based-airtime-sche.patch b/package/kernel/mac80211/patches/subsys/382-mac80211-Switch-to-a-virtual-time-based-airtime-sche.patch
deleted file mode 100644
index c547f5a81b..0000000000
--- a/package/kernel/mac80211/patches/subsys/382-mac80211-Switch-to-a-virtual-time-based-airtime-sche.patch
+++ /dev/null
@@ -1,1277 +0,0 @@
-From: =?UTF-8?q?Toke=20H=C3=B8iland-J=C3=B8rgensen?= <toke@redhat.com>
-Date: Wed, 23 Jun 2021 15:47:55 +0200
-Subject: [PATCH] mac80211: Switch to a virtual time-based airtime scheduler
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This switches the airtime scheduler in mac80211 to use a virtual
-time-based scheduler instead of the round-robin scheduler used before.
-This has a couple of advantages:
-
-- No need to sync up the round-robin scheduler in firmware/hardware with
-  the round-robin airtime scheduler.
-
-- If several stations are eligible for transmission we can schedule both
-  of them; no need to hard-block the scheduling rotation until the head
-  of the queue has used up its quantum.
-
-- The check of whether a station is eligible for transmission becomes
-  simpler (in ieee80211_txq_may_transmit()).
-
-The drawback is that scheduling becomes slightly more expensive, as we
-need to maintain an rbtree of TXQs sorted by virtual time. This means
-that ieee80211_register_airtime() becomes O(logN) in the number of
-currently scheduled TXQs because it can change the order of the
-scheduled stations. We mitigate this overhead by only resorting when a
-station changes position in the tree, and hopefully N rarely grows too
-big (it's only TXQs currently backlogged, not all associated stations),
-so it shouldn't be too big of an issue.
-
-To prevent divisions in the fast path, we maintain both station sums and
-pre-computed reciprocals of the sums. This turns the fast-path operation
-into a multiplication, with divisions only happening as the number of
-active stations change (to re-compute the current sum of all active
-station weights). To prevent this re-computation of the reciprocal from
-happening too frequently, we use a time-based notion of station
-activity, instead of updating the weight every time a station gets
-scheduled or de-scheduled. As queues can oscillate between empty and
-occupied quite frequently, this can significantly cut down on the number
-of re-computations. It also has the added benefit of making the station
-airtime calculation independent on whether the queue happened to have
-drained at the time an airtime value was accounted.
-
-Co-developed-by: Yibo Zhao <yiboz@codeaurora.org>
-Signed-off-by: Yibo Zhao <yiboz@codeaurora.org>
-Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
-Link: https://lore.kernel.org/r/20210623134755.235545-1-toke@redhat.com
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -6557,9 +6557,6 @@ static inline void ieee80211_txq_schedul
- {
- }
- 
--void __ieee80211_schedule_txq(struct ieee80211_hw *hw,
--			      struct ieee80211_txq *txq, bool force);
--
- /**
-  * ieee80211_schedule_txq - schedule a TXQ for transmission
-  *
-@@ -6572,11 +6569,7 @@ void __ieee80211_schedule_txq(struct iee
-  * The driver may call this function if it has buffered packets for
-  * this TXQ internally.
-  */
--static inline void
--ieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq)
--{
--	__ieee80211_schedule_txq(hw, txq, true);
--}
-+void ieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq);
- 
- /**
-  * ieee80211_return_txq - return a TXQ previously acquired by ieee80211_next_txq()
-@@ -6588,12 +6581,8 @@ ieee80211_schedule_txq(struct ieee80211_
-  * The driver may set force=true if it has buffered packets for this TXQ
-  * internally.
-  */
--static inline void
--ieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq,
--		     bool force)
--{
--	__ieee80211_schedule_txq(hw, txq, force);
--}
-+void ieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq,
-+			  bool force);
- 
- /**
-  * ieee80211_txq_may_transmit - check whether TXQ is allowed to transmit
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -1464,6 +1464,38 @@ static void sta_apply_mesh_params(struct
- #endif
- }
- 
-+static void sta_apply_airtime_params(struct ieee80211_local *local,
-+				     struct sta_info *sta,
-+				     struct station_parameters *params)
-+{
-+	u8 ac;
-+
-+	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-+		struct airtime_sched_info *air_sched = &local->airtime[ac];
-+		struct airtime_info *air_info = &sta->airtime[ac];
-+		struct txq_info *txqi;
-+		u8 tid;
-+
-+		spin_lock_bh(&air_sched->lock);
-+		for (tid = 0; tid < IEEE80211_NUM_TIDS + 1; tid++) {
-+			if (air_info->weight == params->airtime_weight ||
-+			    !sta->sta.txq[tid] ||
-+			    ac != ieee80211_ac_from_tid(tid))
-+				continue;
-+
-+			airtime_weight_set(air_info, params->airtime_weight);
-+
-+			txqi = to_txq_info(sta->sta.txq[tid]);
-+			if (RB_EMPTY_NODE(&txqi->schedule_order))
-+				continue;
-+
-+			ieee80211_update_airtime_weight(local, air_sched,
-+							0, true);
-+		}
-+		spin_unlock_bh(&air_sched->lock);
-+	}
-+}
-+
- static int sta_apply_parameters(struct ieee80211_local *local,
- 				struct sta_info *sta,
- 				struct station_parameters *params)
-@@ -1651,7 +1683,8 @@ static int sta_apply_parameters(struct i
- 		sta_apply_mesh_params(local, sta, params);
- 
- 	if (params->airtime_weight)
--		sta->airtime_weight = params->airtime_weight;
-+		sta_apply_airtime_params(local, sta, params);
-+
- 
- 	/* set the STA state after all sta info from usermode has been set */
- 	if (test_sta_flag(sta, WLAN_STA_TDLS_PEER) ||
---- a/net/mac80211/debugfs.c
-+++ b/net/mac80211/debugfs.c
-@@ -216,14 +216,14 @@ static ssize_t aql_txq_limit_read(struct
- 			"VI	%u		%u\n"
- 			"BE	%u		%u\n"
- 			"BK	%u		%u\n",
--			local->aql_txq_limit_low[IEEE80211_AC_VO],
--			local->aql_txq_limit_high[IEEE80211_AC_VO],
--			local->aql_txq_limit_low[IEEE80211_AC_VI],
--			local->aql_txq_limit_high[IEEE80211_AC_VI],
--			local->aql_txq_limit_low[IEEE80211_AC_BE],
--			local->aql_txq_limit_high[IEEE80211_AC_BE],
--			local->aql_txq_limit_low[IEEE80211_AC_BK],
--			local->aql_txq_limit_high[IEEE80211_AC_BK]);
-+			local->airtime[IEEE80211_AC_VO].aql_txq_limit_low,
-+			local->airtime[IEEE80211_AC_VO].aql_txq_limit_high,
-+			local->airtime[IEEE80211_AC_VI].aql_txq_limit_low,
-+			local->airtime[IEEE80211_AC_VI].aql_txq_limit_high,
-+			local->airtime[IEEE80211_AC_BE].aql_txq_limit_low,
-+			local->airtime[IEEE80211_AC_BE].aql_txq_limit_high,
-+			local->airtime[IEEE80211_AC_BK].aql_txq_limit_low,
-+			local->airtime[IEEE80211_AC_BK].aql_txq_limit_high);
- 	return simple_read_from_buffer(user_buf, count, ppos,
- 				       buf, len);
- }
-@@ -255,11 +255,11 @@ static ssize_t aql_txq_limit_write(struc
- 	if (ac >= IEEE80211_NUM_ACS)
- 		return -EINVAL;
- 
--	q_limit_low_old = local->aql_txq_limit_low[ac];
--	q_limit_high_old = local->aql_txq_limit_high[ac];
-+	q_limit_low_old = local->airtime[ac].aql_txq_limit_low;
-+	q_limit_high_old = local->airtime[ac].aql_txq_limit_high;
- 
--	local->aql_txq_limit_low[ac] = q_limit_low;
--	local->aql_txq_limit_high[ac] = q_limit_high;
-+	local->airtime[ac].aql_txq_limit_low = q_limit_low;
-+	local->airtime[ac].aql_txq_limit_high = q_limit_high;
- 
- 	mutex_lock(&local->sta_mtx);
- 	list_for_each_entry(sta, &local->sta_list, list) {
-@@ -382,6 +382,46 @@ static const struct file_operations forc
- 	.llseek = default_llseek,
- };
- 
-+static ssize_t airtime_read(struct file *file,
-+			    char __user *user_buf,
-+			    size_t count,
-+			    loff_t *ppos)
-+{
-+	struct ieee80211_local *local = file->private_data;
-+	char buf[200];
-+	u64 v_t[IEEE80211_NUM_ACS];
-+	u64 wt[IEEE80211_NUM_ACS];
-+	int len = 0, ac;
-+
-+	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-+		spin_lock_bh(&local->airtime[ac].lock);
-+		v_t[ac] = local->airtime[ac].v_t;
-+		wt[ac] = local->airtime[ac].weight_sum;
-+		spin_unlock_bh(&local->airtime[ac].lock);
-+	}
-+	len = scnprintf(buf, sizeof(buf),
-+			"\tVO         VI         BE         BK\n"
-+			"Virt-t\t%-10llu %-10llu %-10llu %-10llu\n"
-+			"Weight\t%-10llu %-10llu %-10llu %-10llu\n",
-+			v_t[0],
-+			v_t[1],
-+			v_t[2],
-+			v_t[3],
-+			wt[0],
-+			wt[1],
-+			wt[2],
-+			wt[3]);
-+
-+	return simple_read_from_buffer(user_buf, count, ppos,
-+				       buf, len);
-+}
-+
-+static const struct file_operations airtime_ops = {
-+	.read = airtime_read,
-+	.open = simple_open,
-+	.llseek = default_llseek,
-+};
-+
- #ifdef CONFIG_PM
- static ssize_t reset_write(struct file *file, const char __user *user_buf,
- 			   size_t count, loff_t *ppos)
-@@ -624,7 +664,11 @@ void debugfs_hw_add(struct ieee80211_loc
- 	if (local->ops->wake_tx_queue)
- 		DEBUGFS_ADD_MODE(aqm, 0600);
- 
--	DEBUGFS_ADD_MODE(airtime_flags, 0600);
-+	if (wiphy_ext_feature_isset(local->hw.wiphy,
-+				    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS)) {
-+		DEBUGFS_ADD_MODE(airtime, 0600);
-+		DEBUGFS_ADD_MODE(airtime_flags, 0600);
-+	}
- 
- 	DEBUGFS_ADD(aql_txq_limit);
- 	debugfs_create_u32("aql_threshold", 0600,
---- a/net/mac80211/debugfs_netdev.c
-+++ b/net/mac80211/debugfs_netdev.c
-@@ -513,6 +513,34 @@ static ssize_t ieee80211_if_fmt_aqm(
- }
- IEEE80211_IF_FILE_R(aqm);
- 
-+static ssize_t ieee80211_if_fmt_airtime(
-+	const struct ieee80211_sub_if_data *sdata, char *buf, int buflen)
-+{
-+	struct ieee80211_local *local = sdata->local;
-+	struct ieee80211_txq *txq = sdata->vif.txq;
-+	struct airtime_info *air_info;
-+	int len;
-+
-+	if (!txq)
-+		return 0;
-+
-+	spin_lock_bh(&local->airtime[txq->ac].lock);
-+	air_info = to_airtime_info(txq);
-+	len = scnprintf(buf,
-+			buflen,
-+			"RX: %llu us\nTX: %llu us\nWeight: %u\n"
-+			"Virt-T: %lld us\n",
-+			air_info->rx_airtime,
-+			air_info->tx_airtime,
-+			air_info->weight,
-+			air_info->v_t);
-+	spin_unlock_bh(&local->airtime[txq->ac].lock);
-+
-+	return len;
-+}
-+
-+IEEE80211_IF_FILE_R(airtime);
-+
- IEEE80211_IF_FILE(multicast_to_unicast, u.ap.multicast_to_unicast, HEX);
- 
- /* IBSS attributes */
-@@ -661,8 +689,10 @@ static void add_common_files(struct ieee
- 
- 	if (sdata->local->ops->wake_tx_queue &&
- 	    sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE &&
--	    sdata->vif.type != NL80211_IFTYPE_NAN)
-+	    sdata->vif.type != NL80211_IFTYPE_NAN) {
- 		DEBUGFS_ADD(aqm);
-+		DEBUGFS_ADD(airtime);
-+	}
- }
- 
- static void add_sta_files(struct ieee80211_sub_if_data *sdata)
---- a/net/mac80211/debugfs_sta.c
-+++ b/net/mac80211/debugfs_sta.c
-@@ -202,7 +202,7 @@ static ssize_t sta_airtime_read(struct f
- 	size_t bufsz = 400;
- 	char *buf = kzalloc(bufsz, GFP_KERNEL), *p = buf;
- 	u64 rx_airtime = 0, tx_airtime = 0;
--	s64 deficit[IEEE80211_NUM_ACS];
-+	u64 v_t[IEEE80211_NUM_ACS];
- 	ssize_t rv;
- 	int ac;
- 
-@@ -210,18 +210,18 @@ static ssize_t sta_airtime_read(struct f
- 		return -ENOMEM;
- 
- 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
--		spin_lock_bh(&local->active_txq_lock[ac]);
-+		spin_lock_bh(&local->airtime[ac].lock);
- 		rx_airtime += sta->airtime[ac].rx_airtime;
- 		tx_airtime += sta->airtime[ac].tx_airtime;
--		deficit[ac] = sta->airtime[ac].deficit;
--		spin_unlock_bh(&local->active_txq_lock[ac]);
-+		v_t[ac] = sta->airtime[ac].v_t;
-+		spin_unlock_bh(&local->airtime[ac].lock);
- 	}
- 
- 	p += scnprintf(p, bufsz + buf - p,
- 		"RX: %llu us\nTX: %llu us\nWeight: %u\n"
--		"Deficit: VO: %lld us VI: %lld us BE: %lld us BK: %lld us\n",
--		rx_airtime, tx_airtime, sta->airtime_weight,
--		deficit[0], deficit[1], deficit[2], deficit[3]);
-+		"Virt-T: VO: %lld us VI: %lld us BE: %lld us BK: %lld us\n",
-+		rx_airtime, tx_airtime, sta->airtime[0].weight,
-+		v_t[0], v_t[1], v_t[2], v_t[3]);
- 
- 	rv = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);
- 	kfree(buf);
-@@ -236,11 +236,11 @@ static ssize_t sta_airtime_write(struct
- 	int ac;
- 
- 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
--		spin_lock_bh(&local->active_txq_lock[ac]);
-+		spin_lock_bh(&local->airtime[ac].lock);
- 		sta->airtime[ac].rx_airtime = 0;
- 		sta->airtime[ac].tx_airtime = 0;
--		sta->airtime[ac].deficit = sta->airtime_weight;
--		spin_unlock_bh(&local->active_txq_lock[ac]);
-+		sta->airtime[ac].v_t = 0;
-+		spin_unlock_bh(&local->airtime[ac].lock);
- 	}
- 
- 	return count;
-@@ -263,10 +263,10 @@ static ssize_t sta_aql_read(struct file
- 		return -ENOMEM;
- 
- 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
--		spin_lock_bh(&local->active_txq_lock[ac]);
-+		spin_lock_bh(&local->airtime[ac].lock);
- 		q_limit_l[ac] = sta->airtime[ac].aql_limit_low;
- 		q_limit_h[ac] = sta->airtime[ac].aql_limit_high;
--		spin_unlock_bh(&local->active_txq_lock[ac]);
-+		spin_unlock_bh(&local->airtime[ac].lock);
- 		q_depth[ac] = atomic_read(&sta->airtime[ac].aql_tx_pending);
- 	}
- 
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -840,20 +840,16 @@ enum txq_info_flags {
-  * @def_flow: used as a fallback flow when a packet destined to @tin hashes to
-  *	a fq_flow which is already owned by a different tin
-  * @def_cvars: codel vars for @def_flow
-- * @frags: used to keep fragments created after dequeue
-  * @schedule_order: used with ieee80211_local->active_txqs
-- * @schedule_round: counter to prevent infinite loops on TXQ scheduling
-+ * @frags: used to keep fragments created after dequeue
-  */
- struct txq_info {
- 	struct fq_tin tin;
- 	struct codel_vars def_cvars;
- 	struct codel_stats cstats;
--
--	u16 schedule_round;
--	struct list_head schedule_order;
-+	struct rb_node schedule_order;
- 
- 	struct sk_buff_head frags;
--
- 	unsigned long flags;
- 
- 	/* keep last! */
-@@ -930,6 +926,8 @@ struct ieee80211_sub_if_data {
- 	struct ieee80211_tx_queue_params tx_conf[IEEE80211_NUM_ACS];
- 	struct mac80211_qos_map __rcu *qos_map;
- 
-+	struct airtime_info airtime[IEEE80211_NUM_ACS];
-+
- 	struct work_struct csa_finalize_work;
- 	bool csa_block_tx; /* write-protected by sdata_lock and local->mtx */
- 	struct cfg80211_chan_def csa_chandef;
-@@ -1148,6 +1146,44 @@ enum mac80211_scan_state {
- 	SCAN_ABORT,
- };
- 
-+/**
-+ * struct airtime_sched_info - state used for airtime scheduling and AQL
-+ *
-+ * @lock: spinlock that protects all the fields in this struct
-+ * @active_txqs: rbtree of currently backlogged queues, sorted by virtual time
-+ * @schedule_pos: the current position maintained while a driver walks the tree
-+ *                with ieee80211_next_txq()
-+ * @active_list: list of struct airtime_info structs that were active within
-+ *               the last AIRTIME_ACTIVE_DURATION (100 ms), used to compute
-+ *               weight_sum
-+ * @last_weight_update: used for rate limiting walking active_list
-+ * @last_schedule_time: tracks the last time a transmission was scheduled; used
-+ *                      for catching up v_t if no stations are eligible for
-+ *                      transmission.
-+ * @v_t: global virtual time; queues with v_t < this are eligible for
-+ *       transmission
-+ * @weight_sum: total sum of all active stations used for dividing airtime
-+ * @weight_sum_reciprocal: reciprocal of weight_sum (to avoid divisions in fast
-+ *                         path - see comment above
-+ *                         IEEE80211_RECIPROCAL_DIVISOR_64)
-+ * @aql_txq_limit_low: AQL limit when total outstanding airtime
-+ *                     is < IEEE80211_AQL_THRESHOLD
-+ * @aql_txq_limit_high: AQL limit when total outstanding airtime
-+ *                      is > IEEE80211_AQL_THRESHOLD
-+ */
-+struct airtime_sched_info {
-+	spinlock_t lock;
-+	struct rb_root_cached active_txqs;
-+	struct rb_node *schedule_pos;
-+	struct list_head active_list;
-+	u64 last_weight_update;
-+	u64 last_schedule_activity;
-+	u64 v_t;
-+	u64 weight_sum;
-+	u64 weight_sum_reciprocal;
-+	u32 aql_txq_limit_low;
-+	u32 aql_txq_limit_high;
-+};
- DECLARE_STATIC_KEY_FALSE(aql_disable);
- 
- struct ieee80211_local {
-@@ -1161,13 +1197,8 @@ struct ieee80211_local {
- 	struct codel_params cparams;
- 
- 	/* protects active_txqs and txqi->schedule_order */
--	spinlock_t active_txq_lock[IEEE80211_NUM_ACS];
--	struct list_head active_txqs[IEEE80211_NUM_ACS];
--	u16 schedule_round[IEEE80211_NUM_ACS];
--
-+	struct airtime_sched_info airtime[IEEE80211_NUM_ACS];
- 	u16 airtime_flags;
--	u32 aql_txq_limit_low[IEEE80211_NUM_ACS];
--	u32 aql_txq_limit_high[IEEE80211_NUM_ACS];
- 	u32 aql_threshold;
- 	atomic_t aql_total_pending_airtime;
- 
-@@ -1586,6 +1617,125 @@ static inline bool txq_has_queue(struct
- 	return !(skb_queue_empty(&txqi->frags) && !txqi->tin.backlog_packets);
- }
- 
-+static inline struct airtime_info *to_airtime_info(struct ieee80211_txq *txq)
-+{
-+	struct ieee80211_sub_if_data *sdata;
-+	struct sta_info *sta;
-+
-+	if (txq->sta) {
-+		sta = container_of(txq->sta, struct sta_info, sta);
-+		return &sta->airtime[txq->ac];
-+	}
-+
-+	sdata = vif_to_sdata(txq->vif);
-+	return &sdata->airtime[txq->ac];
-+}
-+
-+/* To avoid divisions in the fast path, we keep pre-computed reciprocals for
-+ * airtime weight calculations. There are two different weights to keep track
-+ * of: The per-station weight and the sum of weights per phy.
-+ *
-+ * For the per-station weights (kept in airtime_info below), we use 32-bit
-+ * reciprocals with a devisor of 2^19. This lets us keep the multiplications and
-+ * divisions for the station weights as 32-bit operations at the cost of a bit
-+ * of rounding error for high weights; but the choice of divisor keeps rounding
-+ * errors <10% for weights <2^15, assuming no more than 8ms of airtime is
-+ * reported at a time.
-+ *
-+ * For the per-phy sum of weights the values can get higher, so we use 64-bit
-+ * operations for those with a 32-bit divisor, which should avoid any
-+ * significant rounding errors.
-+ */
-+#define IEEE80211_RECIPROCAL_DIVISOR_64 0x100000000ULL
-+#define IEEE80211_RECIPROCAL_SHIFT_64 32
-+#define IEEE80211_RECIPROCAL_DIVISOR_32 0x80000U
-+#define IEEE80211_RECIPROCAL_SHIFT_32 19
-+
-+static inline void airtime_weight_set(struct airtime_info *air_info, u16 weight)
-+{
-+	if (air_info->weight == weight)
-+		return;
-+
-+	air_info->weight = weight;
-+	if (weight) {
-+		air_info->weight_reciprocal =
-+			IEEE80211_RECIPROCAL_DIVISOR_32 / weight;
-+	} else {
-+		air_info->weight_reciprocal = 0;
-+	}
-+}
-+
-+static inline void airtime_weight_sum_set(struct airtime_sched_info *air_sched,
-+					  int weight_sum)
-+{
-+	if (air_sched->weight_sum == weight_sum)
-+		return;
-+
-+	air_sched->weight_sum = weight_sum;
-+	if (air_sched->weight_sum) {
-+		air_sched->weight_sum_reciprocal = IEEE80211_RECIPROCAL_DIVISOR_64;
-+		do_div(air_sched->weight_sum_reciprocal, air_sched->weight_sum);
-+	} else {
-+		air_sched->weight_sum_reciprocal = 0;
-+	}
-+}
-+
-+/* A problem when trying to enforce airtime fairness is that we want to divide
-+ * the airtime between the currently *active* stations. However, basing this on
-+ * the instantaneous queue state of stations doesn't work, as queues tend to
-+ * oscillate very quickly between empty and occupied, leading to the scheduler
-+ * thinking only a single station is active when deciding whether to allow
-+ * transmission (and thus not throttling correctly).
-+ *
-+ * To fix this we use a timer-based notion of activity: a station is considered
-+ * active if it has been scheduled within the last 100 ms; we keep a separate
-+ * list of all the stations considered active in this manner, and lazily update
-+ * the total weight of active stations from this list (filtering the stations in
-+ * the list by their 'last active' time).
-+ *
-+ * We add one additional safeguard to guard against stations that manage to get
-+ * scheduled every 100 ms but don't transmit a lot of data, and thus don't use
-+ * up any airtime. Such stations would be able to get priority for an extended
-+ * period of time if they do start transmitting at full capacity again, and so
-+ * we add an explicit maximum for how far behind a station is allowed to fall in
-+ * the virtual airtime domain. This limit is set to a relatively high value of
-+ * 20 ms because the main mechanism for catching up idle stations is the active
-+ * state as described above; i.e., the hard limit should only be hit in
-+ * pathological cases.
-+ */
-+#define AIRTIME_ACTIVE_DURATION (100 * NSEC_PER_MSEC)
-+#define AIRTIME_MAX_BEHIND 20000 /* 20 ms */
-+
-+static inline bool airtime_is_active(struct airtime_info *air_info, u64 now)
-+{
-+	return air_info->last_scheduled >= now - AIRTIME_ACTIVE_DURATION;
-+}
-+
-+static inline void airtime_set_active(struct airtime_sched_info *air_sched,
-+				      struct airtime_info *air_info, u64 now)
-+{
-+	air_info->last_scheduled = now;
-+	air_sched->last_schedule_activity = now;
-+	list_move_tail(&air_info->list, &air_sched->active_list);
-+}
-+
-+static inline bool airtime_catchup_v_t(struct airtime_sched_info *air_sched,
-+				       u64 v_t, u64 now)
-+{
-+	air_sched->v_t = v_t;
-+	return true;
-+}
-+
-+static inline void init_airtime_info(struct airtime_info *air_info,
-+				     struct airtime_sched_info *air_sched)
-+{
-+	atomic_set(&air_info->aql_tx_pending, 0);
-+	air_info->aql_limit_low = air_sched->aql_txq_limit_low;
-+	air_info->aql_limit_high = air_sched->aql_txq_limit_high;
-+	airtime_weight_set(air_info, IEEE80211_DEFAULT_AIRTIME_WEIGHT);
-+	INIT_LIST_HEAD(&air_info->list);
-+}
-+
- static inline int ieee80211_bssid_match(const u8 *raddr, const u8 *addr)
- {
- 	return ether_addr_equal(raddr, addr) ||
-@@ -1826,6 +1976,14 @@ int ieee80211_tx_control_port(struct wip
- 			      u64 *cookie);
- int ieee80211_probe_mesh_link(struct wiphy *wiphy, struct net_device *dev,
- 			      const u8 *buf, size_t len);
-+void ieee80211_resort_txq(struct ieee80211_hw *hw,
-+			  struct ieee80211_txq *txq);
-+void ieee80211_unschedule_txq(struct ieee80211_hw *hw,
-+			      struct ieee80211_txq *txq,
-+			      bool purge);
-+void ieee80211_update_airtime_weight(struct ieee80211_local *local,
-+				     struct airtime_sched_info *air_sched,
-+				     u64 now, bool force);
- 
- /* HT */
- void ieee80211_apply_htcap_overrides(struct ieee80211_sub_if_data *sdata,
---- a/net/mac80211/iface.c
-+++ b/net/mac80211/iface.c
-@@ -2088,6 +2088,9 @@ int ieee80211_if_add(struct ieee80211_lo
- 		}
- 	}
- 
-+	for (i = 0; i < IEEE80211_NUM_ACS; i++)
-+		init_airtime_info(&sdata->airtime[i], &local->airtime[i]);
-+
- 	ieee80211_set_default_queues(sdata);
- 
- 	sdata->ap_power_level = IEEE80211_UNSET_POWER_LEVEL;
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -693,10 +693,13 @@ struct ieee80211_hw *ieee80211_alloc_hw_
- 	spin_lock_init(&local->queue_stop_reason_lock);
- 
- 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
--		INIT_LIST_HEAD(&local->active_txqs[i]);
--		spin_lock_init(&local->active_txq_lock[i]);
--		local->aql_txq_limit_low[i] = IEEE80211_DEFAULT_AQL_TXQ_LIMIT_L;
--		local->aql_txq_limit_high[i] =
-+		struct airtime_sched_info *air_sched = &local->airtime[i];
-+
-+		air_sched->active_txqs = RB_ROOT_CACHED;
-+		INIT_LIST_HEAD(&air_sched->active_list);
-+		spin_lock_init(&air_sched->lock);
-+		air_sched->aql_txq_limit_low = IEEE80211_DEFAULT_AQL_TXQ_LIMIT_L;
-+		air_sched->aql_txq_limit_high =
- 			IEEE80211_DEFAULT_AQL_TXQ_LIMIT_H;
- 	}
- 
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -1572,12 +1572,8 @@ static void sta_ps_start(struct sta_info
- 
- 	for (tid = 0; tid < IEEE80211_NUM_TIDS; tid++) {
- 		struct ieee80211_txq *txq = sta->sta.txq[tid];
--		struct txq_info *txqi = to_txq_info(txq);
- 
--		spin_lock(&local->active_txq_lock[txq->ac]);
--		if (!list_empty(&txqi->schedule_order))
--			list_del_init(&txqi->schedule_order);
--		spin_unlock(&local->active_txq_lock[txq->ac]);
-+		ieee80211_unschedule_txq(&local->hw, txq, false);
- 
- 		if (txq_has_queue(txq))
- 			set_bit(tid, &sta->txq_buffered_tids);
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -426,15 +426,11 @@ struct sta_info *sta_info_alloc(struct i
- 	if (sta_prepare_rate_control(local, sta, gfp))
- 		goto free_txq;
- 
--	sta->airtime_weight = IEEE80211_DEFAULT_AIRTIME_WEIGHT;
- 
- 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
- 		skb_queue_head_init(&sta->ps_tx_buf[i]);
- 		skb_queue_head_init(&sta->tx_filtered[i]);
--		sta->airtime[i].deficit = sta->airtime_weight;
--		atomic_set(&sta->airtime[i].aql_tx_pending, 0);
--		sta->airtime[i].aql_limit_low = local->aql_txq_limit_low[i];
--		sta->airtime[i].aql_limit_high = local->aql_txq_limit_high[i];
-+		init_airtime_info(&sta->airtime[i], &local->airtime[i]);
- 	}
- 
- 	for (i = 0; i < IEEE80211_NUM_TIDS; i++)
-@@ -1893,24 +1889,59 @@ void ieee80211_sta_set_buffered(struct i
- }
- EXPORT_SYMBOL(ieee80211_sta_set_buffered);
- 
--void ieee80211_sta_register_airtime(struct ieee80211_sta *pubsta, u8 tid,
--				    u32 tx_airtime, u32 rx_airtime)
-+void ieee80211_register_airtime(struct ieee80211_txq *txq,
-+				u32 tx_airtime, u32 rx_airtime)
- {
--	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
--	struct ieee80211_local *local = sta->sdata->local;
--	u8 ac = ieee80211_ac_from_tid(tid);
-+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(txq->vif);
-+	struct ieee80211_local *local = sdata->local;
-+	u64 weight_sum, weight_sum_reciprocal;
-+	struct airtime_sched_info *air_sched;
-+	struct airtime_info *air_info;
- 	u32 airtime = 0;
- 
--	if (sta->local->airtime_flags & AIRTIME_USE_TX)
-+	air_sched = &local->airtime[txq->ac];
-+	air_info = to_airtime_info(txq);
-+
-+	if (local->airtime_flags & AIRTIME_USE_TX)
- 		airtime += tx_airtime;
--	if (sta->local->airtime_flags & AIRTIME_USE_RX)
-+	if (local->airtime_flags & AIRTIME_USE_RX)
- 		airtime += rx_airtime;
- 
--	spin_lock_bh(&local->active_txq_lock[ac]);
--	sta->airtime[ac].tx_airtime += tx_airtime;
--	sta->airtime[ac].rx_airtime += rx_airtime;
--	sta->airtime[ac].deficit -= airtime;
--	spin_unlock_bh(&local->active_txq_lock[ac]);
-+	/* Weights scale so the unit weight is 256 */
-+	airtime <<= 8;
-+
-+	spin_lock_bh(&air_sched->lock);
-+
-+	air_info->tx_airtime += tx_airtime;
-+	air_info->rx_airtime += rx_airtime;
-+
-+	if (air_sched->weight_sum) {
-+		weight_sum = air_sched->weight_sum;
-+		weight_sum_reciprocal = air_sched->weight_sum_reciprocal;
-+	} else {
-+		weight_sum = air_info->weight;
-+		weight_sum_reciprocal = air_info->weight_reciprocal;
-+	}
-+
-+	/* Round the calculation of global vt */
-+	air_sched->v_t += (u64)((airtime + (weight_sum >> 1)) *
-+				weight_sum_reciprocal) >> IEEE80211_RECIPROCAL_SHIFT_64;
-+	air_info->v_t += (u32)((airtime + (air_info->weight >> 1)) *
-+			       air_info->weight_reciprocal) >> IEEE80211_RECIPROCAL_SHIFT_32;
-+	ieee80211_resort_txq(&local->hw, txq);
-+
-+	spin_unlock_bh(&air_sched->lock);
-+}
-+
-+void ieee80211_sta_register_airtime(struct ieee80211_sta *pubsta, u8 tid,
-+				    u32 tx_airtime, u32 rx_airtime)
-+{
-+	struct ieee80211_txq *txq = pubsta->txq[tid];
-+
-+	if (!txq)
-+		return;
-+
-+	ieee80211_register_airtime(txq, tx_airtime, rx_airtime);
- }
- EXPORT_SYMBOL(ieee80211_sta_register_airtime);
- 
-@@ -2354,7 +2385,7 @@ void sta_set_sinfo(struct sta_info *sta,
- 	}
- 
- 	if (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_AIRTIME_WEIGHT))) {
--		sinfo->airtime_weight = sta->airtime_weight;
-+		sinfo->airtime_weight = sta->airtime[0].weight;
- 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_AIRTIME_WEIGHT);
- 	}
- 
---- a/net/mac80211/sta_info.h
-+++ b/net/mac80211/sta_info.h
-@@ -135,18 +135,25 @@ enum ieee80211_agg_stop_reason {
- #define AIRTIME_USE_TX		BIT(0)
- #define AIRTIME_USE_RX		BIT(1)
- 
-+
- struct airtime_info {
- 	u64 rx_airtime;
- 	u64 tx_airtime;
--	s64 deficit;
-+	u64 v_t;
-+	u64 last_scheduled;
-+	struct list_head list;
- 	atomic_t aql_tx_pending; /* Estimated airtime for frames pending */
- 	u32 aql_limit_low;
- 	u32 aql_limit_high;
-+	u32 weight_reciprocal;
-+	u16 weight;
- };
- 
- void ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,
- 					  struct sta_info *sta, u8 ac,
- 					  u16 tx_airtime, bool tx_completed);
-+void ieee80211_register_airtime(struct ieee80211_txq *txq,
-+				u32 tx_airtime, u32 rx_airtime);
- 
- struct sta_info;
- 
-@@ -516,7 +523,6 @@ struct ieee80211_fragment_cache {
-  * @tid_seq: per-TID sequence numbers for sending to this STA
-  * @airtime: per-AC struct airtime_info describing airtime statistics for this
-  *	station
-- * @airtime_weight: station weight for airtime fairness calculation purposes
-  * @ampdu_mlme: A-MPDU state machine state
-  * @mesh: mesh STA information
-  * @debugfs_dir: debug filesystem directory dentry
-@@ -647,7 +653,6 @@ struct sta_info {
- 	u16 tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1];
- 
- 	struct airtime_info airtime[IEEE80211_NUM_ACS];
--	u16 airtime_weight;
- 
- 	/*
- 	 * Aggregation information, locked with lock.
---- a/net/mac80211/status.c
-+++ b/net/mac80211/status.c
-@@ -972,6 +972,25 @@ static void __ieee80211_tx_status(struct
- 		if (!(info->flags & IEEE80211_TX_CTL_INJECTED) && acked)
- 			ieee80211_frame_acked(sta, skb);
- 
-+	} else if (wiphy_ext_feature_isset(local->hw.wiphy,
-+					   NL80211_EXT_FEATURE_AIRTIME_FAIRNESS)) {
-+		struct ieee80211_sub_if_data *sdata;
-+		struct ieee80211_txq *txq;
-+		u32 airtime;
-+
-+		/* Account airtime to multicast queue */
-+		sdata = ieee80211_sdata_from_skb(local, skb);
-+
-+		if (sdata && (txq = sdata->vif.txq)) {
-+			airtime = info->status.tx_time ?:
-+				ieee80211_calc_expected_tx_airtime(hw,
-+								   &sdata->vif,
-+								   NULL,
-+								   skb->len,
-+								   false);
-+
-+			ieee80211_register_airtime(txq, airtime, 0);
-+		}
- 	}
- 
- 	/* SNMP counters
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -18,6 +18,7 @@
- #include <linux/bitmap.h>
- #include <linux/rcupdate.h>
- #include <linux/export.h>
-+#include <linux/timekeeping.h>
- #include <net/net_namespace.h>
- #include <net/ieee80211_radiotap.h>
- #include <net/cfg80211.h>
-@@ -1489,7 +1490,7 @@ void ieee80211_txq_init(struct ieee80211
- 	codel_vars_init(&txqi->def_cvars);
- 	codel_stats_init(&txqi->cstats);
- 	__skb_queue_head_init(&txqi->frags);
--	INIT_LIST_HEAD(&txqi->schedule_order);
-+	RB_CLEAR_NODE(&txqi->schedule_order);
- 
- 	txqi->txq.vif = &sdata->vif;
- 
-@@ -1533,9 +1534,7 @@ void ieee80211_txq_purge(struct ieee8021
- 	ieee80211_purge_tx_queue(&local->hw, &txqi->frags);
- 	spin_unlock_bh(&fq->lock);
- 
--	spin_lock_bh(&local->active_txq_lock[txqi->txq.ac]);
--	list_del_init(&txqi->schedule_order);
--	spin_unlock_bh(&local->active_txq_lock[txqi->txq.ac]);
-+	ieee80211_unschedule_txq(&local->hw, &txqi->txq, true);
- }
- 
- void ieee80211_txq_set_params(struct ieee80211_local *local)
-@@ -3831,102 +3830,259 @@ EXPORT_SYMBOL(ieee80211_tx_dequeue);
- struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
- {
- 	struct ieee80211_local *local = hw_to_local(hw);
-+	struct airtime_sched_info *air_sched;
-+	u64 now = ktime_get_boottime_ns();
- 	struct ieee80211_txq *ret = NULL;
--	struct txq_info *txqi = NULL, *head = NULL;
--	bool found_eligible_txq = false;
-+	struct airtime_info *air_info;
-+	struct txq_info *txqi = NULL;
-+	struct rb_node *node;
-+	bool first = false;
- 
--	spin_lock_bh(&local->active_txq_lock[ac]);
-+	air_sched = &local->airtime[ac];
-+	spin_lock_bh(&air_sched->lock);
- 
-- begin:
--	txqi = list_first_entry_or_null(&local->active_txqs[ac],
--					struct txq_info,
--					schedule_order);
--	if (!txqi)
-+	node = air_sched->schedule_pos;
-+
-+begin:
-+	if (!node) {
-+		node = rb_first_cached(&air_sched->active_txqs);
-+		first = true;
-+	} else {
-+		node = rb_next(node);
-+	}
-+
-+	if (!node)
- 		goto out;
- 
--	if (txqi == head) {
--		if (!found_eligible_txq)
--			goto out;
--		else
--			found_eligible_txq = false;
-+	txqi = container_of(node, struct txq_info, schedule_order);
-+	air_info = to_airtime_info(&txqi->txq);
-+
-+	if (air_info->v_t > air_sched->v_t &&
-+	    (!first || !airtime_catchup_v_t(air_sched, air_info->v_t, now)))
-+		goto out;
-+
-+	if (!ieee80211_txq_airtime_check(hw, &txqi->txq)) {
-+		first = false;
-+		goto begin;
- 	}
- 
--	if (!head)
--		head = txqi;
-+	air_sched->schedule_pos = node;
-+	air_sched->last_schedule_activity = now;
-+	ret = &txqi->txq;
-+out:
-+	spin_unlock_bh(&air_sched->lock);
-+	return ret;
-+}
-+EXPORT_SYMBOL(ieee80211_next_txq);
- 
--	if (txqi->txq.sta) {
--		struct sta_info *sta = container_of(txqi->txq.sta,
--						    struct sta_info, sta);
--		bool aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);
--		s64 deficit = sta->airtime[txqi->txq.ac].deficit;
-+static void __ieee80211_insert_txq(struct rb_root_cached *root,
-+				   struct txq_info *txqi)
-+{
-+	struct rb_node **new = &root->rb_root.rb_node;
-+	struct airtime_info *old_air, *new_air;
-+	struct rb_node *parent = NULL;
-+	struct txq_info *__txqi;
-+	bool leftmost = true;
-+
-+	while (*new) {
-+		parent = *new;
-+		__txqi = rb_entry(parent, struct txq_info, schedule_order);
-+		old_air = to_airtime_info(&__txqi->txq);
-+		new_air = to_airtime_info(&txqi->txq);
- 
--		if (aql_check)
--			found_eligible_txq = true;
-+		if (new_air->v_t <= old_air->v_t) {
-+			new = &parent->rb_left;
-+		} else {
-+			new = &parent->rb_right;
-+			leftmost = false;
-+		}
-+	}
- 
--		if (deficit < 0)
--			sta->airtime[txqi->txq.ac].deficit +=
--				sta->airtime_weight;
--
--		if (deficit < 0 || !aql_check) {
--			list_move_tail(&txqi->schedule_order,
--				       &local->active_txqs[txqi->txq.ac]);
--			goto begin;
-+	rb_link_node(&txqi->schedule_order, parent, new);
-+	rb_insert_color_cached(&txqi->schedule_order, root, leftmost);
-+}
-+
-+void ieee80211_resort_txq(struct ieee80211_hw *hw,
-+			  struct ieee80211_txq *txq)
-+{
-+	struct airtime_info *air_info = to_airtime_info(txq);
-+	struct ieee80211_local *local = hw_to_local(hw);
-+	struct txq_info *txqi = to_txq_info(txq);
-+	struct airtime_sched_info *air_sched;
-+
-+	air_sched = &local->airtime[txq->ac];
-+
-+	lockdep_assert_held(&air_sched->lock);
-+
-+	if (!RB_EMPTY_NODE(&txqi->schedule_order)) {
-+		struct airtime_info *a_prev = NULL, *a_next = NULL;
-+		struct txq_info *t_prev, *t_next;
-+		struct rb_node *n_prev, *n_next;
-+
-+		/* Erasing a node can cause an expensive rebalancing operation,
-+		 * so we check the previous and next nodes first and only remove
-+		 * and re-insert if the current node is not already in the
-+		 * correct position.
-+		 */
-+		if ((n_prev = rb_prev(&txqi->schedule_order)) != NULL) {
-+			t_prev = container_of(n_prev, struct txq_info,
-+					      schedule_order);
-+			a_prev = to_airtime_info(&t_prev->txq);
-+		}
-+
-+		if ((n_next = rb_next(&txqi->schedule_order)) != NULL) {
-+			t_next = container_of(n_next, struct txq_info,
-+					      schedule_order);
-+			a_next = to_airtime_info(&t_next->txq);
- 		}
-+
-+		if ((!a_prev || a_prev->v_t <= air_info->v_t) &&
-+		    (!a_next || a_next->v_t > air_info->v_t))
-+			return;
-+
-+		if (air_sched->schedule_pos == &txqi->schedule_order)
-+			air_sched->schedule_pos = n_prev;
-+
-+		rb_erase_cached(&txqi->schedule_order,
-+				&air_sched->active_txqs);
-+		RB_CLEAR_NODE(&txqi->schedule_order);
-+		__ieee80211_insert_txq(&air_sched->active_txqs, txqi);
- 	}
-+}
-+
-+void ieee80211_update_airtime_weight(struct ieee80211_local *local,
-+				     struct airtime_sched_info *air_sched,
-+				     u64 now, bool force)
-+{
-+	struct airtime_info *air_info, *tmp;
-+	u64 weight_sum = 0;
-+
-+	if (unlikely(!now))
-+		now = ktime_get_boottime_ns();
-+
-+	lockdep_assert_held(&air_sched->lock);
-+
-+	if (!force && (air_sched->last_weight_update <
-+		       now - AIRTIME_ACTIVE_DURATION))
-+		return;
-+
-+	list_for_each_entry_safe(air_info, tmp,
-+				 &air_sched->active_list, list) {
-+		if (airtime_is_active(air_info, now))
-+			weight_sum += air_info->weight;
-+		else
-+			list_del_init(&air_info->list);
-+	}
-+	airtime_weight_sum_set(air_sched, weight_sum);
-+	air_sched->last_weight_update = now;
-+}
- 
-+void ieee80211_schedule_txq(struct ieee80211_hw *hw,
-+			    struct ieee80211_txq *txq)
-+	__acquires(txq_lock) __releases(txq_lock)
-+{
-+	struct ieee80211_local *local = hw_to_local(hw);
-+	struct txq_info *txqi = to_txq_info(txq);
-+	struct airtime_sched_info *air_sched;
-+	u64 now = ktime_get_boottime_ns();
-+	struct airtime_info *air_info;
-+	u8 ac = txq->ac;
-+	bool was_active;
- 
--	if (txqi->schedule_round == local->schedule_round[ac])
-+	air_sched = &local->airtime[ac];
-+	air_info = to_airtime_info(txq);
-+
-+	spin_lock_bh(&air_sched->lock);
-+	was_active = airtime_is_active(air_info, now);
-+	airtime_set_active(air_sched, air_info, now);
-+
-+	if (!RB_EMPTY_NODE(&txqi->schedule_order))
- 		goto out;
- 
--	list_del_init(&txqi->schedule_order);
--	txqi->schedule_round = local->schedule_round[ac];
--	ret = &txqi->txq;
-+	/* If the station has been inactive for a while, catch up its v_t so it
-+	 * doesn't get indefinite priority; see comment above the definition of
-+	 * AIRTIME_MAX_BEHIND.
-+	 */
-+	if ((!was_active && air_info->v_t < air_sched->v_t) ||
-+	    air_info->v_t < air_sched->v_t - AIRTIME_MAX_BEHIND)
-+		air_info->v_t = air_sched->v_t;
-+
-+	ieee80211_update_airtime_weight(local, air_sched, now, !was_active);
-+	__ieee80211_insert_txq(&air_sched->active_txqs, txqi);
- 
- out:
--	spin_unlock_bh(&local->active_txq_lock[ac]);
--	return ret;
-+	spin_unlock_bh(&air_sched->lock);
- }
--EXPORT_SYMBOL(ieee80211_next_txq);
-+EXPORT_SYMBOL(ieee80211_schedule_txq);
- 
--void __ieee80211_schedule_txq(struct ieee80211_hw *hw,
--			      struct ieee80211_txq *txq,
--			      bool force)
-+static void __ieee80211_unschedule_txq(struct ieee80211_hw *hw,
-+				       struct ieee80211_txq *txq,
-+				       bool purge)
- {
- 	struct ieee80211_local *local = hw_to_local(hw);
- 	struct txq_info *txqi = to_txq_info(txq);
-+	struct airtime_sched_info *air_sched;
-+	struct airtime_info *air_info;
- 
--	spin_lock_bh(&local->active_txq_lock[txq->ac]);
-+	air_sched = &local->airtime[txq->ac];
-+	air_info = to_airtime_info(&txqi->txq);
- 
--	if (list_empty(&txqi->schedule_order) &&
--	    (force || !skb_queue_empty(&txqi->frags) ||
--	     txqi->tin.backlog_packets)) {
--		/* If airtime accounting is active, always enqueue STAs at the
--		 * head of the list to ensure that they only get moved to the
--		 * back by the airtime DRR scheduler once they have a negative
--		 * deficit. A station that already has a negative deficit will
--		 * get immediately moved to the back of the list on the next
--		 * call to ieee80211_next_txq().
--		 */
--		if (txqi->txq.sta && local->airtime_flags &&
--		    wiphy_ext_feature_isset(local->hw.wiphy,
--					    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
--			list_add(&txqi->schedule_order,
--				 &local->active_txqs[txq->ac]);
--		else
--			list_add_tail(&txqi->schedule_order,
--				      &local->active_txqs[txq->ac]);
-+	lockdep_assert_held(&air_sched->lock);
-+
-+	if (purge) {
-+		list_del_init(&air_info->list);
-+		ieee80211_update_airtime_weight(local, air_sched, 0, true);
- 	}
- 
--	spin_unlock_bh(&local->active_txq_lock[txq->ac]);
-+	if (RB_EMPTY_NODE(&txqi->schedule_order))
-+		return;
-+
-+	if (air_sched->schedule_pos == &txqi->schedule_order)
-+		air_sched->schedule_pos = rb_prev(&txqi->schedule_order);
-+
-+	if (!purge)
-+		airtime_set_active(air_sched, air_info,
-+				   ktime_get_boottime_ns());
-+
-+	rb_erase_cached(&txqi->schedule_order,
-+			&air_sched->active_txqs);
-+	RB_CLEAR_NODE(&txqi->schedule_order);
-+}
-+
-+void ieee80211_unschedule_txq(struct ieee80211_hw *hw,
-+			      struct ieee80211_txq *txq,
-+			      bool purge)
-+	__acquires(txq_lock) __releases(txq_lock)
-+{
-+	struct ieee80211_local *local = hw_to_local(hw);
-+
-+	spin_lock_bh(&local->airtime[txq->ac].lock);
-+	__ieee80211_unschedule_txq(hw, txq, purge);
-+	spin_unlock_bh(&local->airtime[txq->ac].lock);
-+}
-+
-+void ieee80211_return_txq(struct ieee80211_hw *hw,
-+			  struct ieee80211_txq *txq, bool force)
-+{
-+	struct ieee80211_local *local = hw_to_local(hw);
-+	struct txq_info *txqi = to_txq_info(txq);
-+
-+	spin_lock_bh(&local->airtime[txq->ac].lock);
-+
-+	if (!RB_EMPTY_NODE(&txqi->schedule_order) && !force &&
-+	    !txq_has_queue(txq))
-+		__ieee80211_unschedule_txq(hw, txq, false);
-+
-+	spin_unlock_bh(&local->airtime[txq->ac].lock);
- }
--EXPORT_SYMBOL(__ieee80211_schedule_txq);
-+EXPORT_SYMBOL(ieee80211_return_txq);
- 
- DEFINE_STATIC_KEY_FALSE(aql_disable);
- 
- bool ieee80211_txq_airtime_check(struct ieee80211_hw *hw,
- 				 struct ieee80211_txq *txq)
- {
--	struct sta_info *sta;
-+	struct airtime_info *air_info = to_airtime_info(txq);
- 	struct ieee80211_local *local = hw_to_local(hw);
- 
- 	if (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))
-@@ -3941,15 +4097,12 @@ bool ieee80211_txq_airtime_check(struct
- 	if (unlikely(txq->tid == IEEE80211_NUM_TIDS))
- 		return true;
- 
--	sta = container_of(txq->sta, struct sta_info, sta);
--	if (atomic_read(&sta->airtime[txq->ac].aql_tx_pending) <
--	    sta->airtime[txq->ac].aql_limit_low)
-+	if (atomic_read(&air_info->aql_tx_pending) < air_info->aql_limit_low)
- 		return true;
- 
- 	if (atomic_read(&local->aql_total_pending_airtime) <
- 	    local->aql_threshold &&
--	    atomic_read(&sta->airtime[txq->ac].aql_tx_pending) <
--	    sta->airtime[txq->ac].aql_limit_high)
-+	    atomic_read(&air_info->aql_tx_pending) < air_info->aql_limit_high)
- 		return true;
- 
- 	return false;
-@@ -3959,60 +4112,59 @@ EXPORT_SYMBOL(ieee80211_txq_airtime_chec
- bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
- 				struct ieee80211_txq *txq)
- {
-+	struct txq_info *first_txqi = NULL, *txqi = to_txq_info(txq);
- 	struct ieee80211_local *local = hw_to_local(hw);
--	struct txq_info *iter, *tmp, *txqi = to_txq_info(txq);
--	struct sta_info *sta;
--	u8 ac = txq->ac;
-+	struct airtime_sched_info *air_sched;
-+	struct airtime_info *air_info;
-+	struct rb_node *node = NULL;
-+	bool ret = false;
-+	u64 now;
- 
--	spin_lock_bh(&local->active_txq_lock[ac]);
- 
--	if (!txqi->txq.sta)
--		goto out;
-+	if (!ieee80211_txq_airtime_check(hw, txq))
-+		return false;
-+
-+	air_sched = &local->airtime[txq->ac];
-+	spin_lock_bh(&air_sched->lock);
- 
--	if (list_empty(&txqi->schedule_order))
-+	if (RB_EMPTY_NODE(&txqi->schedule_order))
- 		goto out;
- 
--	list_for_each_entry_safe(iter, tmp, &local->active_txqs[ac],
--				 schedule_order) {
--		if (iter == txqi)
--			break;
-+	now = ktime_get_boottime_ns();
- 
--		if (!iter->txq.sta) {
--			list_move_tail(&iter->schedule_order,
--				       &local->active_txqs[ac]);
--			continue;
--		}
--		sta = container_of(iter->txq.sta, struct sta_info, sta);
--		if (sta->airtime[ac].deficit < 0)
--			sta->airtime[ac].deficit += sta->airtime_weight;
--		list_move_tail(&iter->schedule_order, &local->active_txqs[ac]);
-+	/* Like in ieee80211_next_txq(), make sure the first station in the
-+	 * scheduling order is eligible for transmission to avoid starvation.
-+	 */
-+	node = rb_first_cached(&air_sched->active_txqs);
-+	if (node) {
-+		first_txqi = container_of(node, struct txq_info,
-+					  schedule_order);
-+		air_info = to_airtime_info(&first_txqi->txq);
-+
-+		if (air_sched->v_t < air_info->v_t)
-+			airtime_catchup_v_t(air_sched, air_info->v_t, now);
- 	}
- 
--	sta = container_of(txqi->txq.sta, struct sta_info, sta);
--	if (sta->airtime[ac].deficit >= 0)
--		goto out;
--
--	sta->airtime[ac].deficit += sta->airtime_weight;
--	list_move_tail(&txqi->schedule_order, &local->active_txqs[ac]);
--	spin_unlock_bh(&local->active_txq_lock[ac]);
-+	air_info = to_airtime_info(&txqi->txq);
-+	if (air_info->v_t <= air_sched->v_t) {
-+		air_sched->last_schedule_activity = now;
-+		ret = true;
-+	}
- 
--	return false;
- out:
--	if (!list_empty(&txqi->schedule_order))
--		list_del_init(&txqi->schedule_order);
--	spin_unlock_bh(&local->active_txq_lock[ac]);
--
--	return true;
-+	spin_unlock_bh(&air_sched->lock);
-+	return ret;
- }
- EXPORT_SYMBOL(ieee80211_txq_may_transmit);
- 
- void ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac)
- {
- 	struct ieee80211_local *local = hw_to_local(hw);
-+	struct airtime_sched_info *air_sched = &local->airtime[ac];
- 
--	spin_lock_bh(&local->active_txq_lock[ac]);
--	local->schedule_round[ac]++;
--	spin_unlock_bh(&local->active_txq_lock[ac]);
-+	spin_lock_bh(&air_sched->lock);
-+	air_sched->schedule_pos = NULL;
-+	spin_unlock_bh(&air_sched->lock);
- }
- EXPORT_SYMBOL(ieee80211_txq_schedule_start);
- 
diff --git a/package/kernel/mac80211/patches/subsys/384-nl80211-add-common-API-to-configure-SAR-power-limita.patch b/package/kernel/mac80211/patches/subsys/384-nl80211-add-common-API-to-configure-SAR-power-limita.patch
deleted file mode 100644
index c77bb9ec53..0000000000
--- a/package/kernel/mac80211/patches/subsys/384-nl80211-add-common-API-to-configure-SAR-power-limita.patch
+++ /dev/null
@@ -1,398 +0,0 @@
-From: Carl Huang <cjhuang@codeaurora.org>
-Date: Thu, 3 Dec 2020 05:37:26 -0500
-Subject: [PATCH] nl80211: add common API to configure SAR power limitations
-
-NL80211_CMD_SET_SAR_SPECS is added to configure SAR from
-user space. NL80211_ATTR_SAR_SPEC is used to pass the SAR
-power specification when used with NL80211_CMD_SET_SAR_SPECS.
-
-Wireless driver needs to register SAR type, supported frequency
-ranges to wiphy, so user space can query it. The index in
-frequency range is used to specify which sub band the power
-limitation applies to. The SAR type is for compatibility, so later
-other SAR mechanism can be implemented without breaking the user
-space SAR applications.
-
-Normal process is user space queries the SAR capability, and
-gets the index of supported frequency ranges and associates the
-power limitation with this index and sends to kernel.
-
-Here is an example of message send to kernel:
-8c 00 00 00 08 00 01 00 00 00 00 00 38 00 2b 81
-08 00 01 00 00 00 00 00 2c 00 02 80 14 00 00 80
-08 00 02 00 00 00 00 00 08 00 01 00 38 00 00 00
-14 00 01 80 08 00 02 00 01 00 00 00 08 00 01 00
-48 00 00 00
-
-NL80211_CMD_SET_SAR_SPECS:  0x8c
-NL80211_ATTR_WIPHY:     0x01(phy idx is 0)
-NL80211_ATTR_SAR_SPEC:  0x812b (NLA_NESTED)
-NL80211_SAR_ATTR_TYPE:  0x00 (NL80211_SAR_TYPE_POWER)
-NL80211_SAR_ATTR_SPECS: 0x8002 (NLA_NESTED)
-freq range 0 power: 0x38 in 0.25dbm unit (14dbm)
-freq range 1 power: 0x48 in 0.25dbm unit (18dbm)
-
-Signed-off-by: Carl Huang <cjhuang@codeaurora.org>
-Reviewed-by: Brian Norris <briannorris@chromium.org>
-Reviewed-by: Abhishek Kumar <kuabhs@chromium.org>
-Link: https://lore.kernel.org/r/20201203103728.3034-2-cjhuang@codeaurora.org
-[minor edits, NLA parse cleanups]
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -1737,6 +1737,54 @@ struct station_info {
- 	u8 connected_to_as;
- };
- 
-+/**
-+ * struct cfg80211_sar_sub_specs - sub specs limit
-+ * @power: power limitation in 0.25dbm
-+ * @freq_range_index: index the power limitation applies to
-+ */
-+struct cfg80211_sar_sub_specs {
-+	s32 power;
-+	u32 freq_range_index;
-+};
-+
-+/**
-+ * struct cfg80211_sar_specs - sar limit specs
-+ * @type: it's set with power in 0.25dbm or other types
-+ * @num_sub_specs: number of sar sub specs
-+ * @sub_specs: memory to hold the sar sub specs
-+ */
-+struct cfg80211_sar_specs {
-+	enum nl80211_sar_type type;
-+	u32 num_sub_specs;
-+	struct cfg80211_sar_sub_specs sub_specs[];
-+};
-+
-+
-+/**
-+ * @struct cfg80211_sar_chan_ranges - sar frequency ranges
-+ * @start_freq:  start range edge frequency
-+ * @end_freq:    end range edge frequency
-+ */
-+struct cfg80211_sar_freq_ranges {
-+	u32 start_freq;
-+	u32 end_freq;
-+};
-+
-+/**
-+ * struct cfg80211_sar_capa - sar limit capability
-+ * @type: it's set via power in 0.25dbm or other types
-+ * @num_freq_ranges: number of frequency ranges
-+ * @freq_ranges: memory to hold the freq ranges.
-+ *
-+ * Note: WLAN driver may append new ranges or split an existing
-+ * range to small ones and then append them.
-+ */
-+struct cfg80211_sar_capa {
-+	enum nl80211_sar_type type;
-+	u32 num_freq_ranges;
-+	const struct cfg80211_sar_freq_ranges *freq_ranges;
-+};
-+
- #if IS_ENABLED(CPTCFG_CFG80211)
- /**
-  * cfg80211_get_station - retrieve information about a given station
-@@ -4259,6 +4307,8 @@ struct cfg80211_ops {
- 				  struct cfg80211_tid_config *tid_conf);
- 	int	(*reset_tid_config)(struct wiphy *wiphy, struct net_device *dev,
- 				    const u8 *peer, u8 tids);
-+	int	(*set_sar_specs)(struct wiphy *wiphy,
-+				 struct cfg80211_sar_specs *sar);
- };
- 
- /*
-@@ -5030,6 +5080,8 @@ struct wiphy {
- 
- 	u8 max_data_retry_count;
- 
-+	const struct cfg80211_sar_capa *sar_capa;
-+
- 	char priv[] __aligned(NETDEV_ALIGN);
- };
- 
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -405,6 +405,18 @@ nl80211_unsol_bcast_probe_resp_policy[NL
- 						       .len = IEEE80211_MAX_DATA_LEN }
- };
- 
-+static const struct nla_policy
-+sar_specs_policy[NL80211_SAR_ATTR_SPECS_MAX + 1] = {
-+	[NL80211_SAR_ATTR_SPECS_POWER] = { .type = NLA_S32 },
-+	[NL80211_SAR_ATTR_SPECS_RANGE_INDEX] = {.type = NLA_U32 },
-+};
-+
-+static const struct nla_policy
-+sar_policy[NL80211_SAR_ATTR_MAX + 1] = {
-+	[NL80211_SAR_ATTR_TYPE] = NLA_POLICY_MAX(NLA_U32, NUM_NL80211_SAR_TYPE),
-+	[NL80211_SAR_ATTR_SPECS] = NLA_POLICY_NESTED_ARRAY(sar_specs_policy),
-+};
-+
- static const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
- 	[0] = { .strict_start_type = NL80211_ATTR_HE_OBSS_PD },
- 	[NL80211_ATTR_WIPHY] = { .type = NLA_U32 },
-@@ -744,6 +756,7 @@ static const struct nla_policy nl80211_p
- 	[NL80211_ATTR_SAE_PWE] =
- 		NLA_POLICY_RANGE(NLA_U8, NL80211_SAE_PWE_HUNT_AND_PECK,
- 				 NL80211_SAE_PWE_BOTH),
-+	[NL80211_ATTR_SAR_SPEC] = NLA_POLICY_NESTED(sar_policy),
- 	[NL80211_ATTR_RECONNECT_REQUESTED] = { .type = NLA_REJECT },
- };
- 
-@@ -2122,6 +2135,56 @@ fail:
- 	return -ENOBUFS;
- }
- 
-+static int
-+nl80211_put_sar_specs(struct cfg80211_registered_device *rdev,
-+		      struct sk_buff *msg)
-+{
-+	struct nlattr *sar_capa, *specs, *sub_freq_range;
-+	u8 num_freq_ranges;
-+	int i;
-+
-+	if (!rdev->wiphy.sar_capa)
-+		return 0;
-+
-+	num_freq_ranges = rdev->wiphy.sar_capa->num_freq_ranges;
-+
-+	sar_capa = nla_nest_start(msg, NL80211_ATTR_SAR_SPEC);
-+	if (!sar_capa)
-+		return -ENOSPC;
-+
-+	if (nla_put_u32(msg, NL80211_SAR_ATTR_TYPE, rdev->wiphy.sar_capa->type))
-+		goto fail;
-+
-+	specs = nla_nest_start(msg, NL80211_SAR_ATTR_SPECS);
-+	if (!specs)
-+		goto fail;
-+
-+	/* report supported freq_ranges */
-+	for (i = 0; i < num_freq_ranges; i++) {
-+		sub_freq_range = nla_nest_start(msg, i + 1);
-+		if (!sub_freq_range)
-+			goto fail;
-+
-+		if (nla_put_u32(msg, NL80211_SAR_ATTR_SPECS_START_FREQ,
-+				rdev->wiphy.sar_capa->freq_ranges[i].start_freq))
-+			goto fail;
-+
-+		if (nla_put_u32(msg, NL80211_SAR_ATTR_SPECS_END_FREQ,
-+				rdev->wiphy.sar_capa->freq_ranges[i].end_freq))
-+			goto fail;
-+
-+		nla_nest_end(msg, sub_freq_range);
-+	}
-+
-+	nla_nest_end(msg, specs);
-+	nla_nest_end(msg, sar_capa);
-+
-+	return 0;
-+fail:
-+	nla_nest_cancel(msg, sar_capa);
-+	return -ENOBUFS;
-+}
-+
- struct nl80211_dump_wiphy_state {
- 	s64 filter_wiphy;
- 	long start;
-@@ -2371,6 +2434,8 @@ static int nl80211_send_wiphy(struct cfg
- 			CMD(set_multicast_to_unicast, SET_MULTICAST_TO_UNICAST);
- 			CMD(update_connect_params, UPDATE_CONNECT_PARAMS);
- 			CMD(update_ft_ies, UPDATE_FT_IES);
-+			if (rdev->wiphy.sar_capa)
-+				CMD(set_sar_specs, SET_SAR_SPECS);
- 		}
- #undef CMD
- 
-@@ -2696,6 +2761,11 @@ static int nl80211_send_wiphy(struct cfg
- 
- 		if (nl80211_put_tid_config_support(rdev, msg))
- 			goto nla_put_failure;
-+		state->split_start++;
-+		break;
-+	case 16:
-+		if (nl80211_put_sar_specs(rdev, msg))
-+			goto nla_put_failure;
- 
- 		/* done */
- 		state->split_start = 0;
-@@ -14744,6 +14814,111 @@ static void nl80211_post_doit(__genl_con
- 	}
- }
- 
-+static int nl80211_set_sar_sub_specs(struct cfg80211_registered_device *rdev,
-+				     struct cfg80211_sar_specs *sar_specs,
-+				     struct nlattr *spec[], int index)
-+{
-+	u32 range_index, i;
-+
-+	if (!sar_specs || !spec)
-+		return -EINVAL;
-+
-+	if (!spec[NL80211_SAR_ATTR_SPECS_POWER] ||
-+	    !spec[NL80211_SAR_ATTR_SPECS_RANGE_INDEX])
-+		return -EINVAL;
-+
-+	range_index = nla_get_u32(spec[NL80211_SAR_ATTR_SPECS_RANGE_INDEX]);
-+
-+	/* check if range_index exceeds num_freq_ranges */
-+	if (range_index >= rdev->wiphy.sar_capa->num_freq_ranges)
-+		return -EINVAL;
-+
-+	/* check if range_index duplicates */
-+	for (i = 0; i < index; i++) {
-+		if (sar_specs->sub_specs[i].freq_range_index == range_index)
-+			return -EINVAL;
-+	}
-+
-+	sar_specs->sub_specs[index].power =
-+		nla_get_s32(spec[NL80211_SAR_ATTR_SPECS_POWER]);
-+
-+	sar_specs->sub_specs[index].freq_range_index = range_index;
-+
-+	return 0;
-+}
-+
-+static int nl80211_set_sar_specs(struct sk_buff *skb, struct genl_info *info)
-+{
-+	struct cfg80211_registered_device *rdev = info->user_ptr[0];
-+	struct nlattr *spec[NL80211_SAR_ATTR_SPECS_MAX + 1];
-+	struct nlattr *tb[NL80211_SAR_ATTR_MAX + 1];
-+	struct cfg80211_sar_specs *sar_spec;
-+	enum nl80211_sar_type type;
-+	struct nlattr *spec_list;
-+	u32 specs;
-+	int rem, err;
-+
-+	if (!rdev->wiphy.sar_capa || !rdev->ops->set_sar_specs)
-+		return -EOPNOTSUPP;
-+
-+	if (!info->attrs[NL80211_ATTR_SAR_SPEC])
-+		return -EINVAL;
-+
-+	nla_parse_nested(tb, NL80211_SAR_ATTR_MAX,
-+			 info->attrs[NL80211_ATTR_SAR_SPEC],
-+			 NULL, NULL);
-+
-+	if (!tb[NL80211_SAR_ATTR_TYPE] || !tb[NL80211_SAR_ATTR_SPECS])
-+		return -EINVAL;
-+
-+	type = nla_get_u32(tb[NL80211_SAR_ATTR_TYPE]);
-+	if (type != rdev->wiphy.sar_capa->type)
-+		return -EINVAL;
-+
-+	specs = 0;
-+	nla_for_each_nested(spec_list, tb[NL80211_SAR_ATTR_SPECS], rem)
-+		specs++;
-+
-+	if (specs > rdev->wiphy.sar_capa->num_freq_ranges)
-+		return -EINVAL;
-+
-+	sar_spec = kzalloc(sizeof(*sar_spec) +
-+			   specs * sizeof(struct cfg80211_sar_sub_specs),
-+			   GFP_KERNEL);
-+	if (!sar_spec)
-+		return -ENOMEM;
-+
-+	sar_spec->type = type;
-+	specs = 0;
-+	nla_for_each_nested(spec_list, tb[NL80211_SAR_ATTR_SPECS], rem) {
-+		nla_parse_nested(spec, NL80211_SAR_ATTR_SPECS_MAX,
-+				 spec_list, NULL, NULL);
-+
-+		switch (type) {
-+		case NL80211_SAR_TYPE_POWER:
-+			if (nl80211_set_sar_sub_specs(rdev, sar_spec,
-+						      spec, specs)) {
-+				err = -EINVAL;
-+				goto error;
-+			}
-+			break;
-+		default:
-+			err = -EINVAL;
-+			goto error;
-+		}
-+		specs++;
-+	}
-+
-+	sar_spec->num_sub_specs = specs;
-+
-+	rdev->cur_cmd_info = info;
-+	err = rdev_set_sar_specs(rdev, sar_spec);
-+	rdev->cur_cmd_info = NULL;
-+error:
-+	kfree(sar_spec);
-+	return err;
-+}
-+
- static __genl_const struct genl_ops nl80211_ops[] = {
- 	{
- 		.cmd = NL80211_CMD_GET_WIPHY,
-@@ -15607,6 +15782,14 @@ static const struct genl_small_ops nl802
- 		.internal_flags = NL80211_FLAG_NEED_NETDEV |
- 				  NL80211_FLAG_NEED_RTNL,
- 	},
-+	{
-+		.cmd = NL80211_CMD_SET_SAR_SPECS,
-+		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
-+		.doit = nl80211_set_sar_specs,
-+		.flags = GENL_UNS_ADMIN_PERM,
-+		.internal_flags = NL80211_FLAG_NEED_WIPHY |
-+				  NL80211_FLAG_NEED_RTNL,
-+	},
- };
- 
- static struct genl_family nl80211_fam __genl_ro_after_init = {
---- a/net/wireless/rdev-ops.h
-+++ b/net/wireless/rdev-ops.h
-@@ -1356,4 +1356,16 @@ static inline int rdev_reset_tid_config(
- 	return ret;
- }
- 
-+static inline int rdev_set_sar_specs(struct cfg80211_registered_device *rdev,
-+				     struct cfg80211_sar_specs *sar)
-+{
-+	int ret;
-+
-+	trace_rdev_set_sar_specs(&rdev->wiphy, sar);
-+	ret = rdev->ops->set_sar_specs(&rdev->wiphy, sar);
-+	trace_rdev_return_int(&rdev->wiphy, ret);
-+
-+	return ret;
-+}
-+
- #endif /* __CFG80211_RDEV_OPS */
---- a/net/wireless/trace.h
-+++ b/net/wireless/trace.h
-@@ -3551,6 +3551,25 @@ TRACE_EVENT(rdev_reset_tid_config,
- 	TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", peer: " MAC_PR_FMT ", tids: 0x%x",
- 		  WIPHY_PR_ARG, NETDEV_PR_ARG, MAC_PR_ARG(peer), __entry->tids)
- );
-+
-+TRACE_EVENT(rdev_set_sar_specs,
-+	TP_PROTO(struct wiphy *wiphy, struct cfg80211_sar_specs *sar),
-+	TP_ARGS(wiphy, sar),
-+	TP_STRUCT__entry(
-+		WIPHY_ENTRY
-+		__field(u16, type)
-+		__field(u16, num)
-+	),
-+	TP_fast_assign(
-+		WIPHY_ASSIGN;
-+		__entry->type = sar->type;
-+		__entry->num = sar->num_sub_specs;
-+
-+	),
-+	TP_printk(WIPHY_PR_FMT ", Set type:%d, num_specs:%d",
-+		  WIPHY_PR_ARG, __entry->type, __entry->num)
-+);
-+
- #endif /* !__RDEV_OPS_TRACE || TRACE_HEADER_MULTI_READ */
- 
- #undef TRACE_INCLUDE_PATH
diff --git a/package/kernel/mac80211/patches/subsys/385-mac80211-add-ieee80211_set_sar_specs.patch b/package/kernel/mac80211/patches/subsys/385-mac80211-add-ieee80211_set_sar_specs.patch
deleted file mode 100644
index c351bc812a..0000000000
--- a/package/kernel/mac80211/patches/subsys/385-mac80211-add-ieee80211_set_sar_specs.patch
+++ /dev/null
@@ -1,51 +0,0 @@
-From: Carl Huang <cjhuang@codeaurora.org>
-Date: Thu, 3 Dec 2020 05:37:27 -0500
-Subject: [PATCH] mac80211: add ieee80211_set_sar_specs
-
-This change registers ieee80211_set_sar_specs to
-mac80211_config_ops, so cfg80211 can call it.
-
-Signed-off-by: Carl Huang <cjhuang@codeaurora.org>
-Reviewed-by: Brian Norris <briannorris@chromium.org>
-Reviewed-by: Abhishek Kumar <kuabhs@chromium.org>
-Link: https://lore.kernel.org/r/20201203103728.3034-3-cjhuang@codeaurora.org
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -4207,6 +4207,8 @@ struct ieee80211_ops {
- 				   struct ieee80211_vif *vif);
- 	void (*sta_set_4addr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
- 			      struct ieee80211_sta *sta, bool enabled);
-+	int (*set_sar_specs)(struct ieee80211_hw *hw,
-+			     const struct cfg80211_sar_specs *sar);
- 	void (*sta_set_decap_offload)(struct ieee80211_hw *hw,
- 				      struct ieee80211_vif *vif,
- 				      struct ieee80211_sta *sta, bool enabled);
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -4136,6 +4136,17 @@ static int ieee80211_reset_tid_config(st
- 	return ret;
- }
- 
-+static int ieee80211_set_sar_specs(struct wiphy *wiphy,
-+				   struct cfg80211_sar_specs *sar)
-+{
-+	struct ieee80211_local *local = wiphy_priv(wiphy);
-+
-+	if (!local->ops->set_sar_specs)
-+		return -EOPNOTSUPP;
-+
-+	return local->ops->set_sar_specs(&local->hw, sar);
-+}
-+
- const struct cfg80211_ops mac80211_config_ops = {
- 	.add_virtual_intf = ieee80211_add_iface,
- 	.del_virtual_intf = ieee80211_del_iface,
-@@ -4239,4 +4250,5 @@ const struct cfg80211_ops mac80211_confi
- 	.probe_mesh_link = ieee80211_probe_mesh_link,
- 	.set_tid_config = ieee80211_set_tid_config,
- 	.reset_tid_config = ieee80211_reset_tid_config,
-+	.set_sar_specs = ieee80211_set_sar_specs,
- };
diff --git a/package/kernel/mac80211/patches/subsys/386-mac80211-check-per-vif-offload_flags-in-Tx-path.patch b/package/kernel/mac80211/patches/subsys/386-mac80211-check-per-vif-offload_flags-in-Tx-path.patch
deleted file mode 100644
index e011e5333c..0000000000
--- a/package/kernel/mac80211/patches/subsys/386-mac80211-check-per-vif-offload_flags-in-Tx-path.patch
+++ /dev/null
@@ -1,26 +0,0 @@
-From: Ryder Lee <ryder.lee@mediatek.com>
-Date: Fri, 18 Jun 2021 04:38:59 +0800
-Subject: [PATCH] mac80211: check per vif offload_flags in Tx path
-
-offload_flags has been introduced to indicate encap status of each interface.
-An interface can encap offload at runtime, or if it has some extra limitations
-it can simply override the flags, so it's more flexible to check offload_flags
-in Tx path.
-
-Signed-off-by: Ryder Lee <ryder.lee@mediatek.com>
-Link: https://lore.kernel.org/r/177785418cf407808bf3a44760302d0647076990.1623961575.git.ryder.lee@mediatek.com
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -3335,6 +3335,9 @@ static bool ieee80211_amsdu_aggregate(st
- 	if (!ieee80211_hw_check(&local->hw, TX_AMSDU))
- 		return false;
- 
-+	if (sdata->vif.offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED)
-+		return false;
-+
- 	if (skb_is_gso(skb))
- 		return false;
- 
diff --git a/package/kernel/mac80211/patches/subsys/387-nl80211-add-support-for-BSS-coloring.patch b/package/kernel/mac80211/patches/subsys/387-nl80211-add-support-for-BSS-coloring.patch
deleted file mode 100644
index b5fb5546ca..0000000000
--- a/package/kernel/mac80211/patches/subsys/387-nl80211-add-support-for-BSS-coloring.patch
+++ /dev/null
@@ -1,485 +0,0 @@
-From: John Crispin <john@phrozen.org>
-Date: Fri, 2 Jul 2021 19:44:07 +0200
-Subject: [PATCH] nl80211: add support for BSS coloring
-
-This patch adds support for BSS color collisions to the wireless subsystem.
-Add the required functionality to nl80211 that will notify about color
-collisions, triggering the color change and notifying when it is completed.
-
-Co-developed-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Signed-off-by: John Crispin <john@phrozen.org>
-Link: https://lore.kernel.org/r/500b3582aec8fe2c42ef46f3117b148cb7cbceb5.1625247619.git.lorenzo@kernel.org
-[remove unnecessary NULL initialisation]
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -1252,6 +1252,27 @@ struct cfg80211_csa_settings {
- #define CFG80211_MAX_NUM_DIFFERENT_CHANNELS 10
- 
- /**
-+ * struct cfg80211_color_change_settings - color change settings
-+ *
-+ * Used for bss color change
-+ *
-+ * @beacon_color_change: beacon data while performing the color countdown
-+ * @counter_offsets_beacon: offsets of the counters within the beacon (tail)
-+ * @counter_offsets_presp: offsets of the counters within the probe response
-+ * @beacon_next: beacon data to be used after the color change
-+ * @count: number of beacons until the color change
-+ * @color: the color used after the change
-+ */
-+struct cfg80211_color_change_settings {
-+	struct cfg80211_beacon_data beacon_color_change;
-+	u16 counter_offset_beacon;
-+	u16 counter_offset_presp;
-+	struct cfg80211_beacon_data beacon_next;
-+	u8 count;
-+	u8 color;
-+};
-+
-+/**
-  * struct iface_combination_params - input parameters for interface combinations
-  *
-  * Used to pass interface combination parameters
-@@ -3979,6 +4000,8 @@ struct mgmt_frame_regs {
-  *	This callback may sleep.
-  * @reset_tid_config: Reset TID specific configuration for the peer, for the
-  *	given TIDs. This callback may sleep.
-+ *
-+ * @color_change: Initiate a color change.
-  */
- struct cfg80211_ops {
- 	int	(*suspend)(struct wiphy *wiphy, struct cfg80211_wowlan *wow);
-@@ -4309,6 +4332,9 @@ struct cfg80211_ops {
- 				    const u8 *peer, u8 tids);
- 	int	(*set_sar_specs)(struct wiphy *wiphy,
- 				 struct cfg80211_sar_specs *sar);
-+	int	(*color_change)(struct wiphy *wiphy,
-+				struct net_device *dev,
-+				struct cfg80211_color_change_settings *params);
- };
- 
- /*
-@@ -8092,4 +8118,70 @@ void cfg80211_update_owe_info_event(stru
-  */
- void cfg80211_bss_flush(struct wiphy *wiphy);
- 
-+/**
-+ * cfg80211_bss_color_notify - notify about bss color event
-+ * @dev: network device
-+ * @gfp: allocation flags
-+ * @cmd: the actual event we want to notify
-+ * @count: the number of TBTTs until the color change happens
-+ * @color_bitmap: representations of the colors that the local BSS is aware of
-+ */
-+int cfg80211_bss_color_notify(struct net_device *dev, gfp_t gfp,
-+			      enum nl80211_commands cmd, u8 count,
-+			      u64 color_bitmap);
-+
-+/**
-+ * cfg80211_obss_color_collision_notify - notify about bss color collision
-+ * @dev: network device
-+ * @color_bitmap: representations of the colors that the local BSS is aware of
-+ */
-+static inline int cfg80211_obss_color_collision_notify(struct net_device *dev,
-+						       u64 color_bitmap)
-+{
-+	return cfg80211_bss_color_notify(dev, GFP_KERNEL,
-+					 NL80211_CMD_OBSS_COLOR_COLLISION,
-+					 0, color_bitmap);
-+}
-+
-+/**
-+ * cfg80211_color_change_started_notify - notify color change start
-+ * @dev: the device on which the color is switched
-+ * @count: the number of TBTTs until the color change happens
-+ *
-+ * Inform the userspace about the color change that has started.
-+ */
-+static inline int cfg80211_color_change_started_notify(struct net_device *dev,
-+						       u8 count)
-+{
-+	return cfg80211_bss_color_notify(dev, GFP_KERNEL,
-+					 NL80211_CMD_COLOR_CHANGE_STARTED,
-+					 count, 0);
-+}
-+
-+/**
-+ * cfg80211_color_change_aborted_notify - notify color change abort
-+ * @dev: the device on which the color is switched
-+ *
-+ * Inform the userspace about the color change that has aborted.
-+ */
-+static inline int cfg80211_color_change_aborted_notify(struct net_device *dev)
-+{
-+	return cfg80211_bss_color_notify(dev, GFP_KERNEL,
-+					 NL80211_CMD_COLOR_CHANGE_ABORTED,
-+					 0, 0);
-+}
-+
-+/**
-+ * cfg80211_color_change_notify - notify color change completion
-+ * @dev: the device on which the color was switched
-+ *
-+ * Inform the userspace about the color change that has completed.
-+ */
-+static inline int cfg80211_color_change_notify(struct net_device *dev)
-+{
-+	return cfg80211_bss_color_notify(dev, GFP_KERNEL,
-+					 NL80211_CMD_COLOR_CHANGE_COMPLETED,
-+					 0, 0);
-+}
-+
- #endif /* __NET_CFG80211_H */
---- a/include/uapi/linux/nl80211.h
-+++ b/include/uapi/linux/nl80211.h
-@@ -1185,6 +1185,21 @@
-  *	passed using %NL80211_ATTR_SAR_SPEC. %NL80211_ATTR_WIPHY is used to
-  *	specify the wiphy index to be applied to.
-  *
-+ * @NL80211_CMD_OBSS_COLOR_COLLISION: This notification is sent out whenever
-+ *	mac80211/drv detects a bss color collision.
-+ *
-+ * @NL80211_CMD_COLOR_CHANGE_REQUEST: This command is used to indicate that
-+ *	userspace wants to change the BSS color.
-+ *
-+ * @NL80211_CMD_COLOR_CHANGE_STARTED: Notify userland, that a color change has
-+ *	started
-+ *
-+ * @NL80211_CMD_COLOR_CHANGE_ABORTED: Notify userland, that the color change has
-+ *	been aborted
-+ *
-+ * @NL80211_CMD_COLOR_CHANGE_COMPLETED: Notify userland that the color change
-+ *	has completed
-+ *
-  * @NL80211_CMD_MAX: highest used command number
-  * @__NL80211_CMD_AFTER_LAST: internal use
-  */
-@@ -1417,6 +1432,14 @@ enum nl80211_commands {
- 
- 	NL80211_CMD_SET_SAR_SPECS,
- 
-+	NL80211_CMD_OBSS_COLOR_COLLISION,
-+
-+	NL80211_CMD_COLOR_CHANGE_REQUEST,
-+
-+	NL80211_CMD_COLOR_CHANGE_STARTED,
-+	NL80211_CMD_COLOR_CHANGE_ABORTED,
-+	NL80211_CMD_COLOR_CHANGE_COMPLETED,
-+
- 	/* add new commands above here */
- 
- 	/* used to define NL80211_CMD_MAX below */
-@@ -2560,6 +2583,16 @@ enum nl80211_commands {
-  *	disassoc events to indicate that an immediate reconnect to the AP
-  *	is desired.
-  *
-+ * @NL80211_ATTR_OBSS_COLOR_BITMAP: bitmap of the u64 BSS colors for the
-+ *	%NL80211_CMD_OBSS_COLOR_COLLISION event.
-+ *
-+ * @NL80211_ATTR_COLOR_CHANGE_COUNT: u8 attribute specifying the number of TBTT's
-+ *	until the color switch event.
-+ * @NL80211_ATTR_COLOR_CHANGE_COLOR: u8 attribute specifying the color that we are
-+ *	switching to
-+ * @NL80211_ATTR_COLOR_CHANGE_ELEMS: Nested set of attributes containing the IE
-+ *	information for the time while performing a color switch.
-+ *
-  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
-  * @NL80211_ATTR_MAX: highest attribute number currently defined
-  * @__NL80211_ATTR_AFTER_LAST: internal use
-@@ -3057,6 +3090,12 @@ enum nl80211_attrs {
- 
- 	NL80211_ATTR_DISABLE_HE,
- 
-+	NL80211_ATTR_OBSS_COLOR_BITMAP,
-+
-+	NL80211_ATTR_COLOR_CHANGE_COUNT,
-+	NL80211_ATTR_COLOR_CHANGE_COLOR,
-+	NL80211_ATTR_COLOR_CHANGE_ELEMS,
-+
- 	/* add attributes here, update the policy in nl80211.c */
- 
- 	__NL80211_ATTR_AFTER_LAST,
-@@ -5950,6 +5989,9 @@ enum nl80211_feature_flags {
-  *      frame protection for all management frames exchanged during the
-  *      negotiation and range measurement procedure.
-  *
-+ * @NL80211_EXT_FEATURE_BSS_COLOR: The driver supports BSS color collision
-+ *	detection and change announcemnts.
-+ *
-  * @NUM_NL80211_EXT_FEATURES: number of extended features.
-  * @MAX_NL80211_EXT_FEATURES: highest extended feature index.
-  */
-@@ -6014,6 +6056,7 @@ enum nl80211_ext_feature_index {
- 	NL80211_EXT_FEATURE_SECURE_LTF,
- 	NL80211_EXT_FEATURE_SECURE_RTT,
- 	NL80211_EXT_FEATURE_PROT_RANGE_NEGO_AND_MEASURE,
-+	NL80211_EXT_FEATURE_BSS_COLOR,
- 
- 	/* add new features before the definition below */
- 	NUM_NL80211_EXT_FEATURES,
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -758,6 +758,10 @@ static const struct nla_policy nl80211_p
- 				 NL80211_SAE_PWE_BOTH),
- 	[NL80211_ATTR_SAR_SPEC] = NLA_POLICY_NESTED(sar_policy),
- 	[NL80211_ATTR_RECONNECT_REQUESTED] = { .type = NLA_REJECT },
-+	[NL80211_ATTR_OBSS_COLOR_BITMAP] = { .type = NLA_U64 },
-+	[NL80211_ATTR_COLOR_CHANGE_COUNT] = { .type = NLA_U8 },
-+	[NL80211_ATTR_COLOR_CHANGE_COLOR] = { .type = NLA_U8 },
-+	[NL80211_ATTR_COLOR_CHANGE_ELEMS] = NLA_POLICY_NESTED(nl80211_policy),
- };
- 
- /* policy for the key attributes */
-@@ -14709,6 +14713,106 @@ bad_tid_conf:
- 	return ret;
- }
- 
-+static int nl80211_color_change(struct sk_buff *skb, struct genl_info *info)
-+{
-+	struct cfg80211_registered_device *rdev = info->user_ptr[0];
-+	struct cfg80211_color_change_settings params = {};
-+	struct net_device *dev = info->user_ptr[1];
-+	struct wireless_dev *wdev = dev->ieee80211_ptr;
-+	struct nlattr **tb;
-+	u16 offset;
-+	int err;
-+
-+	if (!rdev->ops->color_change)
-+		return -EOPNOTSUPP;
-+
-+	if (!wiphy_ext_feature_isset(&rdev->wiphy,
-+				     NL80211_EXT_FEATURE_BSS_COLOR))
-+		return -EOPNOTSUPP;
-+
-+	if (wdev->iftype != NL80211_IFTYPE_AP)
-+		return -EOPNOTSUPP;
-+
-+	if (!info->attrs[NL80211_ATTR_COLOR_CHANGE_COUNT] ||
-+	    !info->attrs[NL80211_ATTR_COLOR_CHANGE_COLOR] ||
-+	    !info->attrs[NL80211_ATTR_COLOR_CHANGE_ELEMS])
-+		return -EINVAL;
-+
-+	params.count = nla_get_u8(info->attrs[NL80211_ATTR_COLOR_CHANGE_COUNT]);
-+	params.color = nla_get_u8(info->attrs[NL80211_ATTR_COLOR_CHANGE_COLOR]);
-+
-+	err = nl80211_parse_beacon(rdev, info->attrs, &params.beacon_next);
-+	if (err)
-+		return err;
-+
-+	tb = kcalloc(NL80211_ATTR_MAX + 1, sizeof(*tb), GFP_KERNEL);
-+	if (!tb)
-+		return -ENOMEM;
-+
-+	err = nla_parse_nested(tb, NL80211_ATTR_MAX,
-+			       info->attrs[NL80211_ATTR_COLOR_CHANGE_ELEMS],
-+			       nl80211_policy, info->extack);
-+	if (err)
-+		goto out;
-+
-+	err = nl80211_parse_beacon(rdev, tb, &params.beacon_color_change);
-+	if (err)
-+		goto out;
-+
-+	if (!tb[NL80211_ATTR_CNTDWN_OFFS_BEACON]) {
-+		err = -EINVAL;
-+		goto out;
-+	}
-+
-+	if (nla_len(tb[NL80211_ATTR_CNTDWN_OFFS_BEACON]) != sizeof(u16)) {
-+		err = -EINVAL;
-+		goto out;
-+	}
-+
-+	offset = nla_get_u16(tb[NL80211_ATTR_CNTDWN_OFFS_BEACON]);
-+	if (offset >= params.beacon_color_change.tail_len) {
-+		err = -EINVAL;
-+		goto out;
-+	}
-+
-+	if (params.beacon_color_change.tail[offset] != params.count) {
-+		err = -EINVAL;
-+		goto out;
-+	}
-+
-+	params.counter_offset_beacon = offset;
-+
-+	if (tb[NL80211_ATTR_CNTDWN_OFFS_PRESP]) {
-+		if (nla_len(tb[NL80211_ATTR_CNTDWN_OFFS_PRESP]) !=
-+		    sizeof(u16)) {
-+			err = -EINVAL;
-+			goto out;
-+		}
-+
-+		offset = nla_get_u16(tb[NL80211_ATTR_CNTDWN_OFFS_PRESP]);
-+		if (offset >= params.beacon_color_change.probe_resp_len) {
-+			err = -EINVAL;
-+			goto out;
-+		}
-+
-+		if (params.beacon_color_change.probe_resp[offset] !=
-+		    params.count) {
-+			err = -EINVAL;
-+			goto out;
-+		}
-+
-+		params.counter_offset_presp = offset;
-+	}
-+
-+	wdev_lock(wdev);
-+	err = rdev_color_change(rdev, dev, &params);
-+	wdev_unlock(wdev);
-+
-+out:
-+	kfree(tb);
-+	return err;
-+}
-+
- #define NL80211_FLAG_NEED_WIPHY		0x01
- #define NL80211_FLAG_NEED_NETDEV	0x02
- #define NL80211_FLAG_NEED_RTNL		0x04
-@@ -15790,6 +15894,14 @@ static const struct genl_small_ops nl802
- 		.internal_flags = NL80211_FLAG_NEED_WIPHY |
- 				  NL80211_FLAG_NEED_RTNL,
- 	},
-+	{
-+		.cmd = NL80211_CMD_COLOR_CHANGE_REQUEST,
-+		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
-+		.doit = nl80211_color_change,
-+		.flags = GENL_UNS_ADMIN_PERM,
-+		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
-+				  NL80211_FLAG_NEED_RTNL,
-+	},
- };
- 
- static struct genl_family nl80211_fam __genl_ro_after_init = {
-@@ -17417,6 +17529,51 @@ void cfg80211_ch_switch_started_notify(s
- }
- EXPORT_SYMBOL(cfg80211_ch_switch_started_notify);
- 
-+int cfg80211_bss_color_notify(struct net_device *dev, gfp_t gfp,
-+			      enum nl80211_commands cmd, u8 count,
-+			      u64 color_bitmap)
-+{
-+	struct wireless_dev *wdev = dev->ieee80211_ptr;
-+	struct wiphy *wiphy = wdev->wiphy;
-+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
-+	struct sk_buff *msg;
-+	void *hdr;
-+
-+	ASSERT_WDEV_LOCK(wdev);
-+
-+	trace_cfg80211_bss_color_notify(dev, cmd, count, color_bitmap);
-+
-+	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
-+	if (!msg)
-+		return -ENOMEM;
-+
-+	hdr = nl80211hdr_put(msg, 0, 0, 0, cmd);
-+	if (!hdr)
-+		goto nla_put_failure;
-+
-+	if (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))
-+		goto nla_put_failure;
-+
-+	if (cmd == NL80211_CMD_COLOR_CHANGE_STARTED &&
-+	    nla_put_u32(msg, NL80211_ATTR_COLOR_CHANGE_COUNT, count))
-+		goto nla_put_failure;
-+
-+	if (cmd == NL80211_CMD_OBSS_COLOR_COLLISION &&
-+	    nla_put_u64_64bit(msg, NL80211_ATTR_OBSS_COLOR_BITMAP,
-+			      color_bitmap, NL80211_ATTR_PAD))
-+		goto nla_put_failure;
-+
-+	genlmsg_end(msg, hdr);
-+
-+	return genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),
-+				       msg, 0, NL80211_MCGRP_MLME, gfp);
-+
-+nla_put_failure:
-+	nlmsg_free(msg);
-+	return -EINVAL;
-+}
-+EXPORT_SYMBOL(cfg80211_bss_color_notify);
-+
- void
- nl80211_radar_notify(struct cfg80211_registered_device *rdev,
- 		     const struct cfg80211_chan_def *chandef,
---- a/net/wireless/rdev-ops.h
-+++ b/net/wireless/rdev-ops.h
-@@ -1368,4 +1368,17 @@ static inline int rdev_set_sar_specs(str
- 	return ret;
- }
- 
-+static inline int rdev_color_change(struct cfg80211_registered_device *rdev,
-+				    struct net_device *dev,
-+				    struct cfg80211_color_change_settings *params)
-+{
-+	int ret;
-+
-+	trace_rdev_color_change(&rdev->wiphy, dev, params);
-+	ret = rdev->ops->color_change(&rdev->wiphy, dev, params);
-+	trace_rdev_return_int(&rdev->wiphy, ret);
-+
-+	return ret;
-+}
-+
- #endif /* __CFG80211_RDEV_OPS */
---- a/net/wireless/trace.h
-+++ b/net/wireless/trace.h
-@@ -3570,6 +3570,52 @@ TRACE_EVENT(rdev_set_sar_specs,
- 		  WIPHY_PR_ARG, __entry->type, __entry->num)
- );
- 
-+TRACE_EVENT(rdev_color_change,
-+	TP_PROTO(struct wiphy *wiphy, struct net_device *netdev,
-+		 struct cfg80211_color_change_settings *params),
-+	TP_ARGS(wiphy, netdev, params),
-+	TP_STRUCT__entry(
-+		WIPHY_ENTRY
-+		NETDEV_ENTRY
-+		__field(u8, count)
-+		__field(u16, bcn_ofs)
-+		__field(u16, pres_ofs)
-+	),
-+	TP_fast_assign(
-+		WIPHY_ASSIGN;
-+		NETDEV_ASSIGN;
-+		__entry->count = params->count;
-+		__entry->bcn_ofs = params->counter_offset_beacon;
-+		__entry->pres_ofs = params->counter_offset_presp;
-+	),
-+	TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT
-+		  ", count: %u",
-+		  WIPHY_PR_ARG, NETDEV_PR_ARG,
-+		  __entry->count)
-+);
-+
-+TRACE_EVENT(cfg80211_bss_color_notify,
-+	TP_PROTO(struct net_device *netdev,
-+		 enum nl80211_commands cmd,
-+		 u8 count, u64 color_bitmap),
-+	TP_ARGS(netdev, cmd, count, color_bitmap),
-+	TP_STRUCT__entry(
-+		NETDEV_ENTRY
-+		__field(enum nl80211_bss_scan_width, cmd)
-+		__field(u8, count)
-+		__field(u64, color_bitmap)
-+	),
-+	TP_fast_assign(
-+		NETDEV_ASSIGN;
-+		__entry->cmd = cmd;
-+		__entry->count = count;
-+		__entry->color_bitmap = color_bitmap;
-+	),
-+	TP_printk(NETDEV_PR_FMT ", cmd: %x, count: %u, bitmap: %llx",
-+		  NETDEV_PR_ARG, __entry->cmd, __entry->count,
-+		  __entry->color_bitmap)
-+);
-+
- #endif /* !__RDEV_OPS_TRACE || TRACE_HEADER_MULTI_READ */
- 
- #undef TRACE_INCLUDE_PATH
diff --git a/package/kernel/mac80211/patches/subsys/388-mac80211-add-support-for-BSS-color-change.patch b/package/kernel/mac80211/patches/subsys/388-mac80211-add-support-for-BSS-color-change.patch
deleted file mode 100644
index 60e1c8f3c6..0000000000
--- a/package/kernel/mac80211/patches/subsys/388-mac80211-add-support-for-BSS-color-change.patch
+++ /dev/null
@@ -1,524 +0,0 @@
-From: John Crispin <john@phrozen.org>
-Date: Fri, 2 Jul 2021 19:44:08 +0200
-Subject: [PATCH] mac80211: add support for BSS color change
-
-The color change announcement is very similar to how CSA works where
-we have an IE that includes a counter. When the counter hits 0, the new
-color is applied via an updated beacon.
-
-This patch makes the CSA counter functionality reusable, rather than
-implementing it again. This also allows for future reuse incase support
-for other counter IEs gets added.
-
-Co-developed-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Signed-off-by: John Crispin <john@phrozen.org>
-Link: https://lore.kernel.org/r/057c1e67b82bee561ea44ce6a45a8462d3da6995.1625247619.git.lorenzo@kernel.org
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -1710,6 +1710,10 @@ enum ieee80211_offload_flags {
-  *	protected by fq->lock.
-  * @offload_flags: 802.3 -> 802.11 enapsulation offload flags, see
-  *	&enum ieee80211_offload_flags.
-+ * @color_change_active: marks whether a color change is ongoing. Internally it is
-+ *	write-protected by sdata_lock and local->mtx so holding either is fine
-+ *	for read access.
-+ * @color_change_color: the bss color that will be used after the change.
-  */
- struct ieee80211_vif {
- 	enum nl80211_iftype type;
-@@ -1738,6 +1742,9 @@ struct ieee80211_vif {
- 
- 	bool txqs_stopped[IEEE80211_NUM_ACS];
- 
-+	bool color_change_active;
-+	u8 color_change_color;
-+
- 	/* must be last */
- 	u8 drv_priv[] __aligned(sizeof(void *));
- };
-@@ -4982,6 +4989,16 @@ void ieee80211_csa_finish(struct ieee802
- bool ieee80211_beacon_cntdwn_is_complete(struct ieee80211_vif *vif);
- 
- /**
-+ * ieee80211_color_change_finish - notify mac80211 about color change
-+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
-+ *
-+ * After a color change announcement was scheduled and the counter in this
-+ * announcement hits 1, this function must be called by the driver to
-+ * notify mac80211 that the color can be changed
-+ */
-+void ieee80211_color_change_finish(struct ieee80211_vif *vif);
-+
-+/**
-  * ieee80211_proberesp_get - retrieve a Probe Response template
-  * @hw: pointer obtained from ieee80211_alloc_hw().
-  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
-@@ -6726,6 +6743,18 @@ ieee80211_get_unsol_bcast_probe_resp_tmp
- 					  struct ieee80211_vif *vif);
- 
- /**
-+ * ieeee80211_obss_color_collision_notify - notify userland about a BSS color
-+ * collision.
-+ *
-+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
-+ * @color_bitmap: a 64 bit bitmap representing the colors that the local BSS is
-+ *	aware of.
-+ */
-+void
-+ieeee80211_obss_color_collision_notify(struct ieee80211_vif *vif,
-+				       u64 color_bitmap);
-+
-+/**
-  * ieee80211_is_tx_data - check if frame is a data frame
-  *
-  * The function is used to check if a frame is a data frame. Frames with
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -827,9 +827,11 @@ static int ieee80211_set_monitor_channel
- 	return ret;
- }
- 
--static int ieee80211_set_probe_resp(struct ieee80211_sub_if_data *sdata,
--				    const u8 *resp, size_t resp_len,
--				    const struct ieee80211_csa_settings *csa)
-+static int
-+ieee80211_set_probe_resp(struct ieee80211_sub_if_data *sdata,
-+			 const u8 *resp, size_t resp_len,
-+			 const struct ieee80211_csa_settings *csa,
-+			 const struct ieee80211_color_change_settings *cca)
- {
- 	struct probe_resp *new, *old;
- 
-@@ -849,6 +851,8 @@ static int ieee80211_set_probe_resp(stru
- 		memcpy(new->cntdwn_counter_offsets, csa->counter_offsets_presp,
- 		       csa->n_counter_offsets_presp *
- 		       sizeof(new->cntdwn_counter_offsets[0]));
-+	else if (cca)
-+		new->cntdwn_counter_offsets[0] = cca->counter_offset_presp;
- 
- 	rcu_assign_pointer(sdata->u.ap.probe_resp, new);
- 	if (old)
-@@ -954,7 +958,8 @@ static int ieee80211_set_ftm_responder_p
- 
- static int ieee80211_assign_beacon(struct ieee80211_sub_if_data *sdata,
- 				   struct cfg80211_beacon_data *params,
--				   const struct ieee80211_csa_settings *csa)
-+				   const struct ieee80211_csa_settings *csa,
-+				   const struct ieee80211_color_change_settings *cca)
- {
- 	struct beacon_data *new, *old;
- 	int new_head_len, new_tail_len;
-@@ -1003,6 +1008,9 @@ static int ieee80211_assign_beacon(struc
- 		memcpy(new->cntdwn_counter_offsets, csa->counter_offsets_beacon,
- 		       csa->n_counter_offsets_beacon *
- 		       sizeof(new->cntdwn_counter_offsets[0]));
-+	} else if (cca) {
-+		new->cntdwn_current_counter = cca->count;
-+		new->cntdwn_counter_offsets[0] = cca->counter_offset_beacon;
- 	}
- 
- 	/* copy in head */
-@@ -1019,7 +1027,7 @@ static int ieee80211_assign_beacon(struc
- 			memcpy(new->tail, old->tail, new_tail_len);
- 
- 	err = ieee80211_set_probe_resp(sdata, params->probe_resp,
--				       params->probe_resp_len, csa);
-+				       params->probe_resp_len, csa, cca);
- 	if (err < 0) {
- 		kfree(new);
- 		return err;
-@@ -1176,7 +1184,7 @@ static int ieee80211_start_ap(struct wip
- 	if (ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL))
- 		sdata->vif.bss_conf.beacon_tx_rate = params->beacon_rate;
- 
--	err = ieee80211_assign_beacon(sdata, &params->beacon, NULL);
-+	err = ieee80211_assign_beacon(sdata, &params->beacon, NULL, NULL);
- 	if (err < 0)
- 		goto error;
- 	changed |= err;
-@@ -1234,17 +1242,17 @@ static int ieee80211_change_beacon(struc
- 	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
- 	sdata_assert_lock(sdata);
- 
--	/* don't allow changing the beacon while CSA is in place - offset
-+	/* don't allow changing the beacon while a countdown is in place - offset
- 	 * of channel switch counter may change
- 	 */
--	if (sdata->vif.csa_active)
-+	if (sdata->vif.csa_active || sdata->vif.color_change_active)
- 		return -EBUSY;
- 
- 	old = sdata_dereference(sdata->u.ap.beacon, sdata);
- 	if (!old)
- 		return -ENOENT;
- 
--	err = ieee80211_assign_beacon(sdata, params, NULL);
-+	err = ieee80211_assign_beacon(sdata, params, NULL, NULL);
- 	if (err < 0)
- 		return err;
- 	ieee80211_bss_info_change_notify(sdata, err);
-@@ -3174,7 +3182,7 @@ static int ieee80211_set_after_csa_beaco
- 	switch (sdata->vif.type) {
- 	case NL80211_IFTYPE_AP:
- 		err = ieee80211_assign_beacon(sdata, sdata->u.ap.next_beacon,
--					      NULL);
-+					      NULL, NULL);
- 		kfree(sdata->u.ap.next_beacon);
- 		sdata->u.ap.next_beacon = NULL;
- 
-@@ -3340,7 +3348,7 @@ static int ieee80211_set_csa_beacon(stru
- 		csa.n_counter_offsets_presp = params->n_counter_offsets_presp;
- 		csa.count = params->count;
- 
--		err = ieee80211_assign_beacon(sdata, &params->beacon_csa, &csa);
-+		err = ieee80211_assign_beacon(sdata, &params->beacon_csa, &csa, NULL);
- 		if (err < 0) {
- 			kfree(sdata->u.ap.next_beacon);
- 			return err;
-@@ -3428,6 +3436,15 @@ static int ieee80211_set_csa_beacon(stru
- 	return 0;
- }
- 
-+static void ieee80211_color_change_abort(struct ieee80211_sub_if_data  *sdata)
-+{
-+	sdata->vif.color_change_active = false;
-+	kfree(sdata->u.ap.next_beacon);
-+	sdata->u.ap.next_beacon = NULL;
-+
-+	cfg80211_color_change_aborted_notify(sdata->dev);
-+}
-+
- static int
- __ieee80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,
- 			   struct cfg80211_csa_settings *params)
-@@ -3496,6 +3513,10 @@ __ieee80211_channel_switch(struct wiphy
- 		goto out;
- 	}
- 
-+	/* if there is a color change in progress, abort it */
-+	if (sdata->vif.color_change_active)
-+		ieee80211_color_change_abort(sdata);
-+
- 	err = ieee80211_set_csa_beacon(sdata, params, &changed);
- 	if (err) {
- 		ieee80211_vif_unreserve_chanctx(sdata);
-@@ -4147,6 +4168,196 @@ static int ieee80211_set_sar_specs(struc
- 	return local->ops->set_sar_specs(&local->hw, sar);
- }
- 
-+static int
-+ieee80211_set_after_color_change_beacon(struct ieee80211_sub_if_data *sdata,
-+					u32 *changed)
-+{
-+	switch (sdata->vif.type) {
-+	case NL80211_IFTYPE_AP: {
-+		int ret;
-+
-+		ret = ieee80211_assign_beacon(sdata, sdata->u.ap.next_beacon,
-+					      NULL, NULL);
-+		kfree(sdata->u.ap.next_beacon);
-+		sdata->u.ap.next_beacon = NULL;
-+
-+		if (ret < 0)
-+			return ret;
-+
-+		*changed |= ret;
-+		break;
-+	}
-+	default:
-+		WARN_ON_ONCE(1);
-+		return -EINVAL;
-+	}
-+
-+	return 0;
-+}
-+
-+static int
-+ieee80211_set_color_change_beacon(struct ieee80211_sub_if_data *sdata,
-+				  struct cfg80211_color_change_settings *params,
-+				  u32 *changed)
-+{
-+	struct ieee80211_color_change_settings color_change = {};
-+	int err;
-+
-+	switch (sdata->vif.type) {
-+	case NL80211_IFTYPE_AP:
-+		sdata->u.ap.next_beacon =
-+			cfg80211_beacon_dup(&params->beacon_next);
-+		if (!sdata->u.ap.next_beacon)
-+			return -ENOMEM;
-+
-+		if (params->count <= 1)
-+			break;
-+
-+		color_change.counter_offset_beacon =
-+			params->counter_offset_beacon;
-+		color_change.counter_offset_presp =
-+			params->counter_offset_presp;
-+		color_change.count = params->count;
-+
-+		err = ieee80211_assign_beacon(sdata, &params->beacon_color_change,
-+					      NULL, &color_change);
-+		if (err < 0) {
-+			kfree(sdata->u.ap.next_beacon);
-+			return err;
-+		}
-+		*changed |= err;
-+		break;
-+	default:
-+		return -EOPNOTSUPP;
-+	}
-+
-+	return 0;
-+}
-+
-+static void
-+ieee80211_color_change_bss_config_notify(struct ieee80211_sub_if_data *sdata,
-+					 u8 color, int enable, u32 changed)
-+{
-+	sdata->vif.bss_conf.he_bss_color.color = color;
-+	sdata->vif.bss_conf.he_bss_color.enabled = enable;
-+	changed |= BSS_CHANGED_HE_BSS_COLOR;
-+
-+	ieee80211_bss_info_change_notify(sdata, changed);
-+}
-+
-+static int ieee80211_color_change_finalize(struct ieee80211_sub_if_data *sdata)
-+{
-+	struct ieee80211_local *local = sdata->local;
-+	u32 changed = 0;
-+	int err;
-+
-+	sdata_assert_lock(sdata);
-+	lockdep_assert_held(&local->mtx);
-+
-+	sdata->vif.color_change_active = false;
-+
-+	err = ieee80211_set_after_color_change_beacon(sdata, &changed);
-+	if (err) {
-+		cfg80211_color_change_aborted_notify(sdata->dev);
-+		return err;
-+	}
-+
-+	ieee80211_color_change_bss_config_notify(sdata,
-+						 sdata->vif.color_change_color,
-+						 1, changed);
-+	cfg80211_color_change_notify(sdata->dev);
-+
-+	return 0;
-+}
-+
-+void ieee80211_color_change_finalize_work(struct work_struct *work)
-+{
-+	struct ieee80211_sub_if_data *sdata =
-+		container_of(work, struct ieee80211_sub_if_data,
-+			     color_change_finalize_work);
-+	struct ieee80211_local *local = sdata->local;
-+
-+	sdata_lock(sdata);
-+	mutex_lock(&local->mtx);
-+
-+	/* AP might have been stopped while waiting for the lock. */
-+	if (!sdata->vif.color_change_active)
-+		goto unlock;
-+
-+	if (!ieee80211_sdata_running(sdata))
-+		goto unlock;
-+
-+	ieee80211_color_change_finalize(sdata);
-+
-+unlock:
-+	mutex_unlock(&local->mtx);
-+	sdata_unlock(sdata);
-+}
-+
-+void ieee80211_color_change_finish(struct ieee80211_vif *vif)
-+{
-+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-+
-+	ieee80211_queue_work(&sdata->local->hw,
-+			     &sdata->color_change_finalize_work);
-+}
-+EXPORT_SYMBOL_GPL(ieee80211_color_change_finish);
-+
-+void
-+ieeee80211_obss_color_collision_notify(struct ieee80211_vif *vif,
-+				       u64 color_bitmap)
-+{
-+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-+
-+	if (sdata->vif.color_change_active || sdata->vif.csa_active)
-+		return;
-+
-+	cfg80211_obss_color_collision_notify(sdata->dev, color_bitmap);
-+}
-+EXPORT_SYMBOL_GPL(ieeee80211_obss_color_collision_notify);
-+
-+static int
-+ieee80211_color_change(struct wiphy *wiphy, struct net_device *dev,
-+		       struct cfg80211_color_change_settings *params)
-+{
-+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
-+	struct ieee80211_local *local = sdata->local;
-+	u32 changed = 0;
-+	int err;
-+
-+	sdata_assert_lock(sdata);
-+
-+	mutex_lock(&local->mtx);
-+
-+	/* don't allow another color change if one is already active or if csa
-+	 * is active
-+	 */
-+	if (sdata->vif.color_change_active || sdata->vif.csa_active) {
-+		err = -EBUSY;
-+		goto out;
-+	}
-+
-+	err = ieee80211_set_color_change_beacon(sdata, params, &changed);
-+	if (err)
-+		goto out;
-+
-+	sdata->vif.color_change_active = true;
-+	sdata->vif.color_change_color = params->color;
-+
-+	cfg80211_color_change_started_notify(sdata->dev, params->count);
-+
-+	if (changed)
-+		ieee80211_color_change_bss_config_notify(sdata, 0, 0, changed);
-+	else
-+		/* if the beacon didn't change, we can finalize immediately */
-+		ieee80211_color_change_finalize(sdata);
-+
-+out:
-+	mutex_unlock(&local->mtx);
-+
-+	return err;
-+}
-+
- const struct cfg80211_ops mac80211_config_ops = {
- 	.add_virtual_intf = ieee80211_add_iface,
- 	.del_virtual_intf = ieee80211_del_iface,
-@@ -4251,4 +4462,5 @@ const struct cfg80211_ops mac80211_confi
- 	.set_tid_config = ieee80211_set_tid_config,
- 	.reset_tid_config = ieee80211_reset_tid_config,
- 	.set_sar_specs = ieee80211_set_sar_specs,
-+	.color_change = ieee80211_color_change,
- };
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -248,6 +248,12 @@ struct ieee80211_csa_settings {
- 	u8 count;
- };
- 
-+struct ieee80211_color_change_settings {
-+	u16 counter_offset_beacon;
-+	u16 counter_offset_presp;
-+	u8 count;
-+};
-+
- struct beacon_data {
- 	u8 *head, *tail;
- 	int head_len, tail_len;
-@@ -932,6 +938,8 @@ struct ieee80211_sub_if_data {
- 	bool csa_block_tx; /* write-protected by sdata_lock and local->mtx */
- 	struct cfg80211_chan_def csa_chandef;
- 
-+	struct work_struct color_change_finalize_work;
-+
- 	struct list_head assigned_chanctx_list; /* protected by chanctx_mtx */
- 	struct list_head reserved_chanctx_list; /* protected by chanctx_mtx */
- 
-@@ -1905,6 +1913,9 @@ void ieee80211_csa_finalize_work(struct
- int ieee80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,
- 			     struct cfg80211_csa_settings *params);
- 
-+/* color change handling */
-+void ieee80211_color_change_finalize_work(struct work_struct *work);
-+
- /* interface handling */
- #define MAC80211_SUPPORTED_FEATURES_TX	(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | \
- 					 NETIF_F_HW_CSUM | NETIF_F_SG | \
---- a/net/mac80211/iface.c
-+++ b/net/mac80211/iface.c
-@@ -465,6 +465,7 @@ static void ieee80211_do_stop(struct iee
- 	sdata_unlock(sdata);
- 
- 	cancel_work_sync(&sdata->csa_finalize_work);
-+	cancel_work_sync(&sdata->color_change_finalize_work);
- 
- 	cancel_delayed_work_sync(&sdata->dfs_cac_timer_work);
- 
-@@ -1639,6 +1640,7 @@ static void ieee80211_setup_sdata(struct
- 	INIT_WORK(&sdata->work, ieee80211_iface_work);
- 	INIT_WORK(&sdata->recalc_smps, ieee80211_recalc_smps_work);
- 	INIT_WORK(&sdata->csa_finalize_work, ieee80211_csa_finalize_work);
-+	INIT_WORK(&sdata->color_change_finalize_work, ieee80211_color_change_finalize_work);
- 	INIT_LIST_HEAD(&sdata->assigned_chanctx_list);
- 	INIT_LIST_HEAD(&sdata->reserved_chanctx_list);
- 
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -4802,11 +4802,11 @@ static int ieee80211_beacon_add_tim(stru
- static void ieee80211_set_beacon_cntdwn(struct ieee80211_sub_if_data *sdata,
- 					struct beacon_data *beacon)
- {
-+	u8 *beacon_data, count, max_count = 1;
- 	struct probe_resp *resp;
--	u8 *beacon_data;
- 	size_t beacon_data_len;
-+	u16 *bcn_offsets;
- 	int i;
--	u8 count = beacon->cntdwn_current_counter;
- 
- 	switch (sdata->vif.type) {
- 	case NL80211_IFTYPE_AP:
-@@ -4826,21 +4826,27 @@ static void ieee80211_set_beacon_cntdwn(
- 	}
- 
- 	rcu_read_lock();
--	for (i = 0; i < IEEE80211_MAX_CNTDWN_COUNTERS_NUM; ++i) {
--		resp = rcu_dereference(sdata->u.ap.probe_resp);
-+	resp = rcu_dereference(sdata->u.ap.probe_resp);
- 
--		if (beacon->cntdwn_counter_offsets[i]) {
--			if (WARN_ON_ONCE(beacon->cntdwn_counter_offsets[i] >=
--					 beacon_data_len)) {
-+	bcn_offsets = beacon->cntdwn_counter_offsets;
-+	count = beacon->cntdwn_current_counter;
-+	if (sdata->vif.csa_active)
-+		max_count = IEEE80211_MAX_CNTDWN_COUNTERS_NUM;
-+
-+	for (i = 0; i < max_count; ++i) {
-+		if (bcn_offsets[i]) {
-+			if (WARN_ON_ONCE(bcn_offsets[i] >= beacon_data_len)) {
- 				rcu_read_unlock();
- 				return;
- 			}
--
--			beacon_data[beacon->cntdwn_counter_offsets[i]] = count;
-+			beacon_data[bcn_offsets[i]] = count;
- 		}
- 
--		if (sdata->vif.type == NL80211_IFTYPE_AP && resp)
--			resp->data[resp->cntdwn_counter_offsets[i]] = count;
-+		if (sdata->vif.type == NL80211_IFTYPE_AP && resp) {
-+			u16 *resp_offsets = resp->cntdwn_counter_offsets;
-+
-+			resp->data[resp_offsets[i]] = count;
-+		}
- 	}
- 	rcu_read_unlock();
- }
-@@ -5050,6 +5056,7 @@ __ieee80211_beacon_get(struct ieee80211_
- 			if (offs) {
- 				offs->tim_offset = beacon->head_len;
- 				offs->tim_length = skb->len - beacon->head_len;
-+				offs->cntdwn_counter_offs[0] = beacon->cntdwn_counter_offsets[0];
- 
- 				/* for AP the csa offsets are from tail */
- 				csa_off_base = skb->len;
diff --git a/package/kernel/mac80211/patches/subsys/389-ieee80211-add-TWT-element-definitions.patch b/package/kernel/mac80211/patches/subsys/389-ieee80211-add-TWT-element-definitions.patch
deleted file mode 100644
index 369619938e..0000000000
--- a/package/kernel/mac80211/patches/subsys/389-ieee80211-add-TWT-element-definitions.patch
+++ /dev/null
@@ -1,112 +0,0 @@
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Mon, 23 Aug 2021 20:02:38 +0200
-Subject: [PATCH] ieee80211: add TWT element definitions
-
-Introduce TWT definitions and TWT Information element structure
-in ieee80211.h
-
-Tested-by: Peter Chiu <chui-hao.chiu@mediatek.com>
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Link: https://lore.kernel.org/r/71d8b581fe4b5abc5b92f8d77ac2de3e2f7591b6.1629741512.git.lorenzo@kernel.org
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/linux/ieee80211.h
-+++ b/include/linux/ieee80211.h
-@@ -1088,6 +1088,48 @@ struct ieee80211_ext {
- 	} u;
- } __packed __aligned(2);
- 
-+#define IEEE80211_TWT_CONTROL_NDP			BIT(0)
-+#define IEEE80211_TWT_CONTROL_RESP_MODE			BIT(1)
-+#define IEEE80211_TWT_CONTROL_NEG_TYPE_BROADCAST	BIT(3)
-+#define IEEE80211_TWT_CONTROL_RX_DISABLED		BIT(4)
-+#define IEEE80211_TWT_CONTROL_WAKE_DUR_UNIT		BIT(5)
-+
-+#define IEEE80211_TWT_REQTYPE_REQUEST			BIT(0)
-+#define IEEE80211_TWT_REQTYPE_SETUP_CMD			GENMASK(3, 1)
-+#define IEEE80211_TWT_REQTYPE_TRIGGER			BIT(4)
-+#define IEEE80211_TWT_REQTYPE_IMPLICIT			BIT(5)
-+#define IEEE80211_TWT_REQTYPE_FLOWTYPE			BIT(6)
-+#define IEEE80211_TWT_REQTYPE_FLOWID			GENMASK(9, 7)
-+#define IEEE80211_TWT_REQTYPE_WAKE_INT_EXP		GENMASK(14, 10)
-+#define IEEE80211_TWT_REQTYPE_PROTECTION		BIT(15)
-+
-+enum ieee80211_twt_setup_cmd {
-+	TWT_SETUP_CMD_REQUEST,
-+	TWT_SETUP_CMD_SUGGEST,
-+	TWT_SETUP_CMD_DEMAND,
-+	TWT_SETUP_CMD_GROUPING,
-+	TWT_SETUP_CMD_ACCEPT,
-+	TWT_SETUP_CMD_ALTERNATE,
-+	TWT_SETUP_CMD_DICTATE,
-+	TWT_SETUP_CMD_REJECT,
-+};
-+
-+struct ieee80211_twt_params {
-+	__le16 req_type;
-+	__le64 twt;
-+	u8 min_twt_dur;
-+	__le16 mantissa;
-+	u8 channel;
-+} __packed;
-+
-+struct ieee80211_twt_setup {
-+	u8 dialog_token;
-+	u8 element_id;
-+	u8 length;
-+	u8 control;
-+	u8 params[];
-+} __packed;
-+
- struct ieee80211_mgmt {
- 	__le16 frame_control;
- 	__le16 duration;
-@@ -1252,6 +1294,10 @@ struct ieee80211_mgmt {
- 					__le16 toa_error;
- 					u8 variable[0];
- 				} __packed ftm;
-+				struct {
-+					u8 action_code;
-+					u8 variable[];
-+				} __packed s1g;
- 			} u;
- 		} __packed action;
- 	} u;
-@@ -2880,6 +2926,7 @@ enum ieee80211_eid {
- 	WLAN_EID_AID_RESPONSE = 211,
- 	WLAN_EID_S1G_BCN_COMPAT = 213,
- 	WLAN_EID_S1G_SHORT_BCN_INTERVAL = 214,
-+	WLAN_EID_S1G_TWT = 216,
- 	WLAN_EID_S1G_CAPABILITIES = 217,
- 	WLAN_EID_VENDOR_SPECIFIC = 221,
- 	WLAN_EID_QOS_PARAMETER = 222,
-@@ -2948,6 +2995,7 @@ enum ieee80211_category {
- 	WLAN_CATEGORY_FST = 18,
- 	WLAN_CATEGORY_UNPROT_DMG = 20,
- 	WLAN_CATEGORY_VHT = 21,
-+	WLAN_CATEGORY_S1G = 22,
- 	WLAN_CATEGORY_VENDOR_SPECIFIC_PROTECTED = 126,
- 	WLAN_CATEGORY_VENDOR_SPECIFIC = 127,
- };
-@@ -3021,6 +3069,20 @@ enum ieee80211_key_len {
- 	WLAN_KEY_LEN_BIP_GMAC_256 = 32,
- };
- 
-+enum ieee80211_s1g_actioncode {
-+	WLAN_S1G_AID_SWITCH_REQUEST,
-+	WLAN_S1G_AID_SWITCH_RESPONSE,
-+	WLAN_S1G_SYNC_CONTROL,
-+	WLAN_S1G_STA_INFO_ANNOUNCE,
-+	WLAN_S1G_EDCA_PARAM_SET,
-+	WLAN_S1G_EL_OPERATION,
-+	WLAN_S1G_TWT_SETUP,
-+	WLAN_S1G_TWT_TEARDOWN,
-+	WLAN_S1G_SECT_GROUP_ID_LIST,
-+	WLAN_S1G_SECT_ID_FEEDBACK,
-+	WLAN_S1G_TWT_INFORMATION = 11,
-+};
-+
- #define IEEE80211_WEP_IV_LEN		4
- #define IEEE80211_WEP_ICV_LEN		4
- #define IEEE80211_CCMP_HDR_LEN		8
diff --git a/package/kernel/mac80211/patches/subsys/390-mac80211-introduce-individual-TWT-support-in-AP-mode.patch b/package/kernel/mac80211/patches/subsys/390-mac80211-introduce-individual-TWT-support-in-AP-mode.patch
deleted file mode 100644
index 973d665002..0000000000
--- a/package/kernel/mac80211/patches/subsys/390-mac80211-introduce-individual-TWT-support-in-AP-mode.patch
+++ /dev/null
@@ -1,576 +0,0 @@
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Mon, 23 Aug 2021 20:02:39 +0200
-Subject: [PATCH] mac80211: introduce individual TWT support in AP mode
-
-Introduce TWT action frames parsing support to mac80211.
-Currently just individual TWT agreement are support in AP mode.
-Whenever the AP receives a TWT action frame from an associated client,
-after performing sanity checks, it will notify the underlay driver with
-requested parameters in order to check if they are supported and if there
-is enough room for a new agreement. The driver is expected to set the
-agreement result and report it to mac80211.
-
-Drivers supporting this have two new callbacks:
- - add_twt_setup (mandatory)
- - twt_teardown_request (optional)
-
-mac80211 will send an action frame reply according to the result
-reported by the driver.
-
-Tested-by: Peter Chiu <chui-hao.chiu@mediatek.com>
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Link: https://lore.kernel.org/r/257512f2e22ba42b9f2624942a128dd8f141de4b.1629741512.git.lorenzo@kernel.org
-[use le16p_replace_bits(), minor cleanups, use (void *) casts,
- fix to use ieee80211_get_he_iftype_cap() correctly]
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -4219,6 +4219,11 @@ struct ieee80211_ops {
- 	void (*sta_set_decap_offload)(struct ieee80211_hw *hw,
- 				      struct ieee80211_vif *vif,
- 				      struct ieee80211_sta *sta, bool enabled);
-+	void (*add_twt_setup)(struct ieee80211_hw *hw,
-+			      struct ieee80211_sta *sta,
-+			      struct ieee80211_twt_setup *twt);
-+	void (*twt_teardown_request)(struct ieee80211_hw *hw,
-+				     struct ieee80211_sta *sta, u8 flowid);
- };
- 
- /**
---- a/net/mac80211/driver-ops.h
-+++ b/net/mac80211/driver-ops.h
-@@ -1432,4 +1432,40 @@ static inline void drv_sta_set_decap_off
- 	trace_drv_return_void(local);
- }
- 
-+static inline void drv_add_twt_setup(struct ieee80211_local *local,
-+				     struct ieee80211_sub_if_data *sdata,
-+				     struct ieee80211_sta *sta,
-+				     struct ieee80211_twt_setup *twt)
-+{
-+	struct ieee80211_twt_params *twt_agrt;
-+
-+	might_sleep();
-+
-+	if (!check_sdata_in_driver(sdata))
-+		return;
-+
-+	twt_agrt = (void *)twt->params;
-+
-+	trace_drv_add_twt_setup(local, sta, twt, twt_agrt);
-+	local->ops->add_twt_setup(&local->hw, sta, twt);
-+	trace_drv_return_void(local);
-+}
-+
-+static inline void drv_twt_teardown_request(struct ieee80211_local *local,
-+					    struct ieee80211_sub_if_data *sdata,
-+					    struct ieee80211_sta *sta,
-+					    u8 flowid)
-+{
-+	might_sleep();
-+	if (!check_sdata_in_driver(sdata))
-+		return;
-+
-+	if (!local->ops->twt_teardown_request)
-+		return;
-+
-+	trace_drv_twt_teardown_request(local, sta, flowid);
-+	local->ops->twt_teardown_request(&local->hw, sta, flowid);
-+	trace_drv_return_void(local);
-+}
-+
- #endif /* __MAC80211_DRIVER_OPS */
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -954,6 +954,7 @@ struct ieee80211_sub_if_data {
- 
- 	struct work_struct work;
- 	struct sk_buff_head skb_queue;
-+	struct sk_buff_head status_queue;
- 
- 	u8 needed_rx_chains;
- 	enum ieee80211_smps_mode smps_mode;
-@@ -2098,6 +2099,11 @@ ieee80211_he_op_ie_to_bss_conf(struct ie
- 
- /* S1G */
- void ieee80211_s1g_sta_rate_init(struct sta_info *sta);
-+bool ieee80211_s1g_is_twt_setup(struct sk_buff *skb);
-+void ieee80211_s1g_rx_twt_action(struct ieee80211_sub_if_data *sdata,
-+				 struct sk_buff *skb);
-+void ieee80211_s1g_status_twt_action(struct ieee80211_sub_if_data *sdata,
-+				     struct sk_buff *skb);
- 
- /* Spectrum management */
- void ieee80211_process_measurement_req(struct ieee80211_sub_if_data *sdata,
---- a/net/mac80211/iface.c
-+++ b/net/mac80211/iface.c
-@@ -563,6 +563,7 @@ static void ieee80211_do_stop(struct iee
- 		 */
- 		ieee80211_free_keys(sdata, true);
- 		skb_queue_purge(&sdata->skb_queue);
-+		skb_queue_purge(&sdata->status_queue);
- 	}
- 
- 	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-@@ -1070,6 +1071,7 @@ int ieee80211_add_virtual_monitor(struct
- 	}
- 
- 	skb_queue_head_init(&sdata->skb_queue);
-+	skb_queue_head_init(&sdata->status_queue);
- 	INIT_WORK(&sdata->work, ieee80211_iface_work);
- 
- 	return 0;
-@@ -1442,6 +1444,24 @@ static void ieee80211_if_setup_no_queue(
- #endif
- }
- 
-+static void ieee80211_iface_process_status(struct ieee80211_sub_if_data *sdata,
-+					   struct sk_buff *skb)
-+{
-+	struct ieee80211_mgmt *mgmt = (void *)skb->data;
-+
-+	if (ieee80211_is_action(mgmt->frame_control) &&
-+	    mgmt->u.action.category == WLAN_CATEGORY_S1G) {
-+		switch (mgmt->u.action.u.s1g.action_code) {
-+		case WLAN_S1G_TWT_TEARDOWN:
-+		case WLAN_S1G_TWT_SETUP:
-+			ieee80211_s1g_status_twt_action(sdata, skb);
-+			break;
-+		default:
-+			break;
-+		}
-+	}
-+}
-+
- static void ieee80211_iface_work(struct work_struct *work)
- {
- 	struct ieee80211_sub_if_data *sdata =
-@@ -1519,6 +1539,16 @@ static void ieee80211_iface_work(struct
- 				WARN_ON(1);
- 				break;
- 			}
-+		} else if (ieee80211_is_action(mgmt->frame_control) &&
-+			   mgmt->u.action.category == WLAN_CATEGORY_S1G) {
-+			switch (mgmt->u.action.u.s1g.action_code) {
-+			case WLAN_S1G_TWT_TEARDOWN:
-+			case WLAN_S1G_TWT_SETUP:
-+				ieee80211_s1g_rx_twt_action(sdata, skb);
-+				break;
-+			default:
-+				break;
-+			}
- 		} else if (ieee80211_is_ext(mgmt->frame_control)) {
- 			if (sdata->vif.type == NL80211_IFTYPE_STATION)
- 				ieee80211_sta_rx_queued_ext(sdata, skb);
-@@ -1574,6 +1604,12 @@ static void ieee80211_iface_work(struct
- 		kfree_skb(skb);
- 	}
- 
-+	/* process status queue */
-+	while ((skb = skb_dequeue(&sdata->status_queue))) {
-+		ieee80211_iface_process_status(sdata, skb);
-+		kfree_skb(skb);
-+	}
-+
- 	/* then other type-dependent work */
- 	switch (sdata->vif.type) {
- 	case NL80211_IFTYPE_STATION:
-@@ -1637,6 +1673,7 @@ static void ieee80211_setup_sdata(struct
- 	}
- 
- 	skb_queue_head_init(&sdata->skb_queue);
-+	skb_queue_head_init(&sdata->status_queue);
- 	INIT_WORK(&sdata->work, ieee80211_iface_work);
- 	INIT_WORK(&sdata->recalc_smps, ieee80211_recalc_smps_work);
- 	INIT_WORK(&sdata->csa_finalize_work, ieee80211_csa_finalize_work);
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -3211,6 +3211,68 @@ ieee80211_rx_h_mgmt_check(struct ieee802
- 	return RX_CONTINUE;
- }
- 
-+static bool
-+ieee80211_process_rx_twt_action(struct ieee80211_rx_data *rx)
-+{
-+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)rx->skb->data;
-+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
-+	struct ieee80211_sub_if_data *sdata = rx->sdata;
-+	const struct ieee80211_sta_he_cap *hecap;
-+	struct ieee80211_supported_band *sband;
-+
-+	/* TWT actions are only supported in AP for the moment */
-+	if (sdata->vif.type != NL80211_IFTYPE_AP)
-+		return false;
-+
-+	if (!rx->local->ops->add_twt_setup)
-+		return false;
-+
-+	sband = rx->local->hw.wiphy->bands[status->band];
-+	hecap = ieee80211_get_he_iftype_cap(sband,
-+					    ieee80211_vif_type_p2p(&sdata->vif));
-+	if (!hecap)
-+		return false;
-+
-+	if (!(hecap->he_cap_elem.mac_cap_info[0] &
-+	      IEEE80211_HE_MAC_CAP0_TWT_RES))
-+		return false;
-+
-+	if (!rx->sta)
-+		return false;
-+
-+	switch (mgmt->u.action.u.s1g.action_code) {
-+	case WLAN_S1G_TWT_SETUP: {
-+		struct ieee80211_twt_setup *twt;
-+
-+		if (rx->skb->len < IEEE80211_MIN_ACTION_SIZE +
-+				   1 + /* action code */
-+				   sizeof(struct ieee80211_twt_setup) +
-+				   2 /* TWT req_type agrt */)
-+			break;
-+
-+		twt = (void *)mgmt->u.action.u.s1g.variable;
-+		if (twt->element_id != WLAN_EID_S1G_TWT)
-+			break;
-+
-+		if (rx->skb->len < IEEE80211_MIN_ACTION_SIZE +
-+				   4 + /* action code + token + tlv */
-+				   twt->length)
-+			break;
-+
-+		return true; /* queue the frame */
-+	}
-+	case WLAN_S1G_TWT_TEARDOWN:
-+		if (rx->skb->len < IEEE80211_MIN_ACTION_SIZE + 2)
-+			break;
-+
-+		return true; /* queue the frame */
-+	default:
-+		break;
-+	}
-+
-+	return false;
-+}
-+
- static ieee80211_rx_result debug_noinline
- ieee80211_rx_h_action(struct ieee80211_rx_data *rx)
- {
-@@ -3490,6 +3552,17 @@ ieee80211_rx_h_action(struct ieee80211_r
- 		    !mesh_path_sel_is_hwmp(sdata))
- 			break;
- 		goto queue;
-+	case WLAN_CATEGORY_S1G:
-+		switch (mgmt->u.action.u.s1g.action_code) {
-+		case WLAN_S1G_TWT_SETUP:
-+		case WLAN_S1G_TWT_TEARDOWN:
-+			if (ieee80211_process_rx_twt_action(rx))
-+				goto queue;
-+			break;
-+		default:
-+			break;
-+		}
-+		break;
- 	}
- 
- 	return RX_CONTINUE;
---- a/net/mac80211/s1g.c
-+++ b/net/mac80211/s1g.c
-@@ -6,6 +6,7 @@
- #include <linux/ieee80211.h>
- #include <net/mac80211.h>
- #include "ieee80211_i.h"
-+#include "driver-ops.h"
- 
- void ieee80211_s1g_sta_rate_init(struct sta_info *sta)
- {
-@@ -14,3 +15,182 @@ void ieee80211_s1g_sta_rate_init(struct
- 	sta->rx_stats.last_rate =
- 			STA_STATS_FIELD(TYPE, STA_STATS_RATE_TYPE_S1G);
- }
-+
-+bool ieee80211_s1g_is_twt_setup(struct sk_buff *skb)
-+{
-+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
-+
-+	if (likely(!ieee80211_is_action(mgmt->frame_control)))
-+		return false;
-+
-+	if (likely(mgmt->u.action.category != WLAN_CATEGORY_S1G))
-+		return false;
-+
-+	return mgmt->u.action.u.s1g.action_code == WLAN_S1G_TWT_SETUP;
-+}
-+
-+static void
-+ieee80211_s1g_send_twt_setup(struct ieee80211_sub_if_data *sdata, const u8 *da,
-+			     const u8 *bssid, struct ieee80211_twt_setup *twt)
-+{
-+	int len = IEEE80211_MIN_ACTION_SIZE + 4 + twt->length;
-+	struct ieee80211_local *local = sdata->local;
-+	struct ieee80211_mgmt *mgmt;
-+	struct sk_buff *skb;
-+
-+	skb = dev_alloc_skb(local->hw.extra_tx_headroom + len);
-+	if (!skb)
-+		return;
-+
-+	skb_reserve(skb, local->hw.extra_tx_headroom);
-+	mgmt = skb_put_zero(skb, len);
-+	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
-+					  IEEE80211_STYPE_ACTION);
-+	memcpy(mgmt->da, da, ETH_ALEN);
-+	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
-+	memcpy(mgmt->bssid, bssid, ETH_ALEN);
-+
-+	mgmt->u.action.category = WLAN_CATEGORY_S1G;
-+	mgmt->u.action.u.s1g.action_code = WLAN_S1G_TWT_SETUP;
-+	memcpy(mgmt->u.action.u.s1g.variable, twt, 3 + twt->length);
-+
-+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |
-+					IEEE80211_TX_INTFL_MLME_CONN_TX |
-+					IEEE80211_TX_CTL_REQ_TX_STATUS;
-+	ieee80211_tx_skb(sdata, skb);
-+}
-+
-+static void
-+ieee80211_s1g_send_twt_teardown(struct ieee80211_sub_if_data *sdata,
-+				const u8 *da, const u8 *bssid, u8 flowid)
-+{
-+	struct ieee80211_local *local = sdata->local;
-+	struct ieee80211_mgmt *mgmt;
-+	struct sk_buff *skb;
-+	u8 *id;
-+
-+	skb = dev_alloc_skb(local->hw.extra_tx_headroom +
-+			    IEEE80211_MIN_ACTION_SIZE + 2);
-+	if (!skb)
-+		return;
-+
-+	skb_reserve(skb, local->hw.extra_tx_headroom);
-+	mgmt = skb_put_zero(skb, IEEE80211_MIN_ACTION_SIZE + 2);
-+	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
-+					  IEEE80211_STYPE_ACTION);
-+	memcpy(mgmt->da, da, ETH_ALEN);
-+	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
-+	memcpy(mgmt->bssid, bssid, ETH_ALEN);
-+
-+	mgmt->u.action.category = WLAN_CATEGORY_S1G;
-+	mgmt->u.action.u.s1g.action_code = WLAN_S1G_TWT_TEARDOWN;
-+	id = (u8 *)mgmt->u.action.u.s1g.variable;
-+	*id = flowid;
-+
-+	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |
-+					IEEE80211_TX_CTL_REQ_TX_STATUS;
-+	ieee80211_tx_skb(sdata, skb);
-+}
-+
-+static void
-+ieee80211_s1g_rx_twt_setup(struct ieee80211_sub_if_data *sdata,
-+			   struct sta_info *sta, struct sk_buff *skb)
-+{
-+	struct ieee80211_mgmt *mgmt = (void *)skb->data;
-+	struct ieee80211_twt_setup *twt = (void *)mgmt->u.action.u.s1g.variable;
-+	struct ieee80211_twt_params *twt_agrt = (void *)twt->params;
-+
-+	twt_agrt->req_type &= cpu_to_le16(~IEEE80211_TWT_REQTYPE_REQUEST);
-+
-+	/* broadcast TWT not supported yet */
-+	if (twt->control & IEEE80211_TWT_CONTROL_NEG_TYPE_BROADCAST) {
-+		le16p_replace_bits(&twt_agrt->req_type,
-+				   TWT_SETUP_CMD_REJECT,
-+				   IEEE80211_TWT_REQTYPE_SETUP_CMD);
-+		goto out;
-+	}
-+
-+	drv_add_twt_setup(sdata->local, sdata, &sta->sta, twt);
-+out:
-+	ieee80211_s1g_send_twt_setup(sdata, mgmt->sa, sdata->vif.addr, twt);
-+}
-+
-+static void
-+ieee80211_s1g_rx_twt_teardown(struct ieee80211_sub_if_data *sdata,
-+			      struct sta_info *sta, struct sk_buff *skb)
-+{
-+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
-+
-+	drv_twt_teardown_request(sdata->local, sdata, &sta->sta,
-+				 mgmt->u.action.u.s1g.variable[0]);
-+}
-+
-+static void
-+ieee80211_s1g_tx_twt_setup_fail(struct ieee80211_sub_if_data *sdata,
-+				struct sta_info *sta, struct sk_buff *skb)
-+{
-+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
-+	struct ieee80211_twt_setup *twt = (void *)mgmt->u.action.u.s1g.variable;
-+	struct ieee80211_twt_params *twt_agrt = (void *)twt->params;
-+	u8 flowid = le16_get_bits(twt_agrt->req_type,
-+				  IEEE80211_TWT_REQTYPE_FLOWID);
-+
-+	drv_twt_teardown_request(sdata->local, sdata, &sta->sta, flowid);
-+
-+	ieee80211_s1g_send_twt_teardown(sdata, mgmt->sa, sdata->vif.addr,
-+					flowid);
-+}
-+
-+void ieee80211_s1g_rx_twt_action(struct ieee80211_sub_if_data *sdata,
-+				 struct sk_buff *skb)
-+{
-+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
-+	struct ieee80211_local *local = sdata->local;
-+	struct sta_info *sta;
-+
-+	mutex_lock(&local->sta_mtx);
-+
-+	sta = sta_info_get_bss(sdata, mgmt->sa);
-+	if (!sta)
-+		goto out;
-+
-+	switch (mgmt->u.action.u.s1g.action_code) {
-+	case WLAN_S1G_TWT_SETUP:
-+		ieee80211_s1g_rx_twt_setup(sdata, sta, skb);
-+		break;
-+	case WLAN_S1G_TWT_TEARDOWN:
-+		ieee80211_s1g_rx_twt_teardown(sdata, sta, skb);
-+		break;
-+	default:
-+		break;
-+	}
-+
-+out:
-+	mutex_unlock(&local->sta_mtx);
-+}
-+
-+void ieee80211_s1g_status_twt_action(struct ieee80211_sub_if_data *sdata,
-+				     struct sk_buff *skb)
-+{
-+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
-+	struct ieee80211_local *local = sdata->local;
-+	struct sta_info *sta;
-+
-+	mutex_lock(&local->sta_mtx);
-+
-+	sta = sta_info_get_bss(sdata, mgmt->da);
-+	if (!sta)
-+		goto out;
-+
-+	switch (mgmt->u.action.u.s1g.action_code) {
-+	case WLAN_S1G_TWT_SETUP:
-+		/* process failed twt setup frames */
-+		ieee80211_s1g_tx_twt_setup_fail(sdata, sta, skb);
-+		break;
-+	default:
-+		break;
-+	}
-+
-+out:
-+	mutex_unlock(&local->sta_mtx);
-+}
---- a/net/mac80211/status.c
-+++ b/net/mac80211/status.c
-@@ -705,13 +705,26 @@ static void ieee80211_report_used_skb(st
- 			/* Check to see if packet is a TDLS teardown packet */
- 			if (ieee80211_is_data(hdr->frame_control) &&
- 			    (ieee80211_get_tdls_action(skb, hdr_size) ==
--			     WLAN_TDLS_TEARDOWN))
-+			     WLAN_TDLS_TEARDOWN)) {
- 				ieee80211_tdls_td_tx_handle(local, sdata, skb,
- 							    info->flags);
--			else
-+			} else if (ieee80211_s1g_is_twt_setup(skb)) {
-+				if (!acked) {
-+					struct sk_buff *qskb;
-+
-+					qskb = skb_clone(skb, GFP_ATOMIC);
-+					if (qskb) {
-+						skb_queue_tail(&sdata->status_queue,
-+							       qskb);
-+						ieee80211_queue_work(&local->hw,
-+								     &sdata->work);
-+					}
-+				}
-+			} else {
- 				ieee80211_mgd_conn_tx_status(sdata,
- 							     hdr->frame_control,
- 							     acked);
-+			}
- 		}
- 
- 		rcu_read_unlock();
---- a/net/mac80211/trace.h
-+++ b/net/mac80211/trace.h
-@@ -2804,6 +2804,73 @@ DEFINE_EVENT(sta_flag_evt, drv_sta_set_d
- 	TP_ARGS(local, sdata, sta, enabled)
- );
- 
-+TRACE_EVENT(drv_add_twt_setup,
-+	TP_PROTO(struct ieee80211_local *local,
-+		 struct ieee80211_sta *sta,
-+		 struct ieee80211_twt_setup *twt,
-+		 struct ieee80211_twt_params *twt_agrt),
-+
-+	TP_ARGS(local, sta, twt, twt_agrt),
-+
-+	TP_STRUCT__entry(
-+		LOCAL_ENTRY
-+		STA_ENTRY
-+		__field(u8, dialog_token)
-+		__field(u8, control)
-+		__field(__le16, req_type)
-+		__field(__le64, twt)
-+		__field(u8, duration)
-+		__field(__le16, mantissa)
-+		__field(u8, channel)
-+	),
-+
-+	TP_fast_assign(
-+		LOCAL_ASSIGN;
-+		STA_ASSIGN;
-+		__entry->dialog_token = twt->dialog_token;
-+		__entry->control = twt->control;
-+		__entry->req_type = twt_agrt->req_type;
-+		__entry->twt = twt_agrt->twt;
-+		__entry->duration = twt_agrt->min_twt_dur;
-+		__entry->mantissa = twt_agrt->mantissa;
-+		__entry->channel = twt_agrt->channel;
-+	),
-+
-+	TP_printk(
-+		LOCAL_PR_FMT STA_PR_FMT
-+		" token:%d control:0x%02x req_type:0x%04x"
-+		" twt:%llu duration:%d mantissa:%d channel:%d",
-+		LOCAL_PR_ARG, STA_PR_ARG, __entry->dialog_token,
-+		__entry->control, le16_to_cpu(__entry->req_type),
-+		le64_to_cpu(__entry->twt), __entry->duration,
-+		le16_to_cpu(__entry->mantissa), __entry->channel
-+	)
-+);
-+
-+TRACE_EVENT(drv_twt_teardown_request,
-+	TP_PROTO(struct ieee80211_local *local,
-+		 struct ieee80211_sta *sta, u8 flowid),
-+
-+	TP_ARGS(local, sta, flowid),
-+
-+	TP_STRUCT__entry(
-+		LOCAL_ENTRY
-+		STA_ENTRY
-+		__field(u8, flowid)
-+	),
-+
-+	TP_fast_assign(
-+		LOCAL_ASSIGN;
-+		STA_ASSIGN;
-+		__entry->flowid = flowid;
-+	),
-+
-+	TP_printk(
-+		LOCAL_PR_FMT STA_PR_FMT " flowid:%d",
-+		LOCAL_PR_ARG, STA_PR_ARG, __entry->flowid
-+	)
-+);
-+
- #endif /* !__MAC80211_DRIVER_TRACE || TRACE_HEADER_MULTI_READ */
- 
- #undef TRACE_INCLUDE_PATH
diff --git a/package/kernel/mac80211/patches/subsys/391-wireless-align-some-HE-capabilities-with-the-spec.patch b/package/kernel/mac80211/patches/subsys/391-wireless-align-some-HE-capabilities-with-the-spec.patch
deleted file mode 100644
index 031669b961..0000000000
--- a/package/kernel/mac80211/patches/subsys/391-wireless-align-some-HE-capabilities-with-the-spec.patch
+++ /dev/null
@@ -1,196 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Fri, 9 Apr 2021 12:40:17 +0300
-Subject: [PATCH] wireless: align some HE capabilities with the spec
-
-Some names were changed, align that with the spec as of
-802.11ax-D6.1.
-
-Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
-Link: https://lore.kernel.org/r/iwlwifi.20210409123755.b1e5fbab0d8c.I3eb6076cb0714ec6aec6b8f9dee613ce4a05d825@changeid
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -3633,7 +3633,7 @@ ath11k_mac_filter_he_cap_mesh(struct iee
- 	    IEEE80211_HE_MAC_CAP4_BQR;
- 	he_cap_elem->mac_cap_info[4] &= ~m;
- 
--	m = IEEE80211_HE_MAC_CAP5_SUBCHAN_SELECVITE_TRANSMISSION |
-+	m = IEEE80211_HE_MAC_CAP5_SUBCHAN_SELECTIVE_TRANSMISSION |
- 	    IEEE80211_HE_MAC_CAP5_UL_2x996_TONE_RU |
- 	    IEEE80211_HE_MAC_CAP5_PUNCTURED_SOUNDING |
- 	    IEEE80211_HE_MAC_CAP5_HT_VHT_TRIG_FRAME_RX;
-@@ -3643,7 +3643,7 @@ ath11k_mac_filter_he_cap_mesh(struct iee
- 	    IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO;
- 	he_cap_elem->phy_cap_info[2] &= ~m;
- 
--	m = IEEE80211_HE_PHY_CAP3_RX_HE_MU_PPDU_FROM_NON_AP_STA |
-+	m = IEEE80211_HE_PHY_CAP3_RX_PARTIAL_BW_SU_IN_20MHZ_MU |
- 	    IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_MASK |
- 	    IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_MASK;
- 	he_cap_elem->phy_cap_info[3] &= ~m;
-@@ -3655,13 +3655,13 @@ ath11k_mac_filter_he_cap_mesh(struct iee
- 	he_cap_elem->phy_cap_info[5] &= ~m;
- 
- 	m = IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_75_MU |
--	    IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMER_FB |
-+	    IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB |
- 	    IEEE80211_HE_PHY_CAP6_TRIG_CQI_FB |
- 	    IEEE80211_HE_PHY_CAP6_PARTIAL_BANDWIDTH_DL_MUMIMO;
- 	he_cap_elem->phy_cap_info[6] &= ~m;
- 
--	m = IEEE80211_HE_PHY_CAP7_SRP_BASED_SR |
--	    IEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_AR |
-+	m = IEEE80211_HE_PHY_CAP7_PSR_BASED_SR |
-+	    IEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_SUPP |
- 	    IEEE80211_HE_PHY_CAP7_STBC_TX_ABOVE_80MHZ |
- 	    IEEE80211_HE_PHY_CAP7_STBC_RX_ABOVE_80MHZ;
- 	he_cap_elem->phy_cap_info[7] &= ~m;
---- a/drivers/net/wireless/mediatek/mt76/mt7915/init.c
-+++ b/drivers/net/wireless/mediatek/mt76/mt7915/init.c
-@@ -307,8 +307,8 @@ mt7915_set_stream_he_txbf_caps(struct ie
- 	    IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_MASK;
- 	elem->phy_cap_info[5] &= ~c;
- 
--	c = IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMER_FB |
--	    IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMER_FB;
-+	c = IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMING_FB |
-+	    IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB;
- 	elem->phy_cap_info[6] &= ~c;
- 
- 	elem->phy_cap_info[7] &= ~IEEE80211_HE_PHY_CAP7_MAX_NC_MASK;
-@@ -348,8 +348,8 @@ mt7915_set_stream_he_txbf_caps(struct ie
- 	c = (nss - 1) | (max_t(int, mcs->tx_mcs_160, 1) << 3);
- 	elem->phy_cap_info[5] |= c;
- 
--	c = IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMER_FB |
--	    IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMER_FB;
-+	c = IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMING_FB |
-+	    IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB;
- 	elem->phy_cap_info[6] |= c;
- }
- 
-@@ -484,7 +484,7 @@ mt7915_init_he_caps(struct mt7915_phy *p
- 				IEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE |
- 				IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT;
- 			he_cap_elem->phy_cap_info[7] |=
--				IEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_AR |
-+				IEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_SUPP |
- 				IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI;
- 			he_cap_elem->phy_cap_info[8] |=
- 				IEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G |
---- a/include/linux/ieee80211.h
-+++ b/include/linux/ieee80211.h
-@@ -2065,7 +2065,7 @@ int ieee80211_get_vht_max_nss(struct iee
- #define IEEE80211_HE_MAC_CAP4_BSRP_BQRP_A_MPDU_AGG		0x01
- #define IEEE80211_HE_MAC_CAP4_QTP				0x02
- #define IEEE80211_HE_MAC_CAP4_BQR				0x04
--#define IEEE80211_HE_MAC_CAP4_SRP_RESP				0x08
-+#define IEEE80211_HE_MAC_CAP4_PSR_RESP				0x08
- #define IEEE80211_HE_MAC_CAP4_NDP_FB_REP			0x10
- #define IEEE80211_HE_MAC_CAP4_OPS				0x20
- #define IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU			0x40
-@@ -2076,7 +2076,7 @@ int ieee80211_get_vht_max_nss(struct iee
- 
- #define IEEE80211_HE_MAC_CAP5_MULTI_TID_AGG_TX_QOS_B40		0x01
- #define IEEE80211_HE_MAC_CAP5_MULTI_TID_AGG_TX_QOS_B41		0x02
--#define IEEE80211_HE_MAC_CAP5_SUBCHAN_SELECVITE_TRANSMISSION	0x04
-+#define IEEE80211_HE_MAC_CAP5_SUBCHAN_SELECTIVE_TRANSMISSION	0x04
- #define IEEE80211_HE_MAC_CAP5_UL_2x996_TONE_RU			0x08
- #define IEEE80211_HE_MAC_CAP5_OM_CTRL_UL_MU_DATA_DIS_RX		0x10
- #define IEEE80211_HE_MAC_CAP5_HE_DYNAMIC_SM_PS			0x20
-@@ -2134,7 +2134,7 @@ int ieee80211_get_vht_max_nss(struct iee
- #define IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_MASK			0x18
- #define IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1				0x00
- #define IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_2				0x20
--#define IEEE80211_HE_PHY_CAP3_RX_HE_MU_PPDU_FROM_NON_AP_STA		0x40
-+#define IEEE80211_HE_PHY_CAP3_RX_PARTIAL_BW_SU_IN_20MHZ_MU		0x40
- #define IEEE80211_HE_PHY_CAP3_SU_BEAMFORMER				0x80
- 
- #define IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE				0x01
-@@ -2181,15 +2181,15 @@ int ieee80211_get_vht_max_nss(struct iee
- 
- #define IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_42_SU			0x01
- #define IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_75_MU			0x02
--#define IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMER_FB			0x04
--#define IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMER_FB			0x08
-+#define IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMING_FB			0x04
-+#define IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB		0x08
- #define IEEE80211_HE_PHY_CAP6_TRIG_CQI_FB				0x10
- #define IEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE			0x20
- #define IEEE80211_HE_PHY_CAP6_PARTIAL_BANDWIDTH_DL_MUMIMO		0x40
- #define IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT			0x80
- 
--#define IEEE80211_HE_PHY_CAP7_SRP_BASED_SR				0x01
--#define IEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_AR			0x02
-+#define IEEE80211_HE_PHY_CAP7_PSR_BASED_SR				0x01
-+#define IEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_SUPP			0x02
- #define IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI		0x04
- #define IEEE80211_HE_PHY_CAP7_MAX_NC_1					0x08
- #define IEEE80211_HE_PHY_CAP7_MAX_NC_2					0x10
---- a/net/mac80211/debugfs_sta.c
-+++ b/net/mac80211/debugfs_sta.c
-@@ -732,15 +732,15 @@ static ssize_t sta_he_capa_read(struct f
- 	PFLAG(MAC, 4, BSRP_BQRP_A_MPDU_AGG, "BSRP-BQRP-A-MPDU-AGG");
- 	PFLAG(MAC, 4, QTP, "QTP");
- 	PFLAG(MAC, 4, BQR, "BQR");
--	PFLAG(MAC, 4, SRP_RESP, "SRP-RESP");
-+	PFLAG(MAC, 4, PSR_RESP, "PSR-RESP");
- 	PFLAG(MAC, 4, NDP_FB_REP, "NDP-FB-REP");
- 	PFLAG(MAC, 4, OPS, "OPS");
- 	PFLAG(MAC, 4, AMDSU_IN_AMPDU, "AMSDU-IN-AMPDU");
- 
- 	PRINT("MULTI-TID-AGG-TX-QOS-%d", ((cap[5] << 1) | (cap[4] >> 7)) & 0x7);
- 
--	PFLAG(MAC, 5, SUBCHAN_SELECVITE_TRANSMISSION,
--	      "SUBCHAN-SELECVITE-TRANSMISSION");
-+	PFLAG(MAC, 5, SUBCHAN_SELECTIVE_TRANSMISSION,
-+	      "SUBCHAN-SELECTIVE-TRANSMISSION");
- 	PFLAG(MAC, 5, UL_2x996_TONE_RU, "UL-2x996-TONE-RU");
- 	PFLAG(MAC, 5, OM_CTRL_UL_MU_DATA_DIS_RX, "OM-CTRL-UL-MU-DATA-DIS-RX");
- 	PFLAG(MAC, 5, HE_DYNAMIC_SM_PS, "HE-DYNAMIC-SM-PS");
-@@ -832,8 +832,8 @@ static ssize_t sta_he_capa_read(struct f
- 
- 	PFLAG(PHY, 3, DCM_MAX_RX_NSS_1, "DCM-MAX-RX-NSS-1");
- 	PFLAG(PHY, 3, DCM_MAX_RX_NSS_2, "DCM-MAX-RX-NSS-2");
--	PFLAG(PHY, 3, RX_HE_MU_PPDU_FROM_NON_AP_STA,
--	      "RX-HE-MU-PPDU-FROM-NON-AP-STA");
-+	PFLAG(PHY, 3, RX_PARTIAL_BW_SU_IN_20MHZ_MU,
-+	      "RX-PARTIAL-BW-SU-IN-20MHZ-MU");
- 	PFLAG(PHY, 3, SU_BEAMFORMER, "SU-BEAMFORMER");
- 
- 	PFLAG(PHY, 4, SU_BEAMFORMEE, "SU-BEAMFORMEE");
-@@ -853,16 +853,17 @@ static ssize_t sta_he_capa_read(struct f
- 
- 	PFLAG(PHY, 6, CODEBOOK_SIZE_42_SU, "CODEBOOK-SIZE-42-SU");
- 	PFLAG(PHY, 6, CODEBOOK_SIZE_75_MU, "CODEBOOK-SIZE-75-MU");
--	PFLAG(PHY, 6, TRIG_SU_BEAMFORMER_FB, "TRIG-SU-BEAMFORMER-FB");
--	PFLAG(PHY, 6, TRIG_MU_BEAMFORMER_FB, "TRIG-MU-BEAMFORMER-FB");
-+	PFLAG(PHY, 6, TRIG_SU_BEAMFORMING_FB, "TRIG-SU-BEAMFORMING-FB");
-+	PFLAG(PHY, 6, TRIG_MU_BEAMFORMING_PARTIAL_BW_FB,
-+	      "MU-BEAMFORMING-PARTIAL-BW-FB");
- 	PFLAG(PHY, 6, TRIG_CQI_FB, "TRIG-CQI-FB");
- 	PFLAG(PHY, 6, PARTIAL_BW_EXT_RANGE, "PARTIAL-BW-EXT-RANGE");
- 	PFLAG(PHY, 6, PARTIAL_BANDWIDTH_DL_MUMIMO,
- 	      "PARTIAL-BANDWIDTH-DL-MUMIMO");
- 	PFLAG(PHY, 6, PPE_THRESHOLD_PRESENT, "PPE-THRESHOLD-PRESENT");
- 
--	PFLAG(PHY, 7, SRP_BASED_SR, "SRP-BASED-SR");
--	PFLAG(PHY, 7, POWER_BOOST_FACTOR_AR, "POWER-BOOST-FACTOR-AR");
-+	PFLAG(PHY, 7, PSR_BASED_SR, "PSR-BASED-SR");
-+	PFLAG(PHY, 7, POWER_BOOST_FACTOR_SUPP, "POWER-BOOST-FACTOR-SUPP");
- 	PFLAG(PHY, 7, HE_SU_MU_PPDU_4XLTF_AND_08_US_GI,
- 	      "HE-SU-MU-PPDU-4XLTF-AND-08-US-GI");
- 	PFLAG_RANGE(PHY, 7, MAX_NC, 0, 1, 1, "MAX-NC-%d");
---- a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
-+++ b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
-@@ -630,7 +630,7 @@ static struct ieee80211_sband_iftype_dat
- 				.phy_cap_info[6] =
- 					IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT,
- 				.phy_cap_info[7] =
--					IEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_AR |
-+					IEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_SUPP |
- 					IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI |
- 					IEEE80211_HE_PHY_CAP7_MAX_NC_1,
- 				.phy_cap_info[8] =
diff --git a/package/kernel/mac80211/patches/subsys/392-wireless-fix-spelling-of-A-MSDU-in-HE-capabilities.patch b/package/kernel/mac80211/patches/subsys/392-wireless-fix-spelling-of-A-MSDU-in-HE-capabilities.patch
deleted file mode 100644
index e90177e379..0000000000
--- a/package/kernel/mac80211/patches/subsys/392-wireless-fix-spelling-of-A-MSDU-in-HE-capabilities.patch
+++ /dev/null
@@ -1,113 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Fri, 9 Apr 2021 12:40:24 +0300
-Subject: [PATCH] wireless: fix spelling of A-MSDU in HE capabilities
-
-In the HE capabilities, spell A-MSDU correctly, not "A-MDSU".
-
-Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
-Link: https://lore.kernel.org/r/iwlwifi.20210409123755.9e6ff1af1181.If6868bc6902ccd9a95c74c78f716c4b41473ef14@changeid
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
-+++ b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
-@@ -597,7 +597,7 @@ static struct ieee80211_sband_iftype_dat
- 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
- 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
- 				.mac_cap_info[4] =
--					IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU |
-+					IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU |
- 					IEEE80211_HE_MAC_CAP4_MULTI_TID_AGG_TX_QOS_B39,
- 				.mac_cap_info[5] =
- 					IEEE80211_HE_MAC_CAP5_MULTI_TID_AGG_TX_QOS_B40 |
-@@ -681,7 +681,7 @@ static struct ieee80211_sband_iftype_dat
- 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
- 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
- 				.mac_cap_info[4] =
--					IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
-+					IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
- 				.mac_cap_info[5] =
- 					IEEE80211_HE_MAC_CAP5_UL_2x996_TONE_RU,
- 				.phy_cap_info[0] =
---- a/drivers/net/wireless/mediatek/mt76/mt7915/init.c
-+++ b/drivers/net/wireless/mediatek/mt76/mt7915/init.c
-@@ -427,7 +427,7 @@ mt7915_init_he_caps(struct mt7915_phy *p
- 			IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
- 			IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_RESERVED;
- 		he_cap_elem->mac_cap_info[4] =
--			IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU;
-+			IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU;
- 
- 		if (band == NL80211_BAND_2GHZ)
- 			he_cap_elem->phy_cap_info[0] =
---- a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
-+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c
-@@ -1358,7 +1358,7 @@ mt7915_mcu_sta_he_tlv(struct sk_buff *sk
- 	if (elem->mac_cap_info[3] & IEEE80211_HE_MAC_CAP3_OMI_CONTROL)
- 		cap |= STA_REC_HE_CAP_OM;
- 
--	if (elem->mac_cap_info[4] & IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU)
-+	if (elem->mac_cap_info[4] & IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU)
- 		cap |= STA_REC_HE_CAP_AMSDU_IN_AMPDU;
- 
- 	if (elem->mac_cap_info[4] & IEEE80211_HE_MAC_CAP4_BQR)
---- a/include/linux/ieee80211.h
-+++ b/include/linux/ieee80211.h
-@@ -2068,7 +2068,7 @@ int ieee80211_get_vht_max_nss(struct iee
- #define IEEE80211_HE_MAC_CAP4_PSR_RESP				0x08
- #define IEEE80211_HE_MAC_CAP4_NDP_FB_REP			0x10
- #define IEEE80211_HE_MAC_CAP4_OPS				0x20
--#define IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU			0x40
-+#define IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU			0x40
- /* Multi TID agg TX is split between byte #4 and #5
-  * The value is a combination of B39,B40,B41
-  */
---- a/net/mac80211/debugfs_sta.c
-+++ b/net/mac80211/debugfs_sta.c
-@@ -735,7 +735,7 @@ static ssize_t sta_he_capa_read(struct f
- 	PFLAG(MAC, 4, PSR_RESP, "PSR-RESP");
- 	PFLAG(MAC, 4, NDP_FB_REP, "NDP-FB-REP");
- 	PFLAG(MAC, 4, OPS, "OPS");
--	PFLAG(MAC, 4, AMDSU_IN_AMPDU, "AMSDU-IN-AMPDU");
-+	PFLAG(MAC, 4, AMSDU_IN_AMPDU, "AMSDU-IN-AMPDU");
- 
- 	PRINT("MULTI-TID-AGG-TX-QOS-%d", ((cap[5] << 1) | (cap[4] >> 7)) & 0x7);
- 
---- a/drivers/net/wireless/mac80211_hwsim.c
-+++ b/drivers/net/wireless/mac80211_hwsim.c
-@@ -2759,7 +2759,7 @@ static const struct ieee80211_sband_ifty
- 				.mac_cap_info[3] =
- 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
- 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
--				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
-+				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
- 				.phy_cap_info[1] =
- 					IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
- 					IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
-@@ -2803,7 +2803,7 @@ static const struct ieee80211_sband_ifty
- 				.mac_cap_info[3] =
- 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
- 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
--				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
-+				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
- 				.phy_cap_info[1] =
- 					IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
- 					IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |
-@@ -2849,7 +2849,7 @@ static const struct ieee80211_sband_ifty
- 				.mac_cap_info[3] =
- 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
- 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
--				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
-+				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
- 				.phy_cap_info[0] =
- 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
- 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |
-@@ -2897,7 +2897,7 @@ static const struct ieee80211_sband_ifty
- 				.mac_cap_info[3] =
- 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
- 					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
--				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMDSU_IN_AMPDU,
-+				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
- 				.phy_cap_info[0] =
- 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
- 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |
diff --git a/package/kernel/mac80211/patches/subsys/393-wireless-align-HE-capabilities-A-MPDU-Length-Exponen.patch b/package/kernel/mac80211/patches/subsys/393-wireless-align-HE-capabilities-A-MPDU-Length-Exponen.patch
deleted file mode 100644
index ecd544324c..0000000000
--- a/package/kernel/mac80211/patches/subsys/393-wireless-align-HE-capabilities-A-MPDU-Length-Exponen.patch
+++ /dev/null
@@ -1,148 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Fri, 9 Apr 2021 12:40:20 +0300
-Subject: [PATCH] wireless: align HE capabilities A-MPDU Length Exponent
- Extension
-
-The A-MPDU length exponent extension is defined differently in
-802.11ax D6.1, align with that.
-
-Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
-Link: https://lore.kernel.org/r/iwlwifi.20210409123755.c2a257d3e2df.I3455245d388c52c61dace7e7958dbed7e807cfb6@changeid
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -1295,9 +1295,8 @@ static void ath11k_peer_assoc_h_he(struc
- 	 * request, then use MAX_AMPDU_LEN_FACTOR as 16 to calculate max_ampdu
- 	 * length.
- 	 */
--	ampdu_factor = (he_cap->he_cap_elem.mac_cap_info[3] &
--			IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_MASK) >>
--			IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_SHIFT;
-+	ampdu_factor = u8_get_bits(he_cap->he_cap_elem.mac_cap_info[3],
-+				   IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_MASK);
- 
- 	if (ampdu_factor) {
- 		if (sta->vht_cap.vht_supported)
---- a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
-+++ b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c
-@@ -595,7 +595,7 @@ static struct ieee80211_sband_iftype_dat
- 					IEEE80211_HE_MAC_CAP2_32BIT_BA_BITMAP,
- 				.mac_cap_info[3] =
- 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
--					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
-+					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_2,
- 				.mac_cap_info[4] =
- 					IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU |
- 					IEEE80211_HE_MAC_CAP4_MULTI_TID_AGG_TX_QOS_B39,
-@@ -679,7 +679,7 @@ static struct ieee80211_sband_iftype_dat
- 					IEEE80211_HE_MAC_CAP2_BSR,
- 				.mac_cap_info[3] =
- 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
--					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
-+					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_2,
- 				.mac_cap_info[4] =
- 					IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
- 				.mac_cap_info[5] =
---- a/drivers/net/wireless/mac80211_hwsim.c
-+++ b/drivers/net/wireless/mac80211_hwsim.c
-@@ -2758,7 +2758,7 @@ static const struct ieee80211_sband_ifty
- 					IEEE80211_HE_MAC_CAP2_ACK_EN,
- 				.mac_cap_info[3] =
- 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
--					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
-+					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,
- 				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
- 				.phy_cap_info[1] =
- 					IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
-@@ -2802,7 +2802,7 @@ static const struct ieee80211_sband_ifty
- 					IEEE80211_HE_MAC_CAP2_ACK_EN,
- 				.mac_cap_info[3] =
- 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
--					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
-+					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,
- 				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
- 				.phy_cap_info[1] =
- 					IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |
-@@ -2848,7 +2848,7 @@ static const struct ieee80211_sband_ifty
- 					IEEE80211_HE_MAC_CAP2_ACK_EN,
- 				.mac_cap_info[3] =
- 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
--					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
-+					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,
- 				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
- 				.phy_cap_info[0] =
- 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
-@@ -2896,7 +2896,7 @@ static const struct ieee80211_sband_ifty
- 					IEEE80211_HE_MAC_CAP2_ACK_EN,
- 				.mac_cap_info[3] =
- 					IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
--					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2,
-+					IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,
- 				.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,
- 				.phy_cap_info[0] =
- 					IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
---- a/drivers/net/wireless/mediatek/mt76/mt7915/init.c
-+++ b/drivers/net/wireless/mediatek/mt76/mt7915/init.c
-@@ -425,7 +425,7 @@ mt7915_init_he_caps(struct mt7915_phy *p
- 			IEEE80211_HE_MAC_CAP0_HTC_HE;
- 		he_cap_elem->mac_cap_info[3] =
- 			IEEE80211_HE_MAC_CAP3_OMI_CONTROL |
--			IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_RESERVED;
-+			IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3;
- 		he_cap_elem->mac_cap_info[4] =
- 			IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU;
- 
---- a/include/linux/ieee80211.h
-+++ b/include/linux/ieee80211.h
-@@ -2051,17 +2051,15 @@ int ieee80211_get_vht_max_nss(struct iee
-  * A-MDPU Length Exponent field in the HT capabilities, VHT capabilities and the
-  * same field in the HE capabilities.
-  */
--#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_USE_VHT	0x00
--#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_1		0x08
--#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2		0x10
--#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_RESERVED	0x18
-+#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_0		0x00
-+#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_1		0x08
-+#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_2		0x10
-+#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3		0x18
- #define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_MASK		0x18
- #define IEEE80211_HE_MAC_CAP3_AMSDU_FRAG			0x20
- #define IEEE80211_HE_MAC_CAP3_FLEX_TWT_SCHED			0x40
- #define IEEE80211_HE_MAC_CAP3_RX_CTRL_FRAME_TO_MULTIBSS		0x80
- 
--#define IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_SHIFT		3
--
- #define IEEE80211_HE_MAC_CAP4_BSRP_BQRP_A_MPDU_AGG		0x01
- #define IEEE80211_HE_MAC_CAP4_QTP				0x02
- #define IEEE80211_HE_MAC_CAP4_BQR				0x04
---- a/net/mac80211/debugfs_sta.c
-+++ b/net/mac80211/debugfs_sta.c
-@@ -711,17 +711,17 @@ static ssize_t sta_he_capa_read(struct f
- 	PFLAG(MAC, 3, OFDMA_RA, "OFDMA-RA");
- 
- 	switch (cap[3] & IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_MASK) {
--	case IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_USE_VHT:
--		PRINT("MAX-AMPDU-LEN-EXP-USE-VHT");
-+	case IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_0:
-+		PRINT("MAX-AMPDU-LEN-EXP-USE-EXT-0");
- 		break;
--	case IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_1:
--		PRINT("MAX-AMPDU-LEN-EXP-VHT-1");
-+	case IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_1:
-+		PRINT("MAX-AMPDU-LEN-EXP-VHT-EXT-1");
- 		break;
--	case IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_VHT_2:
--		PRINT("MAX-AMPDU-LEN-EXP-VHT-2");
-+	case IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_2:
-+		PRINT("MAX-AMPDU-LEN-EXP-VHT-EXT-2");
- 		break;
--	case IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_RESERVED:
--		PRINT("MAX-AMPDU-LEN-EXP-RESERVED");
-+	case IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3:
-+		PRINT("MAX-AMPDU-LEN-EXP-VHT-EXT-3");
- 		break;
- 	}
- 
diff --git a/package/kernel/mac80211/patches/subsys/394-mac80211-fix-rate-control-for-retransmitted-frames.patch b/package/kernel/mac80211/patches/subsys/394-mac80211-fix-rate-control-for-retransmitted-frames.patch
deleted file mode 100644
index cd91a925f3..0000000000
--- a/package/kernel/mac80211/patches/subsys/394-mac80211-fix-rate-control-for-retransmitted-frames.patch
+++ /dev/null
@@ -1,35 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Mon, 22 Nov 2021 21:39:38 +0100
-Subject: [PATCH] mac80211: fix rate control for retransmitted frames
-
-Since retransmission clears info->control, rate control needs to be called
-again, otherwise the driver might crash due to invalid rates.
-
-Cc: stable@vger.kernel.org # 5.14+
-Reported-by: Aaro Koskinen <aaro.koskinen@iki.fi>
-Reported-by: Robert W <rwbugreport@lost-in-the-void.net>
-Fixes: 03c3911d2d67 ("mac80211: call ieee80211_tx_h_rate_ctrl() when dequeue")
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -1835,15 +1835,15 @@ static int invoke_tx_handlers_late(struc
- 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);
- 	ieee80211_tx_result res = TX_CONTINUE;
- 
-+	if (!ieee80211_hw_check(&tx->local->hw, HAS_RATE_CONTROL))
-+		CALL_TXH(ieee80211_tx_h_rate_ctrl);
-+
- 	if (unlikely(info->flags & IEEE80211_TX_INTFL_RETRANSMISSION)) {
- 		__skb_queue_tail(&tx->skbs, tx->skb);
- 		tx->skb = NULL;
- 		goto txh_done;
- 	}
- 
--	if (!ieee80211_hw_check(&tx->local->hw, HAS_RATE_CONTROL))
--		CALL_TXH(ieee80211_tx_h_rate_ctrl);
--
- 	CALL_TXH(ieee80211_tx_h_michael_mic_add);
- 	CALL_TXH(ieee80211_tx_h_sequence);
- 	CALL_TXH(ieee80211_tx_h_fragment);
diff --git a/package/kernel/mac80211/patches/subsys/397-disable-mbssid.patch b/package/kernel/mac80211/patches/subsys/397-disable-mbssid.patch
deleted file mode 100644
index c4a8d30d7c..0000000000
--- a/package/kernel/mac80211/patches/subsys/397-disable-mbssid.patch
+++ /dev/null
@@ -1,44 +0,0 @@
---- a/net/mac80211/util.c
-+++ b/net/mac80211/util.c
-@@ -1402,6 +1402,7 @@ static size_t ieee802_11_find_bssid_prof
- 	if (!bss_bssid || !transmitter_bssid)
- 		return profile_len;
- 
-+	return 0;
- 	for_each_element_id(elem, WLAN_EID_MULTIPLE_BSSID, start, len) {
- 		if (elem->datalen < 2)
- 			continue;
---- a/net/wireless/scan.c
-+++ b/net/wireless/scan.c
-@@ -2010,6 +2010,7 @@ static const struct element
- 	const struct element *next_mbssid;
- 	const struct element *next_sub;
- 
-+	return NULL;
- 	next_mbssid = cfg80211_find_elem(WLAN_EID_MULTIPLE_BSSID,
- 					 mbssid_end,
- 					 ielen - (mbssid_end - ie));
-@@ -2091,6 +2092,7 @@ static void cfg80211_parse_mbssid_data(s
- 	u16 capability;
- 	struct cfg80211_bss *bss;
- 
-+	return;
- 	if (!non_tx_data)
- 		return;
- 	if (!cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, ie, ielen))
-@@ -2251,6 +2253,7 @@ cfg80211_update_notlisted_nontrans(struc
- 	const struct cfg80211_bss_ies *old;
- 	size_t cpy_len;
- 
-+	return;
- 	lockdep_assert_held(&wiphy_to_rdev(wiphy)->bss_lock);
- 
- 	ie = mgmt->u.probe_resp.variable;
-@@ -2468,6 +2471,7 @@ cfg80211_inform_bss_frame_data(struct wi
- 
- 	res = cfg80211_inform_single_bss_frame_data(wiphy, data, mgmt,
- 						    len, gfp);
-+	return res;
- 	if (!res || !wiphy->support_mbssid ||
- 	    !cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, ie, ielen))
- 		return res;
diff --git a/package/kernel/mac80211/patches/subsys/400-allow-ibss-mixed.patch b/package/kernel/mac80211/patches/subsys/400-allow-ibss-mixed.patch
index 974595e11a..f2ed528d23 100644
--- a/package/kernel/mac80211/patches/subsys/400-allow-ibss-mixed.patch
+++ b/package/kernel/mac80211/patches/subsys/400-allow-ibss-mixed.patch
@@ -5,7 +5,7 @@ and we should ignore this.
 
 --- a/net/wireless/core.c
 +++ b/net/wireless/core.c
-@@ -615,21 +615,6 @@ static int wiphy_verify_combinations(str
+@@ -625,21 +625,6 @@ static int wiphy_verify_combinations(str
  				    c->limits[j].max > 1))
  				return -EINVAL;
  
diff --git a/package/kernel/mac80211/patches/subsys/500-mac80211_configure_antenna_gain.patch b/package/kernel/mac80211/patches/subsys/500-mac80211_configure_antenna_gain.patch
index 4a0bb1a933..0e83e9bd8e 100644
--- a/package/kernel/mac80211/patches/subsys/500-mac80211_configure_antenna_gain.patch
+++ b/package/kernel/mac80211/patches/subsys/500-mac80211_configure_antenna_gain.patch
@@ -1,24 +1,24 @@
 --- a/include/net/cfg80211.h
 +++ b/include/net/cfg80211.h
-@@ -3814,6 +3814,7 @@ struct mgmt_frame_regs {
+@@ -3869,6 +3869,7 @@ struct mgmt_frame_regs {
   *	(as advertised by the nl80211 feature flag.)
   * @get_tx_power: store the current TX power into the dbm variable;
   *	return 0 if successful
 + * @set_antenna_gain: set antenna gain to reduce maximum tx power if necessary
   *
-  * @set_wds_peer: set the WDS peer for a WDS interface
-  *
-@@ -4138,6 +4139,7 @@ struct cfg80211_ops {
+  * @rfkill_poll: polls the hw rfkill line, use cfg80211 reporting
+  *	functions to adjust rfkill hw state
+@@ -4202,6 +4203,7 @@ struct cfg80211_ops {
  				enum nl80211_tx_power_setting type, int mbm);
  	int	(*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,
  				int *dbm);
 +	int	(*set_antenna_gain)(struct wiphy *wiphy, int dbi);
  
- 	int	(*set_wds_peer)(struct wiphy *wiphy, struct net_device *dev,
- 				const u8 *addr);
+ 	void	(*rfkill_poll)(struct wiphy *wiphy);
+ 
 --- a/include/net/mac80211.h
 +++ b/include/net/mac80211.h
-@@ -1561,6 +1561,7 @@ enum ieee80211_smps_mode {
+@@ -1566,6 +1566,7 @@ enum ieee80211_smps_mode {
   *
   * @power_level: requested transmit power (in dBm), backward compatibility
   *	value only that is set to the minimum of all interfaces
@@ -26,7 +26,7 @@
   *
   * @chandef: the channel definition to tune to
   * @radar_enabled: whether radar detection is enabled
-@@ -1581,6 +1582,7 @@ enum ieee80211_smps_mode {
+@@ -1586,6 +1587,7 @@ enum ieee80211_smps_mode {
  struct ieee80211_conf {
  	u32 flags;
  	int power_level, dynamic_ps_timeout;
@@ -36,9 +36,9 @@
  	u8 ps_dtim_period;
 --- a/include/uapi/linux/nl80211.h
 +++ b/include/uapi/linux/nl80211.h
-@@ -2593,6 +2593,9 @@ enum nl80211_commands {
-  * @NL80211_ATTR_COLOR_CHANGE_ELEMS: Nested set of attributes containing the IE
-  *	information for the time while performing a color switch.
+@@ -2615,6 +2615,9 @@ enum nl80211_commands {
+  *	switching on a different channel during CAC detection on the selected
+  *	radar channel.
   *
 + * @NL80211_ATTR_WIPHY_ANTENNA_GAIN: Configured antenna gain. Used to reduce
 + *	transmit power to stay within regulatory limits. u32, dBi.
@@ -46,9 +46,9 @@
   * @NUM_NL80211_ATTR: total number of nl80211_attrs available
   * @NL80211_ATTR_MAX: highest attribute number currently defined
   * @__NL80211_ATTR_AFTER_LAST: internal use
-@@ -3096,6 +3099,8 @@ enum nl80211_attrs {
- 	NL80211_ATTR_COLOR_CHANGE_COLOR,
- 	NL80211_ATTR_COLOR_CHANGE_ELEMS,
+@@ -3123,6 +3126,8 @@ enum nl80211_attrs {
+ 
+ 	NL80211_ATTR_RADAR_BACKGROUND,
  
 +	NL80211_ATTR_WIPHY_ANTENNA_GAIN,
 +
@@ -57,7 +57,7 @@
  	__NL80211_ATTR_AFTER_LAST,
 --- a/net/mac80211/cfg.c
 +++ b/net/mac80211/cfg.c
-@@ -2769,6 +2769,19 @@ static int ieee80211_get_tx_power(struct
+@@ -2812,6 +2812,19 @@ static int ieee80211_get_tx_power(struct
  	return 0;
  }
  
@@ -74,20 +74,20 @@
 +	return 0;
 +}
 +
- static int ieee80211_set_wds_peer(struct wiphy *wiphy, struct net_device *dev,
- 				  const u8 *addr)
+ static void ieee80211_rfkill_poll(struct wiphy *wiphy)
  {
-@@ -4413,6 +4426,7 @@ const struct cfg80211_ops mac80211_confi
+ 	struct ieee80211_local *local = wiphy_priv(wiphy);
+@@ -4516,6 +4529,7 @@ const struct cfg80211_ops mac80211_confi
  	.set_wiphy_params = ieee80211_set_wiphy_params,
  	.set_tx_power = ieee80211_set_tx_power,
  	.get_tx_power = ieee80211_get_tx_power,
 +	.set_antenna_gain = ieee80211_set_antenna_gain,
- 	.set_wds_peer = ieee80211_set_wds_peer,
  	.rfkill_poll = ieee80211_rfkill_poll,
  	CFG80211_TESTMODE_CMD(ieee80211_testmode_cmd)
+ 	CFG80211_TESTMODE_DUMP(ieee80211_testmode_dump)
 --- a/net/mac80211/ieee80211_i.h
 +++ b/net/mac80211/ieee80211_i.h
-@@ -1440,6 +1440,7 @@ struct ieee80211_local {
+@@ -1447,6 +1447,7 @@ struct ieee80211_local {
  	int dynamic_ps_forced_timeout;
  
  	int user_power_level; /* in dBm, for all interfaces */
@@ -119,7 +119,7 @@
  	if (local->hw.conf.power_level != power) {
  		changed |= IEEE80211_CONF_CHANGE_POWER;
  		local->hw.conf.power_level = power;
-@@ -665,6 +671,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
+@@ -679,6 +685,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
  					 IEEE80211_RADIOTAP_MCS_HAVE_BW;
  	local->hw.radiotap_vht_details = IEEE80211_RADIOTAP_VHT_KNOWN_GI |
  					 IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH;
@@ -129,32 +129,34 @@
  	local->hw.max_mtu = IEEE80211_MAX_DATA_LEN;
 --- a/net/wireless/nl80211.c
 +++ b/net/wireless/nl80211.c
-@@ -762,6 +762,7 @@ static const struct nla_policy nl80211_p
- 	[NL80211_ATTR_COLOR_CHANGE_COUNT] = { .type = NLA_U8 },
- 	[NL80211_ATTR_COLOR_CHANGE_COLOR] = { .type = NLA_U8 },
- 	[NL80211_ATTR_COLOR_CHANGE_ELEMS] = NLA_POLICY_NESTED(nl80211_policy),
+@@ -802,6 +802,7 @@ static const struct nla_policy nl80211_p
+ 			NLA_POLICY_NESTED(nl80211_mbssid_config_policy),
+ 	[NL80211_ATTR_MBSSID_ELEMS] = { .type = NLA_NESTED },
+ 	[NL80211_ATTR_RADAR_BACKGROUND] = { .type = NLA_FLAG },
 +	[NL80211_ATTR_WIPHY_ANTENNA_GAIN] = { .type = NLA_U32 },
  };
  
  /* policy for the key attributes */
-@@ -3336,6 +3337,20 @@ static int nl80211_set_wiphy(struct sk_b
+@@ -3391,6 +3392,22 @@ static int nl80211_set_wiphy(struct sk_b
  		if (result)
- 			return result;
+ 			goto out;
  	}
 +
 +	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_GAIN]) {
 +		int idx, dbi = 0;
 +
-+		if (!rdev->ops->set_antenna_gain)
-+			return -EOPNOTSUPP;
++		if (!rdev->ops->set_antenna_gain) {
++			result = -EOPNOTSUPP;
++			goto out;
++		}
 +
 +		idx = NL80211_ATTR_WIPHY_ANTENNA_GAIN;
 +		dbi = nla_get_u32(info->attrs[idx]);
 +
 +		result = rdev->ops->set_antenna_gain(&rdev->wiphy, dbi);
 +		if (result)
-+			return result;
++			goto out;
 +	}
  
- 	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&
- 	    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {
+ 	if (info->attrs[NL80211_ATTR_WIPHY_TX_POWER_SETTING]) {
+ 		struct wireless_dev *txp_wdev = wdev;
diff --git a/package/kernel/mac80211/patches/subsys/782-net-next-1-of-net-pass-the-dst-buffer-to-of_get_mac_address.patch b/package/kernel/mac80211/patches/subsys/782-net-next-1-of-net-pass-the-dst-buffer-to-of_get_mac_address.patch
new file mode 100644
index 0000000000..26af6a2fb9
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/782-net-next-1-of-net-pass-the-dst-buffer-to-of_get_mac_address.patch
@@ -0,0 +1,29 @@
+--- a/backport-include/linux/of_net.h
++++ /dev/null
+@@ -1,26 +0,0 @@
+-#ifndef _BP_OF_NET_H
+-#define _BP_OF_NET_H
+-#include_next <linux/of_net.h>
+-#include <linux/version.h>
+-#include <linux/etherdevice.h>
+-
+-/* The behavior of of_get_mac_address() changed in kernel 5.2, it now
+- * returns an error code and not NULL in case of an error.
+- */
+-#if LINUX_VERSION_IS_LESS(5,13,0)
+-static inline int backport_of_get_mac_address(struct device_node *np, u8 *mac_out)
+-{
+-	const void *mac = of_get_mac_address(np);
+-
+-	if (!mac)
+-		return -ENODEV;
+-	if (IS_ERR(mac))
+-		return PTR_ERR(mac);
+-	ether_addr_copy(mac_out, mac);
+-	
+-	return 0;
+-}
+-#define of_get_mac_address LINUX_BACKPORT(of_get_mac_address)
+-#endif /* < 5.2 */
+-
+-#endif /* _BP_OF_NET_H */
diff --git a/package/kernel/mac80211/realtek.mk b/package/kernel/mac80211/realtek.mk
index 75cb94d7b6..44c6c25b08 100644
--- a/package/kernel/mac80211/realtek.mk
+++ b/package/kernel/mac80211/realtek.mk
@@ -27,6 +27,8 @@ config-y += STAGING
 
 config-$(call config_package,rtw88) += RTW88 RTW88_CORE RTW88_PCI
 config-y += RTW88_8822BE RTW88_8822CE RTW88_8723DE
+config-$(CONFIG_PACKAGE_RTW88_DEBUG) += RTW88_DEBUG
+config-$(CONFIG_PACKAGE_RTW88_DEBUGFS) += RTW88_DEBUGFS
 
 define KernelPackage/rtl818x/Default
   $(call KernelPackage/mac80211/Default)
@@ -175,6 +177,22 @@ define KernelPackage/rtl8xxxu/description
   Please report your results!
 endef
 
+define KernelPackage/rtw88/config
+	config PACKAGE_RTW88_DEBUG
+		bool "Realtek wireless debugging (rtw88)"
+		depends on PACKAGE_kmod-rtw88
+		help
+		  Enable debugging output for rtw88 devices
+
+	config PACKAGE_RTW88_DEBUGFS
+		bool "Enable rtw88 debugfS support"
+		select KERNEL_DEBUG_FS
+		depends on PACKAGE_kmod-rtw88
+		help
+		  Select this to see extensive information about
+		  the internal state of rtw88 in debugfs.
+endef
+
 define KernelPackage/rtw88
   $(call KernelPackage/mac80211/Default)
   TITLE:=Realtek RTL8822BE/RTL8822CE/RTL8723DE
-- 
2.34.1

